Support for Accton AS4610_30

diff --git a/Makefile b/Makefile
index 4017993..38bf9cc 100755
--- a/Makefile
+++ b/Makefile
@@ -316,7 +316,6 @@ LIBS-y += lib/libfdt/libfdt.o
 LIBS-y += api/libapi.o
 LIBS-y += post/libpost.o
 LIBS-y += test/libtest.o
-LIBS-y += drivers/d1w/libds1wm.o
 
 ifneq ($(CONFIG_AM33XX)$(CONFIG_OMAP34XX)$(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX),)
 LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
diff --git a/arch/arm/cpu/armv7/iproc/benchscreen.c b/arch/arm/cpu/armv7/iproc/benchscreen.c
index 3349837..2faac77 100755
--- a/arch/arm/cpu/armv7/iproc/benchscreen.c
+++ b/arch/arm/cpu/armv7/iproc/benchscreen.c
@@ -14,27 +14,22 @@
 */
 #if (defined(CONFIG_HELIX4) || defined(CONFIG_HURRICANE2))
 void bench_screen_test1(void)
-{ 
+{
 	uint32_t val, i;
-	printf("BENCH SCREENING TEST1\n");
-	printf("=========================================\n");
-	val = reg32_read(IPROC_WRAP_IPROC_XGPLL_CTRL_3);
+    val = reg32_read(IPROC_WRAP_IPROC_XGPLL_CTRL_3);
+#if HELIX4_BENCHSCREEN_DEBUG
 	printf("IPROC_XGPLL_CTRL_3: 0x%08x\n", val);
-	reg32_clear_bits(IPROC_WRAP_IPROC_XGPLL_CTRL_3, 1 << 17);
+#endif
+    reg32_clear_bits(IPROC_WRAP_IPROC_XGPLL_CTRL_3, 1 << 17);
 	reg32_write_masked(IPROC_WRAP_IPROC_XGPLL_CTRL_3, 7 << 14, 4 << 14);
 	reg32_set_bits(IPROC_WRAP_IPROC_XGPLL_CTRL_3, 1<<17);
 	for(i =0; i < 1000; i++)
 		val = reg32_read(IPROC_WRAP_IPROC_XGPLL_STATUS);
+#if HELIX4_BENCHSCREEN_DEBUG
 	printf("IPROC_XGPLL_STATUS: 0x%08x\n", val);
-	val = ((val >> 4) & 0xFF); /* bits 11:4 */
-	printf("DCO code: %d\n", val);
-#if 0
-	if(val > 14)
-		printf("PASS\n");
-	else
-		printf("FAIL\n");
 #endif
-	printf("=========================================\n");
+    val = ((val >> 4) & 0xFF); /* bits 11:4 */
+    printf("DCO:   %d (%s)\n", val, val > 14 ? "PASS" : "FAIL");
 }
 #endif
 
diff --git a/arch/arm/cpu/armv7/iproc/ddr_init.c b/arch/arm/cpu/armv7/iproc/ddr_init.c
index fc06121..01d76c5 100755
--- a/arch/arm/cpu/armv7/iproc/ddr_init.c
+++ b/arch/arm/cpu/armv7/iproc/ddr_init.c
@@ -36,6 +36,7 @@ extern unsigned int ddr_clk_tab[];
 extern unsigned int ddr_phy_ctl_ovrd_tab[];
 extern unsigned int ddr_phy_wl0_tab[];
 
+/* #define IPROC_DDR_INIT2_DEBUG */
 
 #if defined(CONFIG_IPROC_DDR_ECC) && !defined(CONFIG_IPROC_P7)
 void iproc_ddr_ovrd_ecc_lane(void)
@@ -331,8 +332,10 @@ int cygnus_phy_powerup(void)
 	}
 	else
 	{
+#if defined(IPROC_DDR_INIT2_DEBUG)
 		printf("DeepSleep wakeup: ddr phy init bypassed 1\n");
-	}
+#endif
+    }
 #endif
 
     /* Step 3: DFI normal mode */
@@ -362,8 +365,10 @@ int cygnus_phy_powerup(void)
 	}
 	else
 	{
+#if defined(IPROC_DDR_INIT2_DEBUG)
 		printf("DeepSleep wakeup: ddr phy init bypassed 2\n");
-	}
+#endif
+    }
 #endif
 
     while((reg32_read((volatile uint32_t *)DDR_S1_IDM_IO_STATUS) & 0x08) != 0x08) {
@@ -1325,7 +1330,9 @@ poll_ddr_ctrl:
 #if defined(CONFIG_NORTHSTAR)
 	while(!(reg32_read((volatile uint32_t *)DDR_DENALI_CTL_89) & 0x200));
 #else
-	while(!(reg32_read((volatile uint32_t *)DDR_DENALI_CTL_89) & 0x100));
+#if !defined(CONFIG_AS4610_30_RECOVERY)
+    while(!(reg32_read((volatile uint32_t *)DDR_DENALI_CTL_89) & 0x100));
+#endif
 #endif
 	if(otp_status && (sku_id == 0)) {
 		reg32_write((volatile uint32_t *)DDR_PHY_WORD_LANE_0_READ_DATA_DLY, 0x03);
@@ -1622,7 +1629,1623 @@ DDR_PHY_ECC_LANE_DRIVE_PAD_CTL_BASE,
 DDR_PHY_ECC_LANE_WR_PREAMBLE_MODE_BASE,
 };
 #endif
-#if defined(CONFIG_IPROC_NAND) && defined(CONFIG_ENV_IS_IN_NAND) && CONFIG_ENV_IS_IN_NAND
+#if defined(CONFIG_AS4610_30_RECOVERY)
+static const uint32_t as4610_30_shmoo_default[] = {
+0x4F4D4853,
+0x0000DC14,
+0x00000BB9,
+0x92436034,
+0x000000C6,
+0x18010830,
+0x00000000,
+0x18010834,
+0x00010028,
+0x1801086C,
+0x000007DF,
+0x18010A00,
+0x0001001A,
+0x18010A04,
+0x00010000,
+0x18010A08,
+0x0001001A,
+0x18010A0C,
+0x0001001A,
+0x18010A10,
+0x00010018,
+0x18010A14,
+0x00010018,
+0x18010A18,
+0x00010018,
+0x18010A1C,
+0x00010018,
+0x18010A20,
+0x00010018,
+0x18010A24,
+0x00010018,
+0x18010A28,
+0x00010018,
+0x18010A2C,
+0x00010018,
+0x18010A30,
+0x00000000,
+0x18010A34,
+0x00010003,
+0x18010A38,
+0x00010003,
+0x18010A3C,
+0x00010003,
+0x18010A40,
+0x00010003,
+0x18010A44,
+0x00010003,
+0x18010A48,
+0x00010003,
+0x18010A4C,
+0x00010003,
+0x18010A50,
+0x00010003,
+0x18010A54,
+0x00010003,
+0x18010A58,
+0x00010003,
+0x18010A5C,
+0x00010003,
+0x18010A60,
+0x00010003,
+0x18010A64,
+0x00010003,
+0x18010A68,
+0x00010003,
+0x18010A6C,
+0x00010003,
+0x18010A70,
+0x00010003,
+0x18010A74,
+0x00010019,
+0x18010AA4,
+0x00010000,
+0x18010AA8,
+0x0001001A,
+0x18010AAC,
+0x0001001A,
+0x18010AB0,
+0x00010019,
+0x18010AB4,
+0x00010019,
+0x18010AB8,
+0x00010019,
+0x18010ABC,
+0x00010019,
+0x18010AC0,
+0x00010019,
+0x18010AC4,
+0x00010019,
+0x18010AC8,
+0x00010019,
+0x18010ACC,
+0x00010019,
+0x18010AD0,
+0x00000000,
+0x18010AD4,
+0x00010002,
+0x18010AD8,
+0x00010002,
+0x18010ADC,
+0x00010002,
+0x18010AE0,
+0x00010002,
+0x18010AE4,
+0x00010002,
+0x18010AE8,
+0x00010002,
+0x18010AEC,
+0x00010002,
+0x18010AF0,
+0x00010002,
+0x18010AF4,
+0x00010002,
+0x18010AF8,
+0x00010002,
+0x18010AFC,
+0x00010002,
+0x18010B00,
+0x00010002,
+0x18010B04,
+0x00010002,
+0x18010B08,
+0x00010002,
+0x18010B0C,
+0x00010002,
+0x18010B10,
+0x00010002,
+0x18010B14,
+0x0001001C,
+0x18010B18,
+0x00000000,
+0x18010B1C,
+0x00000000,
+0x18010B20,
+0x00000000,
+0x18010B24,
+0x00000000,
+0x18010B28,
+0x00000000,
+0x18010B2C,
+0x00000000,
+0x18010B30,
+0x00000000,
+0x18010B34,
+0x00000000,
+0x18010B38,
+0x00000000,
+0x18010B3C,
+0x00000000,
+0x18010B40,
+0x00000000,
+0x18010B44,
+0x00000000,
+0x18010B48,
+0x00000000,
+0x18010B4C,
+0x00000000,
+0x18010B50,
+0x00000000,
+0x18010B54,
+0x00000000,
+0x18010B58,
+0x00000000,
+0x18010B5C,
+0x00000000,
+0x18010B60,
+0x00000004,
+0x18010B64,
+0x00000007,
+0x18010B68,
+0x00000000,
+0x18010B6C,
+0x00000000,
+0x18010BA0,
+0x00500000,
+0x18010BA4,
+0x0000000A,
+0x18010BA8,
+0x00000000,
+0x18010BAC,
+0x00000003,
+0x18010BB0,
+0x00000000,
+0x18010C00,
+0x00010028,
+0x18010C04,
+0x00010000,
+0x18010C08,
+0x0001001F,
+0x18010C0C,
+0x0001001F,
+0x18010C10,
+0x0001001D,
+0x18010C14,
+0x0001001D,
+0x18010C18,
+0x0001001D,
+0x18010C1C,
+0x0001001D,
+0x18010C20,
+0x0001001D,
+0x18010C24,
+0x0001001D,
+0x18010C28,
+0x0001001D,
+0x18010C2C,
+0x0001001D,
+0x18010C30,
+0x00000000,
+0x18010C34,
+0x0001000F,
+0x18010C38,
+0x0001000F,
+0x18010C3C,
+0x0001000F,
+0x18010C40,
+0x0001000F,
+0x18010C44,
+0x0001000F,
+0x18010C48,
+0x0001000F,
+0x18010C4C,
+0x0001000F,
+0x18010C50,
+0x0001000F,
+0x18010C54,
+0x0001000F,
+0x18010C58,
+0x0001000F,
+0x18010C5C,
+0x0001000F,
+0x18010C60,
+0x0001000F,
+0x18010C64,
+0x0001000F,
+0x18010C68,
+0x0001000F,
+0x18010C6C,
+0x0001000F,
+0x18010C70,
+0x0001000F,
+0x18010C74,
+0x00010027,
+0x18010CA4,
+0x00010000,
+0x18010CA8,
+0x00010019,
+0x18010CAC,
+0x00010019,
+0x18010CB0,
+0x00010018,
+0x18010CB4,
+0x00010018,
+0x18010CB8,
+0x00010018,
+0x18010CBC,
+0x00010018,
+0x18010CC0,
+0x00010018,
+0x18010CC4,
+0x00010018,
+0x18010CC8,
+0x00010018,
+0x18010CCC,
+0x00010018,
+0x18010CD0,
+0x00000000,
+0x18010CD4,
+0x00010000,
+0x18010CD8,
+0x00010000,
+0x18010CDC,
+0x00010000,
+0x18010CE0,
+0x00010000,
+0x18010CE4,
+0x00010000,
+0x18010CE8,
+0x00010000,
+0x18010CEC,
+0x00010000,
+0x18010CF0,
+0x00010000,
+0x18010CF4,
+0x00010000,
+0x18010CF8,
+0x00010000,
+0x18010CFC,
+0x00010000,
+0x18010D00,
+0x00010000,
+0x18010D04,
+0x00010000,
+0x18010D08,
+0x00010000,
+0x18010D0C,
+0x00010000,
+0x18010D10,
+0x00010000,
+0x18010D14,
+0x00010029,
+0x18010D18,
+0x00000000,
+0x18010D1C,
+0x00000000,
+0x18010D20,
+0x00000000,
+0x18010D24,
+0x00000000,
+0x18010D28,
+0x00000000,
+0x18010D2C,
+0x00000000,
+0x18010D30,
+0x00000000,
+0x18010D34,
+0x00000000,
+0x18010D38,
+0x00000000,
+0x18010D3C,
+0x00000000,
+0x18010D40,
+0x00000000,
+0x18010D44,
+0x00000000,
+0x18010D48,
+0x00000000,
+0x18010D4C,
+0x00000000,
+0x18010D50,
+0x00000000,
+0x18010D54,
+0x00000000,
+0x18010D58,
+0x00000000,
+0x18010D5C,
+0x00000000,
+0x18010D60,
+0x00000004,
+0x18010D64,
+0x00000007,
+0x18010D68,
+0x00000000,
+0x18010D6C,
+0x00000000,
+0x18010DA0,
+0x00500000,
+0x18010DA4,
+0x0000000A,
+0x18010DA8,
+0x00000000,
+0x18010DAC,
+0x00000003,
+0x18010DB0,
+0x00000000,
+0x18010E00,
+0x0001002D,
+0x18010E04,
+0x00010000,
+0x18010E08,
+0x0001001A,
+0x18010E0C,
+0x0001001A,
+0x18010E10,
+0x00010016,
+0x18010E14,
+0x00010016,
+0x18010E18,
+0x00010016,
+0x18010E1C,
+0x00010016,
+0x18010E20,
+0x00000000,
+0x18010E34,
+0x00010000,
+0x18010E38,
+0x00010000,
+0x18010E3C,
+0x00010000,
+0x18010E40,
+0x00010000,
+0x18010E44,
+0x00010000,
+0x18010E48,
+0x00010000,
+0x18010E4C,
+0x00010000,
+0x18010E50,
+0x00010000,
+0x18010E74,
+0x0001002D,
+0x18010F60,
+0x00000004,
+0x18010F64,
+0x00000007,
+0x18010FA0,
+0x00500000,
+0x18010FA4,
+0x0000000A,
+0x18010FAC,
+0x00000003,
+0x00000A09,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0xEA00001A,
+0xE59FF018,
+0xE59FF018,
+0xE59FF018,
+0xE59FF018,
+0xE59FF018,
+0xE59FF018,
+0xE59FF018,
+0x55AA55AA,
+0xDFF4C240,
+0xDFF4C2A0,
+0xDFF4C300,
+0xDFF4C360,
+0xDFF4C3C0,
+0xDFF4C420,
+0xDFF4C460,
+0x12345678,
+0xDEADBEEF,
+0xDEADBEEF,
+0xDEADBEEF,
+0x1B006000,
+0x00061128,
+0x00061128,
+0x000A2250,
+0x00063FF8,
+0xDFF46F64,
+0xDFF45F64,
+0xDFF46F70,
+0xEB00005E,
+0xE10F0000,
+0xE3C0001F,
+0xE38000D3,
+0xE129F000,
+0xEE110F10,
+0xE3C00A02,
+0xEE010F10,
+0xE59F0408,
+0xEE0C0F10,
+0xEB000055,
+0xEB000062,
+0xE59FD3FC,
+0xE3CDD007,
+0xE3A00000,
+0xEB003AC6,
+0xE1A04000,
+0xE1A05001,
+0xE1A06002,
+0xE1A0D004,
+0xE24F00C8,
+0xE1500006,
+0x03A09000,
+0x0A000026,
+0xE1A01006,
+0xE51F3084,
+0xE0802003,
+0xE8B00600,
+0xE8A10600,
+0xE1500002,
+0x3AFFFFFB,
+0xE51F00A4,
+0xE0469000,
+0xE59FA06C,
+0xE08AA000,
+0xE59F205C,
+0xE0822000,
+0xE59F3058,
+0xE0833000,
+0xE5920000,
+0xE0800009,
+0xE5921004,
+0xE20170FF,
+0xE3570017,
+0x0A000007,
+0xE3570002,
+0x0A000000,
+0xEA000006,
+0xE1A01221,
+0xE08A1001,
+0xE5911004,
+0xE0811009,
+0xEA000001,
+0xE5901000,
+0xE0811009,
+0xE5801000,
+0xE2822008,
+0xE1520003,
+0x3AFFFFEB,
+0xEA000002,
+0x00061128,
+0x000634C8,
+0x000634C8,
+0xE51F0120,
+0xE51F111C,
+0xE1A04006,
+0xE0800004,
+0xE0811004,
+0xE3A02000,
+0xE1500001,
+0x2A00000A,
+0xE5802000,
+0xE2800004,
+0xEAFFFFFA,
+0xE1A00006,
+0xE3A01000,
+0xE3A02040,
+0xE0822006,
+0xE8B00180,
+0xE8A10180,
+0xE1500002,
+0x3AFFFFFB,
+0xEE070F15,
+0xEE070F9A,
+0xEE070F95,
+0xE59F02D4,
+0xE0800009,
+0xEE0C0F10,
+0xE59F0014,
+0xE24F1F77,
+0xE080E001,
+0xE08EE009,
+0xE1A00005,
+0xE1A01006,
+0xE1A0F00E,
+0x0000EABC,
+0xE12FFF1E,
+0xE3A00000,
+0xEE080F17,
+0xEE070F15,
+0xEE070FD5,
+0xEE070F9A,
+0xEE070F95,
+0xEE110F10,
+0xE3C00A02,
+0xE3C00007,
+0xE3800002,
+0xE3800B02,
+0xE3800A01,
+0xEE010F10,
+0xE1A0F00E,
+0xEA0000A6,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE51FD1DC,
+0xE58DE000,
+0xE14FE000,
+0xE58DE004,
+0xE3A0D013,
+0xE169F00D,
+0xE1A0E00F,
+0xE1B0F00E,
+0xE24DD048,
+0xE88D1FFF,
+0xE51F2204,
+0xE892000C,
+0xE28D0048,
+0xE28D5034,
+0xE1A0100E,
+0xE885000F,
+0xE1A0000D,
+0xEB003C21,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE24DD004,
+0xE58D0000,
+0xE51F0244,
+0xE580E000,
+0xE14F0000,
+0xE580E004,
+0xE59D0000,
+0xE28DD004,
+0xE24DD048,
+0xE88D1FFF,
+0xE51F2264,
+0xE892000C,
+0xE28D0048,
+0xE28D5034,
+0xE1A0100E,
+0xE885000F,
+0xE1A0000D,
+0xEB003C13,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE51FD29C,
+0xE58DE000,
+0xE14FE000,
+0xE58DE004,
+0xE3A0D013,
+0xE169F00D,
+0xE1A0E00F,
+0xE1B0F00E,
+0xE24DD048,
+0xE88D1FFF,
+0xE51F22C4,
+0xE892000C,
+0xE28D0048,
+0xE28D5034,
+0xE1A0100E,
+0xE885000F,
+0xE1A0000D,
+0xEB003C05,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE51FD2FC,
+0xE58DE000,
+0xE14FE000,
+0xE58DE004,
+0xE3A0D013,
+0xE169F00D,
+0xE1A0E00F,
+0xE1B0F00E,
+0xE24DD048,
+0xE88D1FFF,
+0xE51F2324,
+0xE892000C,
+0xE28D0048,
+0xE28D5034,
+0xE1A0100E,
+0xE885000F,
+0xE1A0000D,
+0xEB003BF7,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE51FD35C,
+0xE58DE000,
+0xE14FE000,
+0xE58DE004,
+0xE3A0D013,
+0xE169F00D,
+0xE1A0E00F,
+0xE1B0F00E,
+0xE24DD048,
+0xE88D1FFF,
+0xE51F2384,
+0xE892000C,
+0xE28D0048,
+0xE28D5034,
+0xE1A0100E,
+0xE885000F,
+0xE1A0000D,
+0xEB003BE9,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE51FD3C4,
+0xE24DD048,
+0xE88D1FFF,
+0xE28D803C,
+0xE9486000,
+0xE588E000,
+0xE14F6000,
+0xE5886004,
+0xE5880008,
+0xE1A0000D,
+0xEB0006DC,
+0xE8DD7FFF,
+0xE1A00000,
+0xE59DE03C,
+0xE28DD048,
+0xE25EF004,
+0xE51FD400,
+0xE24DD048,
+0xE88D1FFF,
+0xE28D803C,
+0xE9486000,
+0xE588E000,
+0xE14F6000,
+0xE5886004,
+0xE5880008,
+0xE1A0000D,
+0xEB003BD2,
+0xE8DD7FFF,
+0xE1A00000,
+0xE59DE03C,
+0xE28DD048,
+0xE25EF004,
+0xDFF4C000,
+0x1B003FF0,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0xE320F000,
+0x18010320,
+0x18010400,
+0x180108B8,
+0xEE100FB0,
+0xE200000F,
+0xE3500000,
+0x0A000329,
+0xE320F002,
+0xEA00035E,
+0xE59F1D78,
+0xE3A02000,
+0xE5812000,
+0xE59F1D70,
+0xE5812000,
+0xE59F1D6C,
+0xE5912000,
+0xE59F3D68,
+0xE0022003,
+0xE3822619,
+0xE5812000,
+0xE59F9D5C,
+0xE3A01000,
+0xE3A03A19,
+0xE1530001,
+0x0A000005,
+0xE2433001,
+0xE3A02000,
+0xE5992000,
+0xE1520001,
+0x1A000000,
+0xEAFFFFF7,
+0xE59F1D34,
+0xE59F2D34,
+0xE5812000,
+0xE5993000,
+0xE59F1D2C,
+0xE59F2D2C,
+0xE5812000,
+0xE5993000,
+0xE59F1D24,
+0xE3A02010,
+0xE5812000,
+0xE5993000,
+0xE59F4D18,
+0xE3A01001,
+0xE3A03B05,
+0xE1530001,
+0x0A000006,
+0xE2433001,
+0xE3A02000,
+0xE5942000,
+0xE2022001,
+0xE1520001,
+0x0A000000,
+0xEAFFFFF6,
+0xE59F1CEC,
+0xE3A02002,
+0xE5812000,
+0xE5993000,
+0xE59F1CE0,
+0xE5913000,
+0xE3A02001,
+0xE0023003,
+0xE3832002,
+0xE59F1CD0,
+0xE5812000,
+0xE5993000,
+0xE59F1CC8,
+0xE3A02601,
+0xE5812000,
+0xE5993000,
+0xE59F1CBC,
+0xE59F2CBC,
+0xE5812000,
+0xE5993000,
+0xE59F4CB4,
+0xE3A01001,
+0xE3A03B05,
+0xE1530001,
+0x0A000006,
+0xE2433001,
+0xE3A02000,
+0xE5942000,
+0xE2022001,
+0xE1520001,
+0x0A000000,
+0xEAFFFFF6,
+0xE59F4C84,
+0xE3A01002,
+0xE5942000,
+0xE2022002,
+0xE1520001,
+0x0A000063,
+0xE59F1C70,
+0xE59F2C70,
+0xE5812000,
+0xE5993000,
+0xE59F1C68,
+0xE59F2C68,
+0xE5812000,
+0xE5993000,
+0xE59F1C60,
+0xE59F2C58,
+0xE5812000,
+0xE5993000,
+0xE59F1C54,
+0xE59F2C48,
+0xE5812000,
+0xE5993000,
+0xE59F1C48,
+0xE59F2C38,
+0xE5812000,
+0xE5993000,
+0xE59F1C3C,
+0xE59F2C28,
+0xE5812000,
+0xE5993000,
+0xE59F1C30,
+0xE59F2C18,
+0xE5812000,
+0xE5993000,
+0xE59F1C24,
+0xE59F2C08,
+0xE5812000,
+0xE5993000,
+0xE59F1C18,
+0xE59F2BF8,
+0xE5812000,
+0xE5993000,
+0xE59F1C0C,
+0xE59F2BE8,
+0xE5812000,
+0xE5993000,
+0xE59F1C00,
+0xE59F2BD8,
+0xE5812000,
+0xE5993000,
+0xE59F1BF4,
+0xE59F2BC8,
+0xE5812000,
+0xE5993000,
+0xE59F1BE8,
+0xE59F2BB8,
+0xE5812000,
+0xE5993000,
+0xE59F1BDC,
+0xE59F2BA8,
+0xE5812000,
+0xE5993000,
+0xE59F1BD0,
+0xE59F2B98,
+0xE5812000,
+0xE5993000,
+0xE59F1BC4,
+0xE59F2B88,
+0xE5812000,
+0xE5993000,
+0xE59F1BB8,
+0xE59F2B78,
+0xE5812000,
+0xE5993000,
+0xE59F1BAC,
+0xE59F2B68,
+0xE5812000,
+0xE5993000,
+0xE59F1BA0,
+0xE59F2B58,
+0xE5812000,
+0xE5993000,
+0xE59F1B94,
+0xE59F2B48,
+0xE5812000,
+0xE5993000,
+0xE59F1B88,
+0xE59F2B38,
+0xE5812000,
+0xE5993000,
+0xE59F1B7C,
+0xE59F2B28,
+0xE5812000,
+0xE5993000,
+0xE59F1B70,
+0xE59F2B18,
+0xE5812000,
+0xE5993000,
+0xE59F1B64,
+0xE59F2B08,
+0xE5812000,
+0xE5993000,
+0xE59F1B58,
+0xE59F2AF8,
+0xE5812000,
+0xE5993000,
+0xE59F1B4C,
+0xE3A02000,
+0xE5812000,
+0xE59F1B44,
+0xE3A020A0,
+0xE5812000,
+0xE59F1B3C,
+0xE3A02E19,
+0xE5812000,
+0xE59F1B34,
+0xE59F2B34,
+0xE5812000,
+0xE59F1B30,
+0xE59F2B30,
+0xE5812000,
+0xE59F1B2C,
+0xE59F2B2C,
+0xE5812000,
+0xE59F1B28,
+0xE59F2B28,
+0xE5812000,
+0xE59F1B24,
+0xE59F2B24,
+0xE5812000,
+0xE59F1B20,
+0xE59F2B20,
+0xE5812000,
+0xE59F1B1C,
+0xE59F2B1C,
+0xE5812000,
+0xE59F1B18,
+0xE59F2B08,
+0xE5812000,
+0xE59F1B10,
+0xE59F2B10,
+0xE5812000,
+0xE59F1B0C,
+0xE3A02001,
+0xE5812000,
+0xE59F1B04,
+0xE59F2B04,
+0xE5812000,
+0xE59F1B00,
+0xE59F2B00,
+0xE5812000,
+0xE59F1AFC,
+0xE59F2AFC,
+0xE5812000,
+0xE59F1AF8,
+0xE59F2AF8,
+0xE5812000,
+0xE59F1AF4,
+0xE3A02000,
+0xE5812000,
+0xE59F1AEC,
+0xE59F2AEC,
+0xE5812000,
+0xE59F1AE8,
+0xE59F2AE8,
+0xE5812000,
+0xE59F1AE4,
+0xE59F2AE4,
+0xE5812000,
+0xE59F1AE0,
+0xE3A02C05
+};
+
+static int write_shmoo_to_flash(uint32_t *buf, int length)
+{
+    /* Dump data to UART for capture */
+    while (length--) {
+        printf("0x%08X,\n",*buf++);
+    }
+    return 0;
+}
+#elif defined(CONFIG_IPROC_NAND) && defined(CONFIG_ENV_IS_IN_NAND) && CONFIG_ENV_IS_IN_NAND
 
 static int write_shmoo_to_flash(void *buf, int length)
 {
@@ -1705,11 +3328,19 @@ static int write_shmoo_to_flash(void *buf, int length)
     
     /* Erase if necessary */
     if (erase) {
+#if defined(CONFIG_SHMOO_REUSE_QSPI_SIZE)
+        ret = spi_flash_erase(
+                flash, 
+                offset / CONFIG_SHMOO_REUSE_QSPI_SIZE * CONFIG_SHMOO_REUSE_QSPI_SIZE,
+                CONFIG_SHMOO_REUSE_QSPI_SIZE
+                );
+#else
         ret = spi_flash_erase(
                 flash, 
                 offset / flash->sector_size * flash->sector_size, 
                 flash->sector_size
                 );
+#endif
         if (ret) {
             printf("SPI flash erase failed, error=%d\n", ret);
             spi_flash_free(flash);
@@ -1814,10 +3445,15 @@ static volatile uint32_t *validate_flash_shmoo_values(struct shmoo_signature *ps
     flptr = (volatile uint32_t *)(IPROC_NOR_MEM_BASE + CONFIG_SHMOO_REUSE_NOR_OFFSET);
     offset = 0;
 #else
+#if defined(CONFIG_AS4610_30_RECOVERY)
+    flptr = (volatile uint32_t *)as4610_30_shmoo_default;
+    offset = 0;
+#else
     /* Read SHMOO data from SPI */
     flptr = (volatile uint32_t *)(IPROC_QSPI_MEM_BASE + CONFIG_SHMOO_REUSE_QSPI_OFFSET);
     offset = 0;
 #endif
+#endif
 
     /* Get chip type and DDR type/clock */
     dev_id = (reg32_read((volatile uint32_t *)ChipcommonA_ChipID)) & 0x0000ffff;
@@ -1885,7 +3521,7 @@ static int try_restore_shmoo(void)
     int pairs, i;
     
     /* Validate values in flash */
-    printf("Validate Shmoo parameters stored in flash ..... ");
+    printf("       Validate DDR shmoo parameters stored in flash ..... ");
     flptr = validate_flash_shmoo_values(&sig, &pairs);
     if (flptr == NULL) {
         printf("failed\n");
@@ -1897,14 +3533,14 @@ static int try_restore_shmoo(void)
     if (CONFIG_SHMOO_REUSE_DELAY_MSECS > 0) {
         char c = 0;
         unsigned long start;
-        printf("Press Ctrl-C to run Shmoo ..... ");
+        printf("       Press Ctrl-C to run DDR shmoo ..... ");
         start = get_timer(0);
         while(get_timer(start) <= CONFIG_SHMOO_REUSE_DELAY_MSECS) {
             if (tstc()) {
                 c = getc();
                 if (c == 0x03) {
                     printf("Pressed.\n");
-                    printf("Do you want to run the Shmoo? [y/N] ");
+                    printf("Do you want to run DDR shmoo? [y/N] ");
                     for(;;) {
                         c = getc();
                         if (c == 'y' || c == 'Y') {
@@ -1932,7 +3568,7 @@ static int try_restore_shmoo(void)
     }
     
     /* Restore values from flash */
-    printf("Restoring Shmoo parameters from flash ..... ");
+    printf("       Restoring DDR shmoo parameters from flash ..... ");
     flptr += 5;
     for(i=0; i<pairs; i++) {
         reg = (uint32_t *)(*flptr++);
@@ -1956,7 +3592,7 @@ static int try_restore_shmoo(void)
     
     /* Perform memory test to see if the parameters work */
     if (CONFIG_SHMOO_REUSE_MEMTEST_LENGTH > 0 ) {
-        printf("Running simple memory test ..... ");
+        printf("       Running simple memory test ..... ");
         i = simple_memory_test(
             (void *)CONFIG_SHMOO_REUSE_MEMTEST_START,
             CONFIG_SHMOO_REUSE_MEMTEST_LENGTH);
@@ -2010,8 +3646,11 @@ void iproc_save_shmoo_values(void)
         printf("Error allocating memory for saving Shmoo values!\n");
         return;
     }
+#if defined(CONFIG_AS4610_30_RECOVERY)
+    printf("%s: length=%d, address=0x%08X\n", __func__, length, buffer);
+#endif
     ptr = buffer;
-    
+
     /* Fill signature */
     shmoo_sig2mem(&sig,ptr);
     ptr += 5;
@@ -2134,8 +3773,10 @@ static int clear_ddr(uint32_t offset, uint32_t size)
 	if((get_timer(start) <= 10000)  &&
 	   (!reg32_read((volatile uint32_t *)DDR_BistErrorOccurred)))
 	{
+#if defined(IPROC_DDR_INIT2_DEBUG)
 		printf("clear_ddr: OK\n");
-		return(0);
+#endif
+        return(0);
 	}
 	printf("clear_ddr: Failed: 0x%lx\n", get_timer(start));
 	if(reg32_read((volatile uint32_t *)DDR_BistErrorOccurred))
@@ -2179,7 +3820,7 @@ static int simple_ddr_crc32_check(void)
 }
 #endif
 
-void ddr_init2(void)
+int ddr_init2(void)
 {
 	int i;
 	volatile unsigned int val;
@@ -2228,7 +3869,15 @@ void ddr_init2(void)
 		dev_id = 56450; /* KATANA2 */
 	}
 
-	printf("DEV ID = 0x%x\n", dev_id);
+    printf("Device:");
+    switch (dev_id) {
+        case 0xdc14:
+            printf("Helix4 (0x%x)\n", dev_id);
+            break;
+        default:
+            printf("Unknown (0x%x)\n", dev_id);
+            break;
+    }
 #if (defined(CONFIG_NS_PLUS))
 	uint32_t otp_status = 0;
 	/* get device id from OTP */
@@ -2254,7 +3903,15 @@ void ddr_init2(void)
 
 #endif /* (defined(CONFIG_NS_PLUS)) */
 
-	printf("SKU ID = 0x%x\n", sku_id);
+    printf("SKU:   ");
+    switch (sku_id) {
+        case 0xb340:
+            printf("BCM56340 (0x%x)\n", sku_id);
+            break;
+        default:
+            printf("Unknown (0x%x)\n", sku_id);
+            break;
+    }
 
 #if defined(CONFIG_IPROC_P7)
 	val = reg32_read((volatile uint32_t *)DDR_S1_IDM_IO_STATUS) & 0x3;
@@ -2264,23 +3921,23 @@ void ddr_init2(void)
 		ddr_type = 2;
 	} else {
 		printf("Unsupported DDR type: %d\n", val);
-		return;
+		return -1;
 	}
     printf("DDR type: DDR%d\n", (ddr_type == 1)? 3 : 4);
 #elif defined(CONFIG_CYGNUS)
     ddr_type = 1;
 #else
 	ddr_type = reg32_read((volatile uint32_t *)DDR_S1_IDM_IO_STATUS) & 0x1; 
-	printf("DDR type: DDR%d\n", (ddr_type) ? 3 : 2);
 #endif /* defined(CONFIG_IPROC_P7) */
     
 	ddr_clk = get_ddr_clock(sku_id, ddr_type);
-	printf("MEMC 0 DDR speed = %dMHz\n", ddr_clk);
+    printf("DRAM:  ");
+    printf("DDR%d, %dMHz\n", (ddr_type) ? 3 : 2, ddr_clk);
 
 	status = change_ddr_clock(ddr_clk);
 	if(status) {
 		printf("CRU LCPLL configuratioin failed\n");
-		return;
+		return -1;
 	}
 
 #if defined(CONFIG_IPROC_P7)
@@ -2327,7 +3984,7 @@ void ddr_init2(void)
 	}
 	if(i == 0x19000) {
 		printf("DDR PHY not power up\n");
-		return;
+		return -1;
 	}
 #endif
 #endif /* defined(CONFIG_IPROC_P7) */
@@ -2368,7 +4025,7 @@ void ddr_init2(void)
 
 	if(i == 0x19000) {
 		printf("DDR PLL not locked\n");
-		return;
+		return -1;
 	}
 
 	/* Get the DDR S0 out of reset */
@@ -2384,14 +4041,16 @@ void ddr_init2(void)
 	for(i=0; i < 0x19000; i++) {
 		val = reg32_read((volatile uint32_t *)DDR_PHY_CONTROL_REGS_REVISION);
 		if( val != 0) {
+#if defined(IPROC_DDR_INIT2_DEBUG)
             printf("PHY revision version: 0x%08x\n", val);
-			break; /* DDR PHY is up */
+#endif
+            break; /* DDR PHY is up */
         }
 	}
 	
 	if(i == 0x19000) {
 		printf("DDR PHY is not up\n");
-		return;
+		return -1;
 	}
 #if (defined(CONFIG_HELIX4) || defined(CONFIG_KATANA2))
 	/* mhz = 0x190, 32 bit bus, 16 bit chip width, 1.35v vddq, 8Gb chip size, jedec type = 25 (DDR3-1866M) */
@@ -2432,8 +4091,10 @@ void ddr_init2(void)
 #endif /* (defined(CONFIG_NS_PLUS)) */
 
 #if (defined(CONFIG_HELIX4) || defined(CONFIG_KATANA2))
-	printf("ddr_init2: Calling soc_ddr40_set_shmoo_dram_config\n");
-	soc_ddr40_set_shmoo_dram_config(unit, ((uint32) 0xFFFFFFFF) >> (32 - 2));
+#if defined(IPROC_DDR_INIT2_DEBUG)
+    printf("ddr_init2: Calling soc_ddr40_set_shmoo_dram_config\n");
+#endif
+    soc_ddr40_set_shmoo_dram_config(unit, ((uint32) 0xFFFFFFFF) >> (32 - 2));
 #elif (defined(CONFIG_HURRICANE2))
 	printf("ddr_init2: Calling soc_ddr40_set_shmoo_dram_config\n");
 	soc_ddr40_set_shmoo_dram_config(unit, ((uint32) 0xFFFFFFFF) >> (32 - 1));
@@ -2473,8 +4134,10 @@ void ddr_init2(void)
 	}
 	else
 	{
+#if defined(IPROC_DDR_INIT2_DEBUG)
 		printf("DeepSleep wakeup: ddr init bypassed 1\n");
-	}
+#endif
+    }
 #elif defined(CONFIG_GREYHOUND)
 	printf("ddr_init2: Calling soc_and28_shmoo_dram_info_set\n");
 	sdi.data_rate_mbps = (ddr_clk == 667) ? 1333 : (ddr_clk * 2);
@@ -2555,7 +4218,7 @@ void ddr_init2(void)
   }
   if (i == 4000) {
 		printf("VDL calibration timeout!\n");
-		return;
+		return -1;
 	}
 	reg32_write((volatile uint32_t *)DDR_PHY_CONTROL_REGS_VDL_CALIBRATE, 0x00000000);
 	/* CKE adjustment */
@@ -2613,13 +4276,17 @@ void ddr_init2(void)
   }
   
 #elif !(defined(CONFIG_CYGNUS) || defined(CONFIG_GREYHOUND))
+#if defined(IPROC_DDR_INIT2_DEBUG)
 	printf("ddr_init2: Calling soc_ddr40_phy_calibrate\n");
-	if(soc_ddr40_phy_calibrate(unit, 0, DDR_PHYTYPE_ENG, 0) != SOC_E_NONE) {
+#endif
+    if(soc_ddr40_phy_calibrate(unit, 0, DDR_PHYTYPE_ENG, 0) != SOC_E_NONE) {
 
 		printf("DDR phy calibration failed\n");
-		return;
+        return -1;
 	} else {
+#if defined(IPROC_DDR_INIT2_DEBUG)
 		printf("DDR phy calibration passed\n");
+#endif
     }
 #else
 	if(!skip_shmoo)
@@ -2628,13 +4295,15 @@ void ddr_init2(void)
 		if(soc_and28_shmoo_phy_init(unit, 0) != SOC_E_NONE) {
 
 			printf("DDR PHY initialization failed\n");
-			return;
+			return -1;
 		}
 	}
 	else
 	{
+#if defined(IPROC_DDR_INIT2_DEBUG)
 		printf("DeepSleep wakeup: ddr init bypassed 2\n");
-	}
+#endif
+    }
 #endif /* !(defined(CONFIG_CYGNUS) || defined(CONFIG_GREYHOUND)) */
 
 #if defined(CONFIG_SABER2)
@@ -2647,10 +4316,11 @@ void ddr_init2(void)
 #endif
 
 #if !(defined(CONFIG_SABER2) && defined(CONFIG_IPROC_EMULATION))
-	printf("Programming controller register\n");
+#if defined(IPROC_DDR_INIT2_DEBUG)
+    printf("Programming controller register\n");
+#endif
 	ddr_init_regs(ddr_init_tab);
 #endif
-
     ddr_type = 1;
 	if(ddr_type) {
 		/* DDR3 */	
@@ -2728,8 +4398,12 @@ void ddr_init2(void)
   {  /* this statement is to reduce compile error */
   }
 #else
-	while(!(reg32_read((volatile uint32_t *)DDR_DENALI_CTL_89) & 0x100));
+#if !defined(CONFIG_AS4610_30_RECOVERY)
+  while(!(reg32_read((volatile uint32_t *)DDR_DENALI_CTL_89) & 0x100));
+#endif
+#if defined(IPROC_DDR_INIT2_DEBUG)
 	printf("ddr_init2: MemC initialization complete\n");
+#endif
 	
 	/* Srini - Write to DDR controller registers */
 	reg32_write((unsigned int *)0x18010354, 0x00FFFFFF);
@@ -2742,7 +4416,9 @@ void ddr_init2(void)
 	if (try_restore_shmoo()) 
   #endif /* CONFIG_SHMOO_REUSE */
 	{
+#if defined(IPROC_DDR_INIT2_DEBUG)
 		printf("ddr_init2: Calling soc_ddr40_shmoo_ctl\n");
+#endif
 		soc_ddr40_shmoo_ctl(unit, 0, 2, 2, 0, 1);
 	}
 #endif  /* defined(CONFIG_SABER2) */
@@ -2798,8 +4474,10 @@ void ddr_init2(void)
 #endif /* !(defined(CONFIG_CYGNUS) || defined(CONFIG_GREYHOUND)) */
 	else
 	{
+#if defined(IPROC_DDR_INIT2_DEBUG)
 		printf("DeepSleep wakeup: ddr init bypassed 3\n");
-	}
+#endif
+    }
 
 #if defined(CONFIG_IPROC_P7) && defined(CONFIG_IPROC_DDR_ECC)
 	printf("Enabling DDR ECC correcting and reporting\n");
@@ -2819,21 +4497,21 @@ void ddr_init2(void)
 	/* Initialize DDR so that uninitialized reads won't report ecc error */
 	clear_ddr(0, CONFIG_PHYS_SDRAM_1_SIZE);
 #elif defined(CONFIG_IPROC_DDR_ECC)
-	printf("Enabling DDR ECC reporting\n");
+	printf("       Enabling DDR ECC reporting\n");
 	/* Clear DDR interrupts if any */
 	*(unsigned int *)(DDR_DENALI_CTL_213) = 0x00FFFFFF;
 	__udelay(1000);
 	reg32_set_bits((volatile uint32_t *)DDR_DENALI_CTL_67, 0x01); //Disable auto correction
 	reg32_set_bits((volatile uint32_t *)DDR_DENALI_CTL_66, 0x01); //Enable ECC
     
-	clear_ddr(0, CONFIG_PHYS_SDRAM_1_SIZE);
-	printf("Enabling DDR ECC correction\n");
+	clear_ddr(0, CONFIG_PHYS_SDRAM_2_SIZE);
+	printf("       Enabling DDR ECC correction\n");
 	reg32_set_bits((volatile uint32_t *)DDR_DENALI_CTL_66, 1 << 1); //Enable ECC correction
 #endif /* defined(CONFIG_IPROC_P7) && defined(CONFIG_IPROC_DDR_ECC) */
 
 	/* Release DDR slave port to AXI */
 	reg32_clear_bits((volatile uint32_t *)DDR_BistConfig, 1 << DDR_BistConfig__axi_port_sel);
-	printf("DDR Interface Ready\n");
+	printf("       DDR Interface Ready\n");
 
 	//dump_phy_regs();
 
@@ -2862,7 +4540,7 @@ void ddr_init2(void)
 //	iproc_dump_ddr_regs();
 
 	if(pwrctli0==0)
-		return;
+		return -1;
 	
 wakeup:
 	printf("Wakeup from %s\n", pwrctli0==2 ? "SLEEP":"DEEPSLEEP");
@@ -2885,7 +4563,7 @@ wakeup:
 		"mov	lr, #0\n"
 		"mov	pc, r5\n");
 #endif /* defined(CONFIG_CYGNUS) */
-
+    return 0;
 }
 
 #endif /*!(defined(CONFIG_NORTHSTAR)) */
diff --git a/arch/arm/cpu/armv7/iproc/iproc_nand.c b/arch/arm/cpu/armv7/iproc/iproc_nand.c
index dc14845..a9aefb0 100755
--- a/arch/arm/cpu/armv7/iproc/iproc_nand.c
+++ b/arch/arm/cpu/armv7/iproc/iproc_nand.c
@@ -382,12 +382,11 @@ static int iproc_nand_config (
     uint32_t full_addr;
 	int i;
 
-	/* 
-	 * Do not remove the printf below
-	 * It is needed because timers are not yet configured 
+	/*
+	 * Do not remove the delay below
 	 */
-    printf(" ");
-	if (cs >= CHIPSELECT_MAX_COUNT)
+    __udelay(500);
+    if (cs >= CHIPSELECT_MAX_COUNT)
 		return NAND_CONFIG_PARAM;
 
     if (inand && (inand[cs].initialized == IPROC_INIT_MAGIC))
@@ -405,9 +404,13 @@ static int iproc_nand_config (
     }
 
     /* read device ID */
+#ifdef NAND_INFO
     printf("NAND_FLASH_DEVICE_ID_ADDR = %X\n", IPROC_R_NAND_FLASH_DEVICE_ID_ADDR);
+#endif
 	reg_data = readl(IPROC_R_NAND_FLASH_DEVICE_ID_ADDR);
+#ifdef NAND_INFO
     printf("Done that\n");
+#endif
 	if (!reg_data) {
         printf("NAND AutoConfig Fail!\n");
         return NAND_AUTOCONFIG_FAIL;
@@ -600,8 +603,10 @@ static int iproc_nand_config (
         iproc_nand_strap_page_sizes[strap_page] != inand[cs].page_size) {
         
         /* Strap options are invalid */
+#ifdef NAND_INFO
         printf("\n*ERROR* Invalid strap options for this NAND: page=%d type=%d\n",
             strap_page, strap_type);
+#endif
             
         /* Trying to fit with available strap options */
         if (inand[cs].spare_area_bytes >= 27) {
@@ -615,7 +620,9 @@ static int iproc_nand_config (
             strap_type = 2;
         }
         
+#ifdef NAND_INFO
         printf("Overriding invalid strap options: strap_type=%d\n", strap_type);
+#endif
     }
 
 	/* Calculate the REG_ACC_CONTROL */
@@ -651,7 +658,7 @@ static int iproc_nand_config (
 
     inand[cs].initialized = IPROC_INIT_MAGIC;
 
-	printf("%u KiB blocks, %u KiB pages, %uB OOB, %u-bit\n", 
+	printf("NAND:  %u KiB blocks, %u KiB pages, %uB OOB, %u-bit\n", 
 		inand[cs].block_size/1024, 
 		inand[cs].page_size/1024, inand[cs].spare_area_bytes, 
 	    inand[cs].device_width);
@@ -737,7 +744,7 @@ static int iproc_nand_config (
 
     }
 
-	printf("NAND:   chipsize ");  /* will be filled in by u-boot */
+	printf("NAND:  chipsize ");  /* will be filled in by u-boot */
 
     return NAND_STATUS_OK;
 }
diff --git a/arch/arm/cpu/armv7/iproc/shmoo2/shmoo_ddr40.c b/arch/arm/cpu/armv7/iproc/shmoo2/shmoo_ddr40.c
index 10fb9c7..efc440f 100755
--- a/arch/arm/cpu/armv7/iproc/shmoo2/shmoo_ddr40.c
+++ b/arch/arm/cpu/armv7/iproc/shmoo2/shmoo_ddr40.c
@@ -752,8 +752,9 @@ _soc_ddr40_phy_PVT_ctl(int unit, int ci, uint32 phyType, int stat)
                         }
                     //}
 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                     printf("VDL calibration result: 0x%0x (cal_steps = %d)\n", rval, DDR40_GET_FIELD(rval,  DDR40_PHY_CONTROL_REGS, VDL_CALIB_STATUS, CALIB_TOTAL) >> 4);
-
+#endif
                     /* clear VDL calib control */
                     SOC_IF_ERROR_RETURN(WRITE_DDR40_PHY_CONTROL_REGS_VDL_CALIBRATEr(unit,ciC,0));
 
@@ -851,7 +852,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                 break;
             case DDR_PHYTYPE_ENG:
             /*    _soc_ddr40_arad_phy_init_mem_set_wrapper(unit, &ENGfgmss, freq_loc, grade_loc); */
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf("C01. Check Power Up Reset_Bar\n");
+#endif
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
                         continue;
@@ -859,7 +862,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                     soc_timeout_init(&to, to_val, 0);
                 }
                 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf("C02. Config and Release PLL from reset\n");
+#endif
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
                         continue;
@@ -883,7 +888,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                     SOC_IF_ERROR_RETURN(WRITE_DDR40_PHY_CONTROL_REGS_PLL_CONFIGr(unit,ciC,rval));
                 }
                 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf("C03. Poll PLL Lock\n");
+#endif
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
                         continue;
@@ -901,7 +908,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                     } while (TRUE);
                 }
                 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf("C04. Calibrate ZQ (ddr40_phy_calib_zq)\n");
+#endif
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
                         continue;
@@ -931,8 +940,10 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                     } while (TRUE);
                 }
                 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf(
                     "C05. DDR PHY VTT On (Virtual VTT setup) DISABLE all Virtual VTT\n");
+#endif
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
                         continue;
@@ -945,7 +956,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
 
                 }
 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf("C06. DDR40_PHY_DDR3_MISC\n");
+#endif
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
                         continue;
@@ -975,7 +988,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                 if (!SAL_BOOT_QUICKTURN) {
                   uint32 rd_en_byte_mode=0, rd_en_byte_vdl_steps=0, rd_en_bit_vdl_offset=0;
 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                     printf("C07. VDL Calibration\n");
+#endif
                     for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                         if(!_check_dram_either(ciC)) {
                             continue;
@@ -995,44 +1010,63 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                         }
                         soc_timeout_init(&to, to_val, 0);
                         do {
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 							printf("C07.1\n");
+#endif
                             SOC_IF_ERROR_RETURN(READ_DDR40_PHY_CONTROL_REGS_VDL_CALIB_STATUSr(unit,ciC,&rval));
                             if (DDR40_GET_FIELD(rval,  DDR40_PHY_CONTROL_REGS, VDL_CALIB_STATUS, CALIB_IDLE)) {
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 								printf("C07.2\n");
+#endif
                                 break;
                             }
-															printf("C07.3\n");
-                            if (soc_timeout_check(&to)) {
+#if defined(IPROC_DDR_SHMOO_DEBUG)
+						printf("C07.3\n");
+#endif
+                        if (soc_timeout_check(&to)) {
                                 soc_cm_debug(DK_ERR, "CI%d: Timed out waiting for VDL Calibration Idle\n", ciC);
                                 return SOC_E_TIMEOUT;
                             }
                         } while (TRUE);
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 						printf("C07.4\n");
+#endif
                         SOC_IF_ERROR_RETURN(READ_DDR40_PHY_CONTROL_REGS_VDL_CALIB_STATUSr(unit,ciC,&rval));
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 						printf("C07.4.1\n");
+#endif
                         //if (soc_property_get(unit, spn_DIAG_EMULATOR_PARTIAL_INIT, 0x0) == 0) {
                             if (0 == DDR40_GET_FIELD(rval,  DDR40_PHY_CONTROL_REGS, VDL_CALIB_STATUS, CALIB_LOCK)) {
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 								printf("C07.4.2\n");
+#endif
                                 soc_cm_debug(DK_ERR, "CI%d: VDL Calibration Did Not Lock reg=%x \n", ciC, rval);
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 								printf("C07.4.3\n");
+#endif
                                 return SOC_E_FAIL;
                             } 
                         //}
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 							printf("C07.4.4\n");
-
+#endif
                         //printf("VDL calibration result: 0x%0x (cal_steps = %d)\n", \
                          //          rval, DDR40_GET_FIELD(rval,  DDR40_PHY_CONTROL_REGS, VDL_CALIB_STATUS, CALIB_TOTAL) >> 4));
 						//while(1); // Srini
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                         printf("VDL calibration result: 0x%0x (cal_steps = %d)\n", rval, DDR40_GET_FIELD(rval,  DDR40_PHY_CONTROL_REGS, VDL_CALIB_STATUS, CALIB_TOTAL) >> 4);
 
 						printf("C07.4.5\n");
-
+#endif
                         /* clear VDL calib control */
                         SOC_IF_ERROR_RETURN(WRITE_DDR40_PHY_CONTROL_REGS_VDL_CALIBRATEr(unit,ciC,0));
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 						printf("C07.4.6\n");
-
+#endif
                     }
+#if defined(IPROC_DDR_SHMOO_DEBUG)
 					printf("C07.5\n");
+#endif
                     for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                         if(!_check_dram_either(ciC)) {
                             continue;
@@ -1076,11 +1110,15 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                         //}
                     }
                 } else {
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                     printf("C07. VDL Calibration SKIPPED\n");
+#endif
                 }/* Not QUICKTURN */
 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf(
                     "C08. DDR40_PHY_DDR3_MISC : Start DDR40_PHY_RDLY_ODT....\n");
+#endif
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
                         continue;
@@ -1115,7 +1153,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
 #endif
                 }
 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf("C09. Start ddr40_phy_autoidle_on (MEM_SYS_PARAM_PHY_AUTO_IDLE) ....\n");
+#endif
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
                         continue;
@@ -1130,7 +1170,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
 #endif
                 }
 
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf("C10. Wait for Phy Ready...");
+#endif
 #if 0
                 for (ciC = 0; ciC < MAX_SHMOO_INTERFACES; ciC+=2) { /* Only Even CIs */
                     if(!_check_dram_either(ciC)) {
@@ -1150,7 +1192,9 @@ soc_ddr40_phy_calibrate(int unit, int ci, uint32 phyType, int stat)
                 }
 #endif
 				sal_usleep(50000); /* 50 ms */
+#if defined(IPROC_DDR_SHMOO_DEBUG)
                 printf("Done.\n");
+#endif
                 break;
             case DDR_PHYTYPE_CE:
                 break;
diff --git a/arch/arm/cpu/armv7/iproc/timer.c b/arch/arm/cpu/armv7/iproc/timer.c
index 555bcbf..47ac975 100755
--- a/arch/arm/cpu/armv7/iproc/timer.c
+++ b/arch/arm/cpu/armv7/iproc/timer.c
@@ -95,13 +95,14 @@ void iproc_clk_enum(void)
 #else
 	iproc_clk.arm_periph_clk = iproc_clk.arm_clk / 2;
 #endif
-	if(iproc_clk.apb_clk < 1000000 || iproc_clk.arm_periph_clk < 1000000) {
-		printf("arm_clk=%dHz, axi_clk=%dHz, apb_clk=%dHz, arm_periph_clk=%dHz\n", 
+    printf("CLOCKS:");
+    if(iproc_clk.apb_clk < 1000000 || iproc_clk.arm_periph_clk < 1000000) {
+        printf("ARM Core=%dHz, AXI=%dHz, APB=%dHz, Peripheral=%dHz\n",
 		iproc_clk.arm_clk, iproc_clk.axi_clk, 
 		iproc_clk.apb_clk, iproc_clk.arm_periph_clk);
 	}
 	else {
-		printf("arm_clk=%dMHz, axi_clk=%dMHz, apb_clk=%dMHz, arm_periph_clk=%dMHz\n", 
+        printf("ARM Core=%dHz, AXI=%dHz, APB=%dHz, Peripheral=%dHz\n",
 		iproc_clk.arm_clk/1000000, iproc_clk.axi_clk/1000000, 
 		iproc_clk.apb_clk/1000000, iproc_clk.arm_periph_clk/1000000);
 	}
diff --git a/arch/arm/include/asm/iproc/ddr_bist.h b/arch/arm/include/asm/iproc/ddr_bist.h
index f5c1183..b8df310 100755
--- a/arch/arm/include/asm/iproc/ddr_bist.h
+++ b/arch/arm/include/asm/iproc/ddr_bist.h
@@ -17,8 +17,13 @@ extern uint32_t iproc_get_ddr3_clock_mhz(uint32_t unit);
 #define SOC_DDR3_CLOCK_MHZ(unit)	iproc_get_ddr3_clock_mhz(unit)
 
 #if (defined(CONFIG_HELIX4) || defined(CONFIG_KATANA2))
+#if defined(CONFIG_AS4610_30_RECOVERY)
+#define DDR_SHMOO_PARAM_MEM_PTR     (0x1b06A500) /* use top of internal SRAM */
+#define DDR_SHMOO_VREFW_MEM_PTR     (0x1b06B500)
+#else
 #define DDR_SHMOO_PARAM_MEM_PTR		(0x1b040000) /*size ~0x300 */
 #define DDR_SHMOO_VREFW_MEM_PTR		(0x1b041000) /* size ~0x30000 */
+#endif
 #elif defined(CONFIG_HURRICANE2)
 #define DDR_SHMOO_PARAM_MEM_PTR		(0x1b000000)
 #define DDR_SHMOO_VREFW_MEM_PTR		(0x50000000)
diff --git a/arch/arm/include/asm/iproc/iproc_common.h b/arch/arm/include/asm/iproc/iproc_common.h
index 78e85b7..fefca71 100755
--- a/arch/arm/include/asm/iproc/iproc_common.h
+++ b/arch/arm/include/asm/iproc/iproc_common.h
@@ -56,7 +56,7 @@ extern uint32_t iproc_get_axi_clk(uint32_t refclk);
 extern void iproc_clk_enum(void);
 extern uint32_t iproc_read_ecc_syndrome(void);
 extern void iproc_clear_ecc_syndrome(void);
-extern void ddr_init2(void);
+extern int ddr_init2(void);
 extern int is_shmoo_data_valid(void);
 extern void save_shmoo_to_flash(void);
 
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
index 466de29..7e042ea 100755
--- a/arch/arm/lib/board.c
+++ b/arch/arm/lib/board.c
@@ -987,8 +987,8 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	}
 #endif
 
-    printf("========== relocate address: 0x%lx, offset 0x%lx ==========\n",
-    		id->relocaddr, id->relocaddr - 0x1e000000);
+/*    printf("========== relocate address: 0x%lx, offset 0x%lx ==========\n",
+    		id->relocaddr, id->relocaddr - 0x1e000000);*/
 
 
 	/* main_loop() can return to retry autoboot, if so just run it again. */
diff --git a/board/accton/as4610_30/Makefile b/board/accton/as4610_30/Makefile
new file mode 100644
index 0000000..ba09d5e
--- /dev/null
+++ b/board/accton/as4610_30/Makefile
@@ -0,0 +1,28 @@
+include $(TOPDIR)/config.mk
+
+LIB = $(obj)lib$(BOARD).o
+
+COBJS	:= $(BOARD).o ddr_init_table.o usb.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB): $(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS), $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+#include /home/lab/uboot_from_denx_tot/uboot/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/accton/as4610_30/as4610_30.c b/board/accton/as4610_30/as4610_30.c
new file mode 100644
index 0000000..b8135cb
--- /dev/null
+++ b/board/accton/as4610_30/as4610_30.c
@@ -0,0 +1,351 @@
+/*
+ * $Copyright Open Broadcom Corporation$ 
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <config.h>
+#include <asm/arch/iproc.h>
+#include <asm/system.h>
+#include "asm/iproc/reg_utils.h"
+#include "asm/iproc/iproc_common.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern int bcmiproc_eth_register(u8 dev_num);
+extern void iproc_save_shmoo_values(void);
+extern void bcmiproc_serdes_init_early(void);
+
+#if 0
+/* Returns core voltage in milli volts mV */
+/* Applicable only to core voltage ADC on Helix4 SVK */
+int get_core_voltage_adc(uint32_t *coreV) {
+    uint32_t val, i;
+	/* Enable SMBus */
+	reg32_set_bits((volatile uint32_t *)CMIC_I2CM_SMBus_Config, 1 << CMIC_I2CM_SMBus_Config__SMB_EN);
+	/* Write the ADC device address (0x28 on SVK), bit 7-1 is address and bit 0 is R/~W */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Write, 0x00000050);
+
+	/* Write ADC data aquisition command with channel0, 
+	   input volatage range 0 - 5V */ /* Indicate this is the end of write */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Write, 0x80000080);
+
+	/* Issue "Send Byte" command */
+
+	val  = reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command);
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command, 0x80000200);
+
+	i = 10000;
+	do {
+		val  = reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command);
+	} while(--i && (val & 0x80000000));
+
+	/* Clear FIFOs */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_FIFO_control, 0xc0000000);
+
+	if(i == 0 || (val & (0x7 << 25))) {
+		printf("i=%d, val = %x\n", i, val);
+		return (1); /* Command is not successful, return error */
+	}
+	/* Add some delay, just in case */
+	for(i = 0; i < 10000; i++)
+		val = i * 2;
+
+	/* Now read two bytes from ADC */
+	/* Write the ADC device address (0x28 on SVK), bit 7-1 is address and bit 0 is R/~W */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Write, 0x80000051);
+
+	/* Issue "Read Word" command */
+
+	val  = reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command);
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command, 0x80000c00);
+
+	i = 10000;
+	do {
+		val  = reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command);
+	} while(--i && (val & 0x80000000));
+
+	if(i == 0 || (val & (0x7 << 25))) {
+		/* Clear FIFOs */
+		reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_FIFO_control, 0xc0000000);
+		printf("i=%d, val = %x\n", i, val);
+		return (1); /* Command is not successful, return error */
+	}
+	/* Get 12 bit value */
+	*coreV = (reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Read) & 0xFF) << 4; /* MSB 8 bits */
+	//printf("coreV: %x\n", *coreV);
+	*coreV |= (reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Read) >> 4) & 0xF; /* LSB 4 bits */
+	//printf("coreV: %x\n", *coreV);
+	/* convert coreV into mV */
+	*coreV = (*coreV * 5000)/4096;
+	//printf("coreV: %x\n", *coreV);
+	 return(0);
+}
+
+
+
+/* Applicable only to core voltage ADC on Helix4 SVK */
+/* Pass coreV in milli volts, mV */
+int set_core_voltage_dac(uint32_t coreV) {
+    uint32_t val, i, steps;
+	if(coreV > 1050 || coreV < 900) {
+		printf("Error: Unsupported core voltage: %d mV\n", coreV);
+		return(1);
+	}
+
+	/* 1024 steps cover the range of 200mV, from 900mV to 1100mV */
+	steps = ((1100 - coreV) * 1024) / 200;
+	if(steps == 1024)
+		steps -= 1; /* to prevent rollover */
+
+	/* Enable SMBus */
+	reg32_set_bits((volatile uint32_t *)CMIC_I2CM_SMBus_Config, 1 << CMIC_I2CM_SMBus_Config__SMB_EN);
+	/* Clear FIFOs */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_FIFO_control, 0xc0000000);
+	
+	/* Write the DAC device address (0x2C on SVK), bit 7-1 is address and bit 0 is R/~W */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Write, 0x00000058);
+
+	/* 0x3FF -> 0.9v, 0x300 -> 0.95v, 0x200 -> 1.00v, 0x100 -> 1.05v, 0x0 -> 1.1v */
+	/* Write BIT D9 - D8 */ 
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Write, (steps >> 8) & 0xFF);
+
+	/* Write BIT D7 - D0 */ 
+	/* Indicate this is the end of write */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Write, 0x80000000 | (steps & 0xFF));
+
+	/* Issue "Write Byte" command */
+	val  = reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command);
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command, 0x80000600);
+
+	i = 10000;
+	do {
+		val  = reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command);
+	} while(--i && (val & 0x80000000));
+
+
+	if(i == 0 || (val & (0x7 << 25))) {
+		printf("i=%d, val = %x\n", i, val);
+		return (1); /* Command is not successful, return error */
+	}
+	 return(0);
+}
+
+/* Applicable only to core voltage ADC on Helix4 SVK */
+/* Pass coreV in milli volts, mV */
+int set_smbus_mux(uint32_t channel) {
+    uint32_t val, i;
+
+	/* Enable SMBus */
+	reg32_set_bits((volatile uint32_t *)CMIC_I2CM_SMBus_Config, 1 << CMIC_I2CM_SMBus_Config__SMB_EN);
+	/* Clear FIFOs */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_FIFO_control, 0xc0000000);
+	
+	/* Write the MUX device address (0x76 on SVK), bit 7-1 is address and bit 0 is R/~W */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Write, 0x000000E6);
+
+
+	/* Indicate this is the end of write */
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Data_Write, 0x80000000 | 1 << channel);
+
+	/* Issue "Send Byte" command */
+	val  = reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command);
+	reg32_write((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command, 0x80000200);
+
+	i = 10000;
+	do {
+		val  = reg32_read((volatile uint32_t *)CMIC_I2CM_SMBus_Master_Command);
+	} while(--i && (val & 0x80000000));
+
+
+	if(i == 0 || (val & (0x7 << 25))) {
+		printf("i=%d, val = %x\n", i, val);
+		return (1); /* Command is not successful, return error */
+	}
+	 return(0);
+}
+
+
+uint32_t cmicd_schan_read_top(uint32_t addr) {
+    uint32_t read;
+    read=0x0;
+
+    reg32_write((volatile uint32_t *)CMIC_CMC0_SCHAN_MESSAGE0, 0x2c600200);
+    reg32_write((volatile uint32_t *)CMIC_CMC0_SCHAN_MESSAGE1, addr);
+
+    reg32_write((volatile uint32_t *)CMIC_CMC0_SCHAN_CTRL, 0x1);
+
+    while (read != 0x2) {
+       read = reg32_read((volatile uint32_t *)CMIC_CMC0_SCHAN_CTRL); 
+    }
+    read = reg32_read((volatile uint32_t *)CMIC_CMC0_SCHAN_MESSAGE1);
+    return read;
+}
+
+void cmicd_init_soc () {
+
+    uint32_t read_reg;
+
+    // Configure SBUS Ring Map
+    reg32_write((volatile uint32_t *)CMIC_SBUS_RING_MAP_0_7, 0x7752100);
+}
+#endif
+
+/*****************************************
+ * board_init -early hardware init
+ *****************************************/
+int board_init (void)
+{
+    gd->bd->bi_arch_number = CONFIG_MACH_TYPE;      /* board id for linux */
+    gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR; /* adress of boot parameters */
+
+    return 0;
+}
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void
+ft_board_setup(void *blob, bd_t *bd)
+{
+        /* FIXME */
+}
+#endif
+
+/*****************************************************************
+ * misc_init_r - miscellaneous platform dependent initializations
+ ******************************************************************/
+int misc_init_r (void)
+{
+    return(0);
+}
+
+/*****************Helix4 SKUs *************
+Device	Part Number	Frequency
+FireScout	56548	315MHz
+			56547	315MHz
+		
+Helix4	56344	315MHz
+		56342	215MHz
+		56340	250MHz
+		
+Spiral	56049	250MHz
+		56048	315MHz
+		56047	315MHz
+
+Ranger	56042	250MHz
+		56041	250MHz
+		56040	315MHz
+
+******************************************/
+
+/**********************************************
+ * dram_init - sets uboots idea of sdram size
+ **********************************************/
+int dram_init (void)
+{
+	uint32_t sku_id, avs, coreV_req, coreV;
+	int status;
+
+	/* init serdes early */
+	bcmiproc_serdes_init_early();
+
+#if !defined(CONFIG_SPL) || defined(CONFIG_SPL_BUILD)
+	bench_screen_test1();
+//#ifdef CONFIG_RUN_DDR_SHMOO
+#if 0
+	/* Get the required core voltage from TOP_AVS_SEL register, 
+	   and set the VRM (DAC) accordingly */
+	cmicd_init_soc();
+	avs = cmicd_schan_read_top(TOP_AVS_SEL_REG) & 0x07;
+	/* AVS 0 -> 1.00V, 1 -> 0.95V, 2 -> 0.90V, 3 -> 0.85V, 4 -> 0.80V */
+	coreV_req = 1000 - (avs * 50); 
+	if(coreV_req < 900)
+		coreV_req = 900;
+	printf("AVS: 0x%x\n", avs);
+	status = set_smbus_mux(0);
+	if(status != 0) {
+		printf("Error: in set_smbus_mux\n");
+		return(status);
+	}
+
+	status = set_core_voltage_dac(coreV_req);
+	if(status != 0) {
+		printf("Error: in set_core_voltage_dac\n");
+		return(status);
+	}
+
+	status  = get_core_voltage_adc(&coreV);
+	if(status != 0) {
+		printf("Error: in get_core_voltage_adc\n");
+		return(status);
+	}
+	printf("Core Voltage set to: %d mV\n", coreV);
+#endif
+	ddr_init2();
+#endif
+
+	/* Default for AS4610-30P is 2GB */
+    gd->ram_size = CONFIG_PHYS_SDRAM_2_SIZE - CONFIG_PHYS_SDRAM_RSVD_SIZE;
+
+    return 0;
+}
+
+int board_early_init_f (void)
+{
+	int status = 0;
+	iproc_config_armpll(1000);
+	//ihost_pwrdown_cpu(1);
+	//ihost_pwrdown_cpu(0);
+
+	return(status);
+}
+
+int board_late_init (void) 
+{
+	int status = 0;
+	/* Systick initialization(private timer)*/
+	iproc_clk_enum();
+#ifndef STDK_BUILD
+	disable_interrupts();
+#else
+	gic_disable_interrupt(29);
+	irq_install_handler(29, systick_isr, NULL);
+	gic_config_interrupt(29, 1, IPROC_INTR_LEVEL_SENSITIVE, 0, IPROC_GIC_DIST_IPTR_CPU0);
+	iproc_systick_init(10000);
+
+	/* MMU and cache setup */
+	disable_interrupts();
+	//printf("Enabling SCU\n");
+	scu_enable();
+
+	printf("Enabling icache and dcache\n");
+	dcache_enable();
+	icache_enable();
+
+	printf("Enabling l2cache\n");
+	status = l2cc_enable();
+	//printf("Enabling done, status = %d\n", status);
+
+	enable_interrupts();
+#endif
+
+#if defined(CONFIG_RUN_DDR_SHMOO2) && defined(CONFIG_SHMOO_REUSE)
+	/* Save DDR PHY parameters into flash if Shmoo was performed */
+	iproc_save_shmoo_values();
+#endif
+
+#ifdef CONFIG_USB_EHCI
+    printf("USB0:  ");
+    linux_usbh_init();
+#endif
+    return status;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = -1;
+#ifdef CONFIG_BCMIPROC_ETH
+	/*printf("Registering eth\n");*/
+	rc = bcmiproc_eth_register(0);
+#endif
+	return rc;
+}
diff --git a/board/accton/as4610_30/config.mk b/board/accton/as4610_30/config.mk
new file mode 100644
index 0000000..12d85d5
--- /dev/null
+++ b/board/accton/as4610_30/config.mk
@@ -0,0 +1,23 @@
+ifdef CONFIG_NAND_IPROC_BOOT
+CONFIG_SYS_TEXT_BASE = 0x1C000000
+else
+CONFIG_SYS_TEXT_BASE = 0x1E000000
+endif
+
+ifdef CONFIG_IPROC_SPL
+CONFIG_SYS_TEXT_BASE = 0x80000000
+endif
+
+ifdef CONFIG_AS4610_30_RECOVERY
+CONFIG_SYS_TEXT_BASE = 0x1B006000
+endif
+
+ifdef CONFIG_NO_CODE_RELOC
+ifdef CONFIG_SYS_BIG_ENDIAN
+LDSCRIPT := $(SRCTREE)/board/$(BOARDDIR)/u-boot-nr-be.lds
+else
+LDSCRIPT := $(SRCTREE)/board/$(BOARDDIR)/u-boot-nr.lds
+endif
+endif
+
+#PLATFORM_RELFLAGS += -DSVN_REVISION=' " $(SVN_REV)"'
diff --git a/board/accton/as4610_30/ddr1066.txt.array b/board/accton/as4610_30/ddr1066.txt.array
new file mode 100644
index 0000000..3f95cc8
--- /dev/null
+++ b/board/accton/as4610_30/ddr1066.txt.array
@@ -0,0 +1,215 @@
+array1 = { 
+	14, 00000001,
+	36, 01000000,
+	37, 10000000,
+	38, 00100400,
+	39, 00000400,
+	40, 00000100,
+	42, 00000001,
+	61, 00010100,
+	78, 01000200,
+	79, 02000040,
+	80, 00400100,
+	81, 00000200,
+	83, 01ffff0a,
+	84, 01010101,
+	85, 01010101,
+	86, 0f000003,
+	87, 0000010c,
+	88, 00010000,
+	112, 00000200,
+	116, 0d000000,
+	117, 00000028,
+	119, 00010001,
+	120, 00010001,
+	121, 00010001,
+	122, 00010001,
+	123, 00010001,
+	130, 00000001,
+	139, 00000001,
+	148, 00000001,
+	149, 00000000,
+	150, 00000000,
+	152, 03030303,
+	153, 03030303,
+	156, 02006400,
+	157, 02020202,
+	158, 00020202,
+	160, 01000000,
+	161, 01010064,
+	162, 01010101,
+	163, 00000101,
+	165, 00020000,
+	166, 00000064,
+	168, 000b0b00,
+	170, 02000200,
+	171, 02000200,
+	175, 02000200,
+	176, 02000200,
+	180, 80000100,
+	181, 04070303,
+	182, 0000000a,
+	185, 0010ffff,
+	187, 0000000f,
+	194, 00000204,
+	205, 00000000,
+	0xffffffff};
+
+ddr3_init_tab_1066 = { 
+	01, 00000000,
+	03, 0000006b,
+	04, 0000010a,
+	05, 10061000,
+	06, 04040406,
+	07, 0804131a,
+	08, 04131a04,
+	09, 0c040408,
+	10, 030091dd,
+	11, 0c040404,
+	12, 030091dd,
+	13, 01010004,
+	15, 00101000,
+	16, 03000200,
+	17, 00001616,
+	18, 08080000,
+	19, 00000000,
+	20, 0000a001,
+	21, 00a0102d,
+	22, 0005102d,
+	23, 00000400,
+	24, 000d0004,
+	25, 0000000d,
+	26, 00000000,
+	27, 02000000,
+	28, 020000a5,
+	29, 000000a5,
+	30, 06000001,
+	31, 00060606,
+	32, 00000000,
+	35, 00000000,
+	41, 00000000,
+	43, 00000000,
+	44, 00084000,
+	45, 00080046,
+	46, 00460840,
+	47, 00000008,
+	48, 08400000,
+	49, 00080046,
+	50, 00460840,
+	51, 00000008,
+	52, 08400000,
+	53, 00080046,
+	54, 00460840,
+	55, 00000008,
+	56, 08400000,
+	57, 00080046,
+	58, 00460840,
+	59, 00000008,
+	60, 00000000,
+	62, 00000000,
+	63, 00000000,
+	64, 00000000,
+	65, 00000000,
+	66, 00000000,
+	67, 00000000,
+	68, 00000000,
+	69, 00000000,
+	70, 00000000,
+	71, 00000000,
+	72, 00000000,
+	73, 00000000,
+	74, 00000000,
+	75, 00000000,
+	76, 00000000,
+	77, 00000000,
+	82, 01010001,
+	89, 00000000,
+	90, 00000000,
+	91, 00000000,
+	92, 00000000,
+	93, 00000000,
+	94, 00000000,
+	95, 00000000,
+	96, 00000000,
+	97, 00000000,
+	98, 00000000,
+	99, 00000000,
+	100, 00000000,
+	101, 00000000,
+	102, 00000000,
+	103, 00000000,
+	104, 00000000,
+	105, 00000000,
+	106, 00000000,
+	107, 00000000,
+	108, 02040108,
+	109, 08010402,
+	110, 02020002,
+	111, 01000200,
+	113, 00000000,
+	114, 00000000,
+	115, 00000000,
+	118, 00000000,
+	124, 00000000,
+	125, 00000000,
+	126, 00000000,
+	127, 00000000,
+	128, 00212100,
+	129, 21210001,
+	131, 00000000,
+	132, 00000000,
+	133, 00012121,
+	134, 00012121,
+	135, 00000000,
+	136, 00000000,
+	137, 00212100,
+	138, 21210001,
+	140, 00000000,
+	141, 00000000,
+	142, 00012121,
+	143, 00012121,
+	144, 00000000,
+	145, 00000000,
+	146, 00212100,
+	147, 21210001,
+	151, 00000000,
+	167, 00000000,
+	169, 102d0000,
+	172, 0000102d,
+	173, 0000a1c2,
+	174, 102d0608,
+	177, 0000102d,
+	178, 0000a1c2,
+	179, 02020608,
+	183, 00000000,
+	184, 00000000,
+	186, 00070303,
+	188, 00000000,
+	189, 00000000,
+	190, 00000000,
+	191, 00000000,
+	192, 00000000,
+	193, 00000000,
+	195, 00000000,
+	196, 00000000,
+	197, 00000000,
+	198, 00000000,
+	199, 00000000,
+	200, 00000000,
+	201, 00000000,
+	202, 00000006,
+	203, 00000006,
+	204, 00000000,
+	206, 02050501,
+	207, 00000002,
+	208, 00000000,
+	209, 00000000,
+	210, 08080000,
+	211, 00000808,
+	212, 00000040,
+	213, 00000000,
+	214, 01010606,
+	215, 00000101,
+	216, 00002020,
+	217, 00000000,
+	0xffffffff};
diff --git a/board/accton/as4610_30/ddr1333.txt.array b/board/accton/as4610_30/ddr1333.txt.array
new file mode 100644
index 0000000..495cf3d
--- /dev/null
+++ b/board/accton/as4610_30/ddr1333.txt.array
@@ -0,0 +1,218 @@
+array1 = { 
+	14, 0x00000001,
+	36, 0x01000000,
+	37, 0x10000000,
+	38, 0x00100400,
+	39, 0x00000400,
+	40, 0x00000100,
+	42, 0x00000001,
+	61, 0x00010100,
+	78, 0x01000200,
+	79, 0x02000040,
+	80, 0x00400100,
+	81, 0x00000200,
+	83, 0x01ffff0a,
+	84, 0x01010101,
+	85, 0x01010101,
+	86, 0x0f000003,
+	87, 0x0000010c,
+	88, 0x00010000,
+	112, 0x00000200,
+	116, 0x0d000000,
+	117, 0x00000028,
+	119, 0x00010001,
+	120, 0x00010001,
+	121, 0x00010001,
+	122, 0x00010001,
+	123, 0x00010001,
+	130, 0x00000001,
+	139, 0x00000001,
+	148, 0x00000001,
+	149, 0x00000000,
+	150, 0x00000000,
+	152, 0x03030303,
+	153, 0x03030303,
+	156, 0x02006400,
+	157, 0x02020202,
+	158, 0x00020202,
+	160, 0x01000000,
+	161, 0x01010064,
+	162, 0x01010101,
+	163, 0x00000101,
+	165, 0x00020000,
+	166, 0x00000064,
+	168, 0x000c0c00,
+	170, 0x02000200,
+	171, 0x02000200,
+	175, 0x02000200,
+	176, 0x02000200,
+	180, 0x80000100,
+	181, 0x04070303,
+	182, 0x0000000a,
+	185, 0x0010ffff,
+	187, 0x0000000f,
+	194, 0x00000204,
+	205, 0x00000000,
+	0xffffffff
+};
+
+ddr3_init_tab_1333[] = { 
+	1, 0x00000600,
+	1, 0x00000000,
+	3, 0x000208d6,
+	4, 0x00051616,
+	5, 0x12071200,
+	6, 0x05040407,
+	7, 0x09051821,
+	8, 0x05182105,
+	9, 0x0c040509,
+	10, 0x0400b6d0,
+	11, 0x0c040504,
+	12, 0x0400b6d0,
+	13, 0x01010004,
+	15, 0x00131300,
+	16, 0x03000200,
+	17, 0x00001b1b,
+	18, 0x09090000,
+	19, 0x00000000,
+	20, 0x0000c801,
+	21, 0x00c81448,
+	22, 0x00051448,
+	23, 0x00000400,
+	24, 0x00100004,
+	25, 0x00000010,
+	26, 0x00000000,
+	27, 0x02000000,
+	28, 0x020000cf,
+	29, 0x000000cf,
+	30, 0x07000001,
+	31, 0x00070707,
+	32, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x000a5000,
+	45, 0x00100046,
+	46, 0x00460a50,
+	47, 0x00000010,
+	48, 0x0a500000,
+	49, 0x00100046,
+	50, 0x00460a50,
+	51, 0x00000010,
+	52, 0x0a500000,
+	53, 0x00100046,
+	54, 0x00460a50,
+	55, 0x00000010,
+	56, 0x0a500000,
+	57, 0x00100046,
+	58, 0x00460a50,
+	59, 0x00000010,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000,
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01010001,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02040108,
+	109, 0x08010402,
+	110, 0x02020002,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x00222200,
+	129, 0x22220001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00012222,
+	134, 0x00012222,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x00222200,
+	138, 0x22220001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00012222,
+	143, 0x00012222,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x00222200,
+	147, 0x22220001,
+	151, 0x00000000,
+	167, 0x00000000,
+	169, 0x14480000,
+	172, 0x00001448,
+	173, 0x0000cad0,
+	174, 0x14480709,
+	177, 0x00001448,
+	178, 0x0000cad0,
+	179, 0x02020709,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00000007,
+	203, 0x00000007,
+	204, 0x00000000,
+	206, 0x02060601,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x0a090000,
+	211, 0x00000a09,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x01010606,
+	215, 0x00000101,
+	216, 0x00002323,
+	217, 0x00000000,
+	0xffffffff
+};
diff --git a/board/accton/as4610_30/ddr1600.txt.array b/board/accton/as4610_30/ddr1600.txt.array
new file mode 100644
index 0000000..5042d63
--- /dev/null
+++ b/board/accton/as4610_30/ddr1600.txt.array
@@ -0,0 +1,215 @@
+array1 = { 
+	14, 00000001,
+	36, 01000000,
+	37, 10000000,
+	38, 00100400,
+	39, 00000400,
+	40, 00000100,
+	42, 00000001,
+	61, 00010100,
+	78, 01000200,
+	79, 02000040,
+	80, 00400100,
+	81, 00000200,
+	83, 01ffff0a,
+	84, 01010101,
+	85, 01010101,
+	86, 0f000003,
+	87, 0000010c,
+	88, 00010000,
+	112, 00000200,
+	116, 0d000000,
+	117, 00000028,
+	119, 00010001,
+	120, 00010001,
+	121, 00010001,
+	122, 00010001,
+	123, 00010001,
+	130, 00000001,
+	139, 00000001,
+	148, 00000001,
+	149, 00000000,
+	150, 00000000,
+	152, 03030303,
+	153, 03030303,
+	156, 02006400,
+	157, 02020202,
+	158, 00020202,
+	160, 01000000,
+	161, 01010064,
+	162, 01010101,
+	163, 00000101,
+	165, 00020000,
+	166, 00000064,
+	168, 000c0c00,
+	170, 02000200,
+	171, 02000200,
+	175, 02000200,
+	176, 02000200,
+	180, 80000100,
+	181, 04070303,
+	182, 0000000a,
+	185, 0010ffff,
+	187, 0000000f,
+	194, 00000204,
+	205, 00000000,
+	0xffffffff};
+
+ddr3_init_tab_1600 = {
+	01, 00000000,
+	03, 000000a0,
+	04, 00000190,
+	05, 16081600,
+	06, 06040408,
+	07, 0b061c27,
+	08, 061c2706,
+	09, 0c04060b,
+	10, 0400db60,
+	11, 0c040604,
+	12, 0400db60,
+	13, 01010004,
+	15, 00171700,
+	16, 03000200,
+	17, 00002020,
+	18, 0b0b0000,
+	19, 00000000,
+	20, 0000f001,
+	21, 00f01858,
+	22, 00051858,
+	23, 00000500,
+	24, 00140005,
+	25, 00000014,
+	26, 00000000,
+	27, 02000000,
+	28, 020000f8,
+	29, 000000f8,
+	30, 08000001,
+	31, 00080808,
+	32, 00000000,
+	35, 00000000,
+	41, 00000000,
+	43, 00000000,
+	44, 000c7000,
+	45, 00180046,
+	46, 00460c70,
+	47, 00000018,
+	48, 0c700000,
+	49, 00180046,
+	50, 00460c70,
+	51, 00000018,
+	52, 0c700000,
+	53, 00180046,
+	54, 00460c70,
+	55, 00000018,
+	56, 0c700000,
+	57, 00180046,
+	58, 00460c70,
+	59, 00000018,
+	60, 00000000,
+	62, 00000000,
+	63, 00000000,
+	64, 00000000,
+	65, 00000000,
+	66, 00000000,
+	67, 00000000,
+	68, 00000000,
+	69, 00000000,
+	70, 00000000,
+	71, 00000000,
+	72, 00000000,
+	73, 00000000,
+	74, 00000000,
+	75, 00000000,
+	76, 00000000,
+	77, 00000000,
+	82, 01010001,
+	89, 00000000,
+	90, 00000000,
+	91, 00000000,
+	92, 00000000,
+	93, 00000000,
+	94, 00000000,
+	95, 00000000,
+	96, 00000000,
+	97, 00000000,
+	98, 00000000,
+	99, 00000000,
+	100, 00000000,
+	101, 00000000,
+	102, 00000000,
+	103, 00000000,
+	104, 00000000,
+	105, 00000000,
+	106, 00000000,
+	107, 00000000,
+	108, 02040108,
+	109, 08010402,
+	110, 02020002,
+	111, 01000200,
+	113, 00000000,
+	114, 00000000,
+	115, 00000000,
+	118, 00000000,
+	124, 00000000,
+	125, 00000000,
+	126, 00000000,
+	127, 00000000,
+	128, 00232300,
+	129, 23230001,
+	131, 00000000,
+	132, 00000000,
+	133, 00012323,
+	134, 00012323,
+	135, 00000000,
+	136, 00000000,
+	137, 00232300,
+	138, 23230001,
+	140, 00000000,
+	141, 00000000,
+	142, 00012323,
+	143, 00012323,
+	144, 00000000,
+	145, 00000000,
+	146, 00232300,
+	147, 23230001,
+	151, 00000000,
+	167, 00000000,
+	169, 18580000,
+	172, 00001858,
+	173, 0000f370,
+	174, 1858080b,
+	177, 00001858,
+	178, 0000f370,
+	179, 0202080b,
+	183, 00000000,
+	184, 00000000,
+	186, 00070303,
+	188, 00000000,
+	189, 00000000,
+	190, 00000000,
+	191, 00000000,
+	192, 00000000,
+	193, 00000000,
+	195, 00000000,
+	196, 00000000,
+	197, 00000000,
+	198, 00000000,
+	199, 00000000,
+	200, 00000000,
+	201, 00000000,
+	202, 00000008,
+	203, 00000008,
+	204, 00000000,
+	206, 02070701,
+	207, 00000002,
+	208, 00000000,
+	209, 00000000,
+	210, 0c0b0000,
+	211, 00000c0b,
+	212, 00000040,
+	213, 00000000,
+	214, 01010606,
+	215, 00000101,
+	216, 00002727,
+	217, 00000000,
+	0xffffffff};
diff --git a/board/accton/as4610_30/ddr667.txt.array b/board/accton/as4610_30/ddr667.txt.array
new file mode 100644
index 0000000..7007298
--- /dev/null
+++ b/board/accton/as4610_30/ddr667.txt.array
@@ -0,0 +1,215 @@
+array1 = { 
+	14, 00000001,
+	36, 01000000,
+	37, 10000000,
+	38, 00100400,
+	39, 00000400,
+	40, 00000100,
+	42, 00000001,
+	61, 00010100,
+	78, 01000200,
+	79, 02000040,
+	80, 00400100,
+	81, 00000200,
+	83, 01ffff0a,
+	84, 01010101,
+	85, 01010101,
+	86, 0f000003,
+	87, 0000010c,
+	88, 00010000,
+	112, 00000200,
+	116, 0d000000,
+	117, 00000028,
+	119, 00010001,
+	120, 00010001,
+	121, 00010001,
+	122, 00010001,
+	123, 00010001,
+	130, 00000001,
+	139, 00000001,
+	148, 00000001,
+	149, 00000000,
+	150, 00000000,
+	152, 03030303,
+	153, 03030303,
+	156, 02006400,
+	157, 02020202,
+	158, 00020202,
+	160, 01000000,
+	161, 01010064,
+	162, 01010101,
+	163, 00000101,
+	165, 00020000,
+	166, 00000064,
+	168, 000b0b00,
+	170, 02000200,
+	171, 02000200,
+	175, 02000200,
+	176, 02000200,
+	180, 80000100,
+	181, 04070303,
+	182, 0000000a,
+	185, 0010ffff,
+	187, 0000000f,
+	194, 00000204,
+	205, 00000000,
+	0xffffffff};
+
+ddr3_init_tab_667 = { 
+	01, 00000000,
+	03, 00000043,
+	04, 000000a7,
+	05, 0a050a00,
+	06, 04040405,
+	07, 05040e14,
+	08, 040e1404,
+	09, 0c040405,
+	10, 03005b68,
+	11, 0c040404,
+	12, 03005b68,
+	13, 01010004,
+	15, 000a0a00,
+	16, 03000200,
+	17, 00000f0f,
+	18, 05050000,
+	19, 00000000,
+	20, 00007801,
+	21, 00780a20,
+	22, 00050a20,
+	23, 00000300,
+	24, 000a0003,
+	25, 0000000a,
+	26, 00000000,
+	27, 02000000,
+	28, 0200005a,
+	29, 0000005a,
+	30, 05000001,
+	31, 00050505,
+	32, 00000000,
+	35, 00000000,
+	41, 00000000,
+	43, 00000000,
+	44, 00021000,
+	45, 00000046,
+	46, 00460210,
+	47, 00000000,
+	48, 02100000,
+	49, 00000046,
+	50, 00460210,
+	51, 00000000,
+	52, 02100000,
+	53, 00000046,
+	54, 00460210,
+	55, 00000000,
+	56, 02100000,
+	57, 00000046,
+	58, 00460210,
+	59, 00000000,
+	60, 00000000,
+	62, 00000000,
+	63, 00000000,
+	64, 00000000,
+	65, 00000000,
+	66, 00000000,
+	67, 00000000,
+	68, 00000000,
+	69, 00000000,
+	70, 00000000,
+	71, 00000000,
+	72, 00000000,
+	73, 00000000,
+	74, 00000000,
+	75, 00000000,
+	76, 00000000,
+	77, 00000000,
+	82, 01010001,
+	89, 00000000,
+	90, 00000000,
+	91, 00000000,
+	92, 00000000,
+	93, 00000000,
+	94, 00000000,
+	95, 00000000,
+	96, 00000000,
+	97, 00000000,
+	98, 00000000,
+	99, 00000000,
+	100, 00000000,
+	101, 00000000,
+	102, 00000000,
+	103, 00000000,
+	104, 00000000,
+	105, 00000000,
+	106, 00000000,
+	107, 00000000,
+	108, 02040108,
+	109, 08010402,
+	110, 02020002,
+	111, 01000200,
+	113, 00000000,
+	114, 00000000,
+	115, 00000000,
+	118, 00000000,
+	124, 00000000,
+	125, 00000000,
+	126, 00000000,
+	127, 00000000,
+	128, 00212100,
+	129, 21210001,
+	131, 00000000,
+	132, 00000000,
+	133, 00012121,
+	134, 00012121,
+	135, 00000000,
+	136, 00000000,
+	137, 00212100,
+	138, 21210001,
+	140, 00000000,
+	141, 00000000,
+	142, 00012121,
+	143, 00012121,
+	144, 00000000,
+	145, 00000000,
+	146, 00212100,
+	147, 21210001,
+	151, 00000000,
+	167, 00000000,
+	169, 0a200000,
+	172, 00000a20,
+	173, 00006540,
+	174, 0a200505,
+	177, 00000a20,
+	178, 00006540,
+	179, 02020505,
+	183, 00000000,
+	184, 00000000,
+	186, 00070303,
+	188, 00000000,
+	189, 00000000,
+	190, 00000000,
+	191, 00000000,
+	192, 00000000,
+	193, 00000000,
+	195, 00000000,
+	196, 00000000,
+	197, 00000000,
+	198, 00000000,
+	199, 00000000,
+	200, 00000000,
+	201, 00000000,
+	202, 00000004,
+	203, 00000004,
+	204, 00000000,
+	206, 02040401,
+	207, 00000002,
+	208, 00000000,
+	209, 00000000,
+	210, 05050000,
+	211, 00000505,
+	212, 00000040,
+	213, 00000000,
+	214, 01010606,
+	215, 00000101,
+	216, 00001a1a,
+	217, 00000000,
+	0xffffffff};
diff --git a/board/accton/as4610_30/ddr800.txt.array b/board/accton/as4610_30/ddr800.txt.array
new file mode 100644
index 0000000..c4bdeb8
--- /dev/null
+++ b/board/accton/as4610_30/ddr800.txt.array
@@ -0,0 +1,215 @@
+array1 = { 
+	14, 00000001,
+	36, 01000000,
+	37, 10000000,
+	38, 00100400,
+	39, 00000400,
+	40, 00000100,
+	42, 00000001,
+	61, 00010100,
+	78, 01000200,
+	79, 02000040,
+	80, 00400100,
+	81, 00000200,
+	83, 01ffff0a,
+	84, 01010101,
+	85, 01010101,
+	86, 0f000003,
+	87, 0000010c,
+	88, 00010000,
+	112, 00000200,
+	116, 0d000000,
+	117, 00000028,
+	119, 00010001,
+	120, 00010001,
+	121, 00010001,
+	122, 00010001,
+	123, 00010001,
+	130, 00000001,
+	139, 00000001,
+	148, 00000001,
+	149, 00000000,
+	150, 00000000,
+	152, 03030303,
+	153, 03030303,
+	156, 02006400,
+	157, 02020202,
+	158, 00020202,
+	160, 01000000,
+	161, 01010064,
+	162, 01010101,
+	163, 00000101,
+	165, 00020000,
+	166, 00000064,
+	168, 000b0b00,
+	170, 02000200,
+	171, 02000200,
+	175, 02000200,
+	176, 02000200,
+	180, 80000100,
+	181, 04070303,
+	182, 0000000a,
+	185, 0010ffff,
+	187, 0000000f,
+	194, 00000204,
+	205, 00000000,
+	0xffffffff};
+
+ddr3_init_tab_800 = { 
+	01, 00000000,
+	03, 00000050,
+	04, 000000c8,
+	05, 0c050c00,
+	06, 04040405,
+	07, 06041018,
+	08, 04101804,
+	09, 0c040406,
+	10, 03006db0,
+	11, 0c040404,
+	12, 03006db0,
+	13, 01010004,
+	15, 000c0c00,
+	16, 03000200,
+	17, 00001212,
+	18, 06060000,
+	19, 00000000,
+	20, 00009001,
+	21, 00900c28,
+	22, 00050c28,
+	23, 00000300,
+	24, 000a0003,
+	25, 0000000a,
+	26, 00000000,
+	27, 02000000,
+	28, 0200006c,
+	29, 0000006c,
+	30, 05000001,
+	31, 00050505,
+	32, 00000000,
+	35, 00000000,
+	41, 00000000,
+	43, 00000000,
+	44, 00042000,
+	45, 00000046,
+	46, 00460420,
+	47, 00000000,
+	48, 04200000,
+	49, 00000046,
+	50, 00460420,
+	51, 00000000,
+	52, 04200000,
+	53, 00000046,
+	54, 00460420,
+	55, 00000000,
+	56, 04200000,
+	57, 00000046,
+	58, 00460420,
+	59, 00000000,
+	60, 00000000,
+	62, 00000000,
+	63, 00000000,
+	64, 00000000,
+	65, 00000000,
+	66, 00000000,
+	67, 00000000,
+	68, 00000000,
+	69, 00000000,
+	70, 00000000,
+	71, 00000000,
+	72, 00000000,
+	73, 00000000,
+	74, 00000000,
+	75, 00000000,
+	76, 00000000,
+	77, 00000000,
+	82, 01010001,
+	89, 00000000,
+	90, 00000000,
+	91, 00000000,
+	92, 00000000,
+	93, 00000000,
+	94, 00000000,
+	95, 00000000,
+	96, 00000000,
+	97, 00000000,
+	98, 00000000,
+	99, 00000000,
+	100, 00000000,
+	101, 00000000,
+	102, 00000000,
+	103, 00000000,
+	104, 00000000,
+	105, 00000000,
+	106, 00000000,
+	107, 00000000,
+	108, 02040108,
+	109, 08010402,
+	110, 02020002,
+	111, 01000200,
+	113, 00000000,
+	114, 00000000,
+	115, 00000000,
+	118, 00000000,
+	124, 00000000,
+	125, 00000000,
+	126, 00000000,
+	127, 00000000,
+	128, 00212100,
+	129, 21210001,
+	131, 00000000,
+	132, 00000000,
+	133, 00012121,
+	134, 00012121,
+	135, 00000000,
+	136, 00000000,
+	137, 00212100,
+	138, 21210001,
+	140, 00000000,
+	141, 00000000,
+	142, 00012121,
+	143, 00012121,
+	144, 00000000,
+	145, 00000000,
+	146, 00212100,
+	147, 21210001,
+	151, 00000000,
+	167, 00000000,
+	169, 0c280000,
+	172, 00000c28,
+	173, 00007990,
+	174, 0c280505,
+	177, 00000c28,
+	178, 00007990,
+	179, 02020506,
+	183, 00000000,
+	184, 00000000,
+	186, 00070303,
+	188, 00000000,
+	189, 00000000,
+	190, 00000000,
+	191, 00000000,
+	192, 00000000,
+	193, 00000000,
+	195, 00000000,
+	196, 00000000,
+	197, 00000000,
+	198, 00000000,
+	199, 00000000,
+	200, 00000000,
+	201, 00000000,
+	202, 00000004,
+	203, 00000004,
+	204, 00000000,
+	206, 02040401,
+	207, 00000002,
+	208, 00000000,
+	209, 00000000,
+	210, 06060000,
+	211, 00000606,
+	212, 00000040,
+	213, 00000000,
+	214, 01010606,
+	215, 00000101,
+	216, 00001c1c,
+	217, 00000000,
+	0xffffffff};
diff --git a/board/accton/as4610_30/ddr_init_table.c b/board/accton/as4610_30/ddr_init_table.c
new file mode 100644
index 0000000..46701e5
--- /dev/null
+++ b/board/accton/as4610_30/ddr_init_table.c
@@ -0,0 +1,1412 @@
+/*
+ * $Copyright Open Broadcom Corporation$ 
+ */
+
+unsigned int ddr_init_tab[] = {
+	14, 0x00000001,
+	36, 0x01000000,
+	37, 0x10000000,
+	38, 0x00100400,
+	39, 0x00000400,
+	40, 0x00000100,
+	42, 0x00000001,
+	61, 0x00010100,
+	78, 0x01000200,
+	79, 0x02000040,
+	80, 0x00400100,
+	81, 0x00000200,
+	83, 0x01ffff0a,
+	84, 0x01010101,
+	85, 0x03010101,
+	86, 0x01000003,
+	87, 0x0000000c,
+	88, 0x00010000,
+	112, 0x00000200,
+	116, 0x0d000000,
+	117, 0x00000028,
+	119, 0x00010001,
+	120, 0x00010001,
+	121, 0x00010001,
+	122, 0x00010001,
+	123, 0x00010001,
+	130, 0x00000001,
+	139, 0x00000001,
+	148, 0x00000001,
+	149, 0x00000000,
+	150, 0x00000000,
+	152, 0x03030303,
+	153, 0x03030303,
+	156, 0x02006400,
+	157, 0x02020202,
+	158, 0x00020202,
+	160, 0x01000000,
+	161, 0x01010064,
+	162, 0x01010101,
+	163, 0x00000101,
+	165, 0x00020000,
+	166, 0x00000064,
+	168, 0x000b0b00,
+	170, 0x02000200,
+	171, 0x02000200,
+	175, 0x02000200,
+	176, 0x02000200,
+	180, 0x80000100,
+	181, 0x04070303,
+	182, 0x0000000a,
+	185, 0x0010ffff,
+	187, 0x0000000f,
+	194, 0x00000204,
+	205, 0x00000000,
+	0xffffffff};
+
+unsigned int ddr2_init_tab_667[] = { 
+	0, 0x00000400,
+	1, 0x00000000,
+	2, 0x00000000,
+	3, 0x00000043,
+	4, 0x000000a7,
+	5, 0x0a040a02,
+	6, 0x04020404,
+	7, 0x05030e12,
+	8, 0x030e1204,
+	9, 0x04020305,
+	10, 0x03005b26,
+	11, 0x04020303,
+	12, 0x03005b26,
+	13, 0x01010003,
+	15, 0x000a0a00,
+	16, 0x030000c8,
+	17, 0x00860f0f,
+	18, 0x06060086,
+	19, 0x00000000,
+	20, 0x00004201,
+	21, 0x00420a24,
+	22, 0x00050a24,
+	23, 0x00000300,
+	24, 0x000a0003,
+	25, 0x0003000a,
+	26, 0x0003000a,
+	27, 0x00c8000a,
+	28, 0x00c80046,
+	29, 0x00000046,
+	30, 0x03000001,
+	31, 0x00030303,
+	32, 0x00000000,
+	33, 0x00000000,
+	34, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x00085300,
+	45, 0x00000004,
+	46, 0x00040853,
+	47, 0x00000000,
+	48, 0x08530000,
+	49, 0x00000004,
+	50, 0x00040853,
+	51, 0x00000000,
+	52, 0x08530000,
+	53, 0x00000004,
+	54, 0x00040853,
+	55, 0x00000000,
+	56, 0x08530000,
+	57, 0x00000004,
+	58, 0x00040853,
+	59, 0x00000000,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000,
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01020001,
+	85, 0x01010101,
+	86, 0x0f000003,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02020101,
+	109, 0x08080404,
+	110, 0x03020000,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x001d1d00,
+	129, 0x1d1d0001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00011d1d,
+	134, 0x00011d1d,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x001d1d00,
+	138, 0x1d1d0001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00011d1d,
+	143, 0x00011d1d,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x001d1d00,
+	147, 0x1d1d0001,
+	151, 0x00000000,
+	154, 0x00000000,
+	155, 0x00000000,
+	159, 0x00000000,
+	164, 0x00000000,
+	167, 0x00000000,
+	169, 0x0a240000,
+	172, 0x00000a24,
+	173, 0x00006568,
+	174, 0x0a240404,
+	177, 0x00000a24,
+	178, 0x00006568,
+	179, 0x02020404,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x0001046b,
+	203, 0x0001046b,
+	204, 0x00000000,
+	206, 0x02030301,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x05050000,
+	211, 0x00000505,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x02010505,
+	215, 0x00000102,
+	216, 0x00001a1a,
+	217, 0x00000000,
+	0xffffffff
+};
+
+unsigned int ddr2_init_tab_800[] = { 
+	0, 0x00000400,
+	1, 0x00000000,
+	2, 0x00000000,
+	3, 0x00000050,
+	4, 0x000000c8,
+	5, 0x0c050c02,
+	6, 0x04020405,
+	7, 0x06031016,
+	8, 0x03101604,
+	9, 0x05020306,
+	10, 0x03006d60,
+	11, 0x05020303,
+	12, 0x03006d60,
+	13, 0x01010003,
+	15, 0x000c0c00,
+	16, 0x030000c8,
+	17, 0x00a01212,
+	18, 0x070700a0,
+	19, 0x00000000,
+	20, 0x00004f01,
+	21, 0x004f0c2d,
+	22, 0x00050c2d,
+	23, 0x00000300,
+	24, 0x000a0003,
+	25, 0x0003000a,
+	26, 0x0003000a,
+	27, 0x00c8000a,
+	28, 0x00c80053,
+	29, 0x00000053,
+	30, 0x03000001,
+	31, 0x00030303,
+	32, 0x00000000,
+	33, 0x00000000,
+	34, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x000a6300,
+	45, 0x00000004,
+	46, 0x00040a63,
+	47, 0x00000000,
+	48, 0x0a630000,
+	49, 0x00000004,
+	50, 0x00040a63,
+	51, 0x00000000,
+	52, 0x0a630000,
+	53, 0x00000004,
+	54, 0x00040a63,
+	55, 0x00000000,
+	56, 0x0a630000,
+	57, 0x00000004,
+	58, 0x00040a63,
+	59, 0x00000000,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000,
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01020001,
+	85, 0x01010101,
+	86, 0x0f000003,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02020101,
+	109, 0x08080404,
+	110, 0x03020000,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x001d1d00,
+	129, 0x1d1d0001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00011d1d,
+	134, 0x00011d1d,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x001d1d00,
+	138, 0x1d1d0001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00011d1d,
+	143, 0x00011d1d,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x001d1d00,
+	147, 0x1d1d0001,
+	151, 0x00000000,
+	154, 0x00000000,
+	155, 0x00000000,
+	159, 0x00000000,
+	164, 0x00000000,
+	167, 0x00000000,
+	169, 0x0c2d0000,
+	172, 0x00000c2d,
+	173, 0x000079c2,
+	174, 0x0c2d0505,
+	177, 0x00000c2d,
+	178, 0x000079c2,
+	179, 0x02020505,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00013880,
+	203, 0x00013880,
+	204, 0x00000000,
+	206, 0x02030301,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x06060000,
+	211, 0x00000606,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x02010505,
+	215, 0x00000102,
+	216, 0x00001c1c,
+	217, 0x00000000,
+	0xffffffff
+};
+
+unsigned int ddr2_init_tab_1066[] = { 
+	0, 0x00000400,
+	1, 0x00000000,
+	2, 0x00000000,
+	3, 0x0000006b,
+	4, 0x0000010a,
+	5, 0x0e060e02,
+	6, 0x06020406,
+	7, 0x0704161d,
+	8, 0x04161d06,
+	9, 0x07020407,
+	10, 0x03009173,
+	11, 0x07020403,
+	12, 0x03009173,
+	13, 0x01010003,
+	15, 0x000f0f00,
+	16, 0x030000c8,
+	17, 0x00d51818,
+	18, 0x080800d5,
+	19, 0x00000000,
+	20, 0x00006a01,
+	21, 0x006a1033,
+	22, 0x00051033,
+	23, 0x00000300,
+	24, 0x000d0003,
+	25, 0x0003000d,
+	26, 0x0003000a,
+	27, 0x00c8000a,
+	28, 0x00c8006f,
+	29, 0x0000006f,
+	30, 0x03000001,
+	31, 0x00030303,
+	32, 0x00000000,
+	33, 0x00000000,
+	34, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x000e7300,
+	45, 0x00000004,
+	46, 0x00040e73,
+	47, 0x00000000,
+	48, 0x0e730000,
+	49, 0x00000004,
+	50, 0x00040e73,
+	51, 0x00000000,
+	52, 0x0e730000,
+	53, 0x00000004,
+	54, 0x00040e73,
+	55, 0x00000000,
+	56, 0x0e730000,
+	57, 0x00000004,
+	58, 0x00040e73,
+	59, 0x00000000,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000,
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01020001,
+	85, 0x01010101,
+	86, 0x0f000003,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02020101,
+	109, 0x08080404,
+	110, 0x03020000,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x001c1c00,
+	129, 0x1c1c0001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00011c1c,
+	134, 0x00011c1c,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x001c1c00,
+	138, 0x1c1c0001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00011c1c,
+	143, 0x00011c1c,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x001c1c00,
+	147, 0x1c1c0001,
+	151, 0x00000000,
+	154, 0x00000000,
+	155, 0x00000000,
+	159, 0x00000000,
+	164, 0x00000000,
+	167, 0x00000000,
+	169, 0x10330000,
+	172, 0x00001033,
+	173, 0x0000a1fe,
+	174, 0x10330606,
+	177, 0x00001033,
+	178, 0x0000a1fe,
+	179, 0x02020606,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00019f8f,
+	203, 0x00019f8f,
+	204, 0x00000000,
+	206, 0x02030301,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x08070000,
+	211, 0x00000807,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x02010505,
+	215, 0x00000102,
+	216, 0x00001e1e,
+	217, 0x00000000,
+	0xffffffff
+};
+
+unsigned int ddr3_init_tab_667[] = { 
+	0, 0x00000600,
+	1, 0x00000000,
+	3, 0x00000043,
+	4, 0x000000a7,
+	5, 0x0a050a00,
+	6, 0x04040405,
+	7, 0x05040e14,
+	8, 0x040e1404,
+	9, 0x0c040405,
+	10, 0x03005b68,
+	11, 0x0c040404,
+	12, 0x03005b68,
+	13, 0x01010004,
+	15, 0x000a0a00,
+	16, 0x03000200,
+	17, 0x00000f0f,
+	18, 0x05050000,
+	19, 0x00000000,
+	20, 0x00007801,
+	21, 0x00780a20,
+	22, 0x00050a20,
+	23, 0x00000300,
+	24, 0x000a0003,
+	25, 0x0000000a,
+	26, 0x00000000,
+	27, 0x02000000,
+	28, 0x0200005a,
+	29, 0x0000005a,
+	30, 0x05000001,
+	31, 0x00050505,
+	32, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x00021000,
+	45, 0x00000046,
+	46, 0x00460210,
+	47, 0x00000000,
+	48, 0x02100000,
+	49, 0x00000046,
+	50, 0x00460210,
+	51, 0x00000000,
+	52, 0x02100000,
+	53, 0x00000046,
+	54, 0x00460210,
+	55, 0x00000000,
+	56, 0x02100000,
+	57, 0x00000046,
+	58, 0x00460210,
+	59, 0x00000000,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000, /* No ECC, set to 0x3 for ECC reporting and correcting */
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01010001,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02040108,
+	109, 0x08010402,
+	110, 0x02020002,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x00212100,
+	129, 0x21210001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00012121,
+	134, 0x00012121,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x00212100,
+	138, 0x21210001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00012121,
+	143, 0x00012121,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x00212100,
+	147, 0x21210001,
+	151, 0x00000000,
+	167, 0x00000000,
+	169, 0x0a200000,
+	172, 0x00000a20,
+	173, 0x00006540,
+	174, 0x0a200504,
+	177, 0x00000a20,
+	178, 0x00006540,
+	179, 0x02020504,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00000004,
+	203, 0x00000004,
+	204, 0x00000000,
+	206, 0x02040401,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x05050000,
+	211, 0x00000505,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x01010606,
+	215, 0x00000101,
+	216, 0x00001a1a,
+	217, 0x00000000,
+	0xffffffff};
+
+unsigned int ddr3_init_tab_800[] = { 
+	0, 0x00000600,
+	1, 0x00000000,
+	3, 0x00000050,
+	4, 0x000000c8,
+	5, 0x0c050c00,
+	6, 0x04040405,
+	7, 0x06041018,
+	8, 0x04101804,
+	9, 0x0c040406,
+	10, 0x03006db0,
+	11, 0x0c040404,
+	12, 0x03006db0,
+	13, 0x01010004,
+	15, 0x000c0c00,
+	16, 0x03000200,
+	17, 0x00001212,
+	18, 0x06060000,
+	19, 0x00000000,
+	20, 0x00009001,
+	21, 0x00900c28,
+	22, 0x00050c28,
+	23, 0x00000300,
+	24, 0x000a0003,
+	25, 0x0000000a,
+	26, 0x00000000,
+	27, 0x02000000,
+	28, 0x0200006c,
+	29, 0x0000006c,
+	30, 0x05000001,
+	31, 0x00050505,
+	32, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x00042000,
+	45, 0x00000046,
+	46, 0x00460420,
+	47, 0x00000000,
+	48, 0x04200000,
+	49, 0x00000046,
+	50, 0x00460420,
+	51, 0x00000000,
+	52, 0x04200000,
+	53, 0x00000046,
+	54, 0x00460420,
+	55, 0x00000000,
+	56, 0x04200000,
+	57, 0x00000046,
+	58, 0x00460420,
+	59, 0x00000000,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000, /* No ECC, set to 0x3 for ECC reporting and correcting */
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01010001,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02040108,
+	109, 0x08010402,
+	110, 0x02020002,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x00212100,
+	129, 0x21210001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00012121,
+	134, 0x00012121,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x00212100,
+	138, 0x21210001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00012121,
+	143, 0x00012121,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x00212100,
+	147, 0x21210001,
+	151, 0x00000000,
+	167, 0x00000000,
+	169, 0x0c280000,
+	172, 0x00000c28,
+	173, 0x00007990,
+	174, 0x0c280505,
+	177, 0x00000c28,
+	178, 0x00007990,
+	179, 0x02020505,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00000004,
+	203, 0x00000004,
+	204, 0x00000000,
+	206, 0x02040401,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x06060000,
+	211, 0x00000606,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x01010606,
+	215, 0x00000101,
+	216, 0x00001c1c,
+	217, 0x00000000,
+	0xffffffff};
+
+unsigned int ddr3_init_tab_1066[] = { 
+	0, 0x00000600,
+	1, 0x00000000,
+	3, 0x0000006b,
+	4, 0x0000010a,
+	5, 0x10061000,
+	6, 0x04040406,
+	7, 0x0804131a,
+	8, 0x04131a04,
+	9, 0x0c040408,
+	10, 0x030091dd,
+	11, 0x0c040404,
+	12, 0x030091dd,
+	13, 0x01010004,
+	15, 0x00101000,
+	16, 0x03000200,
+	17, 0x00001616,
+	18, 0x08080000,
+	19, 0x00000000,
+	20, 0x0000a001,
+	21, 0x00a0102d,
+	22, 0x0005102d,
+	23, 0x00000400,
+	24, 0x000d0004,
+	25, 0x0000000d,
+	26, 0x00000000,
+	27, 0x02000000,
+	28, 0x020000a5,
+	29, 0x000000a5,
+	30, 0x06000001,
+	31, 0x00060606,
+	32, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x00084000,
+	45, 0x00080046,
+	46, 0x00460840,
+	47, 0x00000008,
+	48, 0x08400000,
+	49, 0x00080046,
+	50, 0x00460840,
+	51, 0x00000008,
+	52, 0x08400000,
+	53, 0x00080046,
+	54, 0x00460840,
+	55, 0x00000008,
+	56, 0x08400000,
+	57, 0x00080046,
+	58, 0x00460840,
+	59, 0x00000008,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000, /* No ECC, set to 0x3 for ECC reporting and correcting */
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01010001,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02040108,
+	109, 0x08010402,
+	110, 0x02020002,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x00212100,
+	129, 0x21210001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00012121,
+	134, 0x00012121,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x00212100,
+	138, 0x21210001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00012121,
+	143, 0x00012121,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x00212100,
+	147, 0x21210001,
+	151, 0x00000000,
+	167, 0x00000000,
+	169, 0x102d0000,
+	172, 0x0000102d,
+	173, 0x0000a1c2,
+	174, 0x102d0607,
+	177, 0x0000102d,
+	178, 0x0000a1c2,
+	179, 0x02020607,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00000006,
+	203, 0x00000006,
+	204, 0x00000000,
+	206, 0x02050501,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x08080000,
+	211, 0x00000808,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x01010606,
+	215, 0x00000101,
+	216, 0x00002020,
+	217, 0x00000000,
+	0xffffffff};
+
+unsigned int ddr3_init_tab_1600[] = {
+	0, 0x00000600,
+	1, 0x00000000,
+	3, 0x000000a0,
+	4, 0x00000190,
+	5, 0x16081600,
+	6, 0x06040408,
+	7, 0x0b061c27,
+	8, 0x061c2706,
+	9, 0x0c04060b,
+	10, 0x0400db60,
+	11, 0x0c040604,
+	12, 0x0400db60,
+	13, 0x01010004,
+	15, 0x00171700,
+	16, 0x03000200,
+	17, 0x00002020,
+	18, 0x0b0b0000,
+	19, 0x00000000,
+	20, 0x0000f001,
+	21, 0x00f01858,
+#ifdef CONFIG_DDR750
+	22, 0x000516d2,
+#else
+	22, 0x00051858,
+#endif
+	23, 0x00000500,
+	24, 0x00140005,
+	25, 0x00000014,
+	26, 0x00000000,
+	27, 0x02000000,
+	28, 0x020000f8,
+	29, 0x000000f8,
+	30, 0x08000001,
+	31, 0x00080808,
+	32, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x000c7000,
+	45, 0x00180046,
+	46, 0x00460c70,
+	47, 0x00000018,
+	48, 0x0c700000,
+	49, 0x00180046,
+	50, 0x00460c70,
+	51, 0x00000018,
+	52, 0x0c700000,
+	53, 0x00180046,
+	54, 0x00460c70,
+	55, 0x00000018,
+	56, 0x0c700000,
+	57, 0x00180046,
+	58, 0x00460c70,
+	59, 0x00000018,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000, /* No ECC, set to 0x3 for ECC reporting and correcting */
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01000001,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02040108,
+	109, 0x08010402,
+	110, 0x02020002,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x00232300,
+	129, 0x23230001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00012323,
+	134, 0x00012323,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x00232300,
+	138, 0x23230001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00012323,
+	143, 0x00012323,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x00232300,
+	147, 0x23230001,
+	151, 0x00000000,
+	167, 0x00000000,
+	169, 0x18580000,
+	172, 0x00001858,
+	173, 0x0000f370,
+	174, 0x1858080a,
+	177, 0x00001858,
+	178, 0x0000f370,
+	179, 0x0202080a,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00000008,
+	203, 0x00000008,
+	204, 0x00000000,
+	206, 0x02070701,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x0c0b0000,
+	211, 0x00000c0b,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x01010606,
+	215, 0x00000101,
+	216, 0x00002727,
+	217, 0x00000000,
+	0xffffffff};
+
+ddr3_init_tab_1333[] = { 
+	0, 0x00000600,
+	1, 0x00000000,
+	3, 0x000208d6,
+	4, 0x00051616,
+	5, 0x12071200,
+	6, 0x05040407,
+	7, 0x09051821,
+	8, 0x05182105,
+	9, 0x0c040509,
+	10, 0x0400b6d0,
+	11, 0x0c040504,
+	12, 0x0400b6d0,
+	13, 0x01010004,
+	15, 0x00131300,
+	16, 0x03000200,
+	17, 0x00001b1b,
+	18, 0x09090000,
+	19, 0x00000000,
+	20, 0x0000c801,
+	21, 0x00c81448,
+	22, 0x00051448,
+	23, 0x00000400,
+	24, 0x00100004,
+	25, 0x00000010,
+	26, 0x00000000,
+	27, 0x02000000,
+	28, 0x020000cf,
+	29, 0x000000cf,
+	30, 0x07000001,
+	31, 0x00070707,
+	32, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x000a5000,
+	45, 0x00100046,
+	46, 0x00460a50,
+	47, 0x00000010,
+	48, 0x0a500000,
+	49, 0x00100046,
+	50, 0x00460a50,
+	51, 0x00000010,
+	52, 0x0a500000,
+	53, 0x00100046,
+	54, 0x00460a50,
+	55, 0x00000010,
+	56, 0x0a500000,
+	57, 0x00100046,
+	58, 0x00460a50,
+	59, 0x00000010,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000,
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01010001,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02040108,
+	109, 0x08010402,
+	110, 0x02020002,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x00222200,
+	129, 0x22220001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00012222,
+	134, 0x00012222,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x00222200,
+	138, 0x22220001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00012222,
+	143, 0x00012222,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x00222200,
+	147, 0x22220001,
+	151, 0x00000000,
+	167, 0x00000000,
+	168, 0x000c0c00,
+	169, 0x14480000,
+	172, 0x00001448,
+	173, 0x0000cad0,
+	174, 0x14480708,
+	177, 0x00001448,
+	178, 0x0000cad0,
+	179, 0x02020708,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00000007,
+	203, 0x00000007,
+	204, 0x00000000,
+	206, 0x02060601,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x0a090000,
+	211, 0x00000a09,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x01010606,
+	215, 0x00000101,
+	216, 0x00002323,
+	217, 0x00000000,
+	0xffffffff
+};
+
+unsigned int ddr2_init_tab[] = { 
+	0, 0,
+	0xffffffff};
+
+unsigned int ddr3_init_tab_933[] = { /* to be added */
+	0, 0,
+	0xffffffff};
+
+unsigned int ddr2_mode_reg_tab[] = {
+		0x0320,
+		0x0046,
+		0x0000,
+		0x0000
+};
+
+unsigned int ddr3_mode_reg_tab[] = {
+		0x0320,
+		0x0046,
+		0x0000,
+		0x0000
+};
+
+unsigned int ddr_clk_tab[] = {
+	/*  clk,	ndiv,	MDIV
+						0	1	2	3	4	5 */
+
+		333,	120,	30,	18,	0, 100, 15, 24,		
+		400,	120,	30,	15,	0, 100, 15, 24,			
+		467,    140,	35,	15,	0, 175, 18, 24,		
+		533,	128,	32,	12,	0, 80,  16, 24,			
+		667,	120,	30,	9,	0, 100, 15, 24,		
+		750,	120,	30,	8,	0, 100, 15, 24,			
+		800,	128,	32,	8,	0, 80,  16, 24,			
+		0xffffffff
+};
diff --git a/board/accton/as4610_30/ddrsim2hex_hx4.pl b/board/accton/as4610_30/ddrsim2hex_hx4.pl
new file mode 100755
index 0000000..c6672e4
--- /dev/null
+++ b/board/accton/as4610_30/ddrsim2hex_hx4.pl
@@ -0,0 +1,41 @@
+my $in = $ARGV[0];
+my $speed = $ARGV[1];
+my $out = $in.".array";
+
+my $str, $array1, $array2, $num, $num2, $i, $byte1, $byte2;
+my $list = ",14,36,37,38,39,40,42,61,78,79,80,81,83,84,85,86,87,88,112,116,117,119,120,121,122,123,130,139,148,149,150,152,153,156,157,158,160,161,162,163,165,166,168,170,171,175,176,180,181,182,185,187,194,205,";
+$prev_lnum = 0;
+    open(my $F, "<", "$in") or die "can't open in file";
+    open(my $FF, ">", "$out") or die "can't open in file";
+    $array1 = "array1 = { \n";
+    $array2 = "ddr3_init_tab_".$speed."[] = { \n";
+    while($str = <$F>) {
+       $str =~ m/_CTL_(.*)_DATA.adr, 32'h(.*), 32'h/;
+      if( $1 && $2) {
+       $num = $1;
+       $val = $2;
+       $num2 = $num;
+       if($num2 == "01" || $num2 == "02" || $num2 == "03" || $num2 == "04" || $num2 == "05" || $num2 == "06" || $num2 == "07" || $num2 == "08" || $num2 == "09") {
+		$num2 =~/0(.*)/;
+			$num = $1;
+	   }
+       $byte1 = ",".$num.",";
+       
+       if($list =~ m/$byte1/) {
+			$array1 .= "\t".$num.", 0x".$val.",\n";
+		}
+		else {
+			$array2 .= "\t".$num.", 0x".$val.",\n";		
+		}
+	 }	
+	}
+	$array1 .= "\t0xffffffff\n};\n\n";
+	$array2 .= "\t0xffffffff\n};\n";
+#	print $array1;
+#	print $array2;       
+	print $FF $array1;
+	print $FF $array2;
+   
+close($F);
+
+close($FF);
diff --git a/board/accton/as4610_30/mt47h128m16/ddr_reggen2hex_hx4.pl b/board/accton/as4610_30/mt47h128m16/ddr_reggen2hex_hx4.pl
new file mode 100755
index 0000000..c4e8526
--- /dev/null
+++ b/board/accton/as4610_30/mt47h128m16/ddr_reggen2hex_hx4.pl
@@ -0,0 +1,42 @@
+my $in = $ARGV[0];
+my $speed = $ARGV[1];
+my $ddrtype = $ARGV[2]; #ddr2 or ddr3
+my $out = $in.".array";
+
+my $str, $array1, $array2, $num, $num2, $i, $byte1, $byte2;
+my $list = ",14,36,37,38,39,40,42,61,78,79,80,81,83,84,87,88,112,116,117,119,120,121,122,123,130,139,148,149,150,152,153,156,157,158,160,161,162,163,165,166,168,170,171,175,176,180,181,182,185,187,194,205,";
+$prev_lnum = 0;
+    open(my $F, "<", "$in") or die "can't open in file";
+    open(my $FF, ">", "$out") or die "can't open in file";
+    $array1 = "unsigned int ddr_init_tab = { \n";
+    $array2 = "unsigned int ".$ddrtype."_init_tab_".$speed."[] = { \n";
+    while($str = <$F>) {
+       $str =~ m/_CTL_(.*)_DATA 0x(.*) \/\/(.*)/;
+      if( $1 && $2) {
+       $num = $1;
+       $val = $2;
+       $num2 = $num;
+       if($num2 == "00" || $num2 == "01" || $num2 == "02" || $num2 == "03" || $num2 == "04" || $num2 == "05" || $num2 == "06" || $num2 == "07" || $num2 == "08" || $num2 == "09") {
+		$num2 =~/0(.*)/;
+			$num = $1;
+	   }
+       $byte1 = ",".$num.",";
+       
+       if($list =~ m/$byte1/) {
+			$array1 .= "\t".$num.", 0x".$val.",\n";
+		}
+		else {
+			$array2 .= "\t".$num.", 0x".$val.",\n";		
+		}
+	 }	
+	}
+	$array1 .= "\t0xffffffff\n};\n\n";
+	$array2 .= "\t0xffffffff\n};\n";
+#	print $array1;
+#	print $array2;       
+	print $FF $array1;
+	print $FF $array2;
+   
+close($F);
+
+close($FF);
diff --git a/board/accton/as4610_30/mt47h128m16/mt47h128m16_1066 b/board/accton/as4610_30/mt47h128m16/mt47h128m16_1066
new file mode 100644
index 0000000..a156755
--- /dev/null
+++ b/board/accton/as4610_30/mt47h128m16/mt47h128m16_1066
@@ -0,0 +1,218 @@
+#define               DENALI_CTL_00_DATA 0x00000400 // VERSION:RD:16:16:=0x0000 DRAM_CLASS:RW:8:4:=0x04 START:RW:0:1:=0x00
+#define               DENALI_CTL_01_DATA 0x00000000 // MAX_CS_REG:RD:16:3:=0x00 MAX_COL_REG:RD:8:4:=0x00 MAX_ROW_REG:RD:0:5:=0x00
+#define               DENALI_CTL_02_DATA 0x00000000 //
+#define               DENALI_CTL_03_DATA 0x0000006b // TRST_PWRON:RW:0:32:=0x0000006b
+#define               DENALI_CTL_04_DATA 0x0000010a // CKE_INACTIVE:RW:0:32:=0x0000010a
+#define               DENALI_CTL_05_DATA 0x0e060e02 // CASLAT_LIN_F1:RW:24:6:=0x0e WRLAT_F0:RW:16:5:=0x06 CASLAT_LIN_F0:RW:8:6:=0x0e INITAREF:RW:0:4:=0x02
+#define               DENALI_CTL_06_DATA 0x06020406 // TRRD_F0:RW:24:8:=0x06 TCCD:RW:16:5:=0x02 TBST_INT_INTERVAL:RW:8:3:=0x04 WRLAT_F1:RW:0:5:=0x06
+#define               DENALI_CTL_07_DATA 0x0704161d // TRP_F0:RW:24:5:=0x07 TWTR_F0:RW:16:4:=0x04 TRAS_MIN_F0:RW:8:8:=0x16 TRC_F0:RW:0:8:=0x1d
+#define               DENALI_CTL_08_DATA 0x04161d06 // TWTR_F1:RW:24:4:=0x04 TRAS_MIN_F1:RW:16:8:=0x16 TRC_F1:RW:8:8:=0x1d TRRD_F1:RW:0:8:=0x06
+#define               DENALI_CTL_09_DATA 0x07020407 // TMOD_F0:RW:24:8:=0x07 TMRD_F0:RW:16:5:=0x02 TRTP_F0:RW:8:4:=0x04 TRP_F1:RW:0:5:=0x07
+#define               DENALI_CTL_10_DATA 0x03009173 // TCKE_F0:RW:24:3:=0x03 TRAS_MAX_F0:RW:0:17:=0x009173
+#define               DENALI_CTL_11_DATA 0x07020403 // TMOD_F1:RW:24:8:=0x07 TMRD_F1:RW:16:5:=0x02 TRTP_F1:RW:8:4:=0x04 TCKESR_F0:RW:0:5:=0x03
+#define               DENALI_CTL_12_DATA 0x03009173 // TCKE_F1:RW:24:3:=0x03 TRAS_MAX_F1:RW:0:17:=0x009173
+#define               DENALI_CTL_13_DATA 0x01010003 // CONCURRENTAP:RW:24:1:=0x01 AP:RW:16:1:=0x01 WRITEINTERP:RW:8:1:=0x00 TCKESR_F1:RW:0:5:=0x03
+#define               DENALI_CTL_14_DATA 0x00000001 // TRAS_LOCKOUT:RW:0:1:=0x01
+#define               DENALI_CTL_15_DATA 0x000f0f00 // TDAL_F1:RW:16:6:=0x0f TDAL_F0:RW:8:6:=0x0f
+#define               DENALI_CTL_16_DATA 0x030000c8 // BSTLEN:RW_D:24:3:=0x03 NO_CMD_INIT:RW:16:1:=0x00 TDLL:RW:0:16:=0x00c8
+#define               DENALI_CTL_17_DATA 0x00d51818 // TCPD_F0:RW:16:16:=0x00d5 TFAW_F1:RW:8:6:=0x18 TFAW_F0:RW:0:6:=0x18
+#define               DENALI_CTL_18_DATA 0x080800d5 // TRP_AB_F1:RW:24:5:=0x08 TRP_AB_F0:RW:16:5:=0x08 TCPD_F1:RW:0:16:=0x00d5
+#define               DENALI_CTL_19_DATA 0x00000000 // AUTO_REFRESH_MODE:RW:24:1:=0x00 AREFRESH:WR:16:1:=0x00 ADDRESS_MIRRORING:RW:8:4:=0x00 REG_DIMM_ENABLE:RW:0:1:=0x00
+#define               DENALI_CTL_20_DATA 0x00006a01 // TRFC_F0:RW:8:10:=0x006a TREF_ENABLE:RW:0:1:=0x01
+#define               DENALI_CTL_21_DATA 0x006a1033 // TRFC_F1:RW:16:10:=0x006a TREF_F0:RW:0:14:=0x1033
+#define               DENALI_CTL_22_DATA 0x00051033 // TREF_INTERVAL:RW:16:14:=0x0005 TREF_F1:RW:0:14:=0x1033
+#define               DENALI_CTL_23_DATA 0x00000300 // TPDEX_F0:RW:8:16:=0x0003
+#define               DENALI_CTL_24_DATA 0x000d0003 // TXPDLL_F0:RW:16:16:=0x000d TPDEX_F1:RW:0:16:=0x0003
+#define               DENALI_CTL_25_DATA 0x0003000d // TXARD_F0:RW:16:16:=0x0003 TXPDLL_F1:RW:0:16:=0x000d
+#define               DENALI_CTL_26_DATA 0x0003000a // TXARD_F1:RW:16:16:=0x0003 TXARDS_F0:RW:0:16:=0x000a
+#define               DENALI_CTL_27_DATA 0x00c8000a // TXSR_F0:RW:16:16:=0x00c8 TXARDS_F1:RW:0:16:=0x000a
+#define               DENALI_CTL_28_DATA 0x00c8006f // TXSR_F1:RW:16:16:=0x00c8 TXSNR_F0:RW:0:16:=0x006f
+#define               DENALI_CTL_29_DATA 0x0000006f // SREFRESH_EXIT_NO_REFRESH:RW:24:1:=0x00 PWRUP_SREFRESH_EXIT:RW:16:1:=0x00 TXSNR_F1:RW:0:16:=0x006f
+#define               DENALI_CTL_30_DATA 0x03000001 // CKSRE_F0:RW:24:4:=0x03 LOWPOWER_REFRESH_ENABLE:RW:16:4:=0x00 CKE_DELAY:RW:8:3:=0x00 ENABLE_QUICK_SREFRESH:RW:0:1:=0x01
+#define               DENALI_CTL_31_DATA 0x00030303 // LP_CMD:WR:24:8:=0x00 CKSRX_F1:RW:16:4:=0x03 CKSRE_F1:RW:8:4:=0x03 CKSRX_F0:RW:0:4:=0x03
+#define               DENALI_CTL_32_DATA 0x00000000 // LP_AUTO_EXIT_EN:RW:24:3:=0x00 LP_AUTO_ENTRY_EN:RW:16:3:=0x00 LP_ARB_STATE:RD:8:4:=0x00 LP_STATE:RD:0:6:=0x00
+#define               DENALI_CTL_33_DATA 0x00000000 //
+#define               DENALI_CTL_34_DATA 0x00000000 //
+#define               DENALI_CTL_35_DATA 0x00000000 // LP_AUTO_SR_IDLE:RW:0:8:=0x00
+#define               DENALI_CTL_36_DATA 0x01000000 // FREQ_CHANGE_ENABLE:RW:24:1:=0x01 RESERVED:RW:16:8:=0x00 LP_AUTO_SR_MC_GATE_IDLE:RW:0:8:=0x00
+#define               DENALI_CTL_37_DATA 0x10000000 // TDFI_INIT_START_F0:RW:24:8:=0x10 FREQ_CHANGE_DLL_OFF:RW:16:2:=0x00 FREQ_CHANGE_DONE_HOLD_CLEAR:WR:8:1:=0x00 FREQ_CHANGE_DONE_HOLD_EN:RW:0:1:=0x00
+#define               DENALI_CTL_38_DATA 0x00100400 // TDFI_INIT_START_F1:RW:16:8:=0x10 TDFI_INIT_COMPLETE_F0:RW:0:16:=0x0400
+#define               DENALI_CTL_39_DATA 0x00000400 // DFS_PHY_REG_WRITE_EN:RW:24:1:=0x00 CURRENT_REG_COPY:RD:16:1:=0x00 TDFI_INIT_COMPLETE_F1:RW:0:16:=0x0400
+#define               DENALI_CTL_40_DATA 0x00000100 // DFS_PHY_REG_WRITE_ADDR:RW:0:32:=0x00000100
+#define               DENALI_CTL_41_DATA 0x00000000 // DFS_PHY_REG_WRITE_DATA_F0:RW:0:32:=0x00000000
+#define               DENALI_CTL_42_DATA 0x00000001 // DFS_PHY_REG_WRITE_DATA_F1:RW:0:32:=0x00000001
+#define               DENALI_CTL_43_DATA 0x00000000 // WRITE_MODEREG:RW+:0:26:=0x00000000
+#define               DENALI_CTL_44_DATA 0x000e7300 // MR0_DATA_F0_0:RW:8:16:=0x0e73 MRW_STATUS:RD:0:8:=0x00
+#define               DENALI_CTL_45_DATA 0x00000004 // MR2_DATA_F0_0:RW:16:16:=0x0000 MR1_DATA_F0_0:RW:0:16:=0x0004
+#define               DENALI_CTL_46_DATA 0x00040e73 // MR1_DATA_F1_0:RW:16:16:=0x0004 MR0_DATA_F1_0:RW:0:16:=0x0e73
+#define               DENALI_CTL_47_DATA 0x00000000 // MRSINGLE_DATA_0:RW:16:16:=0x0000 MR2_DATA_F1_0:RW:0:16:=0x0000
+#define               DENALI_CTL_48_DATA 0x0e730000 // MR0_DATA_F0_1:RW:16:16:=0x0e73 MR3_DATA_0:RW:0:16:=0x0000
+#define               DENALI_CTL_49_DATA 0x00000004 // MR2_DATA_F0_1:RW:16:16:=0x0000 MR1_DATA_F0_1:RW:0:16:=0x0004
+#define               DENALI_CTL_50_DATA 0x00040e73 // MR1_DATA_F1_1:RW:16:16:=0x0004 MR0_DATA_F1_1:RW:0:16:=0x0e73
+#define               DENALI_CTL_51_DATA 0x00000000 // MRSINGLE_DATA_1:RW:16:16:=0x0000 MR2_DATA_F1_1:RW:0:16:=0x0000
+#define               DENALI_CTL_52_DATA 0x0e730000 // MR0_DATA_F0_2:RW:16:16:=0x0e73 MR3_DATA_1:RW:0:16:=0x0000
+#define               DENALI_CTL_53_DATA 0x00000004 // MR2_DATA_F0_2:RW:16:16:=0x0000 MR1_DATA_F0_2:RW:0:16:=0x0004
+#define               DENALI_CTL_54_DATA 0x00040e73 // MR1_DATA_F1_2:RW:16:16:=0x0004 MR0_DATA_F1_2:RW:0:16:=0x0e73
+#define               DENALI_CTL_55_DATA 0x00000000 // MRSINGLE_DATA_2:RW:16:16:=0x0000 MR2_DATA_F1_2:RW:0:16:=0x0000
+#define               DENALI_CTL_56_DATA 0x0e730000 // MR0_DATA_F0_3:RW:16:16:=0x0e73 MR3_DATA_2:RW:0:16:=0x0000
+#define               DENALI_CTL_57_DATA 0x00000004 // MR2_DATA_F0_3:RW:16:16:=0x0000 MR1_DATA_F0_3:RW:0:16:=0x0004
+#define               DENALI_CTL_58_DATA 0x00040e73 // MR1_DATA_F1_3:RW:16:16:=0x0004 MR0_DATA_F1_3:RW:0:16:=0x0e73
+#define               DENALI_CTL_59_DATA 0x00000000 // MRSINGLE_DATA_3:RW:16:16:=0x0000 MR2_DATA_F1_3:RW:0:16:=0x0000
+#define               DENALI_CTL_60_DATA 0x00000000 // BIST_RESULT:RD:24:2:=0x00 BIST_GO:WR:16:1:=0x00 MR3_DATA_3:RW:0:16:=0x0000
+#define               DENALI_CTL_61_DATA 0x00010100 // BIST_ADDR_CHECK:RW:16:1:=0x01 BIST_DATA_CHECK:RW:8:1:=0x01 ADDR_SPACE:RW:0:6:=0x00
+#define               DENALI_CTL_62_DATA 0x00000000 // BIST_START_ADDRESS:RW:0:34:=0x00000000
+#define               DENALI_CTL_63_DATA 0x00000000 // BIST_START_ADDRESS:RW:0:34:=0x00
+#define               DENALI_CTL_64_DATA 0x00000000 // BIST_DATA_MASK:RW:0:64:=0x00000000
+#define               DENALI_CTL_65_DATA 0x00000000 // BIST_DATA_MASK:RW:0:64:=0x00000000
+#define               DENALI_CTL_66_DATA 0x00000003 // XOR_CHECK_BITS:RW:16:16:=0x0000 FWC:WR:8:1:=0x00 CTRL_RAW:RW:0:2:=0x03
+#define               DENALI_CTL_67_DATA 0x00000000 // ECC_DISABLE_W_UC_ERR:RW:0:1:=0x00
+#define               DENALI_CTL_68_DATA 0x00000000 // ECC_U_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_69_DATA 0x00000000 // ECC_U_SYND:RD:8:8:=0x00 ECC_U_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_70_DATA 0x00000000 // ECC_U_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_71_DATA 0x00000000 // ECC_U_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_72_DATA 0x00000000 // ECC_C_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_73_DATA 0x00000000 // ECC_C_SYND:RD:8:8:=0x00 ECC_C_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_74_DATA 0x00000000 // ECC_C_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_75_DATA 0x00000000 // ECC_C_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_76_DATA 0x00000000 // ECC_U_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_77_DATA 0x00000000 // ECC_C_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_78_DATA 0x01000200 // ZQCL_F0:RW:16:12:=0x0100 ZQINIT_F0:RW_D:0:12:=0x0200
+#define               DENALI_CTL_79_DATA 0x02000040 // ZQINIT_F1:RW_D:16:12:=0x0200 ZQCS_F0:RW:0:12:=0x0040
+#define               DENALI_CTL_80_DATA 0x00400100 // ZQCS_F1:RW:16:12:=0x0040 ZQCL_F1:RW:0:12:=0x0100
+#define               DENALI_CTL_81_DATA 0x00000200 // ZQ_IN_PROGRESS:RD:24:1:=0x00 ZQ_ON_SREF_EXIT:RW:8:2:=0x02 ZQ_REQ:WR:0:2:=0x00
+#define               DENALI_CTL_82_DATA 0x01020001 // COL_DIFF:RW:24:3:=0x01 ROW_DIFF:RW:16:3:=0x02 BANK_DIFF:RW:8:2:=0x00 ZQCS_ROTATE:RW:0:1:=0x01
+#define               DENALI_CTL_83_DATA 0x01ffff0a // ADDR_CMP_EN:RW:24:1:=0x01 COMMAND_AGE_COUNT:RW:16:8:=0xff AGE_COUNT:RW:8:8:=0xff APREBIT:RW_D:0:4:=0x0a
+#define               DENALI_CTL_84_DATA 0x01010101 // RW_SAME_EN:RW:24:1:=0x01 PRIORITY_EN:RW:16:1:=0x01 PLACEMENT_EN:RW:8:1:=0x01 BANK_SPLIT_EN:RW:0:1:=0x01
+#define               DENALI_CTL_85_DATA 0x01010101 // DISABLE_RW_GROUP_W_BNK_CONFLICT:RW:24:2:=0x01 W2R_SPLIT_EN:RW:16:1:=0x01 CS_SAME_EN:RW:8:1:=0x01 SWAP_EN:RW:0:1:=0x01
+#define               DENALI_CTL_86_DATA 0x0f000003 // CS_MAP:RW:24:4:=0x0f INHIBIT_DRAM_CMD:RW:16:1:=0x00 DISABLE_RD_INTERLEAVE:RW:8:1:=0x00 NUM_Q_ENTRIES_ACT_DISABLE:RW:0:3:=0x03
+#define               DENALI_CTL_87_DATA 0x0000010c // IN_ORDER_ACCEPT:RW:24:1:=0x00 Q_FULLNESS:RW:16:3:=0x00 REDUC:RW:8:1:=0x01 BURST_ON_FLY_BIT:RW:0:4:=0x0c
+#define               DENALI_CTL_88_DATA 0x00010000 // CTRLUPD_REQ_PER_AREF_EN:RW:16:1:=0x01 CTRLUPD_REQ:WR:8:1:=0x00 CONTROLLER_BUSY:RD:0:1:=0x00
+#define               DENALI_CTL_89_DATA 0x00000000 // INT_STATUS:RD:0:26:=0x00000000
+#define               DENALI_CTL_90_DATA 0x00000000 //
+#define               DENALI_CTL_91_DATA 0x00000000 // INT_MASK:RW:0:26:=0x00000000
+#define               DENALI_CTL_92_DATA 0x00000000 // OUT_OF_RANGE_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_93_DATA 0x00000000 // OUT_OF_RANGE_TYPE:RD:16:6:=0x00 OUT_OF_RANGE_LENGTH:RD:8:7:=0x00 OUT_OF_RANGE_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_94_DATA 0x00000000 // OUT_OF_RANGE_SOURCE_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_95_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_96_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_97_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_98_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_99_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_100_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_101_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_102_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_103_DATA 0x00000000 // BIST_FAIL_ADDR:RD:0:34:=0x00000000
+#define              DENALI_CTL_104_DATA 0x00000000 // BIST_FAIL_ADDR:RD:0:34:=0x00
+#define              DENALI_CTL_105_DATA 0x00000000 // PORT_CMD_ERROR_ADDR:RD:0:34:=0x00000000
+#define              DENALI_CTL_106_DATA 0x00000000 // PORT_CMD_ERROR_ID:RD:8:17:=0x000000 PORT_CMD_ERROR_ADDR:RD:0:34:=0x00
+#define              DENALI_CTL_107_DATA 0x00000000 // PORT_CMD_ERROR_TYPE:RD:0:2:=0x00
+#define              DENALI_CTL_108_DATA 0x02020101 // ODT_WR_MAP_CS1:RW:24:4:=0x02 ODT_RD_MAP_CS1:RW:16:4:=0x02 ODT_WR_MAP_CS0:RW:8:4:=0x01 ODT_RD_MAP_CS0:RW:0:4:=0x01
+#define              DENALI_CTL_109_DATA 0x08080404 // ODT_WR_MAP_CS3:RW:24:4:=0x08 ODT_RD_MAP_CS3:RW:16:4:=0x08 ODT_WR_MAP_CS2:RW:8:4:=0x04 ODT_RD_MAP_CS2:RW:0:4:=0x04
+#define              DENALI_CTL_110_DATA 0x03020000 // ADD_ODT_CLK_SAMETYPE_DIFFCS:RW:24:4:=0x03 ADD_ODT_CLK_DIFFTYPE_DIFFCS:RW:16:6:=0x02 ADD_ODT_CLK_W2R_SAMECS:RW:8:4:=0x00 ADD_ODT_CLK_R2W_SAMECS:RW:0:4:=0x00
+#define              DENALI_CTL_111_DATA 0x01000200 // W2W_DIFFCS_DLY:RW_D:24:3:=0x01 R2W_DIFFCS_DLY:RW_D:8:3:=0x02
+#define              DENALI_CTL_112_DATA 0x00000200 // W2W_SAMECS_DLY:RW:24:3:=0x00 W2R_SAMECS_DLY:RW:16:3:=0x00 R2W_SAMECS_DLY:RW_D:8:3:=0x02 R2R_SAMECS_DLY:RW:0:3:=0x00
+#define              DENALI_CTL_113_DATA 0x00000000 // SWLVL_LOAD:WR:24:1:=0x00 SW_LEVELING_MODE:RW:16:2:=0x00 OCD_ADJUST_PUP_CS_0:RW:8:5:=0x00 OCD_ADJUST_PDN_CS_0:RW:0:5:=0x00
+#define              DENALI_CTL_114_DATA 0x00000000 // LVL_STATUS:RD:24:4:=0x00 SWLVL_OP_DONE:RD:16:1:=0x00 SWLVL_EXIT:WR:8:1:=0x00 SWLVL_START:WR:0:1:=0x00
+#define              DENALI_CTL_115_DATA 0x00000000 // SWLVL_RESP_3:RD:24:8:=0x00 SWLVL_RESP_2:RD:16:8:=0x00 SWLVL_RESP_1:RD:8:8:=0x00 SWLVL_RESP_0:RD:0:8:=0x00
+#define              DENALI_CTL_116_DATA 0x0d000000 // WLDQSEN:RW:24:6:=0x0d WRLVL_CS:RW:16:2:=0x00 WRLVL_REQ:WR:8:1:=0x00 SWLVL_RESP_4:RD:0:8:=0x00
+#define              DENALI_CTL_117_DATA 0x00000028 // WRLVL_EN:RW:8:1:=0x00 WLMRD:RW:0:6:=0x28
+#define              DENALI_CTL_118_DATA 0x00000000 // WRLVL_REG_EN:RW:16:1:=0x00 WRLVL_ERROR_STATUS:RD:0:12:=0x0000
+#define              DENALI_CTL_119_DATA 0x00010001 // WRLVL_DELAY_F1_0:RW:16:16:=0x0001 WRLVL_DELAY_F0_0:RW:0:16:=0x0001
+#define              DENALI_CTL_120_DATA 0x00010001 // WRLVL_DELAY_F1_1:RW:16:16:=0x0001 WRLVL_DELAY_F0_1:RW:0:16:=0x0001
+#define              DENALI_CTL_121_DATA 0x00010001 // WRLVL_DELAY_F1_2:RW:16:16:=0x0001 WRLVL_DELAY_F0_2:RW:0:16:=0x0001
+#define              DENALI_CTL_122_DATA 0x00010001 // WRLVL_DELAY_F1_3:RW:16:16:=0x0001 WRLVL_DELAY_F0_3:RW:0:16:=0x0001
+#define              DENALI_CTL_123_DATA 0x00010001 // WRLVL_DELAY_F1_4:RW:16:16:=0x0001 WRLVL_DELAY_F0_4:RW:0:16:=0x0001
+#define              DENALI_CTL_124_DATA 0x00000000 // RDLVL_EDGE:RW:24:1:=0x00 RDLVL_CS:RW:16:2:=0x00 RDLVL_GATE_REQ:WR:8:1:=0x00 RDLVL_REQ:WR:0:1:=0x00
+#define              DENALI_CTL_125_DATA 0x00000000 // RDLVL_GATE_REG_EN:RW:16:1:=0x00 RDLVL_REG_EN:RW:8:1:=0x00 RDLVL_BEGIN_DELAY_EN:RW:0:1:=0x00
+#define              DENALI_CTL_126_DATA 0x00000000 // RDLVL_END_DELAY_0:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_0:RD:0:16:=0x0000
+#define              DENALI_CTL_127_DATA 0x00000000 // RDLVL_OFFSET_DELAY_0:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_0:RD:0:16:=0x0000
+#define              DENALI_CTL_128_DATA 0x001c1c00 // RDLVL_DELAY_F0_0:RW:8:16:=0x1c1c RDLVL_OFFSET_DIR_0:RW:0:1:=0x00
+#define              DENALI_CTL_129_DATA 0x1c1c0001 // RDLVL_DELAY_F1_0:RW:16:16:=0x1c1c RDLVL_GATE_DELAY_F0_0:RW:0:16:=0x0001
+#define              DENALI_CTL_130_DATA 0x00000001 // RDLVL_BEGIN_DELAY_1:RD:16:16:=0x0000 RDLVL_GATE_DELAY_F1_0:RW:0:16:=0x0001
+#define              DENALI_CTL_131_DATA 0x00000000 // RDLVL_MIDPOINT_DELAY_1:RD:16:16:=0x0000 RDLVL_END_DELAY_1:RD:0:16:=0x0000
+#define              DENALI_CTL_132_DATA 0x00000000 // RDLVL_OFFSET_DIR_1:RW:16:1:=0x00 RDLVL_OFFSET_DELAY_1:RW:0:16:=0x0000
+#define              DENALI_CTL_133_DATA 0x00011c1c // RDLVL_GATE_DELAY_F0_1:RW:16:16:=0x0001 RDLVL_DELAY_F0_1:RW:0:16:=0x1c1c
+#define              DENALI_CTL_134_DATA 0x00011c1c // RDLVL_GATE_DELAY_F1_1:RW:16:16:=0x0001 RDLVL_DELAY_F1_1:RW:0:16:=0x1c1c
+#define              DENALI_CTL_135_DATA 0x00000000 // RDLVL_END_DELAY_2:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_2:RD:0:16:=0x0000
+#define              DENALI_CTL_136_DATA 0x00000000 // RDLVL_OFFSET_DELAY_2:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_2:RD:0:16:=0x0000
+#define              DENALI_CTL_137_DATA 0x001c1c00 // RDLVL_DELAY_F0_2:RW:8:16:=0x1c1c RDLVL_OFFSET_DIR_2:RW:0:1:=0x00
+#define              DENALI_CTL_138_DATA 0x1c1c0001 // RDLVL_DELAY_F1_2:RW:16:16:=0x1c1c RDLVL_GATE_DELAY_F0_2:RW:0:16:=0x0001
+#define              DENALI_CTL_139_DATA 0x00000001 // RDLVL_BEGIN_DELAY_3:RD:16:16:=0x0000 RDLVL_GATE_DELAY_F1_2:RW:0:16:=0x0001
+#define              DENALI_CTL_140_DATA 0x00000000 // RDLVL_MIDPOINT_DELAY_3:RD:16:16:=0x0000 RDLVL_END_DELAY_3:RD:0:16:=0x0000
+#define              DENALI_CTL_141_DATA 0x00000000 // RDLVL_OFFSET_DIR_3:RW:16:1:=0x00 RDLVL_OFFSET_DELAY_3:RW:0:16:=0x0000
+#define              DENALI_CTL_142_DATA 0x00011c1c // RDLVL_GATE_DELAY_F0_3:RW:16:16:=0x0001 RDLVL_DELAY_F0_3:RW:0:16:=0x1c1c
+#define              DENALI_CTL_143_DATA 0x00011c1c // RDLVL_GATE_DELAY_F1_3:RW:16:16:=0x0001 RDLVL_DELAY_F1_3:RW:0:16:=0x1c1c
+#define              DENALI_CTL_144_DATA 0x00000000 // RDLVL_END_DELAY_4:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_4:RD:0:16:=0x0000
+#define              DENALI_CTL_145_DATA 0x00000000 // RDLVL_OFFSET_DELAY_4:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_4:RD:0:16:=0x0000
+#define              DENALI_CTL_146_DATA 0x001c1c00 // RDLVL_DELAY_F0_4:RW:8:16:=0x1c1c RDLVL_OFFSET_DIR_4:RW:0:1:=0x00
+#define              DENALI_CTL_147_DATA 0x1c1c0001 // RDLVL_DELAY_F1_4:RW:16:16:=0x1c1c RDLVL_GATE_DELAY_F0_4:RW:0:16:=0x0001
+#define              DENALI_CTL_148_DATA 0x00000001 // RDLVL_GATE_DELAY_F1_4:RW:0:16:=0x0001
+#define              DENALI_CTL_149_DATA 0x00000000 // AXI1_FIFO_TYPE_REG:RW:24:2:=0x00 AXI0_FIFO_TYPE_REG:RW:0:2:=0x00
+#define              DENALI_CTL_150_DATA 0x00000000 // AXI2_FIFO_TYPE_REG:RW:16:2:=0x00
+#define              DENALI_CTL_151_DATA 0x00000000 // WRR_PARAM_VALUE_ERR:RD:24:4:=0x00 WEIGHTED_ROUND_ROBIN_WEIGHT_SHARING:RW:16:1:=0x00 WEIGHTED_ROUND_ROBIN_LATENCY_CONTROL:RW:8:1:=0x00
+#define              DENALI_CTL_152_DATA 0x03030303 // AXI0_PRIORITY3_RELATIVE_PRIORITY:RW:24:4:=0x03 AXI0_PRIORITY2_RELATIVE_PRIORITY:RW:16:4:=0x03 AXI0_PRIORITY1_RELATIVE_PRIORITY:RW:8:4:=0x03 AXI0_PRIORITY0_RELATIVE_PRIORITY:RW:0:4:=0x03
+#define              DENALI_CTL_153_DATA 0x03030303 // AXI0_PRIORITY7_RELATIVE_PRIORITY:RW:24:4:=0x03 AXI0_PRIORITY6_RELATIVE_PRIORITY:RW:16:4:=0x03 AXI0_PRIORITY5_RELATIVE_PRIORITY:RW:8:4:=0x03 AXI0_PRIORITY4_RELATIVE_PRIORITY:RW:0:4:=0x03
+#define              DENALI_CTL_154_DATA 0x00000000 //
+#define              DENALI_CTL_155_DATA 0x00000000 //
+#define              DENALI_CTL_156_DATA 0x02006400 // AXI1_PRIORITY0_RELATIVE_PRIORITY:RW:24:4:=0x02 AXI0_PRIORITY_RELAX:RW:8:10:=0x0064 AXI0_PORT_ORDERING:RW:0:2:=0x00
+#define              DENALI_CTL_157_DATA 0x02020202 // AXI1_PRIORITY4_RELATIVE_PRIORITY:RW:24:4:=0x02 AXI1_PRIORITY3_RELATIVE_PRIORITY:RW:16:4:=0x02 AXI1_PRIORITY2_RELATIVE_PRIORITY:RW:8:4:=0x02 AXI1_PRIORITY1_RELATIVE_PRIORITY:RW:0:4:=0x02
+#define              DENALI_CTL_158_DATA 0x00020202 // AXI1_PRIORITY7_RELATIVE_PRIORITY:RW:16:4:=0x02 AXI1_PRIORITY6_RELATIVE_PRIORITY:RW:8:4:=0x02 AXI1_PRIORITY5_RELATIVE_PRIORITY:RW:0:4:=0x02
+#define              DENALI_CTL_159_DATA 0x00000000 //
+#define              DENALI_CTL_160_DATA 0x01000000 // AXI1_PORT_ORDERING:RW:24:2:=0x01
+#define              DENALI_CTL_161_DATA 0x01010064 // AXI2_PRIORITY1_RELATIVE_PRIORITY:RW:24:4:=0x01 AXI2_PRIORITY0_RELATIVE_PRIORITY:RW:16:4:=0x01 AXI1_PRIORITY_RELAX:RW:0:10:=0x0064
+#define              DENALI_CTL_162_DATA 0x01010101 // AXI2_PRIORITY5_RELATIVE_PRIORITY:RW:24:4:=0x01 AXI2_PRIORITY4_RELATIVE_PRIORITY:RW:16:4:=0x01 AXI2_PRIORITY3_RELATIVE_PRIORITY:RW:8:4:=0x01 AXI2_PRIORITY2_RELATIVE_PRIORITY:RW:0:4:=0x01
+#define              DENALI_CTL_163_DATA 0x00000101 // AXI2_PRIORITY7_RELATIVE_PRIORITY:RW:8:4:=0x01 AXI2_PRIORITY6_RELATIVE_PRIORITY:RW:0:4:=0x01
+#define              DENALI_CTL_164_DATA 0x00000000 //
+#define              DENALI_CTL_165_DATA 0x00020000 // AXI2_PORT_ORDERING:RW:16:2:=0x02
+#define              DENALI_CTL_166_DATA 0x00000064 // MEM_RST_VALID:RD:24:1:=0x00 CKE_STATUS:RD:16:4:=0x00 AXI2_PRIORITY_RELAX:RW:0:10:=0x0064
+#define              DENALI_CTL_167_DATA 0x00000000 // TDFI_PHY_WRLAT:RD:24:6:=0x00 DLL_RST_ADJ_DLY:RW:16:8:=0x00 DLL_RST_DELAY:RW:0:16:=0x0000
+#define              DENALI_CTL_168_DATA 0x000b0b00 // TDFI_RDDATA_EN:RD:24:7:=0x00 TDFI_PHY_RDLAT_F1:RW_D:16:6:=0x0b TDFI_PHY_RDLAT_F0:RW_D:8:6:=0x0b UPDATE_ERROR_STATUS:RD:0:7:=0x00
+#define              DENALI_CTL_169_DATA 0x10330000 // TDFI_CTRLUPD_MAX_F0:RW:16:14:=0x1033 TDFI_CTRLUPD_MIN:RD:8:4:=0x00 DRAM_CLK_DISABLE:RW:0:4:=0x00
+#define              DENALI_CTL_170_DATA 0x02000200 // TDFI_PHYUPD_TYPE1_F0:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE0_F0:RW:0:16:=0x0200
+#define              DENALI_CTL_171_DATA 0x02000200 // TDFI_PHYUPD_TYPE3_F0:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE2_F0:RW:0:16:=0x0200
+#define              DENALI_CTL_172_DATA 0x00001033 // TDFI_PHYUPD_RESP_F0:RW:0:14:=0x1033
+#define              DENALI_CTL_173_DATA 0x0000a1fe // TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x0000a1fe
+#define              DENALI_CTL_174_DATA 0x10330607 // TDFI_CTRLUPD_MAX_F1:RW:16:14:=0x1033 WRLAT_ADJ_F0:RW:8:5:=0x06 RDLAT_ADJ_F0:RW:0:6:=0x07
+#define              DENALI_CTL_175_DATA 0x02000200 // TDFI_PHYUPD_TYPE1_F1:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE0_F1:RW:0:16:=0x0200
+#define              DENALI_CTL_176_DATA 0x02000200 // TDFI_PHYUPD_TYPE3_F1:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE2_F1:RW:0:16:=0x0200
+#define              DENALI_CTL_177_DATA 0x00001033 // TDFI_PHYUPD_RESP_F1:RW:0:14:=0x1033
+#define              DENALI_CTL_178_DATA 0x0000a1fe // TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x0000a1fe
+#define              DENALI_CTL_179_DATA 0x02020607 // TDFI_CTRL_DELAY_F1:RW_D:24:4:=0x02 TDFI_CTRL_DELAY_F0:RW_D:16:4:=0x02 WRLAT_ADJ_F1:RW:8:5:=0x06 RDLAT_ADJ_F1:RW:0:6:=0x07
+#define              DENALI_CTL_180_DATA 0x80000100 // DFI_WRLVL_MAX_DELAY:RW:16:16:=0x8000 TDFI_DRAM_CLK_ENABLE:RW:8:4:=0x01 TDFI_DRAM_CLK_DISABLE:RW:0:4:=0x00
+#define              DENALI_CTL_181_DATA 0x04070303 // TDFI_WRLVL_RESPLAT:RW:24:8:=0x04 TDFI_WRLVL_LOAD:RW:16:8:=0x07 TDFI_WRLVL_DLL:RW:8:8:=0x03 TDFI_WRLVL_EN:RW:0:8:=0x03
+#define              DENALI_CTL_182_DATA 0x0000000a // TDFI_WRLVL_WW:RW:0:10:=0x000a
+#define              DENALI_CTL_183_DATA 0x00000000 // TDFI_WRLVL_RESP:RW:0:32:=0x00000000
+#define              DENALI_CTL_184_DATA 0x00000000 // TDFI_WRLVL_MAX:RW:0:32:=0x00000000
+#define              DENALI_CTL_185_DATA 0x0010ffff // RDLVL_GATE_MAX_DELAY:RW:16:16:=0x0010 RDLVL_MAX_DELAY:RW:0:16:=0xffff
+#define              DENALI_CTL_186_DATA 0x00070303 // TDFI_RDLVL_LOAD:RW:16:8:=0x07 TDFI_RDLVL_DLL:RW:8:8:=0x03 TDFI_RDLVL_EN:RW:0:8:=0x03
+#define              DENALI_CTL_187_DATA 0x0000000f // TDFI_RDLVL_RR:RW:0:10:=0x000f
+#define              DENALI_CTL_188_DATA 0x00000000 // TDFI_RDLVL_RESP:RW:0:32:=0x00000000
+#define              DENALI_CTL_189_DATA 0x00000000 // RDLVL_RESP_MASK:RW:0:36:=0x00000000
+#define              DENALI_CTL_190_DATA 0x00000000 // RDLVL_RESP_MASK:RW:0:36:=0x00
+#define              DENALI_CTL_191_DATA 0x00000000 // RDLVL_GATE_RESP_MASK:RW:0:36:=0x00000000
+#define              DENALI_CTL_192_DATA 0x00000000 // RDLVL_GATE_PREAMBLE_CHECK_EN:RW:24:1:=0x00 RDLVL_GATE_EN:RW:16:1:=0x00 RDLVL_EN:RW:8:1:=0x00 RDLVL_GATE_RESP_MASK:RW:0:36:=0x00
+#define              DENALI_CTL_193_DATA 0x00000000 // TDFI_RDLVL_MAX:RW:0:32:=0x00000000
+#define              DENALI_CTL_194_DATA 0x00000204 // RDLVL_GATE_DQ_ZERO_COUNT:RW:8:4:=0x02 RDLVL_DQ_ZERO_COUNT:RW:0:4:=0x04
+#define              DENALI_CTL_195_DATA 0x00000000 // RDLVL_ERROR_STATUS:RD:0:22:=0x000000
+#define              DENALI_CTL_196_DATA 0x00000000 //
+#define              DENALI_CTL_197_DATA 0x00000001 // TDFI_PHY_WRDATA:RW:0:3:=0x01
+#define              DENALI_CTL_198_DATA 0x00000000 // USER_DEF_REG_0:RW:0:32:=0x00000000
+#define              DENALI_CTL_199_DATA 0x00000000 // USER_DEF_REG_1:RW:0:32:=0x00000000
+#define              DENALI_CTL_200_DATA 0x00000000 // USER_DEF_REG_RO_0:RD:0:32:=0x00000000
+#define              DENALI_CTL_201_DATA 0x00000000 // USER_DEF_REG_RO_1:RD:0:32:=0x00000000
+#define              DENALI_CTL_202_DATA 0x00019f8f // TINIT_F0:RW:0:24:=0x019f8f
+#define              DENALI_CTL_203_DATA 0x00019f8f // LP_AUTO_MEM_GATE_EN:RW:24:2:=0x00 TINIT_F1:RW:0:24:=0x019f8f
+#define              DENALI_CTL_204_DATA 0x00000000 // LP_AUTO_PD_IDLE:RW:0:12:=0x0000
+#define              DENALI_CTL_205_DATA 0x00000000 //
+#define              DENALI_CTL_206_DATA 0x02030301 // W2R_DIFFCS_DLY_F0:RW_D:24:3:=0x02 TODTL_2CMD_F1:RW:16:5:=0x03 TODTL_2CMD_F0:RW:8:5:=0x03 RW_SAME_PAGE_EN:RW:0:1:=0x01
+#define              DENALI_CTL_207_DATA 0x00000002 // W2R_DIFFCS_DLY_F1:RW_D:0:3:=0x02
+#define              DENALI_CTL_208_DATA 0x00000000 //
+#define              DENALI_CTL_209_DATA 0x00000000 // OBSOLETE_PLACEHOLDER:RW:0:16:=0x0000
+#define              DENALI_CTL_210_DATA 0x08070000 // TWR_F0:RW:24:6:=0x08 TRCD_F0:RW:16:8:=0x07 RESERVED:RW:8:5:=0x00 RESERVED:RW:0:5:=0x00
+#define              DENALI_CTL_211_DATA 0x00000807 // NO_MEMORY_DM:RW:24:1:=0x00 RESERVED:RW:16:1:=0x00 TWR_F1:RW:8:6:=0x08 TRCD_F1:RW:0:8:=0x07
+#define              DENALI_CTL_212_DATA 0x00000040 // ZQ_INTERVAL:RW:0:32:=0x00000040
+#define              DENALI_CTL_213_DATA 0x00000000 // INT_ACK:WR:0:25:=0x00000000
+#define              DENALI_CTL_214_DATA 0x02010505 // R2R_DIFFCS_DLY_F0:RW_D:24:3:=0x02 ODT_EN:RW:16:1:=0x01 TODTH_RD:RW:8:4:=0x05 TODTH_WR:RW:0:4:=0x05
+#define              DENALI_CTL_215_DATA 0x00000102 // WRLVL_INTERVAL:RW:16:16:=0x0000 LVL_AREF_EN:RW:8:1:=0x01 R2R_DIFFCS_DLY_F1:RW_D:0:3:=0x02
+#define              DENALI_CTL_216_DATA 0x00001e1e // RDLVL_INTERVAL:RW:16:16:=0x0000 TDFI_RDLVL_RESPLAT_F1:RW:8:8:=0x1e TDFI_RDLVL_RESPLAT_F0:RW:0:8:=0x1e
+#define              DENALI_CTL_217_DATA 0x00000000 // RDLVL_GATE_INTERVAL:RW:0:16:=0x0000
diff --git a/board/accton/as4610_30/mt47h128m16/mt47h128m16_1066.array b/board/accton/as4610_30/mt47h128m16/mt47h128m16_1066.array
new file mode 100644
index 0000000..72291bf
--- /dev/null
+++ b/board/accton/as4610_30/mt47h128m16/mt47h128m16_1066.array
@@ -0,0 +1,225 @@
+unsigned int ddr_init_tab = { 
+	14, 0x00000001,
+	36, 0x01000000,
+	37, 0x10000000,
+	38, 0x00100400,
+	39, 0x00000400,
+	40, 0x00000100,
+	42, 0x00000001,
+	61, 0x00010100,
+	78, 0x01000200,
+	79, 0x02000040,
+	80, 0x00400100,
+	81, 0x00000200,
+	83, 0x01ffff0a,
+	84, 0x01010101,
+	87, 0x0000010c,
+	88, 0x00010000,
+	112, 0x00000200,
+	116, 0x0d000000,
+	117, 0x00000028,
+	119, 0x00010001,
+	120, 0x00010001,
+	121, 0x00010001,
+	122, 0x00010001,
+	123, 0x00010001,
+	130, 0x00000001,
+	139, 0x00000001,
+	148, 0x00000001,
+	149, 0x00000000,
+	150, 0x00000000,
+	152, 0x03030303,
+	153, 0x03030303,
+	156, 0x02006400,
+	157, 0x02020202,
+	158, 0x00020202,
+	160, 0x01000000,
+	161, 0x01010064,
+	162, 0x01010101,
+	163, 0x00000101,
+	165, 0x00020000,
+	166, 0x00000064,
+	168, 0x000b0b00,
+	170, 0x02000200,
+	171, 0x02000200,
+	175, 0x02000200,
+	176, 0x02000200,
+	180, 0x80000100,
+	181, 0x04070303,
+	182, 0x0000000a,
+	185, 0x0010ffff,
+	187, 0x0000000f,
+	194, 0x00000204,
+	205, 0x00000000,
+	0xffffffff
+};
+
+unsigned int ddr2_init_tab_1066[] = { 
+	0, 0x00000400,
+	1, 0x00000000,
+	2, 0x00000000,
+	3, 0x0000006b,
+	4, 0x0000010a,
+	5, 0x0e060e02,
+	6, 0x06020406,
+	7, 0x0704161d,
+	8, 0x04161d06,
+	9, 0x07020407,
+	10, 0x03009173,
+	11, 0x07020403,
+	12, 0x03009173,
+	13, 0x01010003,
+	15, 0x000f0f00,
+	16, 0x030000c8,
+	17, 0x00d51818,
+	18, 0x080800d5,
+	19, 0x00000000,
+	20, 0x00006a01,
+	21, 0x006a1033,
+	22, 0x00051033,
+	23, 0x00000300,
+	24, 0x000d0003,
+	25, 0x0003000d,
+	26, 0x0003000a,
+	27, 0x00c8000a,
+	28, 0x00c8006f,
+	29, 0x0000006f,
+	30, 0x03000001,
+	31, 0x00030303,
+	32, 0x00000000,
+	33, 0x00000000,
+	34, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x000e7300,
+	45, 0x00000004,
+	46, 0x00040e73,
+	47, 0x00000000,
+	48, 0x0e730000,
+	49, 0x00000004,
+	50, 0x00040e73,
+	51, 0x00000000,
+	52, 0x0e730000,
+	53, 0x00000004,
+	54, 0x00040e73,
+	55, 0x00000000,
+	56, 0x0e730000,
+	57, 0x00000004,
+	58, 0x00040e73,
+	59, 0x00000000,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000,
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01020001,
+	85, 0x01010101,
+	86, 0x0f000003,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02020101,
+	109, 0x08080404,
+	110, 0x03020000,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x001c1c00,
+	129, 0x1c1c0001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00011c1c,
+	134, 0x00011c1c,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x001c1c00,
+	138, 0x1c1c0001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00011c1c,
+	143, 0x00011c1c,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x001c1c00,
+	147, 0x1c1c0001,
+	151, 0x00000000,
+	154, 0x00000000,
+	155, 0x00000000,
+	159, 0x00000000,
+	164, 0x00000000,
+	167, 0x00000000,
+	169, 0x10330000,
+	172, 0x00001033,
+	173, 0x0000a1fe,
+	174, 0x10330607,
+	177, 0x00001033,
+	178, 0x0000a1fe,
+	179, 0x02020607,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00019f8f,
+	203, 0x00019f8f,
+	204, 0x00000000,
+	206, 0x02030301,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x08070000,
+	211, 0x00000807,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x02010505,
+	215, 0x00000102,
+	216, 0x00001e1e,
+	217, 0x00000000,
+	0xffffffff
+};
diff --git a/board/accton/as4610_30/mt47h128m16/mt47h128m16_667 b/board/accton/as4610_30/mt47h128m16/mt47h128m16_667
new file mode 100644
index 0000000..b8afaf4
--- /dev/null
+++ b/board/accton/as4610_30/mt47h128m16/mt47h128m16_667
@@ -0,0 +1,218 @@
+#define               DENALI_CTL_00_DATA 0x00000400 // VERSION:RD:16:16:=0x0000 DRAM_CLASS:RW:8:4:=0x04 START:RW:0:1:=0x00
+#define               DENALI_CTL_01_DATA 0x00000000 // MAX_CS_REG:RD:16:3:=0x00 MAX_COL_REG:RD:8:4:=0x00 MAX_ROW_REG:RD:0:5:=0x00
+#define               DENALI_CTL_02_DATA 0x00000000 //
+#define               DENALI_CTL_03_DATA 0x00000043 // TRST_PWRON:RW:0:32:=0x00000043
+#define               DENALI_CTL_04_DATA 0x000000a7 // CKE_INACTIVE:RW:0:32:=0x000000a7
+#define               DENALI_CTL_05_DATA 0x0a040a02 // CASLAT_LIN_F1:RW:24:6:=0x0a WRLAT_F0:RW:16:5:=0x04 CASLAT_LIN_F0:RW:8:6:=0x0a INITAREF:RW:0:4:=0x02
+#define               DENALI_CTL_06_DATA 0x04020404 // TRRD_F0:RW:24:8:=0x04 TCCD:RW:16:5:=0x02 TBST_INT_INTERVAL:RW:8:3:=0x04 WRLAT_F1:RW:0:5:=0x04
+#define               DENALI_CTL_07_DATA 0x05030e12 // TRP_F0:RW:24:5:=0x05 TWTR_F0:RW:16:4:=0x03 TRAS_MIN_F0:RW:8:8:=0x0e TRC_F0:RW:0:8:=0x12
+#define               DENALI_CTL_08_DATA 0x030e1204 // TWTR_F1:RW:24:4:=0x03 TRAS_MIN_F1:RW:16:8:=0x0e TRC_F1:RW:8:8:=0x12 TRRD_F1:RW:0:8:=0x04
+#define               DENALI_CTL_09_DATA 0x04020305 // TMOD_F0:RW:24:8:=0x04 TMRD_F0:RW:16:5:=0x02 TRTP_F0:RW:8:4:=0x03 TRP_F1:RW:0:5:=0x05
+#define               DENALI_CTL_10_DATA 0x03005b26 // TCKE_F0:RW:24:3:=0x03 TRAS_MAX_F0:RW:0:17:=0x005b26
+#define               DENALI_CTL_11_DATA 0x04020303 // TMOD_F1:RW:24:8:=0x04 TMRD_F1:RW:16:5:=0x02 TRTP_F1:RW:8:4:=0x03 TCKESR_F0:RW:0:5:=0x03
+#define               DENALI_CTL_12_DATA 0x03005b26 // TCKE_F1:RW:24:3:=0x03 TRAS_MAX_F1:RW:0:17:=0x005b26
+#define               DENALI_CTL_13_DATA 0x01010003 // CONCURRENTAP:RW:24:1:=0x01 AP:RW:16:1:=0x01 WRITEINTERP:RW:8:1:=0x00 TCKESR_F1:RW:0:5:=0x03
+#define               DENALI_CTL_14_DATA 0x00000001 // TRAS_LOCKOUT:RW:0:1:=0x01
+#define               DENALI_CTL_15_DATA 0x000a0a00 // TDAL_F1:RW:16:6:=0x0a TDAL_F0:RW:8:6:=0x0a
+#define               DENALI_CTL_16_DATA 0x030000c8 // BSTLEN:RW_D:24:3:=0x03 NO_CMD_INIT:RW:16:1:=0x00 TDLL:RW:0:16:=0x00c8
+#define               DENALI_CTL_17_DATA 0x00860f0f // TCPD_F0:RW:16:16:=0x0086 TFAW_F1:RW:8:6:=0x0f TFAW_F0:RW:0:6:=0x0f
+#define               DENALI_CTL_18_DATA 0x06060086 // TRP_AB_F1:RW:24:5:=0x06 TRP_AB_F0:RW:16:5:=0x06 TCPD_F1:RW:0:16:=0x0086
+#define               DENALI_CTL_19_DATA 0x00000000 // AUTO_REFRESH_MODE:RW:24:1:=0x00 AREFRESH:WR:16:1:=0x00 ADDRESS_MIRRORING:RW:8:4:=0x00 REG_DIMM_ENABLE:RW:0:1:=0x00
+#define               DENALI_CTL_20_DATA 0x00004201 // TRFC_F0:RW:8:10:=0x0042 TREF_ENABLE:RW:0:1:=0x01
+#define               DENALI_CTL_21_DATA 0x00420a24 // TRFC_F1:RW:16:10:=0x0042 TREF_F0:RW:0:14:=0x0a24
+#define               DENALI_CTL_22_DATA 0x00050a24 // TREF_INTERVAL:RW:16:14:=0x0005 TREF_F1:RW:0:14:=0x0a24
+#define               DENALI_CTL_23_DATA 0x00000300 // TPDEX_F0:RW:8:16:=0x0003
+#define               DENALI_CTL_24_DATA 0x000a0003 // TXPDLL_F0:RW:16:16:=0x000a TPDEX_F1:RW:0:16:=0x0003
+#define               DENALI_CTL_25_DATA 0x0003000a // TXARD_F0:RW:16:16:=0x0003 TXPDLL_F1:RW:0:16:=0x000a
+#define               DENALI_CTL_26_DATA 0x0003000a // TXARD_F1:RW:16:16:=0x0003 TXARDS_F0:RW:0:16:=0x000a
+#define               DENALI_CTL_27_DATA 0x00c8000a // TXSR_F0:RW:16:16:=0x00c8 TXARDS_F1:RW:0:16:=0x000a
+#define               DENALI_CTL_28_DATA 0x00c80046 // TXSR_F1:RW:16:16:=0x00c8 TXSNR_F0:RW:0:16:=0x0046
+#define               DENALI_CTL_29_DATA 0x00000046 // SREFRESH_EXIT_NO_REFRESH:RW:24:1:=0x00 PWRUP_SREFRESH_EXIT:RW:16:1:=0x00 TXSNR_F1:RW:0:16:=0x0046
+#define               DENALI_CTL_30_DATA 0x03000001 // CKSRE_F0:RW:24:4:=0x03 LOWPOWER_REFRESH_ENABLE:RW:16:4:=0x00 CKE_DELAY:RW:8:3:=0x00 ENABLE_QUICK_SREFRESH:RW:0:1:=0x01
+#define               DENALI_CTL_31_DATA 0x00030303 // LP_CMD:WR:24:8:=0x00 CKSRX_F1:RW:16:4:=0x03 CKSRE_F1:RW:8:4:=0x03 CKSRX_F0:RW:0:4:=0x03
+#define               DENALI_CTL_32_DATA 0x00000000 // LP_AUTO_EXIT_EN:RW:24:3:=0x00 LP_AUTO_ENTRY_EN:RW:16:3:=0x00 LP_ARB_STATE:RD:8:4:=0x00 LP_STATE:RD:0:6:=0x00
+#define               DENALI_CTL_33_DATA 0x00000000 //
+#define               DENALI_CTL_34_DATA 0x00000000 //
+#define               DENALI_CTL_35_DATA 0x00000000 // LP_AUTO_SR_IDLE:RW:0:8:=0x00
+#define               DENALI_CTL_36_DATA 0x01000000 // FREQ_CHANGE_ENABLE:RW:24:1:=0x01 RESERVED:RW:16:8:=0x00 LP_AUTO_SR_MC_GATE_IDLE:RW:0:8:=0x00
+#define               DENALI_CTL_37_DATA 0x10000000 // TDFI_INIT_START_F0:RW:24:8:=0x10 FREQ_CHANGE_DLL_OFF:RW:16:2:=0x00 FREQ_CHANGE_DONE_HOLD_CLEAR:WR:8:1:=0x00 FREQ_CHANGE_DONE_HOLD_EN:RW:0:1:=0x00
+#define               DENALI_CTL_38_DATA 0x00100400 // TDFI_INIT_START_F1:RW:16:8:=0x10 TDFI_INIT_COMPLETE_F0:RW:0:16:=0x0400
+#define               DENALI_CTL_39_DATA 0x00000400 // DFS_PHY_REG_WRITE_EN:RW:24:1:=0x00 CURRENT_REG_COPY:RD:16:1:=0x00 TDFI_INIT_COMPLETE_F1:RW:0:16:=0x0400
+#define               DENALI_CTL_40_DATA 0x00000100 // DFS_PHY_REG_WRITE_ADDR:RW:0:32:=0x00000100
+#define               DENALI_CTL_41_DATA 0x00000000 // DFS_PHY_REG_WRITE_DATA_F0:RW:0:32:=0x00000000
+#define               DENALI_CTL_42_DATA 0x00000001 // DFS_PHY_REG_WRITE_DATA_F1:RW:0:32:=0x00000001
+#define               DENALI_CTL_43_DATA 0x00000000 // WRITE_MODEREG:RW+:0:26:=0x00000000
+#define               DENALI_CTL_44_DATA 0x00085300 // MR0_DATA_F0_0:RW:8:16:=0x0853 MRW_STATUS:RD:0:8:=0x00
+#define               DENALI_CTL_45_DATA 0x00000004 // MR2_DATA_F0_0:RW:16:16:=0x0000 MR1_DATA_F0_0:RW:0:16:=0x0004
+#define               DENALI_CTL_46_DATA 0x00040853 // MR1_DATA_F1_0:RW:16:16:=0x0004 MR0_DATA_F1_0:RW:0:16:=0x0853
+#define               DENALI_CTL_47_DATA 0x00000000 // MRSINGLE_DATA_0:RW:16:16:=0x0000 MR2_DATA_F1_0:RW:0:16:=0x0000
+#define               DENALI_CTL_48_DATA 0x08530000 // MR0_DATA_F0_1:RW:16:16:=0x0853 MR3_DATA_0:RW:0:16:=0x0000
+#define               DENALI_CTL_49_DATA 0x00000004 // MR2_DATA_F0_1:RW:16:16:=0x0000 MR1_DATA_F0_1:RW:0:16:=0x0004
+#define               DENALI_CTL_50_DATA 0x00040853 // MR1_DATA_F1_1:RW:16:16:=0x0004 MR0_DATA_F1_1:RW:0:16:=0x0853
+#define               DENALI_CTL_51_DATA 0x00000000 // MRSINGLE_DATA_1:RW:16:16:=0x0000 MR2_DATA_F1_1:RW:0:16:=0x0000
+#define               DENALI_CTL_52_DATA 0x08530000 // MR0_DATA_F0_2:RW:16:16:=0x0853 MR3_DATA_1:RW:0:16:=0x0000
+#define               DENALI_CTL_53_DATA 0x00000004 // MR2_DATA_F0_2:RW:16:16:=0x0000 MR1_DATA_F0_2:RW:0:16:=0x0004
+#define               DENALI_CTL_54_DATA 0x00040853 // MR1_DATA_F1_2:RW:16:16:=0x0004 MR0_DATA_F1_2:RW:0:16:=0x0853
+#define               DENALI_CTL_55_DATA 0x00000000 // MRSINGLE_DATA_2:RW:16:16:=0x0000 MR2_DATA_F1_2:RW:0:16:=0x0000
+#define               DENALI_CTL_56_DATA 0x08530000 // MR0_DATA_F0_3:RW:16:16:=0x0853 MR3_DATA_2:RW:0:16:=0x0000
+#define               DENALI_CTL_57_DATA 0x00000004 // MR2_DATA_F0_3:RW:16:16:=0x0000 MR1_DATA_F0_3:RW:0:16:=0x0004
+#define               DENALI_CTL_58_DATA 0x00040853 // MR1_DATA_F1_3:RW:16:16:=0x0004 MR0_DATA_F1_3:RW:0:16:=0x0853
+#define               DENALI_CTL_59_DATA 0x00000000 // MRSINGLE_DATA_3:RW:16:16:=0x0000 MR2_DATA_F1_3:RW:0:16:=0x0000
+#define               DENALI_CTL_60_DATA 0x00000000 // BIST_RESULT:RD:24:2:=0x00 BIST_GO:WR:16:1:=0x00 MR3_DATA_3:RW:0:16:=0x0000
+#define               DENALI_CTL_61_DATA 0x00010100 // BIST_ADDR_CHECK:RW:16:1:=0x01 BIST_DATA_CHECK:RW:8:1:=0x01 ADDR_SPACE:RW:0:6:=0x00
+#define               DENALI_CTL_62_DATA 0x00000000 // BIST_START_ADDRESS:RW:0:34:=0x00000000
+#define               DENALI_CTL_63_DATA 0x00000000 // BIST_START_ADDRESS:RW:0:34:=0x00
+#define               DENALI_CTL_64_DATA 0x00000000 // BIST_DATA_MASK:RW:0:64:=0x00000000
+#define               DENALI_CTL_65_DATA 0x00000000 // BIST_DATA_MASK:RW:0:64:=0x00000000
+#define               DENALI_CTL_66_DATA 0x00000003 // XOR_CHECK_BITS:RW:16:16:=0x0000 FWC:WR:8:1:=0x00 CTRL_RAW:RW:0:2:=0x03
+#define               DENALI_CTL_67_DATA 0x00000000 // ECC_DISABLE_W_UC_ERR:RW:0:1:=0x00
+#define               DENALI_CTL_68_DATA 0x00000000 // ECC_U_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_69_DATA 0x00000000 // ECC_U_SYND:RD:8:8:=0x00 ECC_U_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_70_DATA 0x00000000 // ECC_U_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_71_DATA 0x00000000 // ECC_U_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_72_DATA 0x00000000 // ECC_C_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_73_DATA 0x00000000 // ECC_C_SYND:RD:8:8:=0x00 ECC_C_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_74_DATA 0x00000000 // ECC_C_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_75_DATA 0x00000000 // ECC_C_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_76_DATA 0x00000000 // ECC_U_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_77_DATA 0x00000000 // ECC_C_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_78_DATA 0x01000200 // ZQCL_F0:RW:16:12:=0x0100 ZQINIT_F0:RW_D:0:12:=0x0200
+#define               DENALI_CTL_79_DATA 0x02000040 // ZQINIT_F1:RW_D:16:12:=0x0200 ZQCS_F0:RW:0:12:=0x0040
+#define               DENALI_CTL_80_DATA 0x00400100 // ZQCS_F1:RW:16:12:=0x0040 ZQCL_F1:RW:0:12:=0x0100
+#define               DENALI_CTL_81_DATA 0x00000200 // ZQ_IN_PROGRESS:RD:24:1:=0x00 ZQ_ON_SREF_EXIT:RW:8:2:=0x02 ZQ_REQ:WR:0:2:=0x00
+#define               DENALI_CTL_82_DATA 0x01020001 // COL_DIFF:RW:24:3:=0x01 ROW_DIFF:RW:16:3:=0x02 BANK_DIFF:RW:8:2:=0x00 ZQCS_ROTATE:RW:0:1:=0x01
+#define               DENALI_CTL_83_DATA 0x01ffff0a // ADDR_CMP_EN:RW:24:1:=0x01 COMMAND_AGE_COUNT:RW:16:8:=0xff AGE_COUNT:RW:8:8:=0xff APREBIT:RW_D:0:4:=0x0a
+#define               DENALI_CTL_84_DATA 0x01010101 // RW_SAME_EN:RW:24:1:=0x01 PRIORITY_EN:RW:16:1:=0x01 PLACEMENT_EN:RW:8:1:=0x01 BANK_SPLIT_EN:RW:0:1:=0x01
+#define               DENALI_CTL_85_DATA 0x01010101 // DISABLE_RW_GROUP_W_BNK_CONFLICT:RW:24:2:=0x01 W2R_SPLIT_EN:RW:16:1:=0x01 CS_SAME_EN:RW:8:1:=0x01 SWAP_EN:RW:0:1:=0x01
+#define               DENALI_CTL_86_DATA 0x0f000003 // CS_MAP:RW:24:4:=0x0f INHIBIT_DRAM_CMD:RW:16:1:=0x00 DISABLE_RD_INTERLEAVE:RW:8:1:=0x00 NUM_Q_ENTRIES_ACT_DISABLE:RW:0:3:=0x03
+#define               DENALI_CTL_87_DATA 0x0000010c // IN_ORDER_ACCEPT:RW:24:1:=0x00 Q_FULLNESS:RW:16:3:=0x00 REDUC:RW:8:1:=0x01 BURST_ON_FLY_BIT:RW:0:4:=0x0c
+#define               DENALI_CTL_88_DATA 0x00010000 // CTRLUPD_REQ_PER_AREF_EN:RW:16:1:=0x01 CTRLUPD_REQ:WR:8:1:=0x00 CONTROLLER_BUSY:RD:0:1:=0x00
+#define               DENALI_CTL_89_DATA 0x00000000 // INT_STATUS:RD:0:26:=0x00000000
+#define               DENALI_CTL_90_DATA 0x00000000 //
+#define               DENALI_CTL_91_DATA 0x00000000 // INT_MASK:RW:0:26:=0x00000000
+#define               DENALI_CTL_92_DATA 0x00000000 // OUT_OF_RANGE_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_93_DATA 0x00000000 // OUT_OF_RANGE_TYPE:RD:16:6:=0x00 OUT_OF_RANGE_LENGTH:RD:8:7:=0x00 OUT_OF_RANGE_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_94_DATA 0x00000000 // OUT_OF_RANGE_SOURCE_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_95_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_96_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_97_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_98_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_99_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_100_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_101_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_102_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_103_DATA 0x00000000 // BIST_FAIL_ADDR:RD:0:34:=0x00000000
+#define              DENALI_CTL_104_DATA 0x00000000 // BIST_FAIL_ADDR:RD:0:34:=0x00
+#define              DENALI_CTL_105_DATA 0x00000000 // PORT_CMD_ERROR_ADDR:RD:0:34:=0x00000000
+#define              DENALI_CTL_106_DATA 0x00000000 // PORT_CMD_ERROR_ID:RD:8:17:=0x000000 PORT_CMD_ERROR_ADDR:RD:0:34:=0x00
+#define              DENALI_CTL_107_DATA 0x00000000 // PORT_CMD_ERROR_TYPE:RD:0:2:=0x00
+#define              DENALI_CTL_108_DATA 0x02020101 // ODT_WR_MAP_CS1:RW:24:4:=0x02 ODT_RD_MAP_CS1:RW:16:4:=0x02 ODT_WR_MAP_CS0:RW:8:4:=0x01 ODT_RD_MAP_CS0:RW:0:4:=0x01
+#define              DENALI_CTL_109_DATA 0x08080404 // ODT_WR_MAP_CS3:RW:24:4:=0x08 ODT_RD_MAP_CS3:RW:16:4:=0x08 ODT_WR_MAP_CS2:RW:8:4:=0x04 ODT_RD_MAP_CS2:RW:0:4:=0x04
+#define              DENALI_CTL_110_DATA 0x03020000 // ADD_ODT_CLK_SAMETYPE_DIFFCS:RW:24:4:=0x03 ADD_ODT_CLK_DIFFTYPE_DIFFCS:RW:16:6:=0x02 ADD_ODT_CLK_W2R_SAMECS:RW:8:4:=0x00 ADD_ODT_CLK_R2W_SAMECS:RW:0:4:=0x00
+#define              DENALI_CTL_111_DATA 0x01000200 // W2W_DIFFCS_DLY:RW_D:24:3:=0x01 R2W_DIFFCS_DLY:RW_D:8:3:=0x02
+#define              DENALI_CTL_112_DATA 0x00000200 // W2W_SAMECS_DLY:RW:24:3:=0x00 W2R_SAMECS_DLY:RW:16:3:=0x00 R2W_SAMECS_DLY:RW_D:8:3:=0x02 R2R_SAMECS_DLY:RW:0:3:=0x00
+#define              DENALI_CTL_113_DATA 0x00000000 // SWLVL_LOAD:WR:24:1:=0x00 SW_LEVELING_MODE:RW:16:2:=0x00 OCD_ADJUST_PUP_CS_0:RW:8:5:=0x00 OCD_ADJUST_PDN_CS_0:RW:0:5:=0x00
+#define              DENALI_CTL_114_DATA 0x00000000 // LVL_STATUS:RD:24:4:=0x00 SWLVL_OP_DONE:RD:16:1:=0x00 SWLVL_EXIT:WR:8:1:=0x00 SWLVL_START:WR:0:1:=0x00
+#define              DENALI_CTL_115_DATA 0x00000000 // SWLVL_RESP_3:RD:24:8:=0x00 SWLVL_RESP_2:RD:16:8:=0x00 SWLVL_RESP_1:RD:8:8:=0x00 SWLVL_RESP_0:RD:0:8:=0x00
+#define              DENALI_CTL_116_DATA 0x0d000000 // WLDQSEN:RW:24:6:=0x0d WRLVL_CS:RW:16:2:=0x00 WRLVL_REQ:WR:8:1:=0x00 SWLVL_RESP_4:RD:0:8:=0x00
+#define              DENALI_CTL_117_DATA 0x00000028 // WRLVL_EN:RW:8:1:=0x00 WLMRD:RW:0:6:=0x28
+#define              DENALI_CTL_118_DATA 0x00000000 // WRLVL_REG_EN:RW:16:1:=0x00 WRLVL_ERROR_STATUS:RD:0:12:=0x0000
+#define              DENALI_CTL_119_DATA 0x00010001 // WRLVL_DELAY_F1_0:RW:16:16:=0x0001 WRLVL_DELAY_F0_0:RW:0:16:=0x0001
+#define              DENALI_CTL_120_DATA 0x00010001 // WRLVL_DELAY_F1_1:RW:16:16:=0x0001 WRLVL_DELAY_F0_1:RW:0:16:=0x0001
+#define              DENALI_CTL_121_DATA 0x00010001 // WRLVL_DELAY_F1_2:RW:16:16:=0x0001 WRLVL_DELAY_F0_2:RW:0:16:=0x0001
+#define              DENALI_CTL_122_DATA 0x00010001 // WRLVL_DELAY_F1_3:RW:16:16:=0x0001 WRLVL_DELAY_F0_3:RW:0:16:=0x0001
+#define              DENALI_CTL_123_DATA 0x00010001 // WRLVL_DELAY_F1_4:RW:16:16:=0x0001 WRLVL_DELAY_F0_4:RW:0:16:=0x0001
+#define              DENALI_CTL_124_DATA 0x00000000 // RDLVL_EDGE:RW:24:1:=0x00 RDLVL_CS:RW:16:2:=0x00 RDLVL_GATE_REQ:WR:8:1:=0x00 RDLVL_REQ:WR:0:1:=0x00
+#define              DENALI_CTL_125_DATA 0x00000000 // RDLVL_GATE_REG_EN:RW:16:1:=0x00 RDLVL_REG_EN:RW:8:1:=0x00 RDLVL_BEGIN_DELAY_EN:RW:0:1:=0x00
+#define              DENALI_CTL_126_DATA 0x00000000 // RDLVL_END_DELAY_0:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_0:RD:0:16:=0x0000
+#define              DENALI_CTL_127_DATA 0x00000000 // RDLVL_OFFSET_DELAY_0:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_0:RD:0:16:=0x0000
+#define              DENALI_CTL_128_DATA 0x001d1d00 // RDLVL_DELAY_F0_0:RW:8:16:=0x1d1d RDLVL_OFFSET_DIR_0:RW:0:1:=0x00
+#define              DENALI_CTL_129_DATA 0x1d1d0001 // RDLVL_DELAY_F1_0:RW:16:16:=0x1d1d RDLVL_GATE_DELAY_F0_0:RW:0:16:=0x0001
+#define              DENALI_CTL_130_DATA 0x00000001 // RDLVL_BEGIN_DELAY_1:RD:16:16:=0x0000 RDLVL_GATE_DELAY_F1_0:RW:0:16:=0x0001
+#define              DENALI_CTL_131_DATA 0x00000000 // RDLVL_MIDPOINT_DELAY_1:RD:16:16:=0x0000 RDLVL_END_DELAY_1:RD:0:16:=0x0000
+#define              DENALI_CTL_132_DATA 0x00000000 // RDLVL_OFFSET_DIR_1:RW:16:1:=0x00 RDLVL_OFFSET_DELAY_1:RW:0:16:=0x0000
+#define              DENALI_CTL_133_DATA 0x00011d1d // RDLVL_GATE_DELAY_F0_1:RW:16:16:=0x0001 RDLVL_DELAY_F0_1:RW:0:16:=0x1d1d
+#define              DENALI_CTL_134_DATA 0x00011d1d // RDLVL_GATE_DELAY_F1_1:RW:16:16:=0x0001 RDLVL_DELAY_F1_1:RW:0:16:=0x1d1d
+#define              DENALI_CTL_135_DATA 0x00000000 // RDLVL_END_DELAY_2:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_2:RD:0:16:=0x0000
+#define              DENALI_CTL_136_DATA 0x00000000 // RDLVL_OFFSET_DELAY_2:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_2:RD:0:16:=0x0000
+#define              DENALI_CTL_137_DATA 0x001d1d00 // RDLVL_DELAY_F0_2:RW:8:16:=0x1d1d RDLVL_OFFSET_DIR_2:RW:0:1:=0x00
+#define              DENALI_CTL_138_DATA 0x1d1d0001 // RDLVL_DELAY_F1_2:RW:16:16:=0x1d1d RDLVL_GATE_DELAY_F0_2:RW:0:16:=0x0001
+#define              DENALI_CTL_139_DATA 0x00000001 // RDLVL_BEGIN_DELAY_3:RD:16:16:=0x0000 RDLVL_GATE_DELAY_F1_2:RW:0:16:=0x0001
+#define              DENALI_CTL_140_DATA 0x00000000 // RDLVL_MIDPOINT_DELAY_3:RD:16:16:=0x0000 RDLVL_END_DELAY_3:RD:0:16:=0x0000
+#define              DENALI_CTL_141_DATA 0x00000000 // RDLVL_OFFSET_DIR_3:RW:16:1:=0x00 RDLVL_OFFSET_DELAY_3:RW:0:16:=0x0000
+#define              DENALI_CTL_142_DATA 0x00011d1d // RDLVL_GATE_DELAY_F0_3:RW:16:16:=0x0001 RDLVL_DELAY_F0_3:RW:0:16:=0x1d1d
+#define              DENALI_CTL_143_DATA 0x00011d1d // RDLVL_GATE_DELAY_F1_3:RW:16:16:=0x0001 RDLVL_DELAY_F1_3:RW:0:16:=0x1d1d
+#define              DENALI_CTL_144_DATA 0x00000000 // RDLVL_END_DELAY_4:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_4:RD:0:16:=0x0000
+#define              DENALI_CTL_145_DATA 0x00000000 // RDLVL_OFFSET_DELAY_4:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_4:RD:0:16:=0x0000
+#define              DENALI_CTL_146_DATA 0x001d1d00 // RDLVL_DELAY_F0_4:RW:8:16:=0x1d1d RDLVL_OFFSET_DIR_4:RW:0:1:=0x00
+#define              DENALI_CTL_147_DATA 0x1d1d0001 // RDLVL_DELAY_F1_4:RW:16:16:=0x1d1d RDLVL_GATE_DELAY_F0_4:RW:0:16:=0x0001
+#define              DENALI_CTL_148_DATA 0x00000001 // RDLVL_GATE_DELAY_F1_4:RW:0:16:=0x0001
+#define              DENALI_CTL_149_DATA 0x00000000 // AXI1_FIFO_TYPE_REG:RW:24:2:=0x00 AXI0_FIFO_TYPE_REG:RW:0:2:=0x00
+#define              DENALI_CTL_150_DATA 0x00000000 // AXI2_FIFO_TYPE_REG:RW:16:2:=0x00
+#define              DENALI_CTL_151_DATA 0x00000000 // WRR_PARAM_VALUE_ERR:RD:24:4:=0x00 WEIGHTED_ROUND_ROBIN_WEIGHT_SHARING:RW:16:1:=0x00 WEIGHTED_ROUND_ROBIN_LATENCY_CONTROL:RW:8:1:=0x00
+#define              DENALI_CTL_152_DATA 0x03030303 // AXI0_PRIORITY3_RELATIVE_PRIORITY:RW:24:4:=0x03 AXI0_PRIORITY2_RELATIVE_PRIORITY:RW:16:4:=0x03 AXI0_PRIORITY1_RELATIVE_PRIORITY:RW:8:4:=0x03 AXI0_PRIORITY0_RELATIVE_PRIORITY:RW:0:4:=0x03
+#define              DENALI_CTL_153_DATA 0x03030303 // AXI0_PRIORITY7_RELATIVE_PRIORITY:RW:24:4:=0x03 AXI0_PRIORITY6_RELATIVE_PRIORITY:RW:16:4:=0x03 AXI0_PRIORITY5_RELATIVE_PRIORITY:RW:8:4:=0x03 AXI0_PRIORITY4_RELATIVE_PRIORITY:RW:0:4:=0x03
+#define              DENALI_CTL_154_DATA 0x00000000 //
+#define              DENALI_CTL_155_DATA 0x00000000 //
+#define              DENALI_CTL_156_DATA 0x02006400 // AXI1_PRIORITY0_RELATIVE_PRIORITY:RW:24:4:=0x02 AXI0_PRIORITY_RELAX:RW:8:10:=0x0064 AXI0_PORT_ORDERING:RW:0:2:=0x00
+#define              DENALI_CTL_157_DATA 0x02020202 // AXI1_PRIORITY4_RELATIVE_PRIORITY:RW:24:4:=0x02 AXI1_PRIORITY3_RELATIVE_PRIORITY:RW:16:4:=0x02 AXI1_PRIORITY2_RELATIVE_PRIORITY:RW:8:4:=0x02 AXI1_PRIORITY1_RELATIVE_PRIORITY:RW:0:4:=0x02
+#define              DENALI_CTL_158_DATA 0x00020202 // AXI1_PRIORITY7_RELATIVE_PRIORITY:RW:16:4:=0x02 AXI1_PRIORITY6_RELATIVE_PRIORITY:RW:8:4:=0x02 AXI1_PRIORITY5_RELATIVE_PRIORITY:RW:0:4:=0x02
+#define              DENALI_CTL_159_DATA 0x00000000 //
+#define              DENALI_CTL_160_DATA 0x01000000 // AXI1_PORT_ORDERING:RW:24:2:=0x01
+#define              DENALI_CTL_161_DATA 0x01010064 // AXI2_PRIORITY1_RELATIVE_PRIORITY:RW:24:4:=0x01 AXI2_PRIORITY0_RELATIVE_PRIORITY:RW:16:4:=0x01 AXI1_PRIORITY_RELAX:RW:0:10:=0x0064
+#define              DENALI_CTL_162_DATA 0x01010101 // AXI2_PRIORITY5_RELATIVE_PRIORITY:RW:24:4:=0x01 AXI2_PRIORITY4_RELATIVE_PRIORITY:RW:16:4:=0x01 AXI2_PRIORITY3_RELATIVE_PRIORITY:RW:8:4:=0x01 AXI2_PRIORITY2_RELATIVE_PRIORITY:RW:0:4:=0x01
+#define              DENALI_CTL_163_DATA 0x00000101 // AXI2_PRIORITY7_RELATIVE_PRIORITY:RW:8:4:=0x01 AXI2_PRIORITY6_RELATIVE_PRIORITY:RW:0:4:=0x01
+#define              DENALI_CTL_164_DATA 0x00000000 //
+#define              DENALI_CTL_165_DATA 0x00020000 // AXI2_PORT_ORDERING:RW:16:2:=0x02
+#define              DENALI_CTL_166_DATA 0x00000064 // MEM_RST_VALID:RD:24:1:=0x00 CKE_STATUS:RD:16:4:=0x00 AXI2_PRIORITY_RELAX:RW:0:10:=0x0064
+#define              DENALI_CTL_167_DATA 0x00000000 // TDFI_PHY_WRLAT:RD:24:6:=0x00 DLL_RST_ADJ_DLY:RW:16:8:=0x00 DLL_RST_DELAY:RW:0:16:=0x0000
+#define              DENALI_CTL_168_DATA 0x000b0b00 // TDFI_RDDATA_EN:RD:24:7:=0x00 TDFI_PHY_RDLAT_F1:RW_D:16:6:=0x0b TDFI_PHY_RDLAT_F0:RW_D:8:6:=0x0b UPDATE_ERROR_STATUS:RD:0:7:=0x00
+#define              DENALI_CTL_169_DATA 0x0a240000 // TDFI_CTRLUPD_MAX_F0:RW:16:14:=0x0a24 TDFI_CTRLUPD_MIN:RD:8:4:=0x00 DRAM_CLK_DISABLE:RW:0:4:=0x00
+#define              DENALI_CTL_170_DATA 0x02000200 // TDFI_PHYUPD_TYPE1_F0:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE0_F0:RW:0:16:=0x0200
+#define              DENALI_CTL_171_DATA 0x02000200 // TDFI_PHYUPD_TYPE3_F0:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE2_F0:RW:0:16:=0x0200
+#define              DENALI_CTL_172_DATA 0x00000a24 // TDFI_PHYUPD_RESP_F0:RW:0:14:=0x0a24
+#define              DENALI_CTL_173_DATA 0x00006568 // TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x00006568
+#define              DENALI_CTL_174_DATA 0x0a240405 // TDFI_CTRLUPD_MAX_F1:RW:16:14:=0x0a24 WRLAT_ADJ_F0:RW:8:5:=0x04 RDLAT_ADJ_F0:RW:0:6:=0x05
+#define              DENALI_CTL_175_DATA 0x02000200 // TDFI_PHYUPD_TYPE1_F1:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE0_F1:RW:0:16:=0x0200
+#define              DENALI_CTL_176_DATA 0x02000200 // TDFI_PHYUPD_TYPE3_F1:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE2_F1:RW:0:16:=0x0200
+#define              DENALI_CTL_177_DATA 0x00000a24 // TDFI_PHYUPD_RESP_F1:RW:0:14:=0x0a24
+#define              DENALI_CTL_178_DATA 0x00006568 // TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x00006568
+#define              DENALI_CTL_179_DATA 0x02020405 // TDFI_CTRL_DELAY_F1:RW_D:24:4:=0x02 TDFI_CTRL_DELAY_F0:RW_D:16:4:=0x02 WRLAT_ADJ_F1:RW:8:5:=0x04 RDLAT_ADJ_F1:RW:0:6:=0x05
+#define              DENALI_CTL_180_DATA 0x80000100 // DFI_WRLVL_MAX_DELAY:RW:16:16:=0x8000 TDFI_DRAM_CLK_ENABLE:RW:8:4:=0x01 TDFI_DRAM_CLK_DISABLE:RW:0:4:=0x00
+#define              DENALI_CTL_181_DATA 0x04070303 // TDFI_WRLVL_RESPLAT:RW:24:8:=0x04 TDFI_WRLVL_LOAD:RW:16:8:=0x07 TDFI_WRLVL_DLL:RW:8:8:=0x03 TDFI_WRLVL_EN:RW:0:8:=0x03
+#define              DENALI_CTL_182_DATA 0x0000000a // TDFI_WRLVL_WW:RW:0:10:=0x000a
+#define              DENALI_CTL_183_DATA 0x00000000 // TDFI_WRLVL_RESP:RW:0:32:=0x00000000
+#define              DENALI_CTL_184_DATA 0x00000000 // TDFI_WRLVL_MAX:RW:0:32:=0x00000000
+#define              DENALI_CTL_185_DATA 0x0010ffff // RDLVL_GATE_MAX_DELAY:RW:16:16:=0x0010 RDLVL_MAX_DELAY:RW:0:16:=0xffff
+#define              DENALI_CTL_186_DATA 0x00070303 // TDFI_RDLVL_LOAD:RW:16:8:=0x07 TDFI_RDLVL_DLL:RW:8:8:=0x03 TDFI_RDLVL_EN:RW:0:8:=0x03
+#define              DENALI_CTL_187_DATA 0x0000000f // TDFI_RDLVL_RR:RW:0:10:=0x000f
+#define              DENALI_CTL_188_DATA 0x00000000 // TDFI_RDLVL_RESP:RW:0:32:=0x00000000
+#define              DENALI_CTL_189_DATA 0x00000000 // RDLVL_RESP_MASK:RW:0:36:=0x00000000
+#define              DENALI_CTL_190_DATA 0x00000000 // RDLVL_RESP_MASK:RW:0:36:=0x00
+#define              DENALI_CTL_191_DATA 0x00000000 // RDLVL_GATE_RESP_MASK:RW:0:36:=0x00000000
+#define              DENALI_CTL_192_DATA 0x00000000 // RDLVL_GATE_PREAMBLE_CHECK_EN:RW:24:1:=0x00 RDLVL_GATE_EN:RW:16:1:=0x00 RDLVL_EN:RW:8:1:=0x00 RDLVL_GATE_RESP_MASK:RW:0:36:=0x00
+#define              DENALI_CTL_193_DATA 0x00000000 // TDFI_RDLVL_MAX:RW:0:32:=0x00000000
+#define              DENALI_CTL_194_DATA 0x00000204 // RDLVL_GATE_DQ_ZERO_COUNT:RW:8:4:=0x02 RDLVL_DQ_ZERO_COUNT:RW:0:4:=0x04
+#define              DENALI_CTL_195_DATA 0x00000000 // RDLVL_ERROR_STATUS:RD:0:22:=0x000000
+#define              DENALI_CTL_196_DATA 0x00000000 //
+#define              DENALI_CTL_197_DATA 0x00000001 // TDFI_PHY_WRDATA:RW:0:3:=0x01
+#define              DENALI_CTL_198_DATA 0x00000000 // USER_DEF_REG_0:RW:0:32:=0x00000000
+#define              DENALI_CTL_199_DATA 0x00000000 // USER_DEF_REG_1:RW:0:32:=0x00000000
+#define              DENALI_CTL_200_DATA 0x00000000 // USER_DEF_REG_RO_0:RD:0:32:=0x00000000
+#define              DENALI_CTL_201_DATA 0x00000000 // USER_DEF_REG_RO_1:RD:0:32:=0x00000000
+#define              DENALI_CTL_202_DATA 0x0001046b // TINIT_F0:RW:0:24:=0x01046b
+#define              DENALI_CTL_203_DATA 0x0001046b // LP_AUTO_MEM_GATE_EN:RW:24:2:=0x00 TINIT_F1:RW:0:24:=0x01046b
+#define              DENALI_CTL_204_DATA 0x00000000 // LP_AUTO_PD_IDLE:RW:0:12:=0x0000
+#define              DENALI_CTL_205_DATA 0x00000000 //
+#define              DENALI_CTL_206_DATA 0x02030301 // W2R_DIFFCS_DLY_F0:RW_D:24:3:=0x02 TODTL_2CMD_F1:RW:16:5:=0x03 TODTL_2CMD_F0:RW:8:5:=0x03 RW_SAME_PAGE_EN:RW:0:1:=0x01
+#define              DENALI_CTL_207_DATA 0x00000002 // W2R_DIFFCS_DLY_F1:RW_D:0:3:=0x02
+#define              DENALI_CTL_208_DATA 0x00000000 //
+#define              DENALI_CTL_209_DATA 0x00000000 // OBSOLETE_PLACEHOLDER:RW:0:16:=0x0000
+#define              DENALI_CTL_210_DATA 0x05050000 // TWR_F0:RW:24:6:=0x05 TRCD_F0:RW:16:8:=0x05 RESERVED:RW:8:5:=0x00 RESERVED:RW:0:5:=0x00
+#define              DENALI_CTL_211_DATA 0x00000505 // NO_MEMORY_DM:RW:24:1:=0x00 RESERVED:RW:16:1:=0x00 TWR_F1:RW:8:6:=0x05 TRCD_F1:RW:0:8:=0x05
+#define              DENALI_CTL_212_DATA 0x00000040 // ZQ_INTERVAL:RW:0:32:=0x00000040
+#define              DENALI_CTL_213_DATA 0x00000000 // INT_ACK:WR:0:25:=0x00000000
+#define              DENALI_CTL_214_DATA 0x02010505 // R2R_DIFFCS_DLY_F0:RW_D:24:3:=0x02 ODT_EN:RW:16:1:=0x01 TODTH_RD:RW:8:4:=0x05 TODTH_WR:RW:0:4:=0x05
+#define              DENALI_CTL_215_DATA 0x00000102 // WRLVL_INTERVAL:RW:16:16:=0x0000 LVL_AREF_EN:RW:8:1:=0x01 R2R_DIFFCS_DLY_F1:RW_D:0:3:=0x02
+#define              DENALI_CTL_216_DATA 0x00001a1a // RDLVL_INTERVAL:RW:16:16:=0x0000 TDFI_RDLVL_RESPLAT_F1:RW:8:8:=0x1a TDFI_RDLVL_RESPLAT_F0:RW:0:8:=0x1a
+#define              DENALI_CTL_217_DATA 0x00000000 // RDLVL_GATE_INTERVAL:RW:0:16:=0x0000
diff --git a/board/accton/as4610_30/mt47h128m16/mt47h128m16_667.array b/board/accton/as4610_30/mt47h128m16/mt47h128m16_667.array
new file mode 100644
index 0000000..d5d2da8
--- /dev/null
+++ b/board/accton/as4610_30/mt47h128m16/mt47h128m16_667.array
@@ -0,0 +1,225 @@
+unsigned int ddr_init_tab = { 
+	14, 0x00000001,
+	36, 0x01000000,
+	37, 0x10000000,
+	38, 0x00100400,
+	39, 0x00000400,
+	40, 0x00000100,
+	42, 0x00000001,
+	61, 0x00010100,
+	78, 0x01000200,
+	79, 0x02000040,
+	80, 0x00400100,
+	81, 0x00000200,
+	83, 0x01ffff0a,
+	84, 0x01010101,
+	87, 0x0000010c,
+	88, 0x00010000,
+	112, 0x00000200,
+	116, 0x0d000000,
+	117, 0x00000028,
+	119, 0x00010001,
+	120, 0x00010001,
+	121, 0x00010001,
+	122, 0x00010001,
+	123, 0x00010001,
+	130, 0x00000001,
+	139, 0x00000001,
+	148, 0x00000001,
+	149, 0x00000000,
+	150, 0x00000000,
+	152, 0x03030303,
+	153, 0x03030303,
+	156, 0x02006400,
+	157, 0x02020202,
+	158, 0x00020202,
+	160, 0x01000000,
+	161, 0x01010064,
+	162, 0x01010101,
+	163, 0x00000101,
+	165, 0x00020000,
+	166, 0x00000064,
+	168, 0x000b0b00,
+	170, 0x02000200,
+	171, 0x02000200,
+	175, 0x02000200,
+	176, 0x02000200,
+	180, 0x80000100,
+	181, 0x04070303,
+	182, 0x0000000a,
+	185, 0x0010ffff,
+	187, 0x0000000f,
+	194, 0x00000204,
+	205, 0x00000000,
+	0xffffffff
+};
+
+unsigned int ddr2_init_tab_667[] = { 
+	0, 0x00000400,
+	1, 0x00000000,
+	2, 0x00000000,
+	3, 0x00000043,
+	4, 0x000000a7,
+	5, 0x0a040a02,
+	6, 0x04020404,
+	7, 0x05030e12,
+	8, 0x030e1204,
+	9, 0x04020305,
+	10, 0x03005b26,
+	11, 0x04020303,
+	12, 0x03005b26,
+	13, 0x01010003,
+	15, 0x000a0a00,
+	16, 0x030000c8,
+	17, 0x00860f0f,
+	18, 0x06060086,
+	19, 0x00000000,
+	20, 0x00004201,
+	21, 0x00420a24,
+	22, 0x00050a24,
+	23, 0x00000300,
+	24, 0x000a0003,
+	25, 0x0003000a,
+	26, 0x0003000a,
+	27, 0x00c8000a,
+	28, 0x00c80046,
+	29, 0x00000046,
+	30, 0x03000001,
+	31, 0x00030303,
+	32, 0x00000000,
+	33, 0x00000000,
+	34, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x00085300,
+	45, 0x00000004,
+	46, 0x00040853,
+	47, 0x00000000,
+	48, 0x08530000,
+	49, 0x00000004,
+	50, 0x00040853,
+	51, 0x00000000,
+	52, 0x08530000,
+	53, 0x00000004,
+	54, 0x00040853,
+	55, 0x00000000,
+	56, 0x08530000,
+	57, 0x00000004,
+	58, 0x00040853,
+	59, 0x00000000,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000,
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01020001,
+	85, 0x01010101,
+	86, 0x0f000003,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02020101,
+	109, 0x08080404,
+	110, 0x03020000,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x001d1d00,
+	129, 0x1d1d0001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00011d1d,
+	134, 0x00011d1d,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x001d1d00,
+	138, 0x1d1d0001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00011d1d,
+	143, 0x00011d1d,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x001d1d00,
+	147, 0x1d1d0001,
+	151, 0x00000000,
+	154, 0x00000000,
+	155, 0x00000000,
+	159, 0x00000000,
+	164, 0x00000000,
+	167, 0x00000000,
+	169, 0x0a240000,
+	172, 0x00000a24,
+	173, 0x00006568,
+	174, 0x0a240405,
+	177, 0x00000a24,
+	178, 0x00006568,
+	179, 0x02020405,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x0001046b,
+	203, 0x0001046b,
+	204, 0x00000000,
+	206, 0x02030301,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x05050000,
+	211, 0x00000505,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x02010505,
+	215, 0x00000102,
+	216, 0x00001a1a,
+	217, 0x00000000,
+	0xffffffff
+};
diff --git a/board/accton/as4610_30/mt47h128m16/mt47h128m16_800 b/board/accton/as4610_30/mt47h128m16/mt47h128m16_800
new file mode 100644
index 0000000..35bb82d
--- /dev/null
+++ b/board/accton/as4610_30/mt47h128m16/mt47h128m16_800
@@ -0,0 +1,218 @@
+#define               DENALI_CTL_00_DATA 0x00000400 // VERSION:RD:16:16:=0x0000 DRAM_CLASS:RW:8:4:=0x04 START:RW:0:1:=0x00
+#define               DENALI_CTL_01_DATA 0x00000000 // MAX_CS_REG:RD:16:3:=0x00 MAX_COL_REG:RD:8:4:=0x00 MAX_ROW_REG:RD:0:5:=0x00
+#define               DENALI_CTL_02_DATA 0x00000000 //
+#define               DENALI_CTL_03_DATA 0x00000050 // TRST_PWRON:RW:0:32:=0x00000050
+#define               DENALI_CTL_04_DATA 0x000000c8 // CKE_INACTIVE:RW:0:32:=0x000000c8
+#define               DENALI_CTL_05_DATA 0x0c050c02 // CASLAT_LIN_F1:RW:24:6:=0x0c WRLAT_F0:RW:16:5:=0x05 CASLAT_LIN_F0:RW:8:6:=0x0c INITAREF:RW:0:4:=0x02
+#define               DENALI_CTL_06_DATA 0x04020405 // TRRD_F0:RW:24:8:=0x04 TCCD:RW:16:5:=0x02 TBST_INT_INTERVAL:RW:8:3:=0x04 WRLAT_F1:RW:0:5:=0x05
+#define               DENALI_CTL_07_DATA 0x06031016 // TRP_F0:RW:24:5:=0x06 TWTR_F0:RW:16:4:=0x03 TRAS_MIN_F0:RW:8:8:=0x10 TRC_F0:RW:0:8:=0x16
+#define               DENALI_CTL_08_DATA 0x03101604 // TWTR_F1:RW:24:4:=0x03 TRAS_MIN_F1:RW:16:8:=0x10 TRC_F1:RW:8:8:=0x16 TRRD_F1:RW:0:8:=0x04
+#define               DENALI_CTL_09_DATA 0x05020306 // TMOD_F0:RW:24:8:=0x05 TMRD_F0:RW:16:5:=0x02 TRTP_F0:RW:8:4:=0x03 TRP_F1:RW:0:5:=0x06
+#define               DENALI_CTL_10_DATA 0x03006d60 // TCKE_F0:RW:24:3:=0x03 TRAS_MAX_F0:RW:0:17:=0x006d60
+#define               DENALI_CTL_11_DATA 0x05020303 // TMOD_F1:RW:24:8:=0x05 TMRD_F1:RW:16:5:=0x02 TRTP_F1:RW:8:4:=0x03 TCKESR_F0:RW:0:5:=0x03
+#define               DENALI_CTL_12_DATA 0x03006d60 // TCKE_F1:RW:24:3:=0x03 TRAS_MAX_F1:RW:0:17:=0x006d60
+#define               DENALI_CTL_13_DATA 0x01010003 // CONCURRENTAP:RW:24:1:=0x01 AP:RW:16:1:=0x01 WRITEINTERP:RW:8:1:=0x00 TCKESR_F1:RW:0:5:=0x03
+#define               DENALI_CTL_14_DATA 0x00000001 // TRAS_LOCKOUT:RW:0:1:=0x01
+#define               DENALI_CTL_15_DATA 0x000c0c00 // TDAL_F1:RW:16:6:=0x0c TDAL_F0:RW:8:6:=0x0c
+#define               DENALI_CTL_16_DATA 0x030000c8 // BSTLEN:RW_D:24:3:=0x03 NO_CMD_INIT:RW:16:1:=0x00 TDLL:RW:0:16:=0x00c8
+#define               DENALI_CTL_17_DATA 0x00a01212 // TCPD_F0:RW:16:16:=0x00a0 TFAW_F1:RW:8:6:=0x12 TFAW_F0:RW:0:6:=0x12
+#define               DENALI_CTL_18_DATA 0x070700a0 // TRP_AB_F1:RW:24:5:=0x07 TRP_AB_F0:RW:16:5:=0x07 TCPD_F1:RW:0:16:=0x00a0
+#define               DENALI_CTL_19_DATA 0x00000000 // AUTO_REFRESH_MODE:RW:24:1:=0x00 AREFRESH:WR:16:1:=0x00 ADDRESS_MIRRORING:RW:8:4:=0x00 REG_DIMM_ENABLE:RW:0:1:=0x00
+#define               DENALI_CTL_20_DATA 0x00004f01 // TRFC_F0:RW:8:10:=0x004f TREF_ENABLE:RW:0:1:=0x01
+#define               DENALI_CTL_21_DATA 0x004f0c2d // TRFC_F1:RW:16:10:=0x004f TREF_F0:RW:0:14:=0x0c2d
+#define               DENALI_CTL_22_DATA 0x00050c2d // TREF_INTERVAL:RW:16:14:=0x0005 TREF_F1:RW:0:14:=0x0c2d
+#define               DENALI_CTL_23_DATA 0x00000300 // TPDEX_F0:RW:8:16:=0x0003
+#define               DENALI_CTL_24_DATA 0x000a0003 // TXPDLL_F0:RW:16:16:=0x000a TPDEX_F1:RW:0:16:=0x0003
+#define               DENALI_CTL_25_DATA 0x0003000a // TXARD_F0:RW:16:16:=0x0003 TXPDLL_F1:RW:0:16:=0x000a
+#define               DENALI_CTL_26_DATA 0x0003000a // TXARD_F1:RW:16:16:=0x0003 TXARDS_F0:RW:0:16:=0x000a
+#define               DENALI_CTL_27_DATA 0x00c8000a // TXSR_F0:RW:16:16:=0x00c8 TXARDS_F1:RW:0:16:=0x000a
+#define               DENALI_CTL_28_DATA 0x00c80053 // TXSR_F1:RW:16:16:=0x00c8 TXSNR_F0:RW:0:16:=0x0053
+#define               DENALI_CTL_29_DATA 0x00000053 // SREFRESH_EXIT_NO_REFRESH:RW:24:1:=0x00 PWRUP_SREFRESH_EXIT:RW:16:1:=0x00 TXSNR_F1:RW:0:16:=0x0053
+#define               DENALI_CTL_30_DATA 0x03000001 // CKSRE_F0:RW:24:4:=0x03 LOWPOWER_REFRESH_ENABLE:RW:16:4:=0x00 CKE_DELAY:RW:8:3:=0x00 ENABLE_QUICK_SREFRESH:RW:0:1:=0x01
+#define               DENALI_CTL_31_DATA 0x00030303 // LP_CMD:WR:24:8:=0x00 CKSRX_F1:RW:16:4:=0x03 CKSRE_F1:RW:8:4:=0x03 CKSRX_F0:RW:0:4:=0x03
+#define               DENALI_CTL_32_DATA 0x00000000 // LP_AUTO_EXIT_EN:RW:24:3:=0x00 LP_AUTO_ENTRY_EN:RW:16:3:=0x00 LP_ARB_STATE:RD:8:4:=0x00 LP_STATE:RD:0:6:=0x00
+#define               DENALI_CTL_33_DATA 0x00000000 //
+#define               DENALI_CTL_34_DATA 0x00000000 //
+#define               DENALI_CTL_35_DATA 0x00000000 // LP_AUTO_SR_IDLE:RW:0:8:=0x00
+#define               DENALI_CTL_36_DATA 0x01000000 // FREQ_CHANGE_ENABLE:RW:24:1:=0x01 RESERVED:RW:16:8:=0x00 LP_AUTO_SR_MC_GATE_IDLE:RW:0:8:=0x00
+#define               DENALI_CTL_37_DATA 0x10000000 // TDFI_INIT_START_F0:RW:24:8:=0x10 FREQ_CHANGE_DLL_OFF:RW:16:2:=0x00 FREQ_CHANGE_DONE_HOLD_CLEAR:WR:8:1:=0x00 FREQ_CHANGE_DONE_HOLD_EN:RW:0:1:=0x00
+#define               DENALI_CTL_38_DATA 0x00100400 // TDFI_INIT_START_F1:RW:16:8:=0x10 TDFI_INIT_COMPLETE_F0:RW:0:16:=0x0400
+#define               DENALI_CTL_39_DATA 0x00000400 // DFS_PHY_REG_WRITE_EN:RW:24:1:=0x00 CURRENT_REG_COPY:RD:16:1:=0x00 TDFI_INIT_COMPLETE_F1:RW:0:16:=0x0400
+#define               DENALI_CTL_40_DATA 0x00000100 // DFS_PHY_REG_WRITE_ADDR:RW:0:32:=0x00000100
+#define               DENALI_CTL_41_DATA 0x00000000 // DFS_PHY_REG_WRITE_DATA_F0:RW:0:32:=0x00000000
+#define               DENALI_CTL_42_DATA 0x00000001 // DFS_PHY_REG_WRITE_DATA_F1:RW:0:32:=0x00000001
+#define               DENALI_CTL_43_DATA 0x00000000 // WRITE_MODEREG:RW+:0:26:=0x00000000
+#define               DENALI_CTL_44_DATA 0x000a6300 // MR0_DATA_F0_0:RW:8:16:=0x0a63 MRW_STATUS:RD:0:8:=0x00
+#define               DENALI_CTL_45_DATA 0x00000004 // MR2_DATA_F0_0:RW:16:16:=0x0000 MR1_DATA_F0_0:RW:0:16:=0x0004
+#define               DENALI_CTL_46_DATA 0x00040a63 // MR1_DATA_F1_0:RW:16:16:=0x0004 MR0_DATA_F1_0:RW:0:16:=0x0a63
+#define               DENALI_CTL_47_DATA 0x00000000 // MRSINGLE_DATA_0:RW:16:16:=0x0000 MR2_DATA_F1_0:RW:0:16:=0x0000
+#define               DENALI_CTL_48_DATA 0x0a630000 // MR0_DATA_F0_1:RW:16:16:=0x0a63 MR3_DATA_0:RW:0:16:=0x0000
+#define               DENALI_CTL_49_DATA 0x00000004 // MR2_DATA_F0_1:RW:16:16:=0x0000 MR1_DATA_F0_1:RW:0:16:=0x0004
+#define               DENALI_CTL_50_DATA 0x00040a63 // MR1_DATA_F1_1:RW:16:16:=0x0004 MR0_DATA_F1_1:RW:0:16:=0x0a63
+#define               DENALI_CTL_51_DATA 0x00000000 // MRSINGLE_DATA_1:RW:16:16:=0x0000 MR2_DATA_F1_1:RW:0:16:=0x0000
+#define               DENALI_CTL_52_DATA 0x0a630000 // MR0_DATA_F0_2:RW:16:16:=0x0a63 MR3_DATA_1:RW:0:16:=0x0000
+#define               DENALI_CTL_53_DATA 0x00000004 // MR2_DATA_F0_2:RW:16:16:=0x0000 MR1_DATA_F0_2:RW:0:16:=0x0004
+#define               DENALI_CTL_54_DATA 0x00040a63 // MR1_DATA_F1_2:RW:16:16:=0x0004 MR0_DATA_F1_2:RW:0:16:=0x0a63
+#define               DENALI_CTL_55_DATA 0x00000000 // MRSINGLE_DATA_2:RW:16:16:=0x0000 MR2_DATA_F1_2:RW:0:16:=0x0000
+#define               DENALI_CTL_56_DATA 0x0a630000 // MR0_DATA_F0_3:RW:16:16:=0x0a63 MR3_DATA_2:RW:0:16:=0x0000
+#define               DENALI_CTL_57_DATA 0x00000004 // MR2_DATA_F0_3:RW:16:16:=0x0000 MR1_DATA_F0_3:RW:0:16:=0x0004
+#define               DENALI_CTL_58_DATA 0x00040a63 // MR1_DATA_F1_3:RW:16:16:=0x0004 MR0_DATA_F1_3:RW:0:16:=0x0a63
+#define               DENALI_CTL_59_DATA 0x00000000 // MRSINGLE_DATA_3:RW:16:16:=0x0000 MR2_DATA_F1_3:RW:0:16:=0x0000
+#define               DENALI_CTL_60_DATA 0x00000000 // BIST_RESULT:RD:24:2:=0x00 BIST_GO:WR:16:1:=0x00 MR3_DATA_3:RW:0:16:=0x0000
+#define               DENALI_CTL_61_DATA 0x00010100 // BIST_ADDR_CHECK:RW:16:1:=0x01 BIST_DATA_CHECK:RW:8:1:=0x01 ADDR_SPACE:RW:0:6:=0x00
+#define               DENALI_CTL_62_DATA 0x00000000 // BIST_START_ADDRESS:RW:0:34:=0x00000000
+#define               DENALI_CTL_63_DATA 0x00000000 // BIST_START_ADDRESS:RW:0:34:=0x00
+#define               DENALI_CTL_64_DATA 0x00000000 // BIST_DATA_MASK:RW:0:64:=0x00000000
+#define               DENALI_CTL_65_DATA 0x00000000 // BIST_DATA_MASK:RW:0:64:=0x00000000
+#define               DENALI_CTL_66_DATA 0x00000003 // XOR_CHECK_BITS:RW:16:16:=0x0000 FWC:WR:8:1:=0x00 CTRL_RAW:RW:0:2:=0x03
+#define               DENALI_CTL_67_DATA 0x00000000 // ECC_DISABLE_W_UC_ERR:RW:0:1:=0x00
+#define               DENALI_CTL_68_DATA 0x00000000 // ECC_U_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_69_DATA 0x00000000 // ECC_U_SYND:RD:8:8:=0x00 ECC_U_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_70_DATA 0x00000000 // ECC_U_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_71_DATA 0x00000000 // ECC_U_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_72_DATA 0x00000000 // ECC_C_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_73_DATA 0x00000000 // ECC_C_SYND:RD:8:8:=0x00 ECC_C_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_74_DATA 0x00000000 // ECC_C_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_75_DATA 0x00000000 // ECC_C_DATA:RD:0:64:=0x00000000
+#define               DENALI_CTL_76_DATA 0x00000000 // ECC_U_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_77_DATA 0x00000000 // ECC_C_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_78_DATA 0x01000200 // ZQCL_F0:RW:16:12:=0x0100 ZQINIT_F0:RW_D:0:12:=0x0200
+#define               DENALI_CTL_79_DATA 0x02000040 // ZQINIT_F1:RW_D:16:12:=0x0200 ZQCS_F0:RW:0:12:=0x0040
+#define               DENALI_CTL_80_DATA 0x00400100 // ZQCS_F1:RW:16:12:=0x0040 ZQCL_F1:RW:0:12:=0x0100
+#define               DENALI_CTL_81_DATA 0x00000200 // ZQ_IN_PROGRESS:RD:24:1:=0x00 ZQ_ON_SREF_EXIT:RW:8:2:=0x02 ZQ_REQ:WR:0:2:=0x00
+#define               DENALI_CTL_82_DATA 0x01020001 // COL_DIFF:RW:24:3:=0x01 ROW_DIFF:RW:16:3:=0x02 BANK_DIFF:RW:8:2:=0x00 ZQCS_ROTATE:RW:0:1:=0x01
+#define               DENALI_CTL_83_DATA 0x01ffff0a // ADDR_CMP_EN:RW:24:1:=0x01 COMMAND_AGE_COUNT:RW:16:8:=0xff AGE_COUNT:RW:8:8:=0xff APREBIT:RW_D:0:4:=0x0a
+#define               DENALI_CTL_84_DATA 0x01010101 // RW_SAME_EN:RW:24:1:=0x01 PRIORITY_EN:RW:16:1:=0x01 PLACEMENT_EN:RW:8:1:=0x01 BANK_SPLIT_EN:RW:0:1:=0x01
+#define               DENALI_CTL_85_DATA 0x01010101 // DISABLE_RW_GROUP_W_BNK_CONFLICT:RW:24:2:=0x01 W2R_SPLIT_EN:RW:16:1:=0x01 CS_SAME_EN:RW:8:1:=0x01 SWAP_EN:RW:0:1:=0x01
+#define               DENALI_CTL_86_DATA 0x0f000003 // CS_MAP:RW:24:4:=0x0f INHIBIT_DRAM_CMD:RW:16:1:=0x00 DISABLE_RD_INTERLEAVE:RW:8:1:=0x00 NUM_Q_ENTRIES_ACT_DISABLE:RW:0:3:=0x03
+#define               DENALI_CTL_87_DATA 0x0000010c // IN_ORDER_ACCEPT:RW:24:1:=0x00 Q_FULLNESS:RW:16:3:=0x00 REDUC:RW:8:1:=0x01 BURST_ON_FLY_BIT:RW:0:4:=0x0c
+#define               DENALI_CTL_88_DATA 0x00010000 // CTRLUPD_REQ_PER_AREF_EN:RW:16:1:=0x01 CTRLUPD_REQ:WR:8:1:=0x00 CONTROLLER_BUSY:RD:0:1:=0x00
+#define               DENALI_CTL_89_DATA 0x00000000 // INT_STATUS:RD:0:26:=0x00000000
+#define               DENALI_CTL_90_DATA 0x00000000 //
+#define               DENALI_CTL_91_DATA 0x00000000 // INT_MASK:RW:0:26:=0x00000000
+#define               DENALI_CTL_92_DATA 0x00000000 // OUT_OF_RANGE_ADDR:RD:0:34:=0x00000000
+#define               DENALI_CTL_93_DATA 0x00000000 // OUT_OF_RANGE_TYPE:RD:16:6:=0x00 OUT_OF_RANGE_LENGTH:RD:8:7:=0x00 OUT_OF_RANGE_ADDR:RD:0:34:=0x00
+#define               DENALI_CTL_94_DATA 0x00000000 // OUT_OF_RANGE_SOURCE_ID:RD:0:17:=0x000000
+#define               DENALI_CTL_95_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_96_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_97_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_98_DATA 0x00000000 // BIST_EXP_DATA:RD:0:128:=0x00000000
+#define               DENALI_CTL_99_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_100_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_101_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_102_DATA 0x00000000 // BIST_FAIL_DATA:RD:0:128:=0x00000000
+#define              DENALI_CTL_103_DATA 0x00000000 // BIST_FAIL_ADDR:RD:0:34:=0x00000000
+#define              DENALI_CTL_104_DATA 0x00000000 // BIST_FAIL_ADDR:RD:0:34:=0x00
+#define              DENALI_CTL_105_DATA 0x00000000 // PORT_CMD_ERROR_ADDR:RD:0:34:=0x00000000
+#define              DENALI_CTL_106_DATA 0x00000000 // PORT_CMD_ERROR_ID:RD:8:17:=0x000000 PORT_CMD_ERROR_ADDR:RD:0:34:=0x00
+#define              DENALI_CTL_107_DATA 0x00000000 // PORT_CMD_ERROR_TYPE:RD:0:2:=0x00
+#define              DENALI_CTL_108_DATA 0x02020101 // ODT_WR_MAP_CS1:RW:24:4:=0x02 ODT_RD_MAP_CS1:RW:16:4:=0x02 ODT_WR_MAP_CS0:RW:8:4:=0x01 ODT_RD_MAP_CS0:RW:0:4:=0x01
+#define              DENALI_CTL_109_DATA 0x08080404 // ODT_WR_MAP_CS3:RW:24:4:=0x08 ODT_RD_MAP_CS3:RW:16:4:=0x08 ODT_WR_MAP_CS2:RW:8:4:=0x04 ODT_RD_MAP_CS2:RW:0:4:=0x04
+#define              DENALI_CTL_110_DATA 0x03020000 // ADD_ODT_CLK_SAMETYPE_DIFFCS:RW:24:4:=0x03 ADD_ODT_CLK_DIFFTYPE_DIFFCS:RW:16:6:=0x02 ADD_ODT_CLK_W2R_SAMECS:RW:8:4:=0x00 ADD_ODT_CLK_R2W_SAMECS:RW:0:4:=0x00
+#define              DENALI_CTL_111_DATA 0x01000200 // W2W_DIFFCS_DLY:RW_D:24:3:=0x01 R2W_DIFFCS_DLY:RW_D:8:3:=0x02
+#define              DENALI_CTL_112_DATA 0x00000200 // W2W_SAMECS_DLY:RW:24:3:=0x00 W2R_SAMECS_DLY:RW:16:3:=0x00 R2W_SAMECS_DLY:RW_D:8:3:=0x02 R2R_SAMECS_DLY:RW:0:3:=0x00
+#define              DENALI_CTL_113_DATA 0x00000000 // SWLVL_LOAD:WR:24:1:=0x00 SW_LEVELING_MODE:RW:16:2:=0x00 OCD_ADJUST_PUP_CS_0:RW:8:5:=0x00 OCD_ADJUST_PDN_CS_0:RW:0:5:=0x00
+#define              DENALI_CTL_114_DATA 0x00000000 // LVL_STATUS:RD:24:4:=0x00 SWLVL_OP_DONE:RD:16:1:=0x00 SWLVL_EXIT:WR:8:1:=0x00 SWLVL_START:WR:0:1:=0x00
+#define              DENALI_CTL_115_DATA 0x00000000 // SWLVL_RESP_3:RD:24:8:=0x00 SWLVL_RESP_2:RD:16:8:=0x00 SWLVL_RESP_1:RD:8:8:=0x00 SWLVL_RESP_0:RD:0:8:=0x00
+#define              DENALI_CTL_116_DATA 0x0d000000 // WLDQSEN:RW:24:6:=0x0d WRLVL_CS:RW:16:2:=0x00 WRLVL_REQ:WR:8:1:=0x00 SWLVL_RESP_4:RD:0:8:=0x00
+#define              DENALI_CTL_117_DATA 0x00000028 // WRLVL_EN:RW:8:1:=0x00 WLMRD:RW:0:6:=0x28
+#define              DENALI_CTL_118_DATA 0x00000000 // WRLVL_REG_EN:RW:16:1:=0x00 WRLVL_ERROR_STATUS:RD:0:12:=0x0000
+#define              DENALI_CTL_119_DATA 0x00010001 // WRLVL_DELAY_F1_0:RW:16:16:=0x0001 WRLVL_DELAY_F0_0:RW:0:16:=0x0001
+#define              DENALI_CTL_120_DATA 0x00010001 // WRLVL_DELAY_F1_1:RW:16:16:=0x0001 WRLVL_DELAY_F0_1:RW:0:16:=0x0001
+#define              DENALI_CTL_121_DATA 0x00010001 // WRLVL_DELAY_F1_2:RW:16:16:=0x0001 WRLVL_DELAY_F0_2:RW:0:16:=0x0001
+#define              DENALI_CTL_122_DATA 0x00010001 // WRLVL_DELAY_F1_3:RW:16:16:=0x0001 WRLVL_DELAY_F0_3:RW:0:16:=0x0001
+#define              DENALI_CTL_123_DATA 0x00010001 // WRLVL_DELAY_F1_4:RW:16:16:=0x0001 WRLVL_DELAY_F0_4:RW:0:16:=0x0001
+#define              DENALI_CTL_124_DATA 0x00000000 // RDLVL_EDGE:RW:24:1:=0x00 RDLVL_CS:RW:16:2:=0x00 RDLVL_GATE_REQ:WR:8:1:=0x00 RDLVL_REQ:WR:0:1:=0x00
+#define              DENALI_CTL_125_DATA 0x00000000 // RDLVL_GATE_REG_EN:RW:16:1:=0x00 RDLVL_REG_EN:RW:8:1:=0x00 RDLVL_BEGIN_DELAY_EN:RW:0:1:=0x00
+#define              DENALI_CTL_126_DATA 0x00000000 // RDLVL_END_DELAY_0:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_0:RD:0:16:=0x0000
+#define              DENALI_CTL_127_DATA 0x00000000 // RDLVL_OFFSET_DELAY_0:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_0:RD:0:16:=0x0000
+#define              DENALI_CTL_128_DATA 0x001d1d00 // RDLVL_DELAY_F0_0:RW:8:16:=0x1d1d RDLVL_OFFSET_DIR_0:RW:0:1:=0x00
+#define              DENALI_CTL_129_DATA 0x1d1d0001 // RDLVL_DELAY_F1_0:RW:16:16:=0x1d1d RDLVL_GATE_DELAY_F0_0:RW:0:16:=0x0001
+#define              DENALI_CTL_130_DATA 0x00000001 // RDLVL_BEGIN_DELAY_1:RD:16:16:=0x0000 RDLVL_GATE_DELAY_F1_0:RW:0:16:=0x0001
+#define              DENALI_CTL_131_DATA 0x00000000 // RDLVL_MIDPOINT_DELAY_1:RD:16:16:=0x0000 RDLVL_END_DELAY_1:RD:0:16:=0x0000
+#define              DENALI_CTL_132_DATA 0x00000000 // RDLVL_OFFSET_DIR_1:RW:16:1:=0x00 RDLVL_OFFSET_DELAY_1:RW:0:16:=0x0000
+#define              DENALI_CTL_133_DATA 0x00011d1d // RDLVL_GATE_DELAY_F0_1:RW:16:16:=0x0001 RDLVL_DELAY_F0_1:RW:0:16:=0x1d1d
+#define              DENALI_CTL_134_DATA 0x00011d1d // RDLVL_GATE_DELAY_F1_1:RW:16:16:=0x0001 RDLVL_DELAY_F1_1:RW:0:16:=0x1d1d
+#define              DENALI_CTL_135_DATA 0x00000000 // RDLVL_END_DELAY_2:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_2:RD:0:16:=0x0000
+#define              DENALI_CTL_136_DATA 0x00000000 // RDLVL_OFFSET_DELAY_2:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_2:RD:0:16:=0x0000
+#define              DENALI_CTL_137_DATA 0x001d1d00 // RDLVL_DELAY_F0_2:RW:8:16:=0x1d1d RDLVL_OFFSET_DIR_2:RW:0:1:=0x00
+#define              DENALI_CTL_138_DATA 0x1d1d0001 // RDLVL_DELAY_F1_2:RW:16:16:=0x1d1d RDLVL_GATE_DELAY_F0_2:RW:0:16:=0x0001
+#define              DENALI_CTL_139_DATA 0x00000001 // RDLVL_BEGIN_DELAY_3:RD:16:16:=0x0000 RDLVL_GATE_DELAY_F1_2:RW:0:16:=0x0001
+#define              DENALI_CTL_140_DATA 0x00000000 // RDLVL_MIDPOINT_DELAY_3:RD:16:16:=0x0000 RDLVL_END_DELAY_3:RD:0:16:=0x0000
+#define              DENALI_CTL_141_DATA 0x00000000 // RDLVL_OFFSET_DIR_3:RW:16:1:=0x00 RDLVL_OFFSET_DELAY_3:RW:0:16:=0x0000
+#define              DENALI_CTL_142_DATA 0x00011d1d // RDLVL_GATE_DELAY_F0_3:RW:16:16:=0x0001 RDLVL_DELAY_F0_3:RW:0:16:=0x1d1d
+#define              DENALI_CTL_143_DATA 0x00011d1d // RDLVL_GATE_DELAY_F1_3:RW:16:16:=0x0001 RDLVL_DELAY_F1_3:RW:0:16:=0x1d1d
+#define              DENALI_CTL_144_DATA 0x00000000 // RDLVL_END_DELAY_4:RD:16:16:=0x0000 RDLVL_BEGIN_DELAY_4:RD:0:16:=0x0000
+#define              DENALI_CTL_145_DATA 0x00000000 // RDLVL_OFFSET_DELAY_4:RW:16:16:=0x0000 RDLVL_MIDPOINT_DELAY_4:RD:0:16:=0x0000
+#define              DENALI_CTL_146_DATA 0x001d1d00 // RDLVL_DELAY_F0_4:RW:8:16:=0x1d1d RDLVL_OFFSET_DIR_4:RW:0:1:=0x00
+#define              DENALI_CTL_147_DATA 0x1d1d0001 // RDLVL_DELAY_F1_4:RW:16:16:=0x1d1d RDLVL_GATE_DELAY_F0_4:RW:0:16:=0x0001
+#define              DENALI_CTL_148_DATA 0x00000001 // RDLVL_GATE_DELAY_F1_4:RW:0:16:=0x0001
+#define              DENALI_CTL_149_DATA 0x00000000 // AXI1_FIFO_TYPE_REG:RW:24:2:=0x00 AXI0_FIFO_TYPE_REG:RW:0:2:=0x00
+#define              DENALI_CTL_150_DATA 0x00000000 // AXI2_FIFO_TYPE_REG:RW:16:2:=0x00
+#define              DENALI_CTL_151_DATA 0x00000000 // WRR_PARAM_VALUE_ERR:RD:24:4:=0x00 WEIGHTED_ROUND_ROBIN_WEIGHT_SHARING:RW:16:1:=0x00 WEIGHTED_ROUND_ROBIN_LATENCY_CONTROL:RW:8:1:=0x00
+#define              DENALI_CTL_152_DATA 0x03030303 // AXI0_PRIORITY3_RELATIVE_PRIORITY:RW:24:4:=0x03 AXI0_PRIORITY2_RELATIVE_PRIORITY:RW:16:4:=0x03 AXI0_PRIORITY1_RELATIVE_PRIORITY:RW:8:4:=0x03 AXI0_PRIORITY0_RELATIVE_PRIORITY:RW:0:4:=0x03
+#define              DENALI_CTL_153_DATA 0x03030303 // AXI0_PRIORITY7_RELATIVE_PRIORITY:RW:24:4:=0x03 AXI0_PRIORITY6_RELATIVE_PRIORITY:RW:16:4:=0x03 AXI0_PRIORITY5_RELATIVE_PRIORITY:RW:8:4:=0x03 AXI0_PRIORITY4_RELATIVE_PRIORITY:RW:0:4:=0x03
+#define              DENALI_CTL_154_DATA 0x00000000 //
+#define              DENALI_CTL_155_DATA 0x00000000 //
+#define              DENALI_CTL_156_DATA 0x02006400 // AXI1_PRIORITY0_RELATIVE_PRIORITY:RW:24:4:=0x02 AXI0_PRIORITY_RELAX:RW:8:10:=0x0064 AXI0_PORT_ORDERING:RW:0:2:=0x00
+#define              DENALI_CTL_157_DATA 0x02020202 // AXI1_PRIORITY4_RELATIVE_PRIORITY:RW:24:4:=0x02 AXI1_PRIORITY3_RELATIVE_PRIORITY:RW:16:4:=0x02 AXI1_PRIORITY2_RELATIVE_PRIORITY:RW:8:4:=0x02 AXI1_PRIORITY1_RELATIVE_PRIORITY:RW:0:4:=0x02
+#define              DENALI_CTL_158_DATA 0x00020202 // AXI1_PRIORITY7_RELATIVE_PRIORITY:RW:16:4:=0x02 AXI1_PRIORITY6_RELATIVE_PRIORITY:RW:8:4:=0x02 AXI1_PRIORITY5_RELATIVE_PRIORITY:RW:0:4:=0x02
+#define              DENALI_CTL_159_DATA 0x00000000 //
+#define              DENALI_CTL_160_DATA 0x01000000 // AXI1_PORT_ORDERING:RW:24:2:=0x01
+#define              DENALI_CTL_161_DATA 0x01010064 // AXI2_PRIORITY1_RELATIVE_PRIORITY:RW:24:4:=0x01 AXI2_PRIORITY0_RELATIVE_PRIORITY:RW:16:4:=0x01 AXI1_PRIORITY_RELAX:RW:0:10:=0x0064
+#define              DENALI_CTL_162_DATA 0x01010101 // AXI2_PRIORITY5_RELATIVE_PRIORITY:RW:24:4:=0x01 AXI2_PRIORITY4_RELATIVE_PRIORITY:RW:16:4:=0x01 AXI2_PRIORITY3_RELATIVE_PRIORITY:RW:8:4:=0x01 AXI2_PRIORITY2_RELATIVE_PRIORITY:RW:0:4:=0x01
+#define              DENALI_CTL_163_DATA 0x00000101 // AXI2_PRIORITY7_RELATIVE_PRIORITY:RW:8:4:=0x01 AXI2_PRIORITY6_RELATIVE_PRIORITY:RW:0:4:=0x01
+#define              DENALI_CTL_164_DATA 0x00000000 //
+#define              DENALI_CTL_165_DATA 0x00020000 // AXI2_PORT_ORDERING:RW:16:2:=0x02
+#define              DENALI_CTL_166_DATA 0x00000064 // MEM_RST_VALID:RD:24:1:=0x00 CKE_STATUS:RD:16:4:=0x00 AXI2_PRIORITY_RELAX:RW:0:10:=0x0064
+#define              DENALI_CTL_167_DATA 0x00000000 // TDFI_PHY_WRLAT:RD:24:6:=0x00 DLL_RST_ADJ_DLY:RW:16:8:=0x00 DLL_RST_DELAY:RW:0:16:=0x0000
+#define              DENALI_CTL_168_DATA 0x000b0b00 // TDFI_RDDATA_EN:RD:24:7:=0x00 TDFI_PHY_RDLAT_F1:RW_D:16:6:=0x0b TDFI_PHY_RDLAT_F0:RW_D:8:6:=0x0b UPDATE_ERROR_STATUS:RD:0:7:=0x00
+#define              DENALI_CTL_169_DATA 0x0c2d0000 // TDFI_CTRLUPD_MAX_F0:RW:16:14:=0x0c2d TDFI_CTRLUPD_MIN:RD:8:4:=0x00 DRAM_CLK_DISABLE:RW:0:4:=0x00
+#define              DENALI_CTL_170_DATA 0x02000200 // TDFI_PHYUPD_TYPE1_F0:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE0_F0:RW:0:16:=0x0200
+#define              DENALI_CTL_171_DATA 0x02000200 // TDFI_PHYUPD_TYPE3_F0:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE2_F0:RW:0:16:=0x0200
+#define              DENALI_CTL_172_DATA 0x00000c2d // TDFI_PHYUPD_RESP_F0:RW:0:14:=0x0c2d
+#define              DENALI_CTL_173_DATA 0x000079c2 // TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x000079c2
+#define              DENALI_CTL_174_DATA 0x0c2d0506 // TDFI_CTRLUPD_MAX_F1:RW:16:14:=0x0c2d WRLAT_ADJ_F0:RW:8:5:=0x05 RDLAT_ADJ_F0:RW:0:6:=0x06
+#define              DENALI_CTL_175_DATA 0x02000200 // TDFI_PHYUPD_TYPE1_F1:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE0_F1:RW:0:16:=0x0200
+#define              DENALI_CTL_176_DATA 0x02000200 // TDFI_PHYUPD_TYPE3_F1:RW:16:16:=0x0200 TDFI_PHYUPD_TYPE2_F1:RW:0:16:=0x0200
+#define              DENALI_CTL_177_DATA 0x00000c2d // TDFI_PHYUPD_RESP_F1:RW:0:14:=0x0c2d
+#define              DENALI_CTL_178_DATA 0x000079c2 // TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x000079c2
+#define              DENALI_CTL_179_DATA 0x02020506 // TDFI_CTRL_DELAY_F1:RW_D:24:4:=0x02 TDFI_CTRL_DELAY_F0:RW_D:16:4:=0x02 WRLAT_ADJ_F1:RW:8:5:=0x05 RDLAT_ADJ_F1:RW:0:6:=0x06
+#define              DENALI_CTL_180_DATA 0x80000100 // DFI_WRLVL_MAX_DELAY:RW:16:16:=0x8000 TDFI_DRAM_CLK_ENABLE:RW:8:4:=0x01 TDFI_DRAM_CLK_DISABLE:RW:0:4:=0x00
+#define              DENALI_CTL_181_DATA 0x04070303 // TDFI_WRLVL_RESPLAT:RW:24:8:=0x04 TDFI_WRLVL_LOAD:RW:16:8:=0x07 TDFI_WRLVL_DLL:RW:8:8:=0x03 TDFI_WRLVL_EN:RW:0:8:=0x03
+#define              DENALI_CTL_182_DATA 0x0000000a // TDFI_WRLVL_WW:RW:0:10:=0x000a
+#define              DENALI_CTL_183_DATA 0x00000000 // TDFI_WRLVL_RESP:RW:0:32:=0x00000000
+#define              DENALI_CTL_184_DATA 0x00000000 // TDFI_WRLVL_MAX:RW:0:32:=0x00000000
+#define              DENALI_CTL_185_DATA 0x0010ffff // RDLVL_GATE_MAX_DELAY:RW:16:16:=0x0010 RDLVL_MAX_DELAY:RW:0:16:=0xffff
+#define              DENALI_CTL_186_DATA 0x00070303 // TDFI_RDLVL_LOAD:RW:16:8:=0x07 TDFI_RDLVL_DLL:RW:8:8:=0x03 TDFI_RDLVL_EN:RW:0:8:=0x03
+#define              DENALI_CTL_187_DATA 0x0000000f // TDFI_RDLVL_RR:RW:0:10:=0x000f
+#define              DENALI_CTL_188_DATA 0x00000000 // TDFI_RDLVL_RESP:RW:0:32:=0x00000000
+#define              DENALI_CTL_189_DATA 0x00000000 // RDLVL_RESP_MASK:RW:0:36:=0x00000000
+#define              DENALI_CTL_190_DATA 0x00000000 // RDLVL_RESP_MASK:RW:0:36:=0x00
+#define              DENALI_CTL_191_DATA 0x00000000 // RDLVL_GATE_RESP_MASK:RW:0:36:=0x00000000
+#define              DENALI_CTL_192_DATA 0x00000000 // RDLVL_GATE_PREAMBLE_CHECK_EN:RW:24:1:=0x00 RDLVL_GATE_EN:RW:16:1:=0x00 RDLVL_EN:RW:8:1:=0x00 RDLVL_GATE_RESP_MASK:RW:0:36:=0x00
+#define              DENALI_CTL_193_DATA 0x00000000 // TDFI_RDLVL_MAX:RW:0:32:=0x00000000
+#define              DENALI_CTL_194_DATA 0x00000204 // RDLVL_GATE_DQ_ZERO_COUNT:RW:8:4:=0x02 RDLVL_DQ_ZERO_COUNT:RW:0:4:=0x04
+#define              DENALI_CTL_195_DATA 0x00000000 // RDLVL_ERROR_STATUS:RD:0:22:=0x000000
+#define              DENALI_CTL_196_DATA 0x00000000 //
+#define              DENALI_CTL_197_DATA 0x00000001 // TDFI_PHY_WRDATA:RW:0:3:=0x01
+#define              DENALI_CTL_198_DATA 0x00000000 // USER_DEF_REG_0:RW:0:32:=0x00000000
+#define              DENALI_CTL_199_DATA 0x00000000 // USER_DEF_REG_1:RW:0:32:=0x00000000
+#define              DENALI_CTL_200_DATA 0x00000000 // USER_DEF_REG_RO_0:RD:0:32:=0x00000000
+#define              DENALI_CTL_201_DATA 0x00000000 // USER_DEF_REG_RO_1:RD:0:32:=0x00000000
+#define              DENALI_CTL_202_DATA 0x00013880 // TINIT_F0:RW:0:24:=0x013880
+#define              DENALI_CTL_203_DATA 0x00013880 // LP_AUTO_MEM_GATE_EN:RW:24:2:=0x00 TINIT_F1:RW:0:24:=0x013880
+#define              DENALI_CTL_204_DATA 0x00000000 // LP_AUTO_PD_IDLE:RW:0:12:=0x0000
+#define              DENALI_CTL_205_DATA 0x00000000 //
+#define              DENALI_CTL_206_DATA 0x02030301 // W2R_DIFFCS_DLY_F0:RW_D:24:3:=0x02 TODTL_2CMD_F1:RW:16:5:=0x03 TODTL_2CMD_F0:RW:8:5:=0x03 RW_SAME_PAGE_EN:RW:0:1:=0x01
+#define              DENALI_CTL_207_DATA 0x00000002 // W2R_DIFFCS_DLY_F1:RW_D:0:3:=0x02
+#define              DENALI_CTL_208_DATA 0x00000000 //
+#define              DENALI_CTL_209_DATA 0x00000000 // OBSOLETE_PLACEHOLDER:RW:0:16:=0x0000
+#define              DENALI_CTL_210_DATA 0x06060000 // TWR_F0:RW:24:6:=0x06 TRCD_F0:RW:16:8:=0x06 RESERVED:RW:8:5:=0x00 RESERVED:RW:0:5:=0x00
+#define              DENALI_CTL_211_DATA 0x00000606 // NO_MEMORY_DM:RW:24:1:=0x00 RESERVED:RW:16:1:=0x00 TWR_F1:RW:8:6:=0x06 TRCD_F1:RW:0:8:=0x06
+#define              DENALI_CTL_212_DATA 0x00000040 // ZQ_INTERVAL:RW:0:32:=0x00000040
+#define              DENALI_CTL_213_DATA 0x00000000 // INT_ACK:WR:0:25:=0x00000000
+#define              DENALI_CTL_214_DATA 0x02010505 // R2R_DIFFCS_DLY_F0:RW_D:24:3:=0x02 ODT_EN:RW:16:1:=0x01 TODTH_RD:RW:8:4:=0x05 TODTH_WR:RW:0:4:=0x05
+#define              DENALI_CTL_215_DATA 0x00000102 // WRLVL_INTERVAL:RW:16:16:=0x0000 LVL_AREF_EN:RW:8:1:=0x01 R2R_DIFFCS_DLY_F1:RW_D:0:3:=0x02
+#define              DENALI_CTL_216_DATA 0x00001c1c // RDLVL_INTERVAL:RW:16:16:=0x0000 TDFI_RDLVL_RESPLAT_F1:RW:8:8:=0x1c TDFI_RDLVL_RESPLAT_F0:RW:0:8:=0x1c
+#define              DENALI_CTL_217_DATA 0x00000000 // RDLVL_GATE_INTERVAL:RW:0:16:=0x0000
diff --git a/board/accton/as4610_30/mt47h128m16/mt47h128m16_800.array b/board/accton/as4610_30/mt47h128m16/mt47h128m16_800.array
new file mode 100644
index 0000000..c9ba89a
--- /dev/null
+++ b/board/accton/as4610_30/mt47h128m16/mt47h128m16_800.array
@@ -0,0 +1,225 @@
+unsigned int ddr_init_tab = { 
+	14, 0x00000001,
+	36, 0x01000000,
+	37, 0x10000000,
+	38, 0x00100400,
+	39, 0x00000400,
+	40, 0x00000100,
+	42, 0x00000001,
+	61, 0x00010100,
+	78, 0x01000200,
+	79, 0x02000040,
+	80, 0x00400100,
+	81, 0x00000200,
+	83, 0x01ffff0a,
+	84, 0x01010101,
+	87, 0x0000010c,
+	88, 0x00010000,
+	112, 0x00000200,
+	116, 0x0d000000,
+	117, 0x00000028,
+	119, 0x00010001,
+	120, 0x00010001,
+	121, 0x00010001,
+	122, 0x00010001,
+	123, 0x00010001,
+	130, 0x00000001,
+	139, 0x00000001,
+	148, 0x00000001,
+	149, 0x00000000,
+	150, 0x00000000,
+	152, 0x03030303,
+	153, 0x03030303,
+	156, 0x02006400,
+	157, 0x02020202,
+	158, 0x00020202,
+	160, 0x01000000,
+	161, 0x01010064,
+	162, 0x01010101,
+	163, 0x00000101,
+	165, 0x00020000,
+	166, 0x00000064,
+	168, 0x000b0b00,
+	170, 0x02000200,
+	171, 0x02000200,
+	175, 0x02000200,
+	176, 0x02000200,
+	180, 0x80000100,
+	181, 0x04070303,
+	182, 0x0000000a,
+	185, 0x0010ffff,
+	187, 0x0000000f,
+	194, 0x00000204,
+	205, 0x00000000,
+	0xffffffff
+};
+
+unsigned int ddr2_init_tab_800[] = { 
+	0, 0x00000400,
+	1, 0x00000000,
+	2, 0x00000000,
+	3, 0x00000050,
+	4, 0x000000c8,
+	5, 0x0c050c02,
+	6, 0x04020405,
+	7, 0x06031016,
+	8, 0x03101604,
+	9, 0x05020306,
+	10, 0x03006d60,
+	11, 0x05020303,
+	12, 0x03006d60,
+	13, 0x01010003,
+	15, 0x000c0c00,
+	16, 0x030000c8,
+	17, 0x00a01212,
+	18, 0x070700a0,
+	19, 0x00000000,
+	20, 0x00004f01,
+	21, 0x004f0c2d,
+	22, 0x00050c2d,
+	23, 0x00000300,
+	24, 0x000a0003,
+	25, 0x0003000a,
+	26, 0x0003000a,
+	27, 0x00c8000a,
+	28, 0x00c80053,
+	29, 0x00000053,
+	30, 0x03000001,
+	31, 0x00030303,
+	32, 0x00000000,
+	33, 0x00000000,
+	34, 0x00000000,
+	35, 0x00000000,
+	41, 0x00000000,
+	43, 0x00000000,
+	44, 0x000a6300,
+	45, 0x00000004,
+	46, 0x00040a63,
+	47, 0x00000000,
+	48, 0x0a630000,
+	49, 0x00000004,
+	50, 0x00040a63,
+	51, 0x00000000,
+	52, 0x0a630000,
+	53, 0x00000004,
+	54, 0x00040a63,
+	55, 0x00000000,
+	56, 0x0a630000,
+	57, 0x00000004,
+	58, 0x00040a63,
+	59, 0x00000000,
+	60, 0x00000000,
+	62, 0x00000000,
+	63, 0x00000000,
+	64, 0x00000000,
+	65, 0x00000000,
+	66, 0x00000000,
+	67, 0x00000000,
+	68, 0x00000000,
+	69, 0x00000000,
+	70, 0x00000000,
+	71, 0x00000000,
+	72, 0x00000000,
+	73, 0x00000000,
+	74, 0x00000000,
+	75, 0x00000000,
+	76, 0x00000000,
+	77, 0x00000000,
+	82, 0x01020001,
+	85, 0x01010101,
+	86, 0x0f000003,
+	89, 0x00000000,
+	90, 0x00000000,
+	91, 0x00000000,
+	92, 0x00000000,
+	93, 0x00000000,
+	94, 0x00000000,
+	95, 0x00000000,
+	96, 0x00000000,
+	97, 0x00000000,
+	98, 0x00000000,
+	99, 0x00000000,
+	100, 0x00000000,
+	101, 0x00000000,
+	102, 0x00000000,
+	103, 0x00000000,
+	104, 0x00000000,
+	105, 0x00000000,
+	106, 0x00000000,
+	107, 0x00000000,
+	108, 0x02020101,
+	109, 0x08080404,
+	110, 0x03020000,
+	111, 0x01000200,
+	113, 0x00000000,
+	114, 0x00000000,
+	115, 0x00000000,
+	118, 0x00000000,
+	124, 0x00000000,
+	125, 0x00000000,
+	126, 0x00000000,
+	127, 0x00000000,
+	128, 0x001d1d00,
+	129, 0x1d1d0001,
+	131, 0x00000000,
+	132, 0x00000000,
+	133, 0x00011d1d,
+	134, 0x00011d1d,
+	135, 0x00000000,
+	136, 0x00000000,
+	137, 0x001d1d00,
+	138, 0x1d1d0001,
+	140, 0x00000000,
+	141, 0x00000000,
+	142, 0x00011d1d,
+	143, 0x00011d1d,
+	144, 0x00000000,
+	145, 0x00000000,
+	146, 0x001d1d00,
+	147, 0x1d1d0001,
+	151, 0x00000000,
+	154, 0x00000000,
+	155, 0x00000000,
+	159, 0x00000000,
+	164, 0x00000000,
+	167, 0x00000000,
+	169, 0x0c2d0000,
+	172, 0x00000c2d,
+	173, 0x000079c2,
+	174, 0x0c2d0506,
+	177, 0x00000c2d,
+	178, 0x000079c2,
+	179, 0x02020506,
+	183, 0x00000000,
+	184, 0x00000000,
+	186, 0x00070303,
+	188, 0x00000000,
+	189, 0x00000000,
+	190, 0x00000000,
+	191, 0x00000000,
+	192, 0x00000000,
+	193, 0x00000000,
+	195, 0x00000000,
+	196, 0x00000000,
+	197, 0x00000000,
+	198, 0x00000000,
+	199, 0x00000000,
+	200, 0x00000000,
+	201, 0x00000000,
+	202, 0x00013880,
+	203, 0x00013880,
+	204, 0x00000000,
+	206, 0x02030301,
+	207, 0x00000002,
+	208, 0x00000000,
+	209, 0x00000000,
+	210, 0x06060000,
+	211, 0x00000606,
+	212, 0x00000040,
+	213, 0x00000000,
+	214, 0x02010505,
+	215, 0x00000102,
+	216, 0x00001c1c,
+	217, 0x00000000,
+	0xffffffff
+};
diff --git a/board/accton/as4610_30/u-boot-nr-be.lds b/board/accton/as4610_30/u-boot-nr-be.lds
new file mode 100644
index 0000000..8171c97
--- /dev/null
+++ b/board/accton/as4610_30/u-boot-nr-be.lds
@@ -0,0 +1,99 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-bigarm", "elf32-bigarm", "elf32-bigarm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x1E000000;
+
+	. = ALIGN(4);
+	.text	:
+	{
+		__image_copy_start = .;
+		arch/arm/cpu/armv7/start.o	(.text)
+		*(.text)
+	}
+
+	.mmu_table : {
+		. = ALIGN(0x10000);
+		*(section_mmu_table)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+	. = ALIGN(4);
+	__data_start_load = .;
+	.data 0x90003000 :
+	  AT ( __data_start_load )
+	{
+		__data_start = .;
+		*(.data)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+
+	__image_copy_end = .;
+
+	.rel.dyn : {
+		__rel_dyn_start = .;
+		*(.rel*)
+		__rel_dyn_end = .;
+	}
+
+	.dynsym : {
+		__dynsym_start = .;
+		*(.dynsym)
+	}
+
+	.bss __rel_dyn_start (OVERLAY) : {
+		__bss_start = .;
+		*(.bss)
+		 . = ALIGN(4);
+		__bss_end__ = .;
+        _end = .;
+	}
+
+	.irqstack : {
+		__irqstack_end = .;
+		. = . + 0x2008;
+		__irqstack_start = .;
+	}
+
+	/DISCARD/ : { *(.dynstr*) }
+	/DISCARD/ : { *(.dynamic*) }
+	/DISCARD/ : { *(.plt*) }
+	/DISCARD/ : { *(.interp*) }
+	/DISCARD/ : { *(.gnu*) }
+}
diff --git a/board/accton/as4610_30/u-boot-nr.lds b/board/accton/as4610_30/u-boot-nr.lds
new file mode 100644
index 0000000..d817bc0
--- /dev/null
+++ b/board/accton/as4610_30/u-boot-nr.lds
@@ -0,0 +1,99 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x1E000000;
+
+	. = ALIGN(4);
+	.text	:
+	{
+		__image_copy_start = .;
+		arch/arm/cpu/armv7/start.o	(.text)
+		*(.text)
+	}
+
+	.mmu_table : {
+		. = ALIGN(0x10000);
+		*(section_mmu_table)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+	. = ALIGN(4);
+	__data_start_load = .;
+	.data 0x90003000 :
+	  AT ( __data_start_load )
+	{
+		__data_start = .;
+		*(.data)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+
+	__image_copy_end = .;
+
+	.rel.dyn : {
+		__rel_dyn_start = .;
+		*(.rel*)
+		__rel_dyn_end = .;
+	}
+
+	.dynsym : {
+		__dynsym_start = .;
+		*(.dynsym)
+	}
+
+	.bss __rel_dyn_start (OVERLAY) : {
+		__bss_start = .;
+		*(.bss)
+		 . = ALIGN(4);
+		__bss_end__ = .;
+        _end = .;
+	}
+
+	.irqstack : {
+		__irqstack_end = .;
+		. = . + 0x2008;
+		__irqstack_start = .;
+	}
+
+	/DISCARD/ : { *(.dynstr*) }
+	/DISCARD/ : { *(.dynamic*) }
+	/DISCARD/ : { *(.plt*) }
+	/DISCARD/ : { *(.interp*) }
+	/DISCARD/ : { *(.gnu*) }
+}
diff --git a/board/accton/as4610_30/usb.c b/board/accton/as4610_30/usb.c
new file mode 100644
index 0000000..c1f6d26
--- /dev/null
+++ b/board/accton/as4610_30/usb.c
@@ -0,0 +1,78 @@
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <usb.h>
+#include <i2c.h>
+#include <part.h>
+
+static int do_usbiddev(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int devno;
+	int target = -1;
+	block_dev_desc_t *blk_dev;
+	char val[2];
+
+	/*
+	 * The internal USB NAND flash drive is connected to the
+	 * internal hub such that the NAND device always appears as
+	 * the *last* mass storage device.
+	 *
+	 * Sure this is dependent on the depth-first USB topology
+	 * enumeration strategy, but that is not going to change.
+	 */
+	for (devno = 0; ; ++devno) {
+		blk_dev = usb_stor_get_dev(devno);
+		if (blk_dev == NULL)
+			break;
+		if ( (blk_dev->if_type == IF_TYPE_USB) &&
+		     !blk_dev->removable &&
+		     ((blk_dev->type & 0x1F) == DEV_TYPE_HARDDISK) ) {
+			target = devno;
+		}
+	}
+
+	if (target == -1) {
+		printf("Error: Unable to detect internal USB flash device.\n");
+		printf("Perhaps you forgot to run 'usb start' ?\n");
+		return 1;
+	}
+
+	if (target > 9) {
+		printf("Error: Unexpectedly large device number: %d.\n", target);
+		return 1;
+	}
+
+	val[0] = '0' + target;
+	val[1] = 0;
+
+	setenv("usbdev", val);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	usbiddev,	3,	1,	do_usbiddev,
+	"Identify internal USB NAND flash device number and set\n"
+	"environment variable 'usbdev' to that number.",
+	""
+);
diff --git a/boards.cfg b/boards.cfg
index 368f3c4..02c65be 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -291,6 +291,7 @@ bcm95301x_svk_iproc_ddr775   arm         armv7       bcm95301x           broadco
 bcm95301x_svk_iproc_ddr775_rw_eye   arm         armv7       bcm95301x           broadcom       northstar         bcm95301x_svk:L2C_AS_RAM,CUSTOM_LINKER_SCRIPT,RUN_DDR_SHMOO,DDR775,MDE_BUILD_RW_EYE
 bcm95301x_svk_iproc_ddr775_rw_eye_pwm   arm         armv7       bcm95301x           broadcom       northstar         bcm95301x_svk:L2C_AS_RAM,CUSTOM_LINKER_SCRIPT,RUN_DDR_SHMOO,DDR775,MDE_BUILD_RW_EYE,PWM0_FOR_FAN
 bcm95301x_svk_l2cram         arm         armv7       bcm95301x           broadcom       northstar         bcm95301x_svk:L2C_AS_RAM,CUSTOM_LINKER_SCRIPT,RUN_DDR_SHMOO
+AS4610_30                   arm         armv7       as4610_30          accton         helix4            AS4610_30:ONIE_PLATFORM_REV=0
 helix4_emul                  arm         armv7       bcm95634x           broadcom       helix4 
 helix4                       arm         armv7       bcm95634x           broadcom       helix4            helix4:RUN_DDR_SHMOO2,IPROC_DDR_ECC 
 helix4_nand                  arm         armv7       bcm95634x           broadcom       helix4            helix4:RUN_DDR_SHMOO2,NAND_IPROC_BOOT,IPROC_SPL
diff --git a/broadcom_boards.mk b/broadcom_boards.mk
index 60b2ecf..4f34589 100644
--- a/broadcom_boards.mk
+++ b/broadcom_boards.mk
@@ -87,6 +87,10 @@ helix4_emul_config: $(obj)helix4_emul_config
 $(obj)helix4_emul_config: $(TOPDIR)/include/configs/helix4_emul.h  
 	@$(MKCONFIG) -A $(@F:_config=); touch $@
 
+AS4610_30_config: $(obj)AS4610_30_config 
+$(obj)AS4610_30_config: $(TOPDIR)/include/configs/AS4610_30.h  
+	@$(MKCONFIG) -A $(@F:_config=); touch $@
+
 helix4_config: $(obj)helix4_config 
 $(obj)helix4_config: $(TOPDIR)/include/configs/helix4.h  
 	@$(MKCONFIG) -A $(@F:_config=); touch $@
diff --git a/common/Makefile b/common/Makefile
index 350491d..6aab9f7 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -202,6 +202,7 @@ COBJS-$(CONFIG_MODEM_SUPPORT) += modem.o
 COBJS-$(CONFIG_UPDATE_TFTP) += update.o
 COBJS-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
 COBJS-$(CONFIG_CMD_DFU) += cmd_dfu.o
+COBJS-$(CONFIG_CMD_GPT) += cmd_gpt.o
 endif
 
 ifdef CONFIG_SPL_BUILD
@@ -239,6 +240,11 @@ $(obj)env_embedded.o: $(src)env_embedded.c $(obj)../tools/envcrc
 $(obj)../tools/envcrc:
 	$(MAKE) -C ../tools
 
+# SEE README.arm-unaligned-accesses
+# $(obj)hush.o: CFLAGS += $(PLATFORM_NO_UNALIGNED)
+# $(obj)fdt_support.o: CFLAGS += $(PLATFORM_NO_UNALIGNED)
+# $(obj)cmd_sys_eeprom.o: CFLAGS += $(PLATFORM_NO_UNALIGNED)
+
 #########################################################################
 
 # defines $(obj).depend target
diff --git a/common/cmd_gpt.c b/common/cmd_gpt.c
new file mode 100644
index 0000000..1f12e6d
--- /dev/null
+++ b/common/cmd_gpt.c
@@ -0,0 +1,316 @@
+/*
+ * cmd_gpt.c -- GPT (GUID Partition Table) handling command
+ *
+ * Copyright (C) 2012 Samsung Electronics
+ * author: Lukasz Majewski <l.majewski@samsung.com>
+ * author: Piotr Wilczek <p.wilczek@samsung.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <command.h>
+#include <part_efi.h>
+#include <exports.h>
+#include <linux/ctype.h>
+#include <div64.h>
+
+#ifndef CONFIG_PARTITION_UUIDS
+#error CONFIG_PARTITION_UUIDS must be enabled for CONFIG_CMD_GPT to be enabled
+#endif
+
+/**
+ * extract_env(): Expand env name from string format '&{env_name}'
+ *                and return pointer to the env (if the env is set)
+ *
+ * @param str - pointer to string
+ * @param env - pointer to pointer to extracted env
+ *
+ * @return - zero on successful expand and env is set
+ */
+static char extract_env(const char *str, char **env)
+{
+	char *e, *s;
+
+	if (!str || strlen(str) < 4)
+		return -1;
+
+	if ((strncmp(str, "${", 2) == 0) && (str[strlen(str) - 1] == '}')) {
+		s = strdup(str);
+		if (s == NULL)
+			return -1;
+		memset(s + strlen(s) - 1, '\0', 1);
+		memmove(s, s + 2, strlen(s) - 1);
+		e = getenv(s);
+		free(s);
+		if (e == NULL) {
+			printf("Environmental '%s' not set\n", str);
+			return -1; /* env not set */
+		}
+		*env = e;
+		return 0;
+	}
+
+	return -1;
+}
+
+/**
+ * extract_val(): Extract value from a key=value pair list (comma separated).
+ *                Only value for the given key is returend.
+ *                Function allocates memory for the value, remember to free!
+ *
+ * @param str - pointer to string with key=values pairs
+ * @param key - pointer to the key to search for
+ *
+ * @return - pointer to allocated string with the value
+ */
+static char *extract_val(const char *str, const char *key)
+{
+	char *v, *k;
+	char *s, *strcopy;
+	char *new = NULL;
+
+	strcopy = strdup(str);
+	if (strcopy == NULL)
+		return NULL;
+
+	s = strcopy;
+	while (s) {
+		v = strsep(&s, ",");
+		if (!v)
+			break;
+		k = strsep(&v, "=");
+		if (!k)
+			break;
+		if  (strcmp(k, key) == 0) {
+			new = strdup(v);
+			break;
+		}
+	}
+
+	free(strcopy);
+
+	return new;
+}
+
+/**
+ * set_gpt_info(): Fill partition information from string
+ *		function allocates memory, remember to free!
+ *
+ * @param dev_desc - pointer block device descriptor
+ * @param str_part - pointer to string with partition information
+ * @param str_disk_guid - pointer to pointer to allocated string with disk guid
+ * @param partitions - pointer to pointer to allocated partitions array
+ * @param parts_count - number of partitions
+ *
+ * @return - zero on success, otherwise error
+ *
+ */
+static int set_gpt_info(block_dev_desc_t *dev_desc,
+			const char *str_part,
+			char **str_disk_guid,
+			disk_partition_t **partitions,
+			u8 *parts_count)
+{
+	char *tok, *str, *s;
+	int i;
+	char *val, *p;
+	int p_count;
+	disk_partition_t *parts;
+	int errno = 0;
+	uint64_t size_ll, start_ll;
+
+	debug("%s:  lba num: 0x%x %d\n", __func__,
+	      (unsigned int)dev_desc->lba, (unsigned int)dev_desc->lba);
+
+	if (str_part == NULL)
+		return -1;
+
+	str = strdup(str_part);
+
+	/* extract disk guid */
+	s = str;
+	tok = strsep(&s, ";");
+	val = extract_val(tok, "uuid_disk");
+	if (!val) {
+		free(str);
+		return -2;
+	}
+	if (extract_env(val, &p))
+		p = val;
+	*str_disk_guid = strdup(p);
+	free(val);
+
+	if (strlen(s) == 0)
+		return -3;
+
+	i = strlen(s) - 1;
+	if (s[i] == ';')
+		s[i] = '\0';
+
+	/* calculate expected number of partitions */
+	p_count = 1;
+	p = s;
+	while (*p) {
+		if (*p++ == ';')
+			p_count++;
+	}
+
+	/* allocate memory for partitions */
+	parts = calloc(sizeof(disk_partition_t), p_count);
+
+	/* retrieve partitions data from string */
+	for (i = 0; i < p_count; i++) {
+		tok = strsep(&s, ";");
+
+		if (tok == NULL)
+			break;
+
+		/* uuid */
+		val = extract_val(tok, "uuid");
+		if (!val) { /* 'uuid' is mandatory */
+			errno = -4;
+			goto err;
+		}
+		if (extract_env(val, &p))
+			p = val;
+		if (strlen(p) >= sizeof(parts[i].uuid)) {
+			printf("Wrong uuid format for partition %d\n", i);
+			errno = -4;
+			goto err;
+		}
+		strcpy((char *)parts[i].uuid, p);
+		free(val);
+
+		/* name */
+		val = extract_val(tok, "name");
+		if (!val) { /* name is mandatory */
+			errno = -4;
+			goto err;
+		}
+		if (extract_env(val, &p))
+			p = val;
+		if (strlen(p) >= sizeof(parts[i].name)) {
+			errno = -4;
+			goto err;
+		}
+		strcpy((char *)parts[i].name, p);
+		free(val);
+
+		/* size */
+		val = extract_val(tok, "size");
+		if (!val) { /* 'size' is mandatory */
+			errno = -4;
+			goto err;
+		}
+		if (extract_env(val, &p))
+			p = val;
+		size_ll = ustrtoull(p, &p, 0);
+		parts[i].size = lldiv(size_ll, dev_desc->blksz);
+		free(val);
+
+		/* start address */
+		val = extract_val(tok, "start");
+		if (val) { /* start address is optional */
+			if (extract_env(val, &p))
+				p = val;
+			start_ll = ustrtoull(p, &p, 0);
+			parts[i].start = lldiv(start_ll, dev_desc->blksz);
+			free(val);
+		}
+	}
+
+	*parts_count = p_count;
+	*partitions = parts;
+	free(str);
+
+	return 0;
+err:
+	free(str);
+	free(*str_disk_guid);
+	free(parts);
+
+	return errno;
+}
+
+static int gpt_default(block_dev_desc_t *blk_dev_desc, const char *str_part)
+{
+	int ret;
+	char *str_disk_guid;
+	u8 part_count = 0;
+	disk_partition_t *partitions = NULL;
+
+	if (!str_part)
+		return -1;
+
+	/* fill partitions */
+	ret = set_gpt_info(blk_dev_desc, str_part,
+			&str_disk_guid, &partitions, &part_count);
+	if (ret) {
+		if (ret == -1)
+			printf("No partition list provided\n");
+		if (ret == -2)
+			printf("Missing disk guid\n");
+		if ((ret == -3) || (ret == -4))
+			printf("Partition list incomplete\n");
+		return -1;
+	}
+
+	/* save partitions layout to disk */
+	gpt_restore(blk_dev_desc, str_disk_guid, partitions, part_count);
+	free(str_disk_guid);
+	free(partitions);
+
+	return 0;
+}
+
+/**
+ * do_gpt(): Perform GPT operations
+ *
+ * @param cmdtp - command name
+ * @param flag
+ * @param argc
+ * @param argv
+ *
+ * @return zero on success; otherwise error
+ */
+static int do_gpt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = CMD_RET_SUCCESS;
+	int dev = 0;
+	char *ep;
+	block_dev_desc_t *blk_dev_desc;
+
+	if (argc < 5)
+		return CMD_RET_USAGE;
+
+	/* command: 'write' */
+	if ((strcmp(argv[1], "write") == 0) && (argc == 5)) {
+		dev = (int)simple_strtoul(argv[3], &ep, 10);
+		if (!ep || ep[0] != '\0') {
+			printf("'%s' is not a number\n", argv[3]);
+			return CMD_RET_USAGE;
+		}
+		blk_dev_desc = get_dev(argv[2], dev);
+		if (!blk_dev_desc) {
+			printf("%s: %s dev %d NOT available\n",
+			       __func__, argv[2], dev);
+			return CMD_RET_FAILURE;
+		}
+
+		if (gpt_default(blk_dev_desc, argv[4]))
+			return CMD_RET_FAILURE;
+	} else {
+		return CMD_RET_USAGE;
+	}
+	return ret;
+}
+
+U_BOOT_CMD(gpt, CONFIG_SYS_MAXARGS, 1, do_gpt,
+	"GUID Partition Table",
+	"<command> <interface> <dev> <partitions_list>\n"
+	" - GUID partition table restoration\n"
+	" Restore GPT information on a device connected\n"
+	" to interface\n"
+);
diff --git a/common/usb_storage.c b/common/usb_storage.c
index 11e2f7a..cf3f9ae 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -1054,7 +1054,7 @@ static void usb_bin_fixup(struct usb_device_descriptor descriptor,
 }
 #endif /* CONFIG_USB_BIN_FIXUP */
 //#define USB_MAX_READ_BLK 20
-#define USB_MAX_READ_BLK 4
+#define USB_MAX_READ_BLK 4095
 unsigned long usb_stor_read(int device, unsigned long blknr,
 			    unsigned long blkcnt, void *buffer)
 {
diff --git a/disk/part_efi.c b/disk/part_efi.c
index 264ea9c..7665017 100644
--- a/disk/part_efi.c
+++ b/disk/part_efi.c
@@ -34,9 +34,11 @@
 #include <command.h>
 #include <ide.h>
 #include <malloc.h>
-#include "part_efi.h"
+#include <part_efi.h>
 #include <linux/ctype.h>
 
+DECLARE_GLOBAL_DATA_PTR;
+
 #if defined(CONFIG_CMD_IDE) || \
     defined(CONFIG_CMD_SATA) || \
     defined(CONFIG_CMD_SCSI) || \
@@ -44,34 +46,6 @@
     defined(CONFIG_MMC) || \
     defined(CONFIG_SYSTEMACE)
 
-/* Convert char[2] in little endian format to the host format integer
- */
-static inline unsigned short le16_to_int(unsigned char *le16)
-{
-	return ((le16[1] << 8) + le16[0]);
-}
-
-/* Convert char[4] in little endian format to the host format integer
- */
-static inline unsigned long le32_to_int(unsigned char *le32)
-{
-	return ((le32[3] << 24) + (le32[2] << 16) + (le32[1] << 8) + le32[0]);
-}
-
-/* Convert char[8] in little endian format to the host format integer
- */
-static inline unsigned long long le64_to_int(unsigned char *le64)
-{
-	return (((unsigned long long)le64[7] << 56) +
-		((unsigned long long)le64[6] << 48) +
-		((unsigned long long)le64[5] << 40) +
-		((unsigned long long)le64[4] << 32) +
-		((unsigned long long)le64[3] << 24) +
-		((unsigned long long)le64[2] << 16) +
-		((unsigned long long)le64[1] << 8) +
-		(unsigned long long)le64[0]);
-}
-
 /**
  * efi_crc32() - EFI version of crc32 function
  * @buf: buffer to calculate crc32 of
@@ -79,7 +53,7 @@ static inline unsigned long long le64_to_int(unsigned char *le64)
  *
  * Description: Returns EFI-style CRC32 value for @buf
  */
-static inline unsigned long efi_crc32(const void *buf, unsigned long len)
+static inline u32 efi_crc32(const void *buf, u32 len)
 {
 	return crc32(0, buf, len);
 }
@@ -90,13 +64,10 @@ static inline unsigned long efi_crc32(const void *buf, unsigned long len)
 
 static int pmbr_part_valid(struct partition *part);
 static int is_pmbr_valid(legacy_mbr * mbr);
-
 static int is_gpt_valid(block_dev_desc_t * dev_desc, unsigned long long lba,
 				gpt_header * pgpt_head, gpt_entry ** pgpt_pte);
-
 static gpt_entry *alloc_read_gpt_entries(block_dev_desc_t * dev_desc,
 				gpt_header * pgpt_head);
-
 static int is_pte_valid(gpt_entry * pte);
 
 static char *print_efiname(gpt_entry *pte)
@@ -113,6 +84,36 @@ static char *print_efiname(gpt_entry *pte)
 	return name;
 }
 
+static void uuid_string(unsigned char *uuid, char *str)
+{
+	static const u8 le[16] = {3, 2, 1, 0, 5, 4, 7, 6, 8, 9, 10, 11,
+				  12, 13, 14, 15};
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		sprintf(str, "%02x", uuid[le[i]]);
+		str += 2;
+		switch (i) {
+		case 3:
+		case 5:
+		case 7:
+		case 9:
+			*str++ = '-';
+			break;
+		}
+	}
+}
+
+static efi_guid_t system_guid = PARTITION_SYSTEM_GUID;
+
+static inline int is_bootable(gpt_entry *p)
+{
+	return p->attributes.fields.legacy_bios_bootable ||
+		!memcmp(&(p->partition_type_guid), &system_guid,
+			sizeof(efi_guid_t));
+}
+
+#ifdef CONFIG_EFI_PARTITION
 /*
  * Public Functions (include/part.h)
  */
@@ -122,6 +123,7 @@ void print_part_efi(block_dev_desc_t * dev_desc)
 	ALLOC_CACHE_ALIGN_BUFFER(gpt_header, gpt_head, 1);
 	gpt_entry *gpt_pte = NULL;
 	int i = 0;
+	char uuid[37];
 
 	if (!dev_desc) {
 		printf("%s: Invalid Argument(s)\n", __func__);
@@ -136,17 +138,25 @@ void print_part_efi(block_dev_desc_t * dev_desc)
 
 	debug("%s: gpt-entry at %p\n", __func__, gpt_pte);
 
-	printf("Part\tName\t\t\tStart LBA\tEnd LBA\n");
-	for (i = 0; i < le32_to_int(gpt_head->num_partition_entries); i++) {
+	printf("Part\tStart LBA\tEnd LBA\t\tName\n");
+	printf("\tAttributes\n");
+	printf("\tType UUID\n");
+	printf("\tPartition UUID\n");
 
-		if (is_pte_valid(&gpt_pte[i])) {
-			printf("%3d\t%-18s\t0x%08llX\t0x%08llX\n", (i + 1),
-				print_efiname(&gpt_pte[i]),
-				le64_to_int(gpt_pte[i].starting_lba),
-				le64_to_int(gpt_pte[i].ending_lba));
-		} else {
-			break;	/* Stop at the first non valid PTE */
-		}
+	for (i = 0; i < le32_to_cpu(gpt_head->num_partition_entries); i++) {
+		/* Stop at the first non valid PTE */
+		if (!is_pte_valid(&gpt_pte[i]))
+			break;
+
+		printf("%3d\t0x%08llx\t0x%08llx\t\"%s\"\n", (i + 1),
+			le64_to_cpu(gpt_pte[i].starting_lba),
+			le64_to_cpu(gpt_pte[i].ending_lba),
+			print_efiname(&gpt_pte[i]));
+		printf("\tattrs:\t0x%016llx\n", gpt_pte[i].attributes.raw);
+		uuid_string(gpt_pte[i].partition_type_guid.b, uuid);
+		printf("\ttype:\t%s\n", uuid);
+		uuid_string(gpt_pte[i].unique_partition_guid.b, uuid);
+		printf("\tuuid:\t%s\n", uuid);
 	}
 
 	/* Remember to free pte */
@@ -154,28 +164,6 @@ void print_part_efi(block_dev_desc_t * dev_desc)
 	return;
 }
 
-#ifdef CONFIG_PARTITION_UUIDS
-static void uuid_string(unsigned char *uuid, char *str)
-{
-	static const u8 le[16] = {3, 2, 1, 0, 5, 4, 7, 6, 8, 9, 10, 11,
-				  12, 13, 14, 15};
-	int i;
-
-	for (i = 0; i < 16; i++) {
-		sprintf(str, "%02x", uuid[le[i]]);
-		str += 2;
-		switch (i) {
-		case 3:
-		case 5:
-		case 7:
-		case 9:
-			*str++ = '-';
-			break;
-		}
-	}
-}
-#endif
-
 int get_partition_info_efi(block_dev_desc_t * dev_desc, int part,
 				disk_partition_t * info)
 {
@@ -195,7 +183,7 @@ int get_partition_info_efi(block_dev_desc_t * dev_desc, int part,
 		return -1;
 	}
 
-	if (part > le32_to_int(gpt_head->num_partition_entries) ||
+	if (part > le32_to_cpu(gpt_head->num_partition_entries) ||
 	    !is_pte_valid(&gpt_pte[part - 1])) {
 		printf("%s: *** ERROR: Invalid partition number %d ***\n",
 			__func__, part);
@@ -203,15 +191,16 @@ int get_partition_info_efi(block_dev_desc_t * dev_desc, int part,
 	}
 
 	/* The ulong casting limits the maximum disk size to 2 TB */
-	info->start = (ulong) le64_to_int(gpt_pte[part - 1].starting_lba);
+	info->start = (u64)le64_to_cpu(gpt_pte[part - 1].starting_lba);
 	/* The ending LBA is inclusive, to calculate size, add 1 to it */
-	info->size = ((ulong)le64_to_int(gpt_pte[part - 1].ending_lba) + 1)
+	info->size = ((u64)le64_to_cpu(gpt_pte[part - 1].ending_lba) + 1)
 		     - info->start;
 	info->blksz = GPT_BLOCK_SIZE;
 
 	sprintf((char *)info->name, "%s",
 			print_efiname(&gpt_pte[part - 1]));
 	sprintf((char *)info->type, "U-Boot");
+	info->bootable = is_bootable(&gpt_pte[part - 1]);
 #ifdef CONFIG_PARTITION_UUIDS
 	uuid_string(gpt_pte[part - 1].unique_partition_guid.b, info->uuid);
 #endif
@@ -236,6 +225,281 @@ int test_part_efi(block_dev_desc_t * dev_desc)
 	return 0;
 }
 
+/**
+ * set_protective_mbr(): Set the EFI protective MBR
+ * @param dev_desc - block device descriptor
+ *
+ * @return - zero on success, otherwise error
+ */
+static int set_protective_mbr(block_dev_desc_t *dev_desc)
+{
+	legacy_mbr *p_mbr;
+
+	/* Setup the Protective MBR */
+	p_mbr = calloc(1, sizeof(p_mbr));
+	if (p_mbr == NULL) {
+		printf("%s: calloc failed!\n", __func__);
+		return -1;
+	}
+	/* Append signature */
+	p_mbr->signature = MSDOS_MBR_SIGNATURE;
+	p_mbr->partition_record[0].sys_ind = EFI_PMBR_OSTYPE_EFI_GPT;
+	p_mbr->partition_record[0].start_sect = 1;
+	p_mbr->partition_record[0].nr_sects = (u32) dev_desc->lba;
+
+	/* Write MBR sector to the MMC device */
+	if (dev_desc->block_write(dev_desc->dev, 0, 1, p_mbr) != 1) {
+		printf("** Can't write to device %d **\n",
+			dev_desc->dev);
+		free(p_mbr);
+		return -1;
+	}
+
+	free(p_mbr);
+	return 0;
+}
+
+/**
+ * string_uuid(); Convert UUID stored as string to bytes
+ *
+ * @param uuid - UUID represented as string
+ * @param dst - GUID buffer
+ *
+ * @return return 0 on successful conversion
+ */
+static int string_uuid(char *uuid, u8 *dst)
+{
+	efi_guid_t guid;
+	u16 b, c, d;
+	u64 e;
+	u32 a;
+	u8 *p;
+	u8 i;
+
+	const u8 uuid_str_len = 36;
+
+	/* The UUID is written in text: */
+	/* 1        9    14   19   24 */
+	/* xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx */
+
+	debug("%s: uuid: %s\n", __func__, uuid);
+
+	if (strlen(uuid) != uuid_str_len)
+		return -1;
+
+	for (i = 0; i < uuid_str_len; i++) {
+		if ((i == 8) || (i == 13) || (i == 18) || (i == 23)) {
+			if (uuid[i] != '-')
+				return -1;
+		} else {
+			if (!isxdigit(uuid[i]))
+				return -1;
+		}
+	}
+
+	a = (u32)simple_strtoul(uuid, NULL, 16);
+	b = (u16)simple_strtoul(uuid + 9, NULL, 16);
+	c = (u16)simple_strtoul(uuid + 14, NULL, 16);
+	d = (u16)simple_strtoul(uuid + 19, NULL, 16);
+	e = (u64)simple_strtoull(uuid + 24, NULL, 16);
+
+	p = (u8 *) &e;
+	guid = EFI_GUID(a, b, c, d >> 8, d & 0xFF,
+			*(p + 5), *(p + 4), *(p + 3),
+			*(p + 2), *(p + 1) , *p);
+
+	memcpy(dst, guid.b, sizeof(efi_guid_t));
+
+	return 0;
+}
+
+int write_gpt_table(block_dev_desc_t *dev_desc,
+		gpt_header *gpt_h, gpt_entry *gpt_e)
+{
+	const int pte_blk_num = (gpt_h->num_partition_entries
+		* sizeof(gpt_entry)) / dev_desc->blksz;
+
+	u32 calc_crc32;
+	u64 val;
+
+	debug("max lba: %x\n", (u32) dev_desc->lba);
+	/* Setup the Protective MBR */
+	if (set_protective_mbr(dev_desc) < 0)
+		goto err;
+
+	/* Generate CRC for the Primary GPT Header */
+	calc_crc32 = efi_crc32((const unsigned char *)gpt_e,
+			      le32_to_cpu(gpt_h->num_partition_entries) *
+			      le32_to_cpu(gpt_h->sizeof_partition_entry));
+	gpt_h->partition_entry_array_crc32 = cpu_to_le32(calc_crc32);
+
+	calc_crc32 = efi_crc32((const unsigned char *)gpt_h,
+			      le32_to_cpu(gpt_h->header_size));
+	gpt_h->header_crc32 = cpu_to_le32(calc_crc32);
+
+	/* Write the First GPT to the block right after the Legacy MBR */
+	if (dev_desc->block_write(dev_desc->dev, 1, 1, gpt_h) != 1)
+		goto err;
+
+	if (dev_desc->block_write(dev_desc->dev, 2, pte_blk_num, gpt_e)
+	    != pte_blk_num)
+		goto err;
+
+	/* recalculate the values for the Second GPT Header */
+	val = le64_to_cpu(gpt_h->my_lba);
+	gpt_h->my_lba = gpt_h->alternate_lba;
+	gpt_h->alternate_lba = cpu_to_le64(val);
+	gpt_h->header_crc32 = 0;
+
+	calc_crc32 = efi_crc32((const unsigned char *)gpt_h,
+			      le32_to_cpu(gpt_h->header_size));
+	gpt_h->header_crc32 = cpu_to_le32(calc_crc32);
+
+	if (dev_desc->block_write(dev_desc->dev,
+				  le32_to_cpu(gpt_h->last_usable_lba + 1),
+				  pte_blk_num, gpt_e) != pte_blk_num)
+		goto err;
+
+	if (dev_desc->block_write(dev_desc->dev,
+				  le32_to_cpu(gpt_h->my_lba), 1, gpt_h) != 1)
+		goto err;
+
+	debug("GPT successfully written to block device!\n");
+	return 0;
+
+ err:
+	printf("** Can't write to device %d **\n", dev_desc->dev);
+	return -1;
+}
+
+int gpt_fill_pte(gpt_header *gpt_h, gpt_entry *gpt_e,
+		disk_partition_t *partitions, int parts)
+{
+	u32 offset = (u32)le32_to_cpu(gpt_h->first_usable_lba);
+	ulong start;
+	int i, k;
+	size_t name_len;
+#ifdef CONFIG_PARTITION_UUIDS
+	char *str_uuid;
+#endif
+
+	for (i = 0; i < parts; i++) {
+		/* partition starting lba */
+		start = partitions[i].start;
+		if (start && (start < offset)) {
+			printf("Partition overlap\n");
+			return -1;
+		}
+		if (start) {
+			gpt_e[i].starting_lba = cpu_to_le64(start);
+			offset = start + partitions[i].size;
+		} else {
+			gpt_e[i].starting_lba = cpu_to_le64(offset);
+			offset += partitions[i].size;
+		}
+		if (offset >= gpt_h->last_usable_lba) {
+			printf("Partitions layout exceds disk size\n");
+			return -1;
+		}
+		/* partition ending lba */
+		if ((i == parts - 1) && (partitions[i].size == 0))
+			/* extend the last partition to maximuim */
+			gpt_e[i].ending_lba = gpt_h->last_usable_lba;
+		else
+			gpt_e[i].ending_lba = cpu_to_le64(offset - 1);
+
+		/* partition type GUID */
+		memcpy(gpt_e[i].partition_type_guid.b,
+			&PARTITION_BASIC_DATA_GUID, 16);
+
+#ifdef CONFIG_PARTITION_UUIDS
+		str_uuid = partitions[i].uuid;
+		if (string_uuid(str_uuid, gpt_e[i].unique_partition_guid.b)) {
+			printf("Partition no. %d: invalid guid: %s\n",
+				i, str_uuid);
+			return -1;
+		}
+#endif
+
+		/* partition attributes */
+		memset(&gpt_e[i].attributes, 0,
+		       sizeof(gpt_entry_attributes));
+
+		/* partition name */
+		name_len = sizeof(gpt_e[i].partition_name)
+			/ sizeof(efi_char16_t);
+		for (k = 0; k < name_len; k++)
+			gpt_e[i].partition_name[k] =
+				(efi_char16_t)(partitions[i].name[k]);
+
+		debug("%s: name: %s offset[%d]: 0x%x size[%d]: 0x%lx\n",
+		      __func__, partitions[i].name, i,
+		      offset, i, partitions[i].size);
+	}
+
+	return 0;
+}
+
+int gpt_fill_header(block_dev_desc_t *dev_desc, gpt_header *gpt_h,
+		char *str_guid, int parts_count)
+{
+	gpt_h->signature = cpu_to_le64(GPT_HEADER_SIGNATURE);
+	gpt_h->revision = cpu_to_le32(GPT_HEADER_REVISION_V1);
+	gpt_h->header_size = cpu_to_le32(sizeof(gpt_header));
+	gpt_h->my_lba = cpu_to_le64(1);
+	gpt_h->alternate_lba = cpu_to_le64(dev_desc->lba - 1);
+	gpt_h->first_usable_lba = cpu_to_le64(34);
+	gpt_h->last_usable_lba = cpu_to_le64(dev_desc->lba - 34);
+	gpt_h->partition_entry_lba = cpu_to_le64(2);
+	gpt_h->num_partition_entries = cpu_to_le32(GPT_ENTRY_NUMBERS);
+	gpt_h->sizeof_partition_entry = cpu_to_le32(sizeof(gpt_entry));
+	gpt_h->header_crc32 = 0;
+	gpt_h->partition_entry_array_crc32 = 0;
+
+	if (string_uuid(str_guid, gpt_h->disk_guid.b))
+		return -1;
+
+	return 0;
+}
+
+int gpt_restore(block_dev_desc_t *dev_desc, char *str_disk_guid,
+		disk_partition_t *partitions, int parts_count)
+{
+	int ret;
+
+	gpt_header *gpt_h = calloc(1, sizeof(gpt_header));
+	if (gpt_h == NULL) {
+		printf("%s: calloc failed!\n", __func__);
+		return -1;
+	}
+
+	gpt_entry *gpt_e = calloc(GPT_ENTRY_NUMBERS, sizeof(gpt_entry));
+	if (gpt_e == NULL) {
+		printf("%s: calloc failed!\n", __func__);
+		free(gpt_h);
+		return -1;
+	}
+
+	/* Generate Primary GPT header (LBA1) */
+	ret = gpt_fill_header(dev_desc, gpt_h, str_disk_guid, parts_count);
+	if (ret)
+		goto err;
+
+	/* Generate partition entries */
+	ret = gpt_fill_pte(gpt_h, gpt_e, partitions, parts_count);
+	if (ret)
+		goto err;
+
+	/* Write GPT partition table */
+	ret = write_gpt_table(dev_desc, gpt_h, gpt_e);
+
+err:
+	free(gpt_e);
+	free(gpt_h);
+	return ret;
+}
+#endif
+
 /*
  * Private functions
  */
@@ -247,7 +511,7 @@ int test_part_efi(block_dev_desc_t * dev_desc)
 static int pmbr_part_valid(struct partition *part)
 {
 	if (part->sys_ind == EFI_PMBR_OSTYPE_EFI_GPT &&
-		le32_to_int(part->start_sect) == 1UL) {
+		le32_to_cpu(part->start_sect) == 1UL) {
 		return 1;
 	}
 
@@ -266,9 +530,8 @@ static int is_pmbr_valid(legacy_mbr * mbr)
 {
 	int i = 0;
 
-	if (!mbr || le16_to_int(mbr->signature) != MSDOS_MBR_SIGNATURE) {
+	if (!mbr || le16_to_cpu(mbr->signature) != MSDOS_MBR_SIGNATURE)
 		return 0;
-	}
 
 	for (i = 0; i < 4; i++) {
 		if (pmbr_part_valid(&mbr->partition_record[i])) {
@@ -291,8 +554,8 @@ static int is_pmbr_valid(legacy_mbr * mbr)
 static int is_gpt_valid(block_dev_desc_t * dev_desc, unsigned long long lba,
 			gpt_header * pgpt_head, gpt_entry ** pgpt_pte)
 {
-	unsigned char crc32_backup[4] = { 0 };
-	unsigned long calc_crc32;
+	u32 crc32_backup = 0;
+	u32 calc_crc32;
 	unsigned long long lastlba;
 
 	if (!dev_desc || !pgpt_head) {
@@ -307,54 +570,54 @@ static int is_gpt_valid(block_dev_desc_t * dev_desc, unsigned long long lba,
 	}
 
 	/* Check the GPT header signature */
-	if (le64_to_int(pgpt_head->signature) != GPT_HEADER_SIGNATURE) {
+	if (le64_to_cpu(pgpt_head->signature) != GPT_HEADER_SIGNATURE) {
 		printf("GUID Partition Table Header signature is wrong:"
 			"0x%llX != 0x%llX\n",
-			(unsigned long long)le64_to_int(pgpt_head->signature),
-			(unsigned long long)GPT_HEADER_SIGNATURE);
+			le64_to_cpu(pgpt_head->signature),
+			GPT_HEADER_SIGNATURE);
 		return 0;
 	}
 
 	/* Check the GUID Partition Table CRC */
-	memcpy(crc32_backup, pgpt_head->header_crc32, sizeof(crc32_backup));
-	memset(pgpt_head->header_crc32, 0, sizeof(pgpt_head->header_crc32));
+	memcpy(&crc32_backup, &pgpt_head->header_crc32, sizeof(crc32_backup));
+	memset(&pgpt_head->header_crc32, 0, sizeof(pgpt_head->header_crc32));
 
 	calc_crc32 = efi_crc32((const unsigned char *)pgpt_head,
-		le32_to_int(pgpt_head->header_size));
+		le32_to_cpu(pgpt_head->header_size));
 
-	memcpy(pgpt_head->header_crc32, crc32_backup, sizeof(crc32_backup));
+	memcpy(&pgpt_head->header_crc32, &crc32_backup, sizeof(crc32_backup));
 
-	if (calc_crc32 != le32_to_int(crc32_backup)) {
+	if (calc_crc32 != le32_to_cpu(crc32_backup)) {
 		printf("GUID Partition Table Header CRC is wrong:"
-			"0x%08lX != 0x%08lX\n",
-			le32_to_int(crc32_backup), calc_crc32);
+			"0x%x != 0x%x\n",
+		       le32_to_cpu(crc32_backup), calc_crc32);
 		return 0;
 	}
 
 	/* Check that the my_lba entry points to the LBA that contains the GPT */
-	if (le64_to_int(pgpt_head->my_lba) != lba) {
+	if (le64_to_cpu(pgpt_head->my_lba) != lba) {
 		printf("GPT: my_lba incorrect: %llX != %llX\n",
-			(unsigned long long)le64_to_int(pgpt_head->my_lba),
-			(unsigned long long)lba);
+			le64_to_cpu(pgpt_head->my_lba),
+			lba);
 		return 0;
 	}
 
 	/* Check the first_usable_lba and last_usable_lba are within the disk. */
 	lastlba = (unsigned long long)dev_desc->lba;
-	if (le64_to_int(pgpt_head->first_usable_lba) > lastlba) {
+	if (le64_to_cpu(pgpt_head->first_usable_lba) > lastlba) {
 		printf("GPT: first_usable_lba incorrect: %llX > %llX\n",
-			le64_to_int(pgpt_head->first_usable_lba), lastlba);
+			le64_to_cpu(pgpt_head->first_usable_lba), lastlba);
 		return 0;
 	}
-	if (le64_to_int(pgpt_head->last_usable_lba) > lastlba) {
+	if (le64_to_cpu(pgpt_head->last_usable_lba) > lastlba) {
 		printf("GPT: last_usable_lba incorrect: %llX > %llX\n",
-			le64_to_int(pgpt_head->last_usable_lba), lastlba);
+			(u64) le64_to_cpu(pgpt_head->last_usable_lba), lastlba);
 		return 0;
 	}
 
 	debug("GPT: first_usable_lba: %llX last_usable_lba %llX last lba %llX\n",
-		le64_to_int(pgpt_head->first_usable_lba),
-		le64_to_int(pgpt_head->last_usable_lba), lastlba);
+		le64_to_cpu(pgpt_head->first_usable_lba),
+		le64_to_cpu(pgpt_head->last_usable_lba), lastlba);
 
 	/* Read and allocate Partition Table Entries */
 	*pgpt_pte = alloc_read_gpt_entries(dev_desc, pgpt_head);
@@ -365,13 +628,13 @@ static int is_gpt_valid(block_dev_desc_t * dev_desc, unsigned long long lba,
 
 	/* Check the GUID Partition Table Entry Array CRC */
 	calc_crc32 = efi_crc32((const unsigned char *)*pgpt_pte,
-		le32_to_int(pgpt_head->num_partition_entries) *
-		le32_to_int(pgpt_head->sizeof_partition_entry));
+		le32_to_cpu(pgpt_head->num_partition_entries) *
+		le32_to_cpu(pgpt_head->sizeof_partition_entry));
 
-	if (calc_crc32 != le32_to_int(pgpt_head->partition_entry_array_crc32)) {
+	if (calc_crc32 != le32_to_cpu(pgpt_head->partition_entry_array_crc32)) {
 		printf("GUID Partition Table Entry Array CRC is wrong:"
-			"0x%08lX != 0x%08lX\n",
-			le32_to_int(pgpt_head->partition_entry_array_crc32),
+			"0x%x != 0x%x\n",
+			le32_to_cpu(pgpt_head->partition_entry_array_crc32),
 			calc_crc32);
 
 		free(*pgpt_pte);
@@ -402,12 +665,12 @@ static gpt_entry *alloc_read_gpt_entries(block_dev_desc_t * dev_desc,
 		return NULL;
 	}
 
-	count = le32_to_int(pgpt_head->num_partition_entries) *
-		le32_to_int(pgpt_head->sizeof_partition_entry);
+	count = le32_to_cpu(pgpt_head->num_partition_entries) *
+		le32_to_cpu(pgpt_head->sizeof_partition_entry);
 
-	debug("%s: count = %lu * %lu = %u\n", __func__,
-		le32_to_int(pgpt_head->num_partition_entries),
-		le32_to_int(pgpt_head->sizeof_partition_entry), count);
+	debug("%s: count = %u * %u = %zu\n", __func__,
+	      (u32) le32_to_cpu(pgpt_head->num_partition_entries),
+	      (u32) le32_to_cpu(pgpt_head->sizeof_partition_entry), count);
 
 	/* Allocate memory for PTE, remember to FREE */
 	if (count != 0) {
@@ -415,14 +678,15 @@ static gpt_entry *alloc_read_gpt_entries(block_dev_desc_t * dev_desc,
 	}
 
 	if (count == 0 || pte == NULL) {
-		printf("%s: ERROR: Can't allocate 0x%X bytes for GPT Entries\n",
+		printf("%s: ERROR: Can't allocate 0x%zX "
+		       "bytes for GPT Entries\n",
 			__func__, count);
 		return NULL;
 	}
 
 	/* Read GPT Entries from device */
 	if (dev_desc->block_read (dev_desc->dev,
-		(unsigned long)le64_to_int(pgpt_head->partition_entry_lba),
+		le64_to_cpu(pgpt_head->partition_entry_lba),
 		(lbaint_t) (count / GPT_BLOCK_SIZE), pte)
 		!= (count / GPT_BLOCK_SIZE)) {
 
@@ -457,7 +721,7 @@ static int is_pte_valid(gpt_entry * pte)
 		sizeof(unused_guid.b)) == 0) {
 
 		debug("%s: Found an unused PTE GUID at 0x%08X\n", __func__,
-		(unsigned int)pte);
+		      (unsigned int)(uintptr_t)pte);
 
 		return 0;
 	} else {
diff --git a/disk/part_efi.h b/disk/part_efi.h
deleted file mode 100644
index 5903e7c..0000000
--- a/disk/part_efi.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2008 RuggedCom, Inc.
- * Richard Retanubun <RichardRetanubun@RuggedCom.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-/*
- * See also linux/fs/partitions/efi.h
- *
- * EFI GUID Partition Table
- * Per Intel EFI Specification v1.02
- * http://developer.intel.com/technology/efi/efi.htm
-*/
-
-#ifndef _DISK_PART_EFI_H
-#define _DISK_PART_EFI_H
-
-#define MSDOS_MBR_SIGNATURE 0xAA55
-#define EFI_PMBR_OSTYPE_EFI 0xEF
-#define EFI_PMBR_OSTYPE_EFI_GPT 0xEE
-
-#define GPT_BLOCK_SIZE 512
-#define GPT_HEADER_SIGNATURE 0x5452415020494645ULL
-#define GPT_HEADER_REVISION_V1 0x00010000
-#define GPT_PRIMARY_PARTITION_TABLE_LBA 1ULL
-#define GPT_ENTRY_NAME "gpt"
-
-#define EFI_GUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
-	((efi_guid_t) \
-	{{ (a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, ((a) >> 24) & 0xff, \
-		(b) & 0xff, ((b) >> 8) & 0xff, \
-		(c) & 0xff, ((c) >> 8) & 0xff, \
-		(d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
-
-#define PARTITION_SYSTEM_GUID \
-	EFI_GUID( 0xC12A7328, 0xF81F, 0x11d2, \
-		0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B)
-#define LEGACY_MBR_PARTITION_GUID \
-	EFI_GUID( 0x024DEE41, 0x33E7, 0x11d3, \
-		0x9D, 0x69, 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F)
-#define PARTITION_MSFT_RESERVED_GUID \
-	EFI_GUID( 0xE3C9E316, 0x0B5C, 0x4DB8, \
-		0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE)
-#define PARTITION_BASIC_DATA_GUID \
-	EFI_GUID( 0xEBD0A0A2, 0xB9E5, 0x4433, \
-		0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7)
-#define PARTITION_LINUX_RAID_GUID \
-	EFI_GUID( 0xa19d880f, 0x05fc, 0x4d3b, \
-		0xa0, 0x06, 0x74, 0x3f, 0x0f, 0x84, 0x91, 0x1e)
-#define PARTITION_LINUX_SWAP_GUID \
-	EFI_GUID( 0x0657fd6d, 0xa4ab, 0x43c4, \
-		0x84, 0xe5, 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f)
-#define PARTITION_LINUX_LVM_GUID \
-	EFI_GUID( 0xe6d6d379, 0xf507, 0x44c2, \
-		0xa2, 0x3c, 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28)
-
-/* linux/include/efi.h */
-typedef unsigned short efi_char16_t;
-
-typedef struct {
-	unsigned char b[16];
-} efi_guid_t;
-
-/* based on linux/include/genhd.h */
-struct partition {
-	unsigned char boot_ind;		/* 0x80 - active */
-	unsigned char head;		/* starting head */
-	unsigned char sector;		/* starting sector */
-	unsigned char cyl;		/* starting cylinder */
-	unsigned char sys_ind;		/* What partition type */
-	unsigned char end_head;		/* end head */
-	unsigned char end_sector;	/* end sector */
-	unsigned char end_cyl;		/* end cylinder */
-	unsigned char start_sect[4];	/* starting sector counting from 0 */
-	unsigned char nr_sects[4];	/* nr of sectors in partition */
-} __attribute__ ((packed));
-
-/* based on linux/fs/partitions/efi.h */
-typedef struct _gpt_header {
-	unsigned char signature[8];
-	unsigned char revision[4];
-	unsigned char header_size[4];
-	unsigned char header_crc32[4];
-	unsigned char reserved1[4];
-	unsigned char my_lba[8];
-	unsigned char alternate_lba[8];
-	unsigned char first_usable_lba[8];
-	unsigned char last_usable_lba[8];
-	efi_guid_t disk_guid;
-	unsigned char partition_entry_lba[8];
-	unsigned char num_partition_entries[4];
-	unsigned char sizeof_partition_entry[4];
-	unsigned char partition_entry_array_crc32[4];
-	unsigned char reserved2[GPT_BLOCK_SIZE - 92];
-} __attribute__ ((packed)) gpt_header;
-
-typedef struct _gpt_entry_attributes {
-	unsigned long long required_to_function:1;
-	unsigned long long reserved:47;
-	unsigned long long type_guid_specific:16;
-} __attribute__ ((packed)) gpt_entry_attributes;
-
-#define PARTNAME_SZ	(72 / sizeof(efi_char16_t))
-typedef struct _gpt_entry {
-	efi_guid_t partition_type_guid;
-	efi_guid_t unique_partition_guid;
-	unsigned char starting_lba[8];
-	unsigned char ending_lba[8];
-	gpt_entry_attributes attributes;
-	efi_char16_t partition_name[PARTNAME_SZ];
-}
-__attribute__ ((packed)) gpt_entry;
-
-typedef struct _legacy_mbr {
-	unsigned char boot_code[440];
-	unsigned char unique_mbr_signature[4];
-	unsigned char unknown[2];
-	struct partition partition_record[4];
-	unsigned char signature[2];
-} __attribute__ ((packed)) legacy_mbr;
-
-#endif	/* _DISK_PART_EFI_H */
diff --git a/drivers/i2c/iproc_i2c.c b/drivers/i2c/iproc_i2c.c
index 879f9e6..f62adec 100644
--- a/drivers/i2c/iproc_i2c.c
+++ b/drivers/i2c/iproc_i2c.c
@@ -36,31 +36,91 @@
 #define debug(fmt,args...)
 #endif /* I2C_DEBUG */
 
-static smb_clk_freq_t  smb_clk_speed;
 static int  i2c_init_done = 0;
 
-#if (defined(CONFIG_NS_PLUS) || defined(CONFIG_HELIX4)) 
-#define SHADOW_CPY_BUFFER 0x70000000
-#define IPROC_SMBUS_BASE_ADDR   (0x18038000)
-//#define IPROC_SMBUS_BASE_ADDR   (0x1803B000)
+#if (defined(CONFIG_NS_PLUS) || defined(CONFIG_HELIX4))
+static u32 SHADOW_CPY_BUFFER = 0x70000000;
+static u32 IPROC_SMBUS_BASE_ADDR = 0x18038000;
 #else
-#define SHADOW_CPY_BUFFER 0x89000000
-#define IPROC_SMBUS_BASE_ADDR   (0x18009000)
+static u32 SHADOW_CPY_BUFFER = 0x89000000;
+static u32 IPROC_SMBUS_BASE_ADDR = 0x18009000;
+#endif
+
+#ifdef CONFIG_I2C_MULTI_BUS
+static unsigned int current_bus;
+
+/**
+ * i2c_set_bus_num - change active I2C bus
+ *	@bus: bus index, zero based
+ *	@returns: 0 on success, non-0 on failure
+ */
+int i2c_set_bus_num(unsigned int bus)
+{
+	if ((bus < 0) || (bus >= CONFIG_SYS_MAX_I2C_BUS)) {
+		printf("Bad bus: %d\n", bus);
+		return -1;
+	}
+
+	switch (bus) {
+        case 0:
+#if defined(CONFIG_HELIX4)
+                IPROC_SMBUS_BASE_ADDR = 0x18038000;
+#else
+                IPROC_SMBUS_BASE_ADDR = 0x18008000;
+#endif
+                SHADOW_CPY_BUFFER = 0x70000000;
+                break;
+        case 1:
+#if defined(CONFIG_HELIX4)
+                IPROC_SMBUS_BASE_ADDR = 0x1803B000;
+#else
+		IPROC_SMBUS_BASE_ADDR = 0x1800B000;
+#endif
+                SHADOW_CPY_BUFFER  = 0x70100000;
+                break;
+#if defined (CONFIG_HELIX4)
+        case 2:
+                IPROC_SMBUS_BASE_ADDR = 0x48000000;
+                SHADOW_CPY_BUFFER = 0x70200000;
+#else
+                return -1;
+#endif
+                break;
+
+    default:
+		return -1;
+	}
+	current_bus = bus;
+	return 0;
+}
+/**
+ * i2c_get_bus_num - returns index of active I2C bus
+ */
+unsigned int i2c_get_bus_num(void)
+{
+	return current_bus;
+}
+
 #endif
 
 /* Function to read a value from specified register. */
 static unsigned int iproc_i2c_reg_read(unsigned long reg_addr)
 {
-    return( __raw_readl((void *)(IPROC_SMBUS_BASE_ADDR + reg_addr)) );
+    unsigned int val;
+    val = __raw_readl((void *)(IPROC_SMBUS_BASE_ADDR + reg_addr));
+    debug("Rd: addr:0x%x val:0x%x\n", (void *)(IPROC_SMBUS_BASE_ADDR + reg_addr), val);
+    return val;
 }
 
 /* Function to write a value ('val') in to a specified register. */
 static int iproc_i2c_reg_write(unsigned long reg_addr, unsigned int val)
 {
+    debug("Wr: addr:0x%x val:0x%x\n", (void *)(IPROC_SMBUS_BASE_ADDR + reg_addr), val);
     __raw_writel(val, (void *)(IPROC_SMBUS_BASE_ADDR + reg_addr));
     return (0);
 }
 
+#ifdef IPROC_I2C_DBG
 static int iproc_dump_i2c_regs(void)
 {
     unsigned int regval;
@@ -68,6 +128,8 @@ static int iproc_dump_i2c_regs(void)
     debug("\n----------------------------------------------\n");
     debug("%s: Dumping SMBus registers... \n", __func__);
 
+    debug("IPROC_SMBUS_BASE_ADDR=0x%08X\n", IPROC_SMBUS_BASE_ADDR);
+
     regval = iproc_i2c_reg_read(CCB_SMB_CFG_REG);
     debug("CCB_SMB_CFG_REG=0x%08X\n", regval);
 
@@ -113,6 +175,7 @@ static int iproc_dump_i2c_regs(void)
     debug("----------------------------------------------\n\n");
     return(0);
 }
+#endif
 
 /*
  * Function to ensure that the previous transaction was completed before
@@ -142,7 +205,7 @@ static int iproc_i2c_startbusy_wait(void)
                  (i < IPROC_SMB_MAX_RETRIES));
 
         if (i >= IPROC_SMB_MAX_RETRIES) {
-            printf("%s: START_BUSY bit didn't clear, exiting\n",
+            debug("%s: START_BUSY bit didn't clear, exiting\n",
                    __func__);;
             return -ETIMEDOUT;
         }
@@ -305,7 +368,7 @@ static int iproc_i2c_data_recv(unsigned short addr,
     rc = iproc_i2c_startbusy_wait();
 
     if (rc < 0) {
-        printf("%s: Receive: Bus is busy, exiting\n", __func__);;
+        debug("%s: Receive: Bus is busy, exiting\n", __func__);;
         return rc;
     }
 
@@ -338,7 +401,7 @@ static int iproc_i2c_data_recv(unsigned short addr,
 
         if (regval != MSTR_STS_XACT_SUCCESS) {
             /* We can flush Tx FIFO here */
-            printf("%s: Error in transaction %d, exiting",
+            debug("%s: Error in transaction %d, exiting",
                    __func__, regval);
            return -EREMOTEIO;
         }
@@ -408,7 +471,7 @@ static int iproc_i2c_set_clk_freq(smb_clk_freq_t freq)
     return(0);
 }
 
-void i2c_init (int speed, int slaveadd)
+static void iproc_i2c_init (int speed, int slaveadd)
 {
     unsigned int regval;
 
@@ -432,14 +495,17 @@ void i2c_init (int speed, int slaveadd)
     udelay(100);
 
     /* Set default clock frequency */
-    iproc_i2c_set_clk_freq(I2C_SPEED_100KHz);
-
+    if (speed == 0) {
+        iproc_i2c_set_clk_freq(I2C_SPEED_100KHz);
+    } else {
+        iproc_i2c_set_clk_freq(I2C_SPEED_400KHz);
+    }
     /* Disable intrs */
     regval = 0x0;
     iproc_i2c_reg_write(CCB_SMB_EVTEN_REG, regval);
 
     /* Clear intrs (W1TC) */
-    regval = iproc_i2c_reg_read(CCB_SMB_EVTSTS_REG);    
+    regval = iproc_i2c_reg_read(CCB_SMB_EVTSTS_REG);
     iproc_i2c_reg_write(CCB_SMB_EVTSTS_REG, regval);
 
     i2c_init_done = 1;
@@ -450,34 +516,52 @@ void i2c_init (int speed, int slaveadd)
     debug("%s: Init successful\n", __func__);
 #endif /* IPROC_I2C_DBG */
 
-    return(0);
+    return;
 }
 
-int i2c_probe (uchar chip)
+void i2c_init (int speed, int slaveadd)
 {
+#ifdef CONFIG_I2C_MULTI_BUS
+    i2c_set_bus_num(0);
+    iproc_i2c_init(speed, slaveadd);
+    i2c_set_bus_num(1);
+    iproc_i2c_init(speed, slaveadd);
+#if defined(CONFIG_HELIX4)
+    i2c_set_bus_num(2);
+    iproc_i2c_init(speed, slaveadd);
+#endif
+#else
+    iproc_i2c_init(speed, slaveadd);
+#endif
+}
 
-#ifdef IPROC_I2C_DBG
-    debug("\n%s: Entering probe\n", __func__);
-#endif /* IPROC_I2C_DBG */
-
-    /* Init internal regs, disable intrs (and then clear intrs), set fifo
-     * thresholds, etc.
-     */
-    if(! i2c_init_done)
-        i2c_init(0, 0);
+static int i2c_receive_byte (u8 devaddr, u8 *value)
+{
+    int rc;
+    struct iproc_xact_info info;
+    unsigned int num_bytes_read = 0;
 
-#ifdef IPROC_I2C_DBG
-    iproc_dump_i2c_regs();
+    devaddr <<= 1;
 
-    debug("%s: probe successful\n", __func__);
-#endif /* IPROC_I2C_DBG */
+    info.cmd_valid = 0;
+    info.data = value;
+    info.size = 1;
+    info.flags = 0;
+    info.smb_proto = SMBUS_PROT_RECV_BYTE;
 
-    return 0;
-}
+    /* Refer to i2c_smbus_read_byte for params passed. */
+    rc = iproc_i2c_data_recv(devaddr, &info, &num_bytes_read);
 
+    if (rc < 0) {
+        debug("%s: %s error accessing device 0x%X",
+                    __func__, "Read", devaddr);
+        return -EREMOTEIO;
+    }
 
+    return (0);
+}
 
-static int i2c_read_byte (u8 devaddr, u8 regoffset, u8 * value)
+static int i2c_read_byte (u8 devaddr, u16 regoffset, u8 * value)
 {
     int rc;
     struct iproc_xact_info info;
@@ -486,7 +570,7 @@ static int i2c_read_byte (u8 devaddr, u8 regoffset, u8 * value)
     devaddr <<= 1;
 
     info.cmd_valid = 1;
-    info.command = (unsigned char)regoffset;
+    info.command = (unsigned short)regoffset;
     info.data = value;
     info.size = 1;
     info.flags = 0;
@@ -496,7 +580,7 @@ static int i2c_read_byte (u8 devaddr, u8 regoffset, u8 * value)
     rc = iproc_i2c_data_recv(devaddr, &info, &num_bytes_read);
 
     if (rc < 0) {
-        printf("%s: %s error accessing device 0x%X", 
+        debug("%s: %s error accessing device 0x%X", 
                     __func__, "Read", devaddr);
         return -EREMOTEIO;
     }
@@ -504,23 +588,68 @@ static int i2c_read_byte (u8 devaddr, u8 regoffset, u8 * value)
     return (0);
 }
 
-int i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
+int i2c_probe (uchar chip)
 {
-	int i;
+    u32 slave_addr;
+    u32 curr_bus;
+    int rc;
+    u8  buffer[1];
 
-	if (alen > 1) {
-		printf ("I2C read: addr len %d not supported\n", alen);
-		return 1;
-	}
+    slave_addr = chip;
+#ifdef IPROC_I2C_DBG
+    debug("\n%s: Entering probe\n", __func__);
+#endif /* IPROC_I2C_DBG */
 
-	if (addr + len > 256) {
-		printf ("I2C read: address out of range\n");
-		return 1;
-	}
+    /* Init internal regs, disable intrs (and then clear intrs), set fifo
+     * thresholds, etc.
+     */
+    if(! i2c_init_done)
+    {
+        curr_bus = i2c_get_bus_num();
+#ifdef CONFIG_I2C_MULTI_BUS
+        i2c_set_bus_num(0);
+        iproc_i2c_init(CONFIG_SYS_I2C_SPEED, 0);
+        i2c_set_bus_num(1);
+        iproc_i2c_init(CONFIG_SYS_I2C_SPEED, 0);
+#if defined(CONFIG_HELIX4)
+        i2c_set_bus_num(2);
+        iproc_i2c_init(CONFIG_SYS_I2C_SPEED, 0);
+#endif
+#else
+        iproc_i2c_init(CONFIG_SYS_I2C_SPEED, 0);
+#endif
+        i2c_set_bus_num(curr_bus);
+    }
+
+    rc = i2c_receive_byte(slave_addr, &buffer[0]);
+    if (rc) {
+        /* receive byte didnt work, let's try read byte */
+        rc = i2c_read_byte(slave_addr, 0x0, &buffer[0]);
+    }
+    if (!rc) {
+        debug("%s: probe successful for dev %d\n", __func__, slave_addr);
+    } else {
+        return rc;
+    }
+
+#ifdef IPROC_I2C_DBG
+    iproc_dump_i2c_regs();
+
+    debug("%s: probe successful\n", __func__);
+#endif /* IPROC_I2C_DBG */
+
+    return 0;
+}
+
+
+
+int i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int i;
 
 	for (i = 0; i < len; i++) {
 		if (i2c_read_byte (chip, addr + i, &buffer[i])) {
-			printf ("I2C read: I/O error\n");
+			debug ("I2C read: I/O error\n");
 			i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
 			return 1;
 		}
@@ -534,16 +663,15 @@ int i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
 
 
 
-static int i2c_write_byte (u8 devaddr, u8 regoffset, u8 value)
+static int i2c_write_byte (u8 devaddr, u16 regoffset, u8 value)
 {
     int rc;
     struct iproc_xact_info info;
-    unsigned int num_bytes_write = 0;
 
     devaddr <<= 1;
 
     info.cmd_valid = 1;
-    info.command = (unsigned char)regoffset;
+    info.command = (unsigned short)regoffset;
     info.data = &value; 
     info.size = 1;
     info.flags = 0;
@@ -565,19 +693,9 @@ int i2c_write (uchar chip, uint addr, int alen, uchar * buffer, int len)
 {
 	int i;
 
-	if (alen > 1) {
-		printf ("I2C read: addr len %d not supported\n", alen);
-		return 1;
-	}
-
-	if (addr + len > 256) {
-		printf ("I2C read: address out of range\n");
-		return 1;
-	}
-
 	for (i = 0; i < len; i++) {
 		if (i2c_write_byte (chip, addr + i, buffer[i])) {
-			printf ("I2C read: I/O error\n");
+			printf ("I2C write: I/O error\n");
 			i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
 			return 1;
 		}
@@ -585,3 +703,59 @@ int i2c_write (uchar chip, uint addr, int alen, uchar * buffer, int len)
 
 	return 0;
 }
+
+/**
+ * i2c_set_bus_speed - set i2c bus speed
+ *      @speed: bus speed (in HZ)
+ * This function returns invalid or 0
+ */
+
+int i2c_set_bus_speed(unsigned int speed)
+{
+
+    switch (speed) {
+
+        case 100000:
+	    iproc_i2c_set_clk_freq(I2C_SPEED_100KHz);
+            break;
+
+        case 400000:
+            iproc_i2c_set_clk_freq(I2C_SPEED_400KHz);
+            break;
+
+        default:
+            return -EINVAL;
+            break;
+    }
+    return 0;
+}
+
+/**
+ * i2c_get_bus_speed - get i2c bus speed
+ *
+ * This function returns the speed of operation in Hz
+ */
+unsigned int i2c_get_bus_speed(void)
+{
+     unsigned int regval;
+     unsigned int val;
+
+     regval = iproc_i2c_reg_read(CCB_SMB_TIMGCFG_REG);
+     val = GETREGFLDVAL(regval, CCB_SMB_TIMGCFG_MODE400_MASK,
+                                 CCB_SMB_TIMGCFG_MODE400_SHIFT);
+     switch (val) {
+        case I2C_SPEED_100KHz:
+            return 100000;
+            break;
+
+        case I2C_SPEED_400KHz:
+            return 400000;
+            break;
+
+        default:
+            return 0;
+            break;
+     }
+     return 0;
+}
+
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index 3953549..9a2becd 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -115,12 +115,14 @@ const struct nand_flash_dev nand_flash_ids[] = {
 	{"NAND 2GiB 3,3V 8-bit",	0xD5, 0, 2048, 0, LP_OPTIONS},
 	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
 	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
+    {"NAND 2GiB 3,3V 8-bit",    0x48, 4096, 2048, 0x100000, 0},
 
 	/* 32 Gigabit */
 	{"NAND 4GiB 1,8V 8-bit",	0xA7, 0, 4096, 0, LP_OPTIONS},
 	{"NAND 4GiB 3,3V 8-bit",	0xD7, 0, 4096, 0, LP_OPTIONS},
 	{"NAND 4GiB 1,8V 16-bit",	0xB7, 0, 4096, 0, LP_OPTIONS16},
 	{"NAND 4GiB 3,3V 16-bit",	0xC7, 0, 4096, 0, LP_OPTIONS16},
+    {"NAND 4GiB 3,3V 8-bit",    0x68, 8192, 4096, 0x100000, 0},
 
 	/* 64 Gigabit */
 	{"NAND 8GiB 1,8V 8-bit",	0xAE, 0, 8192, 0, LP_OPTIONS},
diff --git a/drivers/mtd/nand/nand_spl_simple.c b/drivers/mtd/nand/nand_spl_simple.c
index 9ecda66..ed4a076 100644
--- a/drivers/mtd/nand/nand_spl_simple.c
+++ b/drivers/mtd/nand/nand_spl_simple.c
@@ -298,7 +298,11 @@ void nand_init(void)
        printf("NAND scan failed\n");
        return;
     }
-    printf("%lu MiB\n", ((int)mtd.size) / (1024 * 1024));
+#ifdef CONFIG_IPROC_SPL
+#ifndef CONFIG_SPL_BUILD
+    printf("%lu MiB\n", ((unsigned int)mtd.size) / (1024 * 1024));
+#endif
+#endif
 #endif
  
 #ifdef CONFIG_SPL_NAND_SOFTECC
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index 9f0f2bf..d10e3ab 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -385,7 +385,7 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		goto err_manufacturer_probe;
 	}
 
-	printf("SF: Detected %s with page size ", flash->name);
+	printf("SF:    %s with page size ", flash->name);
 	print_size(flash->sector_size, ", total ");
 	print_size(flash->size, "\n");
 
diff --git a/drivers/net/bcmiproc_eth.c b/drivers/net/bcmiproc_eth.c
index 04158bb..b05ced0 100755
--- a/drivers/net/bcmiproc_eth.c
+++ b/drivers/net/bcmiproc_eth.c
@@ -25,7 +25,7 @@
 #include <asm/arch/ethHw.h>
 #include <asm/arch/ethHw_dma.h>
 
-#define BCMIPROC_ETH_DEV_NAME          "bcmiproc_eth"
+#define BCMIPROC_ETH_DEV_NAME          "eth"
 
 #define BCM_NET_MODULE_DESCRIPTION    "Broadcom BCM IPROC Ethernet driver"
 #define BCM_NET_MODULE_VERSION        "0.1"
@@ -180,7 +180,9 @@ bcmiproc_eth_register(u8 dev_num)
 	memset(dev, 0, sizeof(*dev));
 	sprintf(dev->name, "%s-%hu", BCMIPROC_ETH_DEV_NAME, dev_num);
 
-	printf(banner);
+#ifdef BCMIPROC_ETH_DEBUG
+    printf(banner);
+#endif
 
 	/* Initialization */
 	ET_TRACE(("Ethernet initialization...\n"));
diff --git a/drivers/net/bcmiproc_ethHw.c b/drivers/net/bcmiproc_ethHw.c
index 1dc6dc6..e159e4a 100755
--- a/drivers/net/bcmiproc_ethHw.c
+++ b/drivers/net/bcmiproc_ethHw.c
@@ -352,7 +352,9 @@ ethHw_Init(void)
 			ET_ERROR(("ERROR: invalid GMAC specified\n"));
 	}
 
-	printf ("Using GMAC%d (0x%x)\n", eth_data->mac, (unsigned int)eth_data->regs);
+#ifdef BCMIPROC_ETH_DEBUG
+    printf ("Using GMAC%d (0x%x)\n", eth_data->mac, (unsigned int)eth_data->regs);
+#endif
 
 #ifdef CONFIG_IPROC_EMULATION
 	/* load options */
@@ -579,7 +581,9 @@ ethHw_chipAttach(bcm_eth_t *eth_data)
 
 	/* reset phy: reset it once now */
 	chipid = iproc_get_chipid();
-	printf("et%d: %s: Chip ID: 0x%x; phyaddr: 0x%x\n", eth_data->unit, __FUNCTION__, chipid, eth_data->bcmgmac.phyaddr);
+#ifdef BCMIPROC_ETH_DEBUG
+    printf("et%d: %s: Chip ID: 0x%x; phyaddr: 0x%x\n", eth_data->unit, __FUNCTION__, chipid, eth_data->bcmgmac.phyaddr);
+#endif
 
 #if defined(CONFIG_CYGNUS)
     /* set switch bypass mode */	
@@ -2624,16 +2628,22 @@ gmac_serdes_init(bcm_eth_t *eth_data)
 	//printf("et%d: %s enter\n", eth_data->unit, __FUNCTION__);
 
 	sdctl = reg32_read(&regs->serdes_ctl);
-	printf("et%d: %s read sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	sdstat0 = reg32_read(&regs->serdes_status0);
+#ifdef BCMIPROC_ETH_DEBUG
+    printf("et%d: %s read sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
+#endif
+    sdstat0 = reg32_read(&regs->serdes_status0);
 	sdstat1 = reg32_read(&regs->serdes_status1);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s() serdes_status0: 0x%x; serdes_status1: 0x%x\n", eth_data->unit, __FUNCTION__, sdstat0, sdstat1);
+#endif
 
     /* Check is PLL already brought up */
 	if (sdstat0 & SS0_TXPLL_LOCK)
 	{
+#ifdef BCMIPROC_ETH_DEBUG
 		printf("et%d: %s() PLL ready brought up exit\n", eth_data->unit, __FUNCTION__);
-		return;
+#endif
+        return;
 	}
   
     /*
@@ -2652,54 +2662,80 @@ gmac_serdes_init(bcm_eth_t *eth_data)
 	sdctl |= (SC_TX1G_FIFO_RST_VAL|SC_FORCE_SPD_STRAP_VAL|SC_REF_TERM_SEL_MASK);
 #endif /* (defined(CONFIG_HELIX4) || defined(CONFIG_CYGNUS)) */
 
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s write sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
+#endif
 
 	reg32_write(&regs->serdes_ctl, sdctl);
 
 	udelay(1000);
 
 	sdctl = reg32_read(&regs->serdes_ctl);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s read sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	sdctl |= (SC_IDDQ_MASK|SC_PWR_DOWN_MASK);
+#endif
+    sdctl |= (SC_IDDQ_MASK|SC_PWR_DOWN_MASK);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s write sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	reg32_write(&regs->serdes_ctl, sdctl);
+#endif
+    reg32_write(&regs->serdes_ctl, sdctl);
 
 	sdctl = reg32_read(&regs->serdes_ctl);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s read sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	sdctl &= ~(SC_IDDQ_MASK|SC_PWR_DOWN_MASK);
+#endif
+    sdctl &= ~(SC_IDDQ_MASK|SC_PWR_DOWN_MASK);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s write sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	reg32_write(&regs->serdes_ctl, sdctl);
+#endif
+    reg32_write(&regs->serdes_ctl, sdctl);
 
     /* Bring hardware out of reset */
 	sdctl = reg32_read(&regs->serdes_ctl);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s read sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	sdctl |= (SC_RSTB_HW_MASK);
+#endif
+    sdctl |= (SC_RSTB_HW_MASK);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s write sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	reg32_write(&regs->serdes_ctl, sdctl);
+#endif
+    reg32_write(&regs->serdes_ctl, sdctl);
 
     /* Bring MDIOREGS out of reset */
 	sdctl = reg32_read(&regs->serdes_ctl);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s read sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	sdctl |= (SC_RSTB_MDIOREGS_MASK);
+#endif
+    sdctl |= (SC_RSTB_MDIOREGS_MASK);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s write sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	reg32_write(&regs->serdes_ctl, sdctl);
+#endif
+    reg32_write(&regs->serdes_ctl, sdctl);
 
 	udelay(1000);
 
     /* Bring PLL out of reset */
 	sdctl = reg32_read(&regs->serdes_ctl);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s read sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	sdctl |= (SC_RSTB_PLL_MASK);
+#endif
+    sdctl |= (SC_RSTB_PLL_MASK);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s write sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	reg32_write(&regs->serdes_ctl, sdctl);
+#endif
+    reg32_write(&regs->serdes_ctl, sdctl);
 
 	udelay(1000);
 
 	sdctl = reg32_read(&regs->serdes_ctl);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s read sdctl(0x%x)\n", eth_data->unit, __FUNCTION__, sdctl);
-	sdstat0 = reg32_read(&regs->serdes_status0);
+#endif
+    sdstat0 = reg32_read(&regs->serdes_status0);
 	sdstat1 = reg32_read(&regs->serdes_status1);
+#ifdef BCMIPROC_ETH_DEBUG
 	printf("et%d: %s read sdstat0(0x%x); sdstat1(0x%x)\n", eth_data->unit, __FUNCTION__, sdstat0, sdstat1);
+#endif
 
 #endif
 	return;
diff --git a/drivers/net/bcmiproc_serdes.c b/drivers/net/bcmiproc_serdes.c
index a76e992..caa9532 100755
--- a/drivers/net/bcmiproc_serdes.c
+++ b/drivers/net/bcmiproc_serdes.c
@@ -198,7 +198,9 @@ serdes_reset_core(bcm_eth_t *eth_data, uint phyaddr)
 
 	/* get serdes id */
 	serdes_id2 = serdes_get_id(eth_data, phyaddr, 2);
-	printf("%s pbyaddr(0x%x) id2(0x%x)\n", __FUNCTION__, phyaddr, serdes_id2);
+#ifdef BCMIPROC_ETH_DEBUG
+    printf("%s pbyaddr(0x%x) id2(0x%x)\n", __FUNCTION__, phyaddr, serdes_id2);
+#endif
 
 	/* unlock lane */
 	data16 = serdes_rd_reg(eth_data, phyaddr, 0x833c);
diff --git a/drivers/serial/serial.c b/drivers/serial/serial.c
index ea55bfd..9c2231f 100644
--- a/drivers/serial/serial.c
+++ b/drivers/serial/serial.c
@@ -550,6 +550,9 @@ int find_str_indx(char *s, size_t len, char *t)
  */
 int early_access_env_vars(void)
 {
+#if defined(CONFIG_AS4610_30_RECOVERY)
+    return -1;
+#else
     volatile uint8_t *env_ptr;
     int i;
     char buf[EARLY_ACC_BUF_SIZE];
@@ -601,4 +604,5 @@ int early_access_env_vars(void)
     }
 
 	return 0;
+#endif
 }
diff --git a/drivers/usb/host/ehci-iproc.c b/drivers/usb/host/ehci-iproc.c
index a7fd7e3..550af55 100644
--- a/drivers/usb/host/ehci-iproc.c
+++ b/drivers/usb/host/ehci-iproc.c
@@ -86,16 +86,16 @@ int linux_usbh_init(void)
 
 	/* enable clock */
 	clk_enable = __raw_readl(IPROC_IDM_USB2_IO_CONTROL_DIRECT);
-	printf("Initial usb2h clock is: %08x\n", clk_enable);
+	/*printf("Initial usb2h clock is: %08x\n", clk_enable);*/
 	clk_enable |= 1;
-	printf("Initial usb2h clock is: %08x\n", clk_enable);
+	/*printf("Initial usb2h clock is: %08x\n", clk_enable);*/
 	__raw_writel(clk_enable, IPROC_IDM_USB2_IO_CONTROL_DIRECT);
 
 #if defined(CONFIG_HELIX4)
 	/* set USB clock to configured */
 	iClk = __raw_readl(IPROC_XGPLL);
 	USBClk = __raw_readl(IPROC_USB_PHY_CTRL);
-	printf("iClk = %08x, USBClk = %08x\n", iClk, USBClk);
+	/*printf("iClk = %08x, USBClk = %08x\n", iClk, USBClk);*/
 	if ((iClk & 0xff) == IPROC_CLK_NDIV_40)
 	{
 		__raw_writel((USBClk & USB_CLK_NDIV_MASK) | USB_CLK_NDIV_40, IPROC_USB_PHY_CTRL);
@@ -105,7 +105,7 @@ int linux_usbh_init(void)
 		__raw_writel((USBClk & USB_CLK_PHY_RESET_MASK) | USB_CLK_NDIV_40, IPROC_USB_PHY_CTRL);
 		udelay(10);
 		USBClk = __raw_readl(IPROC_USB_PHY_CTRL);
-		printf("iClk = %08x, USBClk = %08x\n", iClk, USBClk);
+		/*printf("iClk = %08x, USBClk = %08x\n", iClk, USBClk);*/
 	}
 	else if ((iClk & 0xff) == IPROC_CLK_NDIV_20)
 	{
@@ -116,7 +116,7 @@ int linux_usbh_init(void)
 		__raw_writel((USBClk & USB_CLK_PHY_RESET_MASK) | USB_CLK_NDIV_20, IPROC_USB_PHY_CTRL);
 		udelay(10);
 		USBClk = __raw_readl(IPROC_USB_PHY_CTRL);
-		printf("iClk = %08x, USBClk = %08x\n", iClk, USBClk);
+		/*printf("iClk = %08x, USBClk = %08x\n", iClk, USBClk);*/
 	}
 #endif
 
@@ -124,13 +124,12 @@ int linux_usbh_init(void)
 	__raw_writel(USBClk | (1<<23), IPROC_USB_PHY_CTRL);
 	udelay(100);
 
-    printf("\nBring usb2h_out of reset.......\n");
+    printf("Bringing USB2 host out of reset...\n");
     __raw_writel(0x0, IPROC_IDM_USB2_RESET_CONTROL);
     udelay(100000);
     usb2_reset_state = __raw_readl(IPROC_IDM_USB2_RESET_CONTROL);
-    printf("usb2_reset_state is set and now it is: %08x\n", usb2_reset_state);
-
-#if (defined(CONFIG_HELIX4) || defined(CONFIG_KATANA2))
+    /*printf("usb2_reset_state is set and now it is: %08x\n", usb2_reset_state);*/
+#if defined(CONFIG_TARGET_HELIX4_SVK)
 	/* supply power for USB device connected to the host */
 	usbdgpiopwr = __raw_readl(ChipcommonA_GPIOOut);
 	usbdgpiopwr &= SUPPLY_USBD_POWER;
diff --git a/include/configs/AS4610_30.h b/include/configs/AS4610_30.h
new file mode 100755
index 0000000..ccccd65
--- /dev/null
+++ b/include/configs/AS4610_30.h
@@ -0,0 +1,335 @@
+/*
+ * Samer Nubani <samer@cumulusnetworks.com>
+ * Curt Brune <curt@cumulusnetworks.com>
+ * Vidya Ravipati <vidya@cumulusnetworks.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * Accton AS4610_30 network switch board configuration file
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/sizes.h>
+#include "configs/common_config.h"
+
+/*
+ * AS4610_30 NOR flash layout
+ * uboot        0x00000000 - 0x000dffff (size 0x000e0000, 896KB)
+ * shmoo        0x000e0000 - 0x000effff (size 0x00010000, 64KB)
+ * uboot-env    0x000f0000 - 0x000fffff (size 0x00010000, 64KB)
+ * onie         0x00100000 - 0x007fffff (size 0x00700000, 7MB)
+ */
+
+/* High level Configuration Options */
+#define CONFIG_AS4610_30		1	/* accton_as4610_30 board specific */
+#define CONFIG_BOARDNAME    "AS4610_30"
+#define CONFIG_RUN_DDR_SHMOO2
+#define CONFIG_IPROC_DDR_ECC
+/* Enable CONFIG_AS4610_30_RECOVERY for recovery u-boot image */
+/* #define CONFIG_AS4610_30_RECOVERY */
+#if defined(CONFIG_AS4610_30_RECOVERY)
+#undef CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
+#endif
+
+/* Following are not yet supported on this platform */
+#undef CONFIG_CMD_IRQ
+#undef CONFIG_CMD_JFFS2
+#undef CONFIG_CMD_PCI
+
+#if defined(CONFIG_AS4610_30_RECOVERY)
+#undef CONFIG_CMD_ASKENV	/* ask for env variable		*/
+#undef CONFIG_CMD_BDI		/* bdinfo			*/
+#undef CONFIG_CMD_BOOTD	/* bootd			*/
+#undef CONFIG_CMD_CONSOLE	/* coninfo			*/
+#undef	CONFIG_CMD_DATE		/* support for RTC, date/time...*/
+#undef CONFIG_CMD_DHCP		/* DHCP Support			*/
+#undef CONFIG_CMD_DIAG		/* Diagnostics			*/
+#undef CONFIG_CMD_ECHO		/* echo arguments		*/
+//#define CONFIG_CMD_EDITENV	/* editenv			*/
+#undef CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#undef CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IRQ		/* irqinfo			*/
+#undef CONFIG_CMD_ITEST	/* Integer (and string) test	*/
+#undef CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+//#define CONFIG_CMD_MEMORY	/* md mm nm mw cp cmp crc base loop mtest */
+#undef CONFIG_CMD_MII		/* MII support			*/
+#undef CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+//#define CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#undef CONFIG_CMD_PCI		/* pciinfo			*/
+#undef CONFIG_CMD_PING		/* ping support			*/
+#undef CONFIG_CMD_RUN		/* run command in env variable	*/
+#undef CONFIG_CMD_SAVEENV	/* saveenv			*/
+#undef CONFIG_CMD_SETEXPR	/* setexpr support		*/
+#undef CONFIG_CMD_SETGETDCR	/* DCR support on 4xx		*/
+#undef CONFIG_CMD_SDRAM	/* SDRAM DIMM SPD info printout */
+#undef CONFIG_CMD_SOURCE	/* "source" command support	*/
+#undef CONFIG_CMD_XIMG		/* Load part of Multi Image	*/
+#endif
+
+#if !defined(CONFIG_AS4610_30_RECOVERY)
+/* USB */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_IPROC
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_FAT
+#define CONFIG_LEGACY_USB_INIT_SEQ
+
+/* PCIe */
+/* #define CONFIG_CMD_PCI_ENUM */
+/* #define CONFIG_PCI */
+/* #define CONFIG_PCI_SCAN_SHOW */
+/* #define CONFIG_IPROC_PCIE */
+
+/* GPT */
+#define CONFIG_CMD_GPT
+#define CONFIG_PARTITION_UUIDS
+#define CONFIG_EFI_PARTITION
+#endif
+
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_BOARD_EARLY_INIT_F (1)
+#define CONFIG_PHYS_SDRAM_1_SIZE	    0x40000000 /* 1GB */
+#define CONFIG_PHYS_SDRAM_2_SIZE        0x80000000 /* 2GB */
+#define IPROC_ETH_MALLOC_BASE           0xD00000
+
+/* Architecture, CPU, etc */
+#define CONFIG_ARMV7
+#define CONFIG_IPROC (1)
+#define CONFIG_HELIX4 (1)
+
+#define CONFIG_IPROC_MMU	(1)
+#define CONFIG_L2_OFF				/* Disable L2 cache */
+#define CONFIG_SYS_ARM_CACHE_WRITETHROUGH (1)
+
+#define CONFIG_MISC_INIT_R			/* Call board's misc_init_r function */
+
+/* Interrupt configuration */
+#define CONFIG_USE_IRQ          1	/* we need IRQ stuff for timer	*/
+
+/* UBIFS */
+#if 0
+#if !defined(CONFIG_SPL_BUILD) && !defined(CONFIG_AS4610_30_RECOVERY)
+#define CONFIG_CMD_UBI
+#define CONFIG_CMD_UBIFS
+#define CONFIG_RBTREE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_LZO
+#endif
+#endif
+
+/* Memory Info */
+#if (defined(CONFIG_L2C_AS_RAM ) && defined(CONFIG_NO_CODE_RELOC))
+#define CONFIG_SYS_MALLOC_LEN 			0x8000  	/* see armv7/start.S. */
+#define CONFIG_STACKSIZE				(0x10000) //64K
+#elif defined(CONFIG_AS4610_30_RECOVERY)
+#define CONFIG_SYS_MALLOC_LEN           (0x3000) //12K
+#define CONFIG_STACKSIZE				(0x3000) //12K
+#elif defined(CONFIG_CMD_UBI)
+#define CONFIG_SYS_MALLOC_LEN 			0x80000   /* UBI needs >= 512K */
+#define CONFIG_STACKSIZE				(0x10000) //64K
+#else
+#define CONFIG_SYS_MALLOC_LEN 			0x40000  	/* see armv7/start.S. */
+#define CONFIG_STACKSIZE				(0x10000) //64K
+#endif
+
+#define CONFIG_STACKSIZE_IRQ			(4096)
+#define CONFIG_STACKSIZE_FIQ			(4096)
+
+#define CONFIG_PHYS_SDRAM_0				0x1b000000  /* SRAM */
+#define CONFIG_L2_CACHE_SIZE			0x80000
+#define CONFIG_PHYS_SDRAM_1				0x60000000
+#define CONFIG_LOADADDR					0x70000000 /* default destination location for tftp file (tftpboot cmd) */
+#define CONFIG_PHYS_SDRAM_RSVD_SIZE		0x01000000 /* bytes reserved from CONFIG_PHYS_SDRAM_1 for custom use */
+
+/* Where kernel is loaded to in memory */
+#define CONFIG_SYS_LOAD_ADDR				0x70000000
+#define CONFIG_SYS_PROMPT					"accton_as4610-30-> "
+#define LINUX_BOOT_PARAM_ADDR				0x60200000 /* default mapped location to store the atags pointer */
+
+#define CONFIG_SYS_MEMTEST_START			CONFIG_PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END			(CONFIG_PHYS_SDRAM_1+CONFIG_PHYS_SDRAM_2_SIZE)
+#define CONFIG_NR_DRAM_BANKS				1
+
+#define CONFIG_SYS_SDRAM_BASE		(CONFIG_PHYS_SDRAM_1 + CONFIG_PHYS_SDRAM_RSVD_SIZE)
+/* CONFIG_SYS_TEXT_BASE is where u-boot is loaded by boot1 */
+#if defined(CONFIG_AS4610_30_RECOVERY)
+#define CONFIG_SYS_STACK_SIZE		(0x00004000) /* 16K */
+#else
+#define CONFIG_SYS_STACK_SIZE		(0x00010000) /* 64K */
+#endif
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_PHYS_SDRAM_0 + CONFIG_SYS_STACK_SIZE - 16)
+
+/* Clocks */
+#define CONFIG_SYS_REF_CLK			(25000000) /*Reference clock = 25MHz */
+#define CONFIG_SYS_REF2_CLK			(200000000) /*Reference clock = 25MHz */
+#define IPROC_ARM_CLK		(1000000000) /* 1GHz */
+#define IPROC_AXI_CLK		(500000000)  /* 500 MHz */
+#define IPROC_APB_CLK		(125000000)  /* 125 MHz */
+
+#define CONFIG_ENV_OVERWRITE	/* Allow serial# and ethernet mac address to be overwritten in nv storage */
+
+/* NO flash */
+#define CONFIG_SYS_NO_FLASH		/* Not using NAND/NOR unmanaged flash */
+
+/* Ethernet configuration */
+#define CONFIG_BCMIPROC_ETH
+#define CONFIG_NET_MULTI
+#define CONFIG_CMD_MII
+
+/* DMA configuration */
+/*#define CONFIG_BCM5301X_DMA */
+
+/* General U-Boot configuration */
+
+#define CONFIG_VERSION_VARIABLE	/* Enabled UBOOT build date/time id string */
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_LONGHELP
+
+#define CONFIG_CRC32_VERIFY		/* Add crc32 to memory verify commands */
+#define CONFIG_MX_CYCLIC			/* Memory display cyclic */
+
+#define CONFIG_CMDLINE_TAG				/* ATAG_CMDLINE setup */
+#define CONFIG_SETUP_MEMORY_TAGS		/* ATAG_MEM setup */
+
+#define CONFIG_CMD_BOOTZ
+
+/*#include <config_cmd_default.h>*/
+#include "iproc_common_configs.h"
+#define CONFIG_ENV_IS_NOWHERE
+#undef CONFIG_CMD_NFS
+#undef CONFIG_GENERIC_MMC
+/*#define CONFIG_CMD_MISC*/
+
+#define CONFIG_GMAC_NUM		0
+
+/* QSPI */
+#define CONFIG_CMD_SPI
+#define CONFIG_IPROC_QSPI
+
+/* Enable generic u-boot SPI flash drivers and commands */
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO_NS
+#define CONFIG_SPI_FLASH_MACRONIX_NS
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_SPI_FLASH_WINBOND
+#define CONFIG_SPI_FLASH_ATMEL
+
+/* SPI flash configurations */
+#define CONFIG_IPROC_QSPI
+#define CONFIG_IPROC_QSPI_BUS                   0
+#define CONFIG_IPROC_QSPI_CS                    0
+
+/* SPI flash configuration - flash specific */
+#define CONFIG_IPROC_BSPI_DATA_LANES            1
+#define CONFIG_IPROC_BSPI_ADDR_LANES            1
+#define CONFIG_IPROC_BSPI_READ_CMD              0x0b
+#define CONFIG_IPROC_BSPI_READ_DUMMY_CYCLES     8
+#define CONFIG_SF_DEFAULT_SPEED                 50000000
+#define CONFIG_SF_DEFAULT_MODE                  SPI_MODE_3
+
+/* Environment variables */
+#if !defined(CONFIG_AS4610_30_RECOVERY)
+#undef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_SPI_FLASH              1
+#endif
+#define CONFIG_ENV_ADDR                         0x1e0f0000
+#define CONFIG_ENV_OFFSET                       0xf0000
+#define CONFIG_ENV_SPI_MAX_HZ                   10000000
+#define CONFIG_ENV_SPI_MODE                     SPI_MODE_3
+#define CONFIG_ENV_SPI_BUS                      CONFIG_IPROC_QSPI_BUS
+#define CONFIG_ENV_SPI_CS                       CONFIG_IPROC_QSPI_CS
+#define CONFIG_ENV_SECT_SIZE                    0x10000     /* 64KB */
+
+/*
+ * EEPROM -- AS4610 uses a 16Kbit I2C EEPROM (AT24C16C-SSHM-T)
+ * I2C address 0x50 - 0x57, sitting begind a PCA9548 mux at 
+ * I2C address 
+ */
+#define CONFIG_SYS_EEPROM_USE_COMMON_I2C_IO         /* I2C based EEPROM */
+#define CONFIG_CMD_EEPROM                           /* EEPROM read/write support */
+#define CONFIG_SYS_I2C_MAC_OFFSET
+#define CONFIG_SYS_EEPROM_BUS_NUM           1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS   0       /* Helix4 iProc SMBUS driver only supports byte accesses for AT24 EEPROM */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS   5
+#define CONFIG_SYS_I2C_EEPROM_MUX_ADDR      0x70    /* EEPROM sits behind an I2C mux */
+#define CONFIG_SYS_I2C_EEPROM_MUX_CTRL      0       /* I2C mux control register */
+#define CONFIG_SYS_I2C_EEPROM_MUX_CHAN      7       /* EEPROM is accessible via mux channel 7 */
+#define CONFIG_SYS_I2C_EEPROM_ADDR          0x50
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN      1       /* 8-bit addressing */
+#define CONFIG_CMD_SYS_EEPROM                       /* TLV EEPROM format */
+#define CONFIG_SYS_EEPROM_OFFSET            0
+#define CONFIG_SYS_EEPROM_MAX_SIZE          0x800   /* Use the whole 16Kbit */
+#define CONFIG_SYS_EEPROM_LOAD_ENV_MAC
+#define CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS 1
+
+/* I2C */
+#define CONFIG_CMD_I2C
+#define CONFIG_IPROC_I2C
+#define CONFIG_SYS_I2C_SPEED    1       /* Default to 400KHz */
+#define CONFIG_SYS_I2C_SLAVE    0xff    /* No slave address */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_SYS_MAX_I2C_BUS  3       /* 2x IPROC + 1x CMIC */
+
+/* Environment variables for NAND flash */
+#define CONFIG_SYS_MAX_NAND_DEVICE			1
+#define CONFIG_SYS_NAND_BASE		        0xdeadbeef
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_INITRD_TAG        1       /*  send initrd params           */
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_MTD_DEVICE
+
+#ifdef CONFIG_RUN_DDR_SHMOO2
+/* Shmoo reuse: skip Shmoo process by reusing values saved in flash. */
+#define CONFIG_SHMOO_REUSE
+/* Define it for 32bit DDR */
+#define CONFIG_SHMOO_REUSE_DDR_32BIT            1
+/* Offset of spi flash to save Shmoo values */
+#define CONFIG_SHMOO_REUSE_QSPI_OFFSET          0x000e0000
+/* Sector size containing Shmoo values */
+#define CONFIG_SHMOO_REUSE_QSPI_SIZE            0x10000 /* 64KB */
+/* Offset of NAND flash to save Shmoo values */
+#define CONFIG_SHMOO_REUSE_NAND_OFFSET          0x00160000
+/* Range for the partition to support NAND bad blocks replacement */
+#define CONFIG_SHMOO_REUSE_NAND_RANGE           0x00040000
+/* Delay to wait for the magic character to force Shmoo; 0 to disable delay */
+#define CONFIG_SHMOO_REUSE_DELAY_MSECS          500
+/* Length of memory test after restored; 0 to disable memory test */
+#define CONFIG_SHMOO_REUSE_MEMTEST_LENGTH       (0x200000)
+/* Starting address of memory test after restored */
+#define CONFIG_SHMOO_REUSE_MEMTEST_START        IPROC_DDR_MEM_BASE2
+#endif /* CONFIG_RUN_DDR_SHMOO2 */
+
+#define CONFIG_HOSTNAME		accton-as4610_30-unknown
+
+/*
+** Platform environment variables needed by the common env
+** infrastructure.
+**
+*/
+#define CONFIG_PLATFORM_ENV	\
+ "consoledev=ttyS0\0"		\
+ "onie_start=0x1e100000\0"	\
+ "onie_sz.b=0x00700000\0" \
+ "initrd_high=0xffffffff\0"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS	\
+ CONFIG_PLATFORM_ENV			\
+ CONFIG_ONIE_COMMON_UBOOT_ENV
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/iproc_common_configs.h b/include/configs/iproc_common_configs.h
index 1e9dca8..874b997 100644
--- a/include/configs/iproc_common_configs.h
+++ b/include/configs/iproc_common_configs.h
@@ -5,11 +5,7 @@
 #define CONFIG_SYS_NS16550
 #define CONFIG_SYS_NS16550_SERIAL
 #define CONFIG_CONS_INDEX					1
-#if defined(CONFIG_HURRICANE2) && !defined(CONFIG_HURRICANE2_EMULATION)
 #define CONFIG_SYS_NS16550_COM1			(0x18000400) /* CCA UART 1 */
-#else
-#define CONFIG_SYS_NS16550_COM1			(0x18000300) /* CCA UART 0 */
-#endif
 #define CONFIG_SYS_NS16550_REG_SIZE		(1)	/* no padding */
 #define CONFIG_SYS_NS16550_CLK			iproc_get_uart_clk(0)
 #if defined(CONFIG_HURRICANE2_EMULATION)
@@ -17,38 +13,10 @@
 #else
 #define CONFIG_BAUDRATE					115200
 #endif
+#ifdef CONFIG_SYS_BAUDRATE_TABLE
+#undef CONFIG_SYS_BAUDRATE_TABLE
 #define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200} 
+#endif
 
-#define CONFIG_STANDALONE_LOAD_ADDR 0x61000000
-
-#define CONFIG_BOOTFILE         "uImage"
 #define CONFIG_MACH_TYPE        4735
-#define CONFIG_BOOTARGS     				"console=ttyS0,115200n8 maxcpus=1 mem=496M"
-
-#define CONFIG_BOOTDELAY			3	/* User can hit a key to abort kernel boot and stay in uboot cmdline */
-#define CONFIG_BOOTCOMMAND 				""	/* UBoot command issued on power up */
-#define CONFIG_SYS_PROMPT					"u-boot> "  
-
-#define CONFIG_CMD_SAVEENV
-
-#define CONFIG_INITRD_TAG        1       /*  send initrd params           */
-#define CONFIG_CMD_CONSOLE
-#define CONFIG_CMD_NET
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_MEMORY
-#define CONFIG_CMD_RUN
-#define CONFIG_CMD_MTDPARTS
-#define CONFIG_MTD_DEVICE
-#define MTDIDS_DEFAULT      "nand0=nand_iproc.0"
-#define MTDPARTS_DEFAULT    "mtdparts=mtdparts=nand_iproc.0:1024k(nboot),1024k(nenv),8192k(nsystem),1038336k(ndata)"
-#define CONFIG_SYS_HUSH_PARSER
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_BOOT
-#define CONFIG_CMD_LICENSE
-#define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ITEST
-#define CONFIG_CMD_MISC
-#define CONFIG_CMD_SOURCE
-
-
 #endif /* _IPROC_COMMON_H_ */
diff --git a/include/exports.h b/include/exports.h
index 63aa4b2..793f6a2 100644
--- a/include/exports.h
+++ b/include/exports.h
@@ -24,6 +24,7 @@ int setenv (const char *varname, const char *varvalue);
 long simple_strtol(const char *cp,char **endp,unsigned int base);
 int strcmp(const char * cs,const char * ct);
 int ustrtoul(const char *cp, char **endp, unsigned int base);
+unsigned long long ustrtoull(const char *cp, char **endp, unsigned int base);
 #if defined(CONFIG_CMD_I2C)
 int i2c_write (uchar, uint, int , uchar* , int);
 int i2c_read (uchar, uint, int , uchar* , int);
diff --git a/include/iproc_i2c.h b/include/iproc_i2c.h
index 26aee00..3f8ac3d 100644
--- a/include/iproc_i2c.h
+++ b/include/iproc_i2c.h
@@ -57,7 +57,7 @@ typedef enum iproc_smb_error_code {
 
 /* Structure used to pass information to read/write functions. */
 struct iproc_xact_info {
-    unsigned char command; /* Passed by caller to send SMBus command code */
+    unsigned short command; /* Passed by caller to send SMBus command code */
     unsigned char *data; /* actual data pased by the caller */
     unsigned int size; /* Size of data buffer passed */
     unsigned short flags; /* Sent by caller specifying PEC, 10-bit addresses */
diff --git a/include/part.h b/include/part.h
index 27ea283..c58a734 100644
--- a/include/part.h
+++ b/include/part.h
@@ -176,10 +176,62 @@ int   test_part_amiga (block_dev_desc_t *dev_desc);
 #endif
 
 #ifdef CONFIG_EFI_PARTITION
+#include <part_efi.h>
 /* disk/part_efi.c */
 int get_partition_info_efi (block_dev_desc_t * dev_desc, int part, disk_partition_t *info);
 void print_part_efi (block_dev_desc_t *dev_desc);
 int   test_part_efi (block_dev_desc_t *dev_desc);
+
+/**
+ * write_gpt_table() - Write the GUID Partition Table to disk
+ *
+ * @param dev_desc - block device descriptor
+ * @param gpt_h - pointer to GPT header representation
+ * @param gpt_e - pointer to GPT partition table entries
+ *
+ * @return - zero on success, otherwise error
+ */
+int write_gpt_table(block_dev_desc_t *dev_desc,
+		  gpt_header *gpt_h, gpt_entry *gpt_e);
+
+/**
+ * gpt_fill_pte(): Fill the GPT partition table entry
+ *
+ * @param gpt_h - GPT header representation
+ * @param gpt_e - GPT partition table entries
+ * @param partitions - list of partitions
+ * @param parts - number of partitions
+ *
+ * @return zero on success
+ */
+int gpt_fill_pte(gpt_header *gpt_h, gpt_entry *gpt_e,
+		disk_partition_t *partitions, int parts);
+
+/**
+ * gpt_fill_header(): Fill the GPT header
+ *
+ * @param dev_desc - block device descriptor
+ * @param gpt_h - GPT header representation
+ * @param str_guid - disk guid string representation
+ * @param parts_count - number of partitions
+ *
+ * @return - error on str_guid conversion error
+ */
+int gpt_fill_header(block_dev_desc_t *dev_desc, gpt_header *gpt_h,
+		char *str_guid, int parts_count);
+
+/**
+ * gpt_restore(): Restore GPT partition table
+ *
+ * @param dev_desc - block device descriptor
+ * @param str_disk_guid - disk GUID
+ * @param partitions - list of partitions
+ * @param parts - number of partitions
+ *
+ * @return zero on success
+ */
+int gpt_restore(block_dev_desc_t *dev_desc, char *str_disk_guid,
+		disk_partition_t *partitions, const int parts_count);
 #endif
 
 #endif /* _PART_H */
diff --git a/include/part_efi.h b/include/part_efi.h
new file mode 100644
index 0000000..6de0a32
--- /dev/null
+++ b/include/part_efi.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2008 RuggedCom, Inc.
+ * Richard Retanubun <RichardRetanubun@RuggedCom.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * See also linux/fs/partitions/efi.h
+ *
+ * EFI GUID Partition Table
+ * Per Intel EFI Specification v1.02
+ * http://developer.intel.com/technology/efi/efi.htm
+*/
+
+#include <linux/compiler.h>
+
+#ifndef _DISK_PART_EFI_H
+#define _DISK_PART_EFI_H
+
+#define MSDOS_MBR_SIGNATURE 0xAA55
+#define EFI_PMBR_OSTYPE_EFI 0xEF
+#define EFI_PMBR_OSTYPE_EFI_GPT 0xEE
+
+#define GPT_BLOCK_SIZE 512
+#define GPT_HEADER_SIGNATURE 0x5452415020494645ULL
+#define GPT_HEADER_REVISION_V1 0x00010000
+#define GPT_PRIMARY_PARTITION_TABLE_LBA 1ULL
+#define GPT_ENTRY_NAME "gpt"
+#define GPT_ENTRY_NUMBERS		128
+#define GPT_ENTRY_SIZE			128
+
+#define EFI_GUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
+	((efi_guid_t) \
+	{{ (a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, ((a) >> 24) & 0xff, \
+		(b) & 0xff, ((b) >> 8) & 0xff, \
+		(c) & 0xff, ((c) >> 8) & 0xff, \
+		(d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
+
+#define PARTITION_SYSTEM_GUID \
+	EFI_GUID( 0xC12A7328, 0xF81F, 0x11d2, \
+		0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B)
+#define LEGACY_MBR_PARTITION_GUID \
+	EFI_GUID( 0x024DEE41, 0x33E7, 0x11d3, \
+		0x9D, 0x69, 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F)
+#define PARTITION_MSFT_RESERVED_GUID \
+	EFI_GUID( 0xE3C9E316, 0x0B5C, 0x4DB8, \
+		0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE)
+#define PARTITION_BASIC_DATA_GUID \
+	EFI_GUID( 0xEBD0A0A2, 0xB9E5, 0x4433, \
+		0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7)
+#define PARTITION_LINUX_RAID_GUID \
+	EFI_GUID( 0xa19d880f, 0x05fc, 0x4d3b, \
+		0xa0, 0x06, 0x74, 0x3f, 0x0f, 0x84, 0x91, 0x1e)
+#define PARTITION_LINUX_SWAP_GUID \
+	EFI_GUID( 0x0657fd6d, 0xa4ab, 0x43c4, \
+		0x84, 0xe5, 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f)
+#define PARTITION_LINUX_LVM_GUID \
+	EFI_GUID( 0xe6d6d379, 0xf507, 0x44c2, \
+		0xa2, 0x3c, 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28)
+
+/* linux/include/efi.h */
+typedef u16 efi_char16_t;
+
+typedef struct {
+	u8 b[16];
+} efi_guid_t;
+
+/* based on linux/include/genhd.h */
+struct partition {
+	u8 boot_ind;		/* 0x80 - active */
+	u8 head;		/* starting head */
+	u8 sector;		/* starting sector */
+	u8 cyl;			/* starting cylinder */
+	u8 sys_ind;		/* What partition type */
+	u8 end_head;		/* end head */
+	u8 end_sector;		/* end sector */
+	u8 end_cyl;		/* end cylinder */
+	__le32 start_sect;	/* starting sector counting from 0 */
+	__le32 nr_sects;	/* nr of sectors in partition */
+} __packed;
+
+/* based on linux/fs/partitions/efi.h */
+typedef struct _gpt_header {
+	__le64 signature;
+	__le32 revision;
+	__le32 header_size;
+	__le32 header_crc32;
+	__le32 reserved1;
+	__le64 my_lba;
+	__le64 alternate_lba;
+	__le64 first_usable_lba;
+	__le64 last_usable_lba;
+	efi_guid_t disk_guid;
+	__le64 partition_entry_lba;
+	__le32 num_partition_entries;
+	__le32 sizeof_partition_entry;
+	__le32 partition_entry_array_crc32;
+	u8 reserved2[GPT_BLOCK_SIZE - 92];
+} __packed gpt_header;
+
+typedef union _gpt_entry_attributes {
+	struct {
+		u64 required_to_function:1;
+		u64 no_block_io_protocol:1;
+		u64 legacy_bios_bootable:1;
+		u64 reserved:45;
+		u64 type_guid_specific:16;
+	} fields;
+	unsigned long long raw;
+} __packed gpt_entry_attributes;
+
+#define PARTNAME_SZ	(72 / sizeof(efi_char16_t))
+typedef struct _gpt_entry {
+	efi_guid_t partition_type_guid;
+	efi_guid_t unique_partition_guid;
+	__le64 starting_lba;
+	__le64 ending_lba;
+	gpt_entry_attributes attributes;
+	efi_char16_t partition_name[PARTNAME_SZ];
+} __packed gpt_entry;
+
+typedef struct _legacy_mbr {
+	u8 boot_code[440];
+	__le32 unique_mbr_signature;
+	__le16 unknown;
+	struct partition partition_record[4];
+	__le16 signature;
+} __packed legacy_mbr;
+
+#endif	/* _DISK_PART_EFI_H */
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index e38a4b7..b939326 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -121,6 +121,29 @@ int ustrtoul(const char *cp, char **endp, unsigned int base)
 	return result;
 }
 
+unsigned long long ustrtoull(const char *cp, char **endp, unsigned int base)
+{
+       unsigned long long result = simple_strtoull(cp, endp, base);
+       switch (**endp) {
+       case 'G':
+               result *= 1024;
+               /* fall through */
+       case 'M':
+               result *= 1024;
+               /* fall through */
+       case 'K':
+       case 'k':
+               result *= 1024;
+               if ((*endp)[1] == 'i') {
+                       if ((*endp)[2] == 'B')
+                               (*endp) += 3;
+                       else
+                               (*endp) += 2;
+               }
+       }
+      return result;
+}
+
 unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
 {
 	unsigned long long result = 0, value;
