Platform support for the Accton as6700_32x

diff --git a/MAINTAINERS b/MAINTAINERS
index 28c052d..d3ed390 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -27,6 +27,10 @@ Poonam Aggrwal <poonam.aggrwal@freescale.com>
 
 	BSC9131RDB	BSC9131
 
+Naveen Burmi <NaveenBurmi@freescale.com>
+
+	BSC9132QDS	BSC9132
+
 Greg Allen <gallen@arlut.utexas.edu>
 
 	UTX8245		MPC8245
diff --git a/Makefile b/Makefile
index 8dd09a5..08c377c 100644
--- a/Makefile
+++ b/Makefile
@@ -23,7 +23,7 @@
 
 VERSION = 2013
 PATCHLEVEL = 01
-SUBLEVEL = 01
+SUBLEVEL =
 EXTRAVERSION =
 ifneq "$(SUBLEVEL)" ""
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
@@ -332,6 +332,7 @@ LIBS-y += common/libcommon.o
 LIBS-y += lib/libfdt/libfdt.o
 LIBS-y += api/libapi.o
 LIBS-y += post/libpost.o
+LIBS-y += drivers/sec/libsec.o
 LIBS-y += test/libtest.o
 
 ifneq ($(CONFIG_AM33XX)$(CONFIG_OMAP34XX)$(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX),)
@@ -728,6 +729,13 @@ tools: $(VERSION_FILE) $(TIMESTAMP_FILE)
 	$(MAKE) -C $@ all
 endif	# config.mk
 
+# ARM relocations should all be R_ARM_RELATIVE.
+checkarmreloc: $(obj)u-boot
+	@if test "R_ARM_RELATIVE" != \
+        "`readelf -r $< | cut -d ' ' -f 4 | grep R_ARM | sort -u`"; \
+        then echo "$< contains relocations other than \
+        R_ARM_RELATIVE"; false; fi
+
 $(VERSION_FILE):
 		@mkdir -p $(dir $(VERSION_FILE))
 		@( localvers='$(shell $(TOPDIR)/tools/setlocalversion $(TOPDIR))' ; \
diff --git a/README b/README
index e016b91..35998c7 100644
--- a/README
+++ b/README
@@ -414,11 +414,41 @@ The following options need to be configured:
 		See Freescale App Note 4493 for more information about
 		this erratum.
 
+		CONFIG_A003399_NOR_WORKAROUND
+		Enables a workaround for IFC erratum A003399. It is only
+		requred during NOR boot.
+
 		CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY
 
 		This is the value to write into CCSR offset 0x18600
 		according to the A004510 workaround.
 
+		CONFIG_SYS_FSL_DDR_EMU
+
+		Specify emulator support for DDR. Some DDR features such as deskew training
+		are not available.
+
+		CONFIG_SYS_FSL_DSP_DDR_ADDR
+		This value denotes start offset of DDR memory which is
+		connected exclusively to the DSP cores.
+
+		CONFIG_SYS_FSL_DSP_M2_RAM_ADDR
+		This value denotes start offset of M2 memory which is directly
+		connected to the DSP core.
+
+		CONFIG_SYS_FSL_DSP_M3_RAM_ADDR
+		This value denotes start offset of M3 memory which is directly
+		connected to the DSP core.
+
+		CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT
+		This value denotes start offset of DSP CCSR space.
+
+		CONFIG_SYS_FSL_SFP_VER_3_0
+		This indicates that the version of SFP block on the platform is 3.0
+
+		CONFIG_SYS_FSL_ISBC_VER
+		This value indicates the major ISBC version on the platform.
+
 - Generic CPU options:
 		CONFIG_SYS_BIG_ENDIAN, CONFIG_SYS_LITTLE_ENDIAN
 
@@ -545,19 +575,6 @@ The following options need to be configured:
 		crash. This is needed for buggy hardware (uc101) where
 		no pull down resistor is connected to the signal IDE5V_DD7.
 
-                CONFIG_FDT_ENV_SIZE
-
-                When fixing up the device tree before booting store
-                the value of the CONFIG_ENV_SIZE macro in the device
-                tree.  This allows the OS to know how the environment
-                area is defined.
-
-                The method first finds the FDT node with a property
-                called "label" whose value is "uboot-env".
-
-                If the node is found then set the "env_size" property to
-                CONFIG_ENV_SIZE.
-
 		CONFIG_MACH_TYPE	[relevant for ARM only][mandatory]
 
 		This setting is mandatory for all boards that have only one
@@ -822,6 +839,7 @@ The following options need to be configured:
 		CONFIG_CMD_BSP		* Board specific commands
 		CONFIG_CMD_BOOTD	  bootd
 		CONFIG_CMD_CACHE	* icache, dcache
+		CONFIG_CMD_CACHE_FLUSH	* flush cache by the address and range
 		CONFIG_CMD_CONSOLE	  coninfo
 		CONFIG_CMD_CRC32	* crc32
 		CONFIG_CMD_DATE		* support for RTC, date/time...
@@ -925,7 +943,9 @@ The following options need to be configured:
 		8260 (where accesses to the IMMR region must be
 		uncached), and it cannot be disabled on all other
 		systems where we (mis-) use the data cache to hold an
-		initial stack and some data.
+		initial stack and some data. The CONFIG_CMD_CACHE_FLUSH
+		macro enables flushing cache by the address and range to
+		maintain coherency if required by architecture.
 
 
 		XXX - this list needs to get updated!
@@ -1762,11 +1782,11 @@ CBFS (Coreboot Filesystem) support
 		of the "hostname" environment variable is passed as
 		option 12 to the DHCP server.
 
-		CONFIG_BOOTP_OPTIONS - The environment is checked for the
-		supported DHCPv4 client options (prefixed with dhcp_), any
-		found are sent during a "DHCP Discover" and "DHCP Request".
-		The DHCP server can use this information to conditionally
-		tailor it's response.
+        CONFIG_BOOTP_OPTIONS - The environment is checked for the
+        supported DHCPv4 client options (prefixed with dhcp_), any
+        found are sent during a "DHCP Discover" and "DHCP Request".
+        The DHCP server can use this information to conditionally
+        tailor it's response.
 
 		CONFIG_BOOTP_DHCP_REQUEST_DELAY
 
@@ -2416,12 +2436,12 @@ CBFS (Coreboot Filesystem) support
 		this is instead controlled by the value of
 		/config/load-environment.
 
-                CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
+        CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
 
-                During boot up, specifically in board_init_r() after
-                last_stage_init(), the CRC of the non-volatile
-                environment is checked.  If the environment is corrupt
-                then write the default environment with a valid CRC.
+        During boot up, specifically in board_init_r() after
+        last_stage_init(), the CRC of the non-volatile
+        environment is checked.  If the environment is corrupt
+        then write the default environment with a valid CRC.
 
 - DataFlash Support:
 		CONFIG_HAS_DATAFLASH
@@ -2454,6 +2474,17 @@ CBFS (Coreboot Filesystem) support
 		Define this option to include a destructive SPI flash
 		test ('sf test').
 
+        CONFIG_SPI_FLASH_BAR            Ban/Extended Addr Reg
+
+        Define this option to use the Bank addr/Extended addr
+        support on SPI flashes which has size > 16Mbytes.
+
+        CONFIG_SF_DUAL_FLASH            Dual flash memories
+
+        Define this option to use dual flash support where two flash
+        memories can be connected with a given cs line.
+        currently Xilinx Zynq qspi support these type of connections.
+
 - SystemACE Support:
 		CONFIG_SYSTEMACE
 
@@ -2903,6 +2934,14 @@ FIT uImage format:
 		CONFIG_SPL_LIBGENERIC_SUPPORT
 		Support for lib/libgeneric.o in SPL binary
 
+        CONFIG_SPL_ENV_SUPPORT
+        Support for the environment operating in SPL binary
+
+        CONFIG_SPL_NET_SUPPORT
+        Support for the net/libnet.o in SPL binary.
+        It conflicts with SPL env from storage medium specified by
+        CONFIG_ENV_IS_xxx but CONFIG_ENV_IS_NOWHERE
+
 		CONFIG_SPL_TARGET
 		Final target image containing SPL and payload.  Some SPLs
 		use an arch-specific makefile fragment instead, for
@@ -3726,6 +3765,9 @@ Low Level (hardware related) configuration options:
 - CONFIG_SRIO2:
 		Board has SRIO 2 port available
 
+- CONFIG_SRIO_PCIE_BOOT_MASTER
+		Board can support master function for Boot from SRIO and PCIE
+
 - CONFIG_SYS_SRIOn_MEM_VIRT:
 		Virtual Address of SRIO port 'n' memory region
 
@@ -3832,6 +3874,11 @@ Low Level (hardware related) configuration options:
 		that is executed before the actual U-Boot. E.g. when
 		compiling a NAND SPL.
 
+- CONFIG_SYS_MPC85XX_NO_RESETVEC
+               Only for 85xx systems. If this variable is specified, the section
+               .resetvec is not kept and the section .bootpg is placed in the
+               previous 4k of the .text section.
+
 - CONFIG_USE_ARCH_MEMCPY
   CONFIG_USE_ARCH_MEMSET
 		If these options are used a optimized version of memcpy/memset will
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
index 9f861cc..cfe32cc 100644
--- a/arch/arm/lib/board.c
+++ b/arch/arm/lib/board.c
@@ -488,7 +488,7 @@ static char *failed = "*** failed ***\n";
 static int should_load_env(void)
 {
 #ifdef CONFIG_OF_CONTROL
-	return fdtdec_get_config_int(gd->fdt_blob, "load-environment", 1);
+	return fdtdec_get_config_int(gd->fdt_blob, "load-environment", 0);
 #elif defined CONFIG_DELAY_ENVIRONMENT
 	return 0;
 #else
diff --git a/arch/powerpc/cpu/mpc83xx/pcie.c b/arch/powerpc/cpu/mpc83xx/pcie.c
index 52d4461..c1b0792 100644
--- a/arch/powerpc/cpu/mpc83xx/pcie.c
+++ b/arch/powerpc/cpu/mpc83xx/pcie.c
@@ -312,6 +312,8 @@ static void mpc83xx_pcie_init_bus(int bus, struct pci_region *reg)
 
 	printf("PCIE%d: ", bus);
 
+#define PCI_LTSSM	0x404 /* PCIe Link Training, Status State Machine */
+#define PCI_LTSSM_L0	0x16 /* L0 state */
 	reg16 = in_le16(hose_cfg_base + PCI_LTSSM);
 	if (reg16 >= PCI_LTSSM_L0)
 		printf("link\n");
diff --git a/arch/powerpc/cpu/mpc83xx/start.S b/arch/powerpc/cpu/mpc83xx/start.S
index b70b4ca..b7d95e0 100644
--- a/arch/powerpc/cpu/mpc83xx/start.S
+++ b/arch/powerpc/cpu/mpc83xx/start.S
@@ -130,6 +130,11 @@ disable_addr_trans:
 	mtspr	SRR1, r3
 	rfi
 
+	.globl get_svr
+get_svr:
+	mfspr	r3, SVR
+	blr
+
 	.globl get_pvr
 get_pvr:
 	mfspr	r3, PVR
diff --git a/arch/powerpc/cpu/mpc85xx/Makefile b/arch/powerpc/cpu/mpc85xx/Makefile
index 4c2b104..cefd57b 100644
--- a/arch/powerpc/cpu/mpc85xx/Makefile
+++ b/arch/powerpc/cpu/mpc85xx/Makefile
@@ -62,6 +62,7 @@ COBJS-$(CONFIG_MPC8568) += ddr-gen2.o
 COBJS-$(CONFIG_MPC8544) += ddr-gen2.o
 
 # supports ddr1/2/3
+COBJS-$(CONFIG_C29X)	+= ddr-gen3.o
 COBJS-$(CONFIG_MPC8572) += ddr-gen3.o
 COBJS-$(CONFIG_MPC8536) += ddr-gen3.o
 COBJS-$(CONFIG_MPC8569)	+= ddr-gen3.o
@@ -73,6 +74,7 @@ COBJS-$(CONFIG_P1014)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1020)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1021)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1022)	+= ddr-gen3.o
+COBJS-$(CONFIG_P1023)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1024)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1025)	+= ddr-gen3.o
 COBJS-$(CONFIG_P2010)	+= ddr-gen3.o
@@ -83,8 +85,12 @@ COBJS-$(CONFIG_PPC_P4080)	+= ddr-gen3.o
 COBJS-$(CONFIG_PPC_P5020)	+= ddr-gen3.o
 COBJS-$(CONFIG_PPC_P5040)	+= ddr-gen3.o
 COBJS-$(CONFIG_PPC_T4240)	+= ddr-gen3.o
+COBJS-$(CONFIG_PPC_T4160)	+= ddr-gen3.o
+COBJS-$(CONFIG_PPC_B4420)	+= ddr-gen3.o
 COBJS-$(CONFIG_PPC_B4860)	+= ddr-gen3.o
 COBJS-$(CONFIG_BSC9131)		+= ddr-gen3.o
+COBJS-$(CONFIG_BSC9132)		+= ddr-gen3.o
+COBJS-$(CONFIG_PPC_T1040)	+= ddr-gen3.o
 
 COBJS-$(CONFIG_CPM2)	+= ether_fcc.o
 COBJS-$(CONFIG_OF_LIBFDT) += fdt.o
@@ -100,14 +106,20 @@ COBJS-$(CONFIG_PPC_P4080) += p4080_ids.o
 COBJS-$(CONFIG_PPC_P5020) += p5020_ids.o
 COBJS-$(CONFIG_PPC_P5040) += p5040_ids.o
 COBJS-$(CONFIG_PPC_T4240) += t4240_ids.o
+COBJS-$(CONFIG_PPC_T4160) += t4240_ids.o
+COBJS-$(CONFIG_PPC_B4420) += b4860_ids.o
 COBJS-$(CONFIG_PPC_B4860) += b4860_ids.o
+COBJS-$(CONFIG_PPC_T1040) += t1040_ids.o
 
 COBJS-$(CONFIG_QE)	+= qe_io.o
 COBJS-$(CONFIG_CPM2)	+= serial_scc.o
 COBJS-$(CONFIG_SYS_FSL_QORIQ_CHASSIS1) += fsl_corenet_serdes.o
 COBJS-$(CONFIG_SYS_FSL_QORIQ_CHASSIS2) += fsl_corenet2_serdes.o
+COBJS-$(CONFIG_SECURE_BOOT) += fsl_sfp_snvs.o
+COBJS-$(CONFIG_CMD_ESBC_VALIDATE) += cmd_esbc_validate.o fsl_validate.o
 
 # SoC specific SERDES support
+COBJS-$(CONFIG_C29X)	+= c29x_serdes.o
 COBJS-$(CONFIG_MPC8536) += mpc8536_serdes.o
 COBJS-$(CONFIG_MPC8544) += mpc8544_serdes.o
 COBJS-$(CONFIG_MPC8548) += mpc8548_serdes.o
@@ -134,7 +146,11 @@ COBJS-$(CONFIG_PPC_P4080) += p4080_serdes.o
 COBJS-$(CONFIG_PPC_P5020) += p5020_serdes.o
 COBJS-$(CONFIG_PPC_P5040) += p5040_serdes.o
 COBJS-$(CONFIG_PPC_T4240) += t4240_serdes.o
+COBJS-$(CONFIG_PPC_T4160) += t4240_serdes.o
+COBJS-$(CONFIG_PPC_B4420) += b4860_serdes.o
 COBJS-$(CONFIG_PPC_B4860) += b4860_serdes.o
+COBJS-$(CONFIG_BSC9132) += bsc9132_serdes.o
+COBJS-$(CONFIG_PPC_T1040) += t1040_serdes.o
 
 COBJS-y	+= cpu.o
 COBJS-y	+= cpu_init.o
diff --git a/arch/powerpc/cpu/mpc85xx/b4860_ids.c b/arch/powerpc/cpu/mpc85xx/b4860_ids.c
index 7d33731..843ae7e 100644
--- a/arch/powerpc/cpu/mpc85xx/b4860_ids.c
+++ b/arch/powerpc/cpu/mpc85xx/b4860_ids.c
@@ -55,11 +55,13 @@ struct qportal_info qp_info[CONFIG_SYS_QMAN_NUM_PORTALS] = {
 };
 #endif
 
+#ifdef CONFIG_SYS_SRIO
 struct srio_liodn_id_table srio_liodn_tbl[] = {
-	SET_SRIO_LIODN_1(1, 307),
-	SET_SRIO_LIODN_1(2, 387),
+	SET_SRIO_LIODN_BASE(1, 307),
+	SET_SRIO_LIODN_BASE(2, 387),
 };
 int srio_liodn_tbl_sz = ARRAY_SIZE(srio_liodn_tbl);
+#endif
 
 struct liodn_id_table liodn_tbl[] = {
 #ifdef CONFIG_SYS_DPAA_QBMAN
@@ -69,17 +71,19 @@ struct liodn_id_table liodn_tbl[] = {
 
 	SET_SDHC_LIODN(1, 552),
 
-	SET_USB_LIODN(1, "fsl-usb2-mph", 553),
+	SET_USB_LIODN(1, "fsl-usb2-dr", 553),
 
-	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 1, 148),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 1, 148),
 
 	SET_DMA_LIODN(1, 147),
 	SET_DMA_LIODN(2, 227),
 
+#ifndef CONFIG_PPC_B4420
 	SET_GUTS_LIODN("fsl,rapidio-delta", 199, rio1liodnr, 0),
 	SET_GUTS_LIODN(NULL, 200, rio2liodnr, 0),
 	SET_GUTS_LIODN(NULL, 201, rio1maintliodnr, 0),
 	SET_GUTS_LIODN(NULL, 202, rio2maintliodnr, 0),
+#endif
 
 	/* SET_NEXUS_LIODN(557), -- not yet implemented */
 };
@@ -93,8 +97,10 @@ struct liodn_id_table fman1_liodn_tbl[] = {
 	SET_FMAN_RX_1G_LIODN(1, 3, 91),
 	SET_FMAN_RX_1G_LIODN(1, 4, 92),
 	SET_FMAN_RX_1G_LIODN(1, 5, 93),
+#ifndef CONFIG_PPC_B4420
 	SET_FMAN_RX_10G_LIODN(1, 0, 94),
 	SET_FMAN_RX_10G_LIODN(1, 1, 95),
+#endif
 };
 int fman1_liodn_tbl_sz = ARRAY_SIZE(fman1_liodn_tbl);
 #endif
@@ -122,10 +128,10 @@ int sec_liodn_tbl_sz = ARRAY_SIZE(sec_liodn_tbl);
 #ifdef CONFIG_SYS_DPAA_RMAN
 struct liodn_id_table rman_liodn_tbl[] = {
 	/* Set RMan block 0-3 liodn offset */
-	SET_RMAN_LIODN(0, 678),
-	SET_RMAN_LIODN(1, 679),
-	SET_RMAN_LIODN(2, 680),
-	SET_RMAN_LIODN(3, 681),
+	SET_RMAN_LIODN(0, 6),
+	SET_RMAN_LIODN(1, 7),
+	SET_RMAN_LIODN(2, 8),
+	SET_RMAN_LIODN(3, 9),
 };
 int rman_liodn_tbl_sz = ARRAY_SIZE(rman_liodn_tbl);
 #endif
diff --git a/arch/powerpc/cpu/mpc85xx/b4860_serdes.c b/arch/powerpc/cpu/mpc85xx/b4860_serdes.c
index 9990202..894c379 100644
--- a/arch/powerpc/cpu/mpc85xx/b4860_serdes.c
+++ b/arch/powerpc/cpu/mpc85xx/b4860_serdes.c
@@ -31,8 +31,27 @@ struct serdes_config {
 	u8 lanes[SRDS_MAX_LANES];
 };
 
+#ifdef CONFIG_PPC_B4860
 static struct serdes_config serdes1_cfg_tbl[] = {
 	/* SerDes 1 */
+	{0x02, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x04, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x05, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x06, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x08, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x09, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x0A, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x0B, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x0C, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
 	{0x0D, {CPRI8, CPRI7, CPRI6, CPRI5,
 		CPRI4, CPRI3, CPRI2, CPRI1}},
 	{0x0E, {CPRI8, CPRI7,	CPRI6, CPRI5,
@@ -41,6 +60,12 @@ static struct serdes_config serdes1_cfg_tbl[] = {
 		CPRI4, CPRI3, CPRI2, CPRI1}},
 	{0x2a, {SGMII_FM1_DTSEC5, SGMII_FM1_DTSEC6,
 		CPRI6, CPRI5, CPRI4, CPRI3, CPRI2, CPRI1}},
+	{0x2C, {SGMII_FM1_DTSEC5, SGMII_FM1_DTSEC6,
+		CPRI6, CPRI5, CPRI4, CPRI3, CPRI2, CPRI1}},
+	{0x2D, {SGMII_FM1_DTSEC5, SGMII_FM1_DTSEC6,
+		CPRI6, CPRI5, CPRI4, CPRI3, CPRI2, CPRI1}},
+	{0x2E, {SGMII_FM1_DTSEC5, SGMII_FM1_DTSEC6,
+		CPRI6, CPRI5, CPRI4, CPRI3, CPRI2, CPRI1}},
 	{0x30, {AURORA, AURORA,
 		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
 		CPRI4, CPRI3, CPRI2, CPRI1}},
@@ -53,8 +78,22 @@ static struct serdes_config serdes1_cfg_tbl[] = {
 	{0x34, {AURORA, AURORA,
 		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
 		CPRI4, CPRI3, CPRI2, CPRI1}},
+	{0x39, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x3A, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x3C, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x3D, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
 	{0x3E, {CPRI8, CPRI7,	CPRI6, CPRI5,
 		CPRI4, CPRI3, CPRI2, CPRI1}},
+	{0x5C, {AURORA, AURORA,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x5D, {AURORA, AURORA,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
 	{}
 };
 static struct serdes_config serdes2_cfg_tbl[] = {
@@ -84,6 +123,8 @@ static struct serdes_config serdes2_cfg_tbl[] = {
 	{0x4E, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
 		SGMII_FM1_DTSEC3, AURORA,
 		SRIO1, SRIO1, SRIO1, SRIO1}},
+	{0x7A, {SRIO2, SRIO2, SRIO2, SRIO2,
+		SRIO1, SRIO1, SRIO1, SRIO1}},
 	{0x84, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
 		SRIO2, SRIO2, AURORA, AURORA,
 		XFI_FM1_MAC9, XFI_FM1_MAC10}},
@@ -94,6 +135,9 @@ static struct serdes_config serdes2_cfg_tbl[] = {
 		SRIO2, SRIO2,
 		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
 		XFI_FM1_MAC9, XFI_FM1_MAC10}},
+	{0x8D, {SRIO2, SRIO2, SRIO2, SRIO2,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
+		XFI_FM1_MAC9, XFI_FM1_MAC10}},
 	{0x93, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
 		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
 		XAUI_FM1_MAC10, XAUI_FM1_MAC10,
@@ -111,8 +155,56 @@ static struct serdes_config serdes2_cfg_tbl[] = {
 	{0xC3, {XAUI_FM1_MAC9, XAUI_FM1_MAC9,
 		XAUI_FM1_MAC9, XAUI_FM1_MAC9,
 		SRIO1, SRIO1, SRIO1, SRIO1}},
+	{0x98, {XAUI_FM1_MAC9, XAUI_FM1_MAC9,
+		XAUI_FM1_MAC9, XAUI_FM1_MAC9,
+		XAUI_FM1_MAC10, XAUI_FM1_MAC10,
+		XAUI_FM1_MAC10, XAUI_FM1_MAC10}},
 	{}
 };
+#endif
+
+#ifdef CONFIG_PPC_B4420
+static struct serdes_config serdes1_cfg_tbl[] = {
+	{0x0D, {NONE, NONE, CPRI6, CPRI5,
+		CPRI4, CPRI3, NONE, NONE}},
+	{0x0E, {NONE, NONE, CPRI8, CPRI5,
+		CPRI4, CPRI3, NONE, NONE}},
+	{0x0F, {NONE, NONE, CPRI6, CPRI5,
+		CPRI4, CPRI3, NONE, NONE}},
+	{0x18, {NONE, NONE,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
+		NONE, NONE, NONE, NONE}},
+	{0x1B, {NONE, NONE,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
+		NONE, NONE, NONE, NONE}},
+	{0x1E, {NONE, NONE, AURORA, AURORA,
+		NONE, NONE, NONE, NONE}},
+	{0x21, {NONE, NONE, AURORA, AURORA,
+		NONE, NONE, NONE, NONE}},
+	{0x3E, {NONE, NONE, CPRI6, CPRI5,
+		CPRI4, CPRI3, NONE, NONE}},
+	{}
+};
+static struct serdes_config serdes2_cfg_tbl[] = {
+	{0x49, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		SGMII_FM1_DTSEC3, AURORA,
+		NONE, NONE, NONE, NONE}},
+	{0x4A, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		SGMII_FM1_DTSEC3, AURORA,
+		NONE, NONE, NONE, NONE}},
+	{0x6F, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		AURORA, AURORA,	NONE, NONE, NONE, NONE}},
+	{0x70, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		AURORA, AURORA,	NONE, NONE, NONE, NONE}},
+	{0x9A, {PCIE1, PCIE1,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
+		NONE, NONE, NONE, NONE}},
+	{0x9E, {PCIE1, PCIE1, PCIE1, PCIE1,
+		NONE, NONE, NONE, NONE}},
+	{}
+};
+#endif
+
 static struct serdes_config *serdes_cfg_tbl[] = {
 	serdes1_cfg_tbl,
 	serdes2_cfg_tbl,
diff --git a/arch/powerpc/cpu/mpc85xx/bsc9132_serdes.c b/arch/powerpc/cpu/mpc85xx/bsc9132_serdes.c
new file mode 100644
index 0000000..300a4db
--- /dev/null
+++ b/arch/powerpc/cpu/mpc85xx/bsc9132_serdes.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ * Author: Prabhakar Kushwaha <prabhakar@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+
+#define SRDS1_MAX_LANES		4
+
+static u32 serdes1_prtcl_map;
+
+static u8 serdes1_cfg_tbl[][SRDS1_MAX_LANES] = {
+	 [0] = {NONE, NONE, NONE, NONE},
+	 [1] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	 [2] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	 [3] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	 [4] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	 [5] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	 [6] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	 [7] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	 [8] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	 [9] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	[10] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	[11] = {PCIE1, PCIE2, SGMII_TSEC1, SGMII_TSEC2},
+	[12] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[13] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[14] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[15] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[16] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[17] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[18] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[19] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[20] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[21] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[22] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	[23] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	[24] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	[25] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	[26] = {PCIE1, PCIE2, CPRI2, CPRI1},
+	[27] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	[28] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	[29] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	[30] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	[31] = {PCIE1, PCIE2, SGMII_TSEC1, CPRI1},
+	[32] = {PCIE1, PCIE2, SGMII_TSEC1, SGMII_TSEC2},
+	[33] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[34] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[35] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[36] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[37] = {PCIE1, SGMII_TSEC2, CPRI2, CPRI1},
+	[38] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[39] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[40] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[41] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[42] = {PCIE1, SGMII_TSEC2, SGMII_TSEC1, CPRI1},
+	[43] = {SGMII_TSEC1, SGMII_TSEC2, CPRI2, CPRI1},
+	[44] = {SGMII_TSEC1, SGMII_TSEC2, CPRI2, CPRI1},
+	[45] = {SGMII_TSEC1, SGMII_TSEC2, CPRI2, CPRI1},
+	[46] = {SGMII_TSEC1, SGMII_TSEC2, CPRI2, CPRI1},
+	[47] = {SGMII_TSEC1, SGMII_TSEC2, CPRI2, CPRI1},
+};
+
+int is_serdes_configured(enum srds_prtcl prtcl)
+{
+	return (1 << prtcl) & serdes1_prtcl_map;
+}
+
+void fsl_serdes_init(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 pordevsr = in_be32(&gur->pordevsr);
+	u32 srds_cfg = (pordevsr & MPC85xx_PORDEVSR_IO_SEL) >>
+				MPC85xx_PORDEVSR_IO_SEL_SHIFT;
+	int lane;
+
+	debug("PORDEVSR[IO_SEL_SRDS] = %x\n", srds_cfg);
+
+	if (srds_cfg >= ARRAY_SIZE(serdes1_cfg_tbl)) {
+		printf("Invalid PORDEVSR[IO_SEL_SRDS] = %d\n", srds_cfg);
+		return;
+	}
+
+	for (lane = 0; lane < SRDS1_MAX_LANES; lane++) {
+		enum srds_prtcl lane_prtcl = serdes1_cfg_tbl[srds_cfg][lane];
+		serdes1_prtcl_map |= (1 << lane_prtcl);
+	}
+}
diff --git a/arch/powerpc/cpu/mpc85xx/c29x_serdes.c b/arch/powerpc/cpu/mpc85xx/c29x_serdes.c
new file mode 100644
index 0000000..4b3214d
--- /dev/null
+++ b/arch/powerpc/cpu/mpc85xx/c29x_serdes.c
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+
+#define SRDS1_MAX_LANES		4
+
+static u32 serdes1_prtcl_map;
+
+struct serdes_config {
+	u32 protocol;
+	u8 lanes[SRDS1_MAX_LANES];
+};
+
+static const struct serdes_config serdes1_cfg_tbl[] = {
+	/* SerDes 1 */
+	{1, {PCIE1, PCIE1, PCIE1, PCIE1} },
+	{2, {PCIE1, PCIE1, PCIE1, PCIE1} },
+	{3, {PCIE1, PCIE1, NONE, NONE} },
+	{4, {PCIE1, PCIE1, NONE, NONE} },
+	{5, {PCIE1, NONE, NONE, NONE} },
+	{6, {PCIE1, NONE, NONE, NONE} },
+	{}
+};
+
+int is_serdes_configured(enum srds_prtcl device)
+{
+	return (1 << device) & serdes1_prtcl_map;
+}
+
+void fsl_serdes_init(void)
+{
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+	u32 pordevsr = in_be32(&gur->pordevsr);
+	u32 srds_cfg = (pordevsr & MPC85xx_PORDEVSR_IO_SEL) >>
+				MPC85xx_PORDEVSR_IO_SEL_SHIFT;
+	const struct serdes_config *ptr;
+	int lane;
+
+	debug("PORDEVSR[IO_SEL_SRDS] = %x\n", srds_cfg);
+
+	if (srds_cfg > ARRAY_SIZE(serdes1_cfg_tbl)) {
+		printf("Invalid PORDEVSR[IO_SEL_SRDS] = %d\n", srds_cfg);
+		return;
+	}
+
+	ptr = &serdes1_cfg_tbl[srds_cfg];
+	if (!ptr->protocol)
+		return;
+
+	for (lane = 0; lane < SRDS1_MAX_LANES; lane++) {
+		enum srds_prtcl lane_prtcl = ptr->lanes[lane];
+		serdes1_prtcl_map |= (1 << lane_prtcl);
+	}
+}
diff --git a/arch/powerpc/cpu/mpc85xx/cmd_errata.c b/arch/powerpc/cpu/mpc85xx/cmd_errata.c
index e5ecf5d..8a72aa1 100644
--- a/arch/powerpc/cpu/mpc85xx/cmd_errata.c
+++ b/arch/powerpc/cpu/mpc85xx/cmd_errata.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -180,7 +180,8 @@ static int do_errata(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	puts("Work-around for Erratum ESDHC111 enabled\n");
 #endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_A004468
-	puts("Work-around for Erratum A004468 enabled\n");
+	if (SVR_SOC_VER(svr) == SVR_T4240 && SVR_MAJ(svr) < 2)
+		puts("Work-around for Erratum A004468 enabled\n");
 #endif
 #if defined(CONFIG_SYS_FSL_ERRATUM_ESDHC135)
 	puts("Work-around for Erratum ESDHC135 enabled\n");
@@ -211,6 +212,10 @@ static int do_errata(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	puts("Work-around for Erratum DDR111 enabled\n");
 	puts("Work-around for Erratum DDR134 enabled\n");
 #endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006918
+	if (IS_SVR_REV(svr, 1, 0))
+		puts("Work-around for Erratum A006918 enabled\n");
+#endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_IFC_A002769
 	puts("Work-around for Erratum IFC-A002769 enabled\n");
 #endif
@@ -231,14 +236,69 @@ static int do_errata(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if ((SVR_MAJ(svr) == 1) || IS_SVR_REV(svr, 2, 0))
 		puts("Work-around for Erratum NMG ETSEC129 enabled\n");
 #endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004390
+	if (SVR_MAJ(svr) == 1)
+		puts("Work-around for Erratum A004390 enabled\n");
+#endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_A004510
 	puts("Work-around for Erratum A004510 enabled\n");
 #endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004511
+	if ((svr & 0xff) == CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV)
+		puts("Work-around for Erratum A004511 enabled\n");
+#endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_SRIO_A004034
 	puts("Work-around for Erratum SRIO-A004034 enabled\n");
 #endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_A_004934
-	puts("Work-around for Erratum A004934 enabled\n");
+	if (SVR_MAJ(svr) == 1)
+		puts("Work-around for Erratum A004934 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_USB138
+	puts("Work-around for Erratum USB138 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ELBC_MULTIBIT_ECC
+	puts("Work-around for Erratum ELBC MULTIBIT ECC enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004809
+	if (PVR_MAJ(get_pvr()) == 1)
+		puts("Work-around for Erratum A004809 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004792
+	if (PVR_MAJ(get_pvr()) == 1)
+		puts("Work-around for Erratum A004792 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004779
+	if (PVR_MAJ(get_pvr()) == 1)
+		puts("Work-around for Erratum A004779 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004786
+	if (PVR_MAJ(get_pvr()) == 1)
+		puts("Work-around for Erratum A004786 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004806
+	if (PVR_MAJ(get_pvr()) == 1)
+		puts("Work-around for Erratum A004806 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004857
+	if (PVR_MAJ(get_pvr()) == 1)
+		puts("Work-around for Erratum A004857 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005475
+	if (SVR_MAJ(svr) == 1)
+		puts("Work-around for Erratum A005475 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005553
+	if (PVR_MAJ(get_pvr()) == 1)
+		puts("Work-around for Erratum A005553 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005871
+	if (IS_SVR_REV(svr, 1, 0))
+		puts("Work-around for Erratum A005871 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005977
+	if (IS_SVR_REV(svr, 1, 0))
+		puts("Work-around for Erratum A005977 enabled\n");
 #endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_A004849
 	/* This work-around is implemented in PBI, so just check for it */
@@ -251,6 +311,32 @@ static int do_errata(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 #ifdef CONFIG_SYS_P4080_ERRATUM_PCIE_A003
 	puts("Work-around for Erratum PCIe-A003 enabled\n");
 #endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006208
+	if (SVR_MAJ(svr) == 1)
+		puts("Work-around for Erratum A006208 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_I2C_A004447
+	if ((SVR_SOC_VER(svr) == SVR_8548 && IS_SVR_REV(svr, 3, 1)) ||
+	    (SVR_SOC_VER(svr) == SVR_P1010 && IS_SVR_REV(svr, 1, 0)) ||
+	    (SVR_SOC_VER(svr) == SVR_P1023 && (svr & 0xff) <= 0x11) ||
+	    (SVR_SOC_VER(svr) == SVR_P3041 && (svr & 0xff) <= 0x20) ||
+	    (SVR_SOC_VER(svr) == SVR_P4080 && (svr & 0xff) <= 0x20) ||
+	    (SVR_SOC_VER(svr) == SVR_P5020 && (svr & 0xff) <= 0x20) ||
+	    (SVR_SOC_VER(svr) == SVR_9131 && (svr & 0xff) <= 0x11))
+		puts("Work-around for Erratum I2C-A004447 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005812
+	puts("Work-around for Erratum A-005812 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006593
+	puts("Work-around for Erratum A006593 enabled\n");
+#endif
+#if defined(CONFIG_SYS_FSL_ERRATUM_A005936) && defined(CONFIG_B4860QDS)
+	puts("Work-around for Erratum A005936 enabled\n");
+#endif
+#if defined(CONFIG_SYS_FSL_B4860QDS_XFI_ERR) && defined(CONFIG_B4860QDS)
+	puts("Work-around for Erratum XFI on B4860QDS enabled\n");
+#endif
 	return 0;
 }
 
diff --git a/arch/powerpc/cpu/mpc85xx/cmd_esbc_validate.c b/arch/powerpc/cpu/mpc85xx/cmd_esbc_validate.c
new file mode 100644
index 0000000..de01a7e
--- /dev/null
+++ b/arch/powerpc/cpu/mpc85xx/cmd_esbc_validate.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <command.h>
+#include <common.h>
+#include <fsl_validate.h>
+
+static int do_esbc_validate(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+
+	return fsl_secboot_validate(cmdtp, flag, argc, argv);
+}
+
+static int do_esbc_blob_encap(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	if (argc < 5)
+		return cmd_usage(cmdtp);
+	return fsl_secboot_blob_encap(cmdtp, flag, argc, argv);
+}
+
+static int do_esbc_blob_decap(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	if (argc < 5)
+		return cmd_usage(cmdtp);
+	return fsl_secboot_blob_decap(cmdtp, flag, argc, argv);
+}
+
+U_BOOT_CMD(
+	esbc_validate,	3,	0,	do_esbc_validate,
+	"Validates signature of a given image using RSA verification"
+	"algorithm as part of Freescale Secure Boot Process",
+	"<hdr_addr> <hash_val>"
+);
+
+static int do_esbc_halt(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	printf("Core is entering spin loop.\n");
+	while (1);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	esbc_halt,	1,	0,	do_esbc_halt,
+	"Put the core in spin loop if control reaches to uboot"
+	"from bootscript",
+	""
+);
+
+U_BOOT_CMD(
+	esbc_blob_encap,	5,	0,	do_esbc_blob_encap,
+	"Creates a Cryptographic blob using a Blob Key , which is a"
+	" random number used as an AES-CCM key",
+	"<src addr of data to be encapsulated> <dest addr of blob> "
+	"<size of data> <128 bit key idnfr>"
+);
+
+U_BOOT_CMD(
+	esbc_blob_decap,	5,	0,	do_esbc_blob_decap,
+	"Decapsulates the cryptgraphic blob",
+	"<blob pointer> <dest addr of decapsulated blob> "
+	"<size of decapsulated blob> <128 bit key idnfr>"
+);
diff --git a/arch/powerpc/cpu/mpc85xx/cpu.c b/arch/powerpc/cpu/mpc85xx/cpu.c
index f6be92f..fc7cdfd 100644
--- a/arch/powerpc/cpu/mpc85xx/cpu.c
+++ b/arch/powerpc/cpu/mpc85xx/cpu.c
@@ -34,8 +34,8 @@
 #include <asm/io.h>
 #include <asm/mmu.h>
 #include <asm/fsl_ifc.h>
-#include <asm/fsl_law.h>
 #include <asm/fsl_lbc.h>
+#include <asm/fsl_law.h>
 #include <post.h>
 #include <asm/processor.h>
 #include <asm/fsl_ddr_sdram.h>
@@ -60,10 +60,9 @@ int checkcpu (void)
 	uint major, minor;
 	struct cpu_type *cpu;
 	char buf1[32], buf2[32];
-#if (defined(CONFIG_DDR_CLK_FREQ) || \
-	defined(CONFIG_FSL_CORENET)) && !defined(CONFIG_SYS_FSL_QORIQ_CHASSIS2)
-	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
-#endif /* CONFIG_FSL_CORENET */
+#if defined(CONFIG_DDR_CLK_FREQ) || defined(CONFIG_FSL_CORENET)
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+#endif
 
 	/*
 	 * Cornet platforms use ddr sync bit in RCW to indicate sync vs async
@@ -227,6 +226,21 @@ int checkcpu (void)
 
 	puts("L1:    D-cache 32 kB enabled\n       I-cache 32 kB enabled\n");
 
+#ifdef CONFIG_FSL_CORENET
+	/* Display the RCW, so that no one gets confused as to what RCW
+	 * we're actually using for this boot.
+	 */
+	puts("Reset Configuration Word (RCW):");
+	for (i = 0; i < ARRAY_SIZE(gur->rcwsr); i++) {
+		u32 rcw = in_be32(&gur->rcwsr[i]);
+
+		if ((i % 4) == 0)
+			printf("\n       %08x:", i * 4);
+		printf(" %08x", rcw);
+	}
+	puts("\n");
+#endif
+
 	return 0;
 }
 
@@ -242,29 +256,29 @@ int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 /* Everything after the first generation of PQ3 parts has RSTCR */
 #if defined(CONFIG_MPC8540) || defined(CONFIG_MPC8541) || \
     defined(CONFIG_MPC8555) || defined(CONFIG_MPC8560)
-	{
-		unsigned long val, msr;
-
-		/*
-		 * Initiate hard reset in debug control register DBCR0
-		 * Make sure MSR[DE] = 1.  This only resets the core.
-		 */
-		msr = mfmsr ();
-		msr |= MSR_DE;
-		mtmsr (msr);
+    {
+	unsigned long val, msr;
 
-		val = mfspr(DBCR0);
-		val |= 0x70000000;
-		mtspr(DBCR0,val);
-	}
+	/*
+	 * Initiate hard reset in debug control register DBCR0
+	 * Make sure MSR[DE] = 1.  This only resets the core.
+	 */
+	msr = mfmsr ();
+	msr |= MSR_DE;
+	mtmsr (msr);
+
+	val = mfspr(DBCR0);
+	val |= 0x70000000;
+	mtspr(DBCR0,val);
+    }
 #else
-	{
-		volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+    {
+	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 
-		/* Try asserting HRESET_REQ */
-		out_be32(&gur->rstcr, 0x2);
-		udelay(100);
-	}
+	/* Next try asserting HRESET_REQ */
+	out_be32(&gur->rstcr, 0x2);
+	udelay(100);
+    }
 #endif
 
 	return 1;
diff --git a/arch/powerpc/cpu/mpc85xx/cpu_init.c b/arch/powerpc/cpu/mpc85xx/cpu_init.c
index d1155e8..185e0d5 100644
--- a/arch/powerpc/cpu/mpc85xx/cpu_init.c
+++ b/arch/powerpc/cpu/mpc85xx/cpu_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2011 Freescale Semiconductor, Inc.
+ * Copyright 2007-2012 Freescale Semiconductor, Inc.
  *
  * (C) Copyright 2003 Motorola Inc.
  * Modified by Xianghua Xiao, X.Xiao@motorola.com
@@ -38,6 +38,7 @@
 #include <asm/fsl_law.h>
 #include <asm/fsl_serdes.h>
 #include <asm/fsl_srio.h>
+#include <asm/fsl_usb.h>
 #include <hwconfig.h>
 #include <linux/compiler.h>
 #include "mp.h"
@@ -46,10 +47,26 @@
 #include <errno.h>
 #endif
 
+#if defined(CONFIG_SECURE_BOOT) && defined(CONFIG_FSL_CORENET)
+#include <asm/fsl_pamu.h>
+#endif
+#ifdef CONFIG_SECURE_BOOT
+#include <jr.h>
+#include <fsl_secboot_err.h>
+#endif
+
 #include "../../../../drivers/block/fsl_sata.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#ifdef CONFIG_SECURE_BOOT
+struct jobring jr;
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006918
+bool     has_fsl_erratum_a006918;
+#endif
+
 #ifdef CONFIG_QE
 extern qe_iop_conf_t qe_iop_conf_tab[];
 extern void qe_config_iopin(u8 port, u8 pin, int dir,
@@ -149,7 +166,7 @@ static void enable_cpc(void)
 	for (i = 0; i < CONFIG_SYS_NUM_CPC; i++, cpc++) {
 		u32 cpccfg0 = in_be32(&cpc->cpccfg0);
 		size += CPC_CFG0_SZ_K(cpccfg0);
-#ifdef CONFIG_RAMBOOT_PBL
+#if defined(CONFIG_RAMBOOT_PBL) || defined(CONFIG_SECURE_HKAREA_CPC)
 		if (in_be32(&cpc->cpcsrcr0) & CPC_SRCR0_SRAMEN) {
 			/* find and disable LAW of SRAM */
 			struct law_entry law = find_law(CONFIG_SYS_INIT_L3_ADDR);
@@ -172,6 +189,9 @@ static void enable_cpc(void)
 #ifdef CONFIG_SYS_FSL_ERRATUM_CPC_A003
 		setbits_be32(&cpc->cpchdbcr0, CPC_HDBCR0_DATA_ECC_SCRUB_DIS);
 #endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006593
+		setbits_be32(&cpc->cpchdbcr0, 1 << (31 - 21));
+#endif
 
 		out_be32(&cpc->cpccsr0, CPC_CSR0_CE | CPC_CSR0_PE);
 		/* Read back to sync write */
@@ -223,6 +243,47 @@ static void corenet_tb_init(void)
 }
 #endif
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006918
+void fsl_erratum_a006918_workaround(void)
+{
+	unsigned int cnt = FSL_MAX_USBPLL_RETRY_COUNT;
+	struct ccsr_usb_phy *usb_phy =
+		(void *)CONFIG_SYS_MPC85xx_USB1_PHY_ADDR;
+
+	has_fsl_erratum_a006918 = true;
+
+	do {
+		/* 1ms delay required for PLL to be stable */
+		mdelay(1);
+		if ((in_be32(&usb_phy->port1.sts)
+			& CONFIG_SYS_FSL_USB_SYS_CLK_VALID)
+				&& (in_be32(&usb_phy->port2.sts)
+					& CONFIG_SYS_FSL_USB_SYS_CLK_VALID)) {
+			has_fsl_erratum_a006918 = false;
+			break;
+		} else {
+			clrsetbits_be32(&usb_phy->pllprg[1],
+				CONFIG_SYS_FSL_USB_PLLPRG2_PLL_EN,
+				CONFIG_SYS_FSL_USB_PLLPRG2_PHY2_CLK_EN |
+				CONFIG_SYS_FSL_USB_PLLPRG2_PHY1_CLK_EN |
+				CONFIG_SYS_FSL_USB_PLLPRG2_FRAC_LPF_EN |
+				CONFIG_SYS_FSL_USB_PLLPRG2_REF_DIV |
+				CONFIG_SYS_FSL_USB_PLLPRG2_MFI);
+			setbits_be32(&usb_phy->pllprg[1],
+				CONFIG_SYS_FSL_USB_PLLPRG2_PHY2_CLK_EN |
+				CONFIG_SYS_FSL_USB_PLLPRG2_PHY1_CLK_EN |
+				CONFIG_SYS_FSL_USB_PLLPRG2_FRAC_LPF_EN |
+				CONFIG_SYS_FSL_USB_PLLPRG2_REF_DIV |
+				CONFIG_SYS_FSL_USB_PLLPRG2_MFI |
+				CONFIG_SYS_FSL_USB_PLLPRG2_PLL_EN);
+		}
+	} while (--cnt);
+
+	if (has_fsl_erratum_a006918)
+		printf("ERROR:fsl internal utmi phy init failed\n");
+}
+#endif
+
 void cpu_init_f (void)
 {
 	extern void m8560_cpm_reset (void);
@@ -312,19 +373,48 @@ int enable_cluster_l2(void)
 
 	/* Look through the remaining clusters, and set up their caches */
 	do {
+		int j, cluster_valid = 0;
+
 		l2cache = (void __iomem *)(CONFIG_SYS_FSL_CLUSTER_1_L2 + i * 0x40000);
+
 		cluster = in_be32(&gur->tp_cluster[i].lower);
 
-		/* set stash ID to (cluster) * 2 + 32 + 1 */
-		clrsetbits_be32(&l2cache->l2csr1, 0xff, 32 + i * 2 + 1);
+		/* check that at least one core/accel is enabled in cluster */
+		for (j = 0; j < 4; j++) {
+			u32 idx = (cluster >> (j*8)) & TP_CLUSTER_INIT_MASK;
+			u32 type = in_be32(&gur->tp_ityp[idx]);
 
-		printf("enable l2 for cluster %d %p\n", i, l2cache);
+			if (type & TP_ITYP_AV)
+				cluster_valid = 1;
+		}
 
-		out_be32(&l2cache->l2csr0, L2CSR0_L2FI|L2CSR0_L2LFC);
-		while ((in_be32(&l2cache->l2csr0) &
-			(L2CSR0_L2FI|L2CSR0_L2LFC)) != 0)
-			;
-		out_be32(&l2cache->l2csr0, L2CSR0_L2E);
+		if (cluster_valid) {
+			/* set stash ID to (cluster) * 2 + 32 + 1 */
+			clrsetbits_be32(&l2cache->l2csr1, 0xff, 32 + i * 2 + 1);
+
+			printf("enable l2 for cluster %d %p\n", i, l2cache);
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004857
+			if (PVR_MAJ(get_pvr()) == 1) {
+				clrsetbits_be32(&l2cache->magic_f04,
+					3UL << (63 - 41), 1UL << (63 - 41));
+			}
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005553
+			if (PVR_MAJ(get_pvr()) == 1) {
+				setbits_be32(&l2cache->magic_f04,
+					1UL << (63 - 54));
+				setbits_be32(&l2cache->magic_f00,
+					1UL << (63 - 41));
+			}
+#endif
+
+			out_be32(&l2cache->l2csr0, L2CSR0_L2FI|L2CSR0_L2LFC);
+			while ((in_be32(&l2cache->l2csr0)
+				& (L2CSR0_L2FI|L2CSR0_L2LFC)) != 0)
+					;
+			out_be32(&l2cache->l2csr0, L2CSR0_L2E|L2CSR0_L2PE|L2CSR0_L2REP_MODE);
+		}
 		i++;
 	} while (!(cluster & TP_CLUSTER_EOC));
 
@@ -398,6 +488,14 @@ int cpu_init_r(void)
 		sync();
 	}
 #endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005812
+	/*
+	 * A-005812 workaround sets bit 32 of SPR 976 for SoCs running
+	 * in write shadow mode. Checking DCWS before setting SPR 976.
+	 */
+	if (mfspr(L1CSR2) & L1CSR2_DCWS)
+		mtspr(SPRN_HDBCR0, (mfspr(SPRN_HDBCR0) | 0x80000000));
+#endif
 
 #if defined(CONFIG_PPC_SPINTABLE_COMPATIBLE) && defined(CONFIG_MP)
 	spin = getenv("spin_table_compat");
@@ -531,12 +629,28 @@ skip_l2:
 
 	enable_cpc();
 
+#ifndef CONFIG_SYS_FSL_NO_SERDES
 	/* needs to be in ram since code uses global static vars */
 	fsl_serdes_init();
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005871
+	if (IS_SVR_REV(svr, 1, 0)) {
+		int i;
+		__be32 *p = (void __iomem *)CONFIG_SYS_DCSRBAR + 0xb004c;
+
+		for (i = 0; i < 12; i++) {
+			p += i + (i > 5 ? 11 : 0);
+			out_be32(p, 0x2);
+		}
+		p = (void __iomem *)CONFIG_SYS_DCSRBAR + 0xb0108;
+		out_be32(p, 0x34);
+	}
+#endif
 
 #ifdef CONFIG_SYS_SRIO
 	srio_init();
-#ifdef CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER 
+#ifdef CONFIG_SRIO_PCIE_BOOT_MASTER
 	char *s = getenv("bootmaster");
 	if (s) {
 		if (!strcmp(s, "SRIO1")) {
@@ -580,7 +694,7 @@ skip_l2:
 
 #ifdef CONFIG_SYS_FSL_USB1_PHY_ENABLE
 	{
-		ccsr_usb_phy_t *usb_phy1 =
+		struct ccsr_usb_phy __iomem *usb_phy1 =
 			(void *)CONFIG_SYS_MPC85xx_USB1_PHY_ADDR;
 		out_be32(&usb_phy1->usb_enable_override,
 				CONFIG_SYS_FSL_USB_ENABLE_OVERRIDE);
@@ -588,13 +702,77 @@ skip_l2:
 #endif
 #ifdef CONFIG_SYS_FSL_USB2_PHY_ENABLE
 	{
-		ccsr_usb_phy_t *usb_phy2 =
+		struct ccsr_usb_phy __iomem *usb_phy2 =
 			(void *)CONFIG_SYS_MPC85xx_USB2_PHY_ADDR;
 		out_be32(&usb_phy2->usb_enable_override,
 				CONFIG_SYS_FSL_USB_ENABLE_OVERRIDE);
 	}
 #endif
 
+#if defined(CONFIG_SYS_FSL_USB_DUAL_PHY_ENABLE)
+		struct ccsr_usb_phy __iomem *usb_phy =
+			(void *)CONFIG_SYS_MPC85xx_USB1_PHY_ADDR;
+		setbits_be32(&usb_phy->pllprg[0],
+				CONFIG_SYS_FSL_USB_PLLPRG1_PHY_DIV);
+		setbits_be32(&usb_phy->pllprg[1],
+				CONFIG_SYS_FSL_USB_PLLPRG2_PHY2_CLK_EN |
+				CONFIG_SYS_FSL_USB_PLLPRG2_PHY1_CLK_EN |
+				CONFIG_SYS_FSL_USB_PLLPRG2_MFI |
+				CONFIG_SYS_FSL_USB_PLLPRG2_PLL_EN);
+		setbits_be32(&usb_phy->port1.ctrl,
+				CONFIG_SYS_FSL_USB_CTRL_PHY_EN);
+		setbits_be32(&usb_phy->port1.drvvbuscfg,
+				CONFIG_SYS_FSL_USB_DRVVBUS_CR_EN);
+		setbits_be32(&usb_phy->port1.pwrfltcfg,
+				CONFIG_SYS_FSL_USB_PWRFLT_CR_EN);
+		setbits_be32(&usb_phy->port2.ctrl,
+				CONFIG_SYS_FSL_USB_CTRL_PHY_EN);
+		setbits_be32(&usb_phy->port2.drvvbuscfg,
+				CONFIG_SYS_FSL_USB_DRVVBUS_CR_EN);
+		setbits_be32(&usb_phy->port2.pwrfltcfg,
+				CONFIG_SYS_FSL_USB_PWRFLT_CR_EN);
+
+	/* Deal with USB Erratum USB-A006918
+	 * UTMI phy clk instability issue
+	 * T4240 rev 1.0
+	 */
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006918
+		if (IS_SVR_REV(svr, 1, 0))
+			fsl_erratum_a006918_workaround();
+#endif
+#endif
+
+	/* On P204x/P304x/P5020 Rev1.0, USB transmit will result internal
+	 * multi-bit ECC errors, which has impact on performance, so software
+	 * should disable all ECC reporting from USB1 and USB2 by setting bits
+	 * 16 and 17 to 1 in the register at DCSRBASE + 0x0002_0520.
+	 */
+#ifdef CONFIG_SYS_FSL_ERRATUM_USB138
+	if (IS_SVR_REV(get_svr(), 1, 0)) {
+		void *p;
+		p = (void *)CONFIG_SYS_DCSRBAR + 0x20520;
+		setbits_be32(p, 3 << (31 - 17));
+	}
+#endif
+#ifdef CONFIG_SYS_FSL_ELBC_MULTIBIT_ECC
+	/*
+	 * On P3041/P3060/P5020, NAND operations will result internal multi-bit
+	 * ECC error, which causes call trace in kernel, so software should
+	 * disable the ECC error reported from eLBC by setting bit 15 in
+	 * the register at DCSRBASE + 0x0002_0520.
+	 */
+#define DCFG_ECC	(CONFIG_SYS_DCSRBAR + 0x20520)
+	setbits_be32((void *)DCFG_ECC, 1 << (31 - 15));
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005977
+	if (IS_SVR_REV(svr, 1, 0)) {
+		void *p;
+		p = (void *)CONFIG_SYS_DCSRBAR + 0x20520;
+		setbits_be32(p, 0xf << (31 - 15));
+	}
+#endif
+
 #ifdef CONFIG_FMAN_ENET
 	fman_enet_init();
 #endif
@@ -622,6 +800,19 @@ skip_l2:
 	}
 #endif
 
+#if defined(CONFIG_SECURE_BOOT) && defined(CONFIG_FSL_CORENET)
+	if (pamu_init() < 0)
+		fsl_secboot_handle_error(ERROR_ESBC_PAMU_INIT);
+#endif
+
+#ifdef CONFIG_SECURE_BOOT
+	if (sec_init(&jr) < 0)
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_INIT);
+	if (get_rng_vid() >= 4) {
+		if (rng_init(&jr) < 0)
+			printf("CAAM:RNG init failed\n");
+	}
+#endif
 
 	return 0;
 }
diff --git a/arch/powerpc/cpu/mpc85xx/cpu_init_early.c b/arch/powerpc/cpu/mpc85xx/cpu_init_early.c
index dacfdd1..f4403c2 100644
--- a/arch/powerpc/cpu/mpc85xx/cpu_init_early.c
+++ b/arch/powerpc/cpu/mpc85xx/cpu_init_early.c
@@ -25,7 +25,7 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#if defined(CONFIG_SYS_FSL_ERRATUM_IFC_A003399) && !defined(CONFIG_SYS_RAMBOOT)
+#ifdef CONFIG_A003399_NOR_WORKAROUND
 void setup_ifc(void)
 {
 	struct fsl_ifc *ifc_regs = (void *)CONFIG_SYS_IFC_ADDR;
@@ -99,7 +99,7 @@ void cpu_init_early_f(void)
 #ifdef CONFIG_SYS_FSL_ERRATUM_P1010_A003549
 	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 #endif
-#if defined(CONFIG_SYS_FSL_ERRATUM_IFC_A003399) && !defined(CONFIG_SYS_RAMBOOT)
+#ifdef CONFIG_A003399_NOR_WORKAROUND
 	ccsr_l2cache_t *l2cache = (void *)CONFIG_SYS_MPC85xx_L2_ADDR;
 	u32  *dst, *src;
 	void (*setup_ifc_sram)(void);
@@ -138,7 +138,7 @@ void cpu_init_early_f(void)
  * Work Around for IFC Erratum A003399, issue will hit only when execution
  * from NOR Flash
  */
-#if defined(CONFIG_SYS_FSL_ERRATUM_IFC_A003399) && !defined(CONFIG_SYS_RAMBOOT)
+#ifdef CONFIG_A003399_NOR_WORKAROUND
 #define SRAM_BASE_ADDR	(0x00000000)
 	/* TLB for SRAM */
 	mas0 = MAS0_TLBSEL(1) | MAS0_ESEL(9);
@@ -180,12 +180,5 @@ void cpu_init_early_f(void)
 
 	invalidate_tlb(1);
 
-#if defined(CONFIG_SECURE_BOOT)
-	/* Disable the TLBs created by ISBC */
-	for (i = CONFIG_SYS_ISBC_START_TLB;
-	     i < CONFIG_SYS_ISBC_START_TLB + CONFIG_SYS_ISBC_NUM_TLBS; i++)
-			disable_tlb(i);
-#endif
-
 	init_tlbs();
 }
diff --git a/arch/powerpc/cpu/mpc85xx/ddr-gen1.c b/arch/powerpc/cpu/mpc85xx/ddr-gen1.c
index 8a86819..4dd8c0b 100644
--- a/arch/powerpc/cpu/mpc85xx/ddr-gen1.c
+++ b/arch/powerpc/cpu/mpc85xx/ddr-gen1.c
@@ -15,7 +15,7 @@
 #endif
 
 void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
-			     unsigned int ctrl_num)
+			     unsigned int ctrl_num, int step)
 {
 	unsigned int i;
 	volatile ccsr_ddr_t *ddr = (void *)CONFIG_SYS_MPC8xxx_DDR_ADDR;
diff --git a/arch/powerpc/cpu/mpc85xx/ddr-gen2.c b/arch/powerpc/cpu/mpc85xx/ddr-gen2.c
index a705862..542bc84 100644
--- a/arch/powerpc/cpu/mpc85xx/ddr-gen2.c
+++ b/arch/powerpc/cpu/mpc85xx/ddr-gen2.c
@@ -16,7 +16,7 @@
 #endif
 
 void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
-			     unsigned int ctrl_num)
+			     unsigned int ctrl_num, int step)
 {
 	unsigned int i;
 	ccsr_ddr_t *ddr = (void *)CONFIG_SYS_MPC8xxx_DDR_ADDR;
diff --git a/arch/powerpc/cpu/mpc85xx/ddr-gen3.c b/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
index ef0dd1d..5a5e1e1 100644
--- a/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
+++ b/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
@@ -15,8 +15,21 @@
 #error Invalid setting for CONFIG_CHIP_SELECTS_PER_CTRL
 #endif
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004390
+unsigned int picos_to_mclk(unsigned int picos);
+#endif
+
+/*
+ * regs has the to-be-set values for DDR controller registers
+ * ctrl_num is the DDR controller number
+ * step: 0 goes through the initialization in one pass
+ *       1 sets registers and returns before enabling controller
+ *       2 resumes from step 1 and continues to initialize
+ * Dividing the initialization to two steps to deassert DDR reset signal
+ * to comply with JEDEC specs for RDIMMs.
+ */
 void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
-			     unsigned int ctrl_num)
+			     unsigned int ctrl_num, int step)
 {
 	unsigned int i, bus_width;
 	volatile ccsr_ddr_t *ddr;
@@ -29,6 +42,9 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 	unsigned int csn_bnds_backup = 0, cs_sa, cs_ea, *csn_bnds_t;
 	int csn = -1;
 #endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004390
+	unsigned int tRFC, tXPR;
+#endif
 
 	switch (ctrl_num) {
 	case 0:
@@ -54,6 +70,9 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 		return;
 	}
 
+	if (step == 2)
+		goto step2;
+
 	if (regs->ddr_eor)
 		out_be32(&ddr->eor, regs->ddr_eor);
 #ifdef CONFIG_SYS_FSL_ERRATUM_DDR111_DDR134
@@ -99,13 +118,24 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 		}
 	}
 
+	out_be32(&ddr->timing_cfg_3, 0x010C1000);
+	out_be32(&ddr->timing_cfg_0, 0x55440104);
+	out_be32(&ddr->timing_cfg_1, 0x98910A45);
+	out_be32(&ddr->timing_cfg_2, 0x0FB8B114);
+/*
 	out_be32(&ddr->timing_cfg_3, regs->timing_cfg_3);
 	out_be32(&ddr->timing_cfg_0, regs->timing_cfg_0);
 	out_be32(&ddr->timing_cfg_1, regs->timing_cfg_1);
 	out_be32(&ddr->timing_cfg_2, regs->timing_cfg_2);
+*/
+	out_be32(&ddr->sdram_cfg_2, 0x24401011);
+	out_be32(&ddr->sdram_mode, 0x00421A50);
+	out_be32(&ddr->sdram_mode_2, 0x00100000);
+/*
 	out_be32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
 	out_be32(&ddr->sdram_mode, regs->ddr_sdram_mode);
 	out_be32(&ddr->sdram_mode_2, regs->ddr_sdram_mode_2);
+*/
 	out_be32(&ddr->sdram_mode_3, regs->ddr_sdram_mode_3);
 	out_be32(&ddr->sdram_mode_4, regs->ddr_sdram_mode_4);
 	out_be32(&ddr->sdram_mode_5, regs->ddr_sdram_mode_5);
@@ -123,18 +153,31 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 	out_be32(&ddr->timing_cfg_5, regs->timing_cfg_5);
 	out_be32(&ddr->ddr_zq_cntl, regs->ddr_zq_cntl);
 	out_be32(&ddr->ddr_wrlvl_cntl, regs->ddr_wrlvl_cntl);
+#ifndef CONFIG_SYS_FSL_DDR_EMU
+	/*
+	 * Skip these two registers if running on emulator
+	 * because emulator doesn't have skew between bytes.
+	 */
+
 	if (regs->ddr_wrlvl_cntl_2)
 		out_be32(&ddr->ddr_wrlvl_cntl_2, regs->ddr_wrlvl_cntl_2);
 	if (regs->ddr_wrlvl_cntl_3)
 		out_be32(&ddr->ddr_wrlvl_cntl_3, regs->ddr_wrlvl_cntl_3);
+#endif
 
 	out_be32(&ddr->ddr_sr_cntr, regs->ddr_sr_cntr);
 	out_be32(&ddr->ddr_sdram_rcw_1, regs->ddr_sdram_rcw_1);
 	out_be32(&ddr->ddr_sdram_rcw_2, regs->ddr_sdram_rcw_2);
+
+	out_be32(&ddr->ddr_cdr1, 0x80000000);
+	out_be32(&ddr->ddr_cdr2, 0x00000000);
+/*
 	out_be32(&ddr->ddr_cdr1, regs->ddr_cdr1);
 	out_be32(&ddr->ddr_cdr2, regs->ddr_cdr2);
+*/
 	out_be32(&ddr->err_disable, regs->err_disable);
 	out_be32(&ddr->err_int_en, regs->err_int_en);
+
 	for (i = 0; i < 32; i++) {
 		if (regs->debug[i]) {
 			debug("Write to debug_%d as %08x\n", i+1, regs->debug[i]);
@@ -142,7 +185,8 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 		}
 	}
 #ifdef CONFIG_SYS_FSL_ERRATUM_A_004934
-	out_be32(&ddr->debug[28], 0x00003000);
+	if (SVR_MAJ(get_svr()) == 1)
+		out_be32(&ddr->debug[28], 0x30003000);
 #endif
 
 #ifdef CONFIG_SYS_FSL_ERRATUM_DDR_A003474
@@ -150,6 +194,20 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 	out_be32(&ddr->debug[21], 0x24000000);
 #endif /* CONFIG_SYS_FSL_ERRATUM_DDR_A003474 */
 
+	/*
+	 * For RDIMMs, JEDEC spec requires clocks to be stable before reset is
+	 * deasserted. Clocks start when any chip select is enabled and clock
+	 * control register is set. Because all DDR components are connected to
+	 * one reset signal, this needs to be done in two steps. Step 1 is to
+	 * get the clocks started. Step 2 resumes after reset signal is
+	 * deasserted.
+	 */
+	if (step == 1) {
+		udelay(200);
+		return;
+	}
+
+step2:
 	/* Set, but do not enable the memory */
 	temp_sdram_cfg = regs->ddr_sdram_cfg;
 	temp_sdram_cfg &= ~(SDRAM_CFG_MEM_EN);
@@ -266,6 +324,31 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 
 #endif	/* part 1 of the workaound */
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004390
+	/* JEDEC specs require the DDR controller to wait a defined amount of
+	 * time (tXPR) before issuing any commands after asserting MCKE
+	 * following a RESET. This amount of time changes with density and
+	 * frequency. The DDRC has hard-coded this value to 300 cycles. The
+	 * workaround is to write SDRAM_MD_CNTL[CKE_CNTL] to force MCKE signal
+	 * high, Wait at least tXPR before setting DDR_SDRAM_CFG[MEM_EN].
+	 * In this implementation, we check if the tXPR is more than 300 cycles
+	 * and set MCKE high before the waiting of 500 microseconds required
+	 * for clock to setup. tXPR = max(5nCK, tRFC + 10ns)
+	 *
+	 * Applied to T4240 rev 1.0 and B4860 rev 1.0.
+	 * To be fixed in rev 2.0.
+	 */
+	if (SVR_MAJ(get_svr()) == 1) {
+		tRFC = (regs->timing_cfg_3 >> 12) & 0x1f0;
+		tRFC += (regs->timing_cfg_1 >> 12) & 0xf;
+		tXPR = tRFC + picos_to_mclk(10000);
+		if (tXPR > 300) {
+			out_be32(&ddr->sdram_md_cntl, MD_CNTL_CKE_CNTL_HIGH);
+			debug("Workaround for A004390: set MCKE high\n");
+		}
+	}
+#endif
+
 	/*
 	 * 500 painful micro-seconds must elapse between
 	 * the DDR clock setup and the DDR config enable.
@@ -280,6 +363,11 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 	out_be32(&ddr->sdram_cfg, temp_sdram_cfg | SDRAM_CFG_MEM_EN);
 	asm volatile("sync;isync");
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004390
+	/* it is safe to write again even workaround wasn't activated */
+	out_be32(&ddr->sdram_md_cntl, regs->ddr_sdram_md_cntl);
+#endif /* second harlf of this workaround */
+
 	total_gb_size_per_controller = 0;
 	for (i = 0; i < CONFIG_CHIP_SELECTS_PER_CTRL; i++) {
 		if (!(regs->cs[i].config & 0x80000000))
diff --git a/arch/powerpc/cpu/mpc85xx/fdt.c b/arch/powerpc/cpu/mpc85xx/fdt.c
index ab09330..1cad07f 100644
--- a/arch/powerpc/cpu/mpc85xx/fdt.c
+++ b/arch/powerpc/cpu/mpc85xx/fdt.c
@@ -100,6 +100,22 @@ void ft_fixup_cpu(void *blob, u64 memory_limit)
 			printf("Failed to reserve memory for bootpg: %s\n",
 				fdt_strerror(off));
 	}
+
+#ifndef CONFIG_MPC8xxx_DISABLE_BPTR
+	/*
+	 * Reserve the default boot page so OSes dont use it.
+	 * The default boot page is always mapped to bootpg above using
+	 * boot page translation.
+	 */
+	if (0xfffff000ull < memory_limit) {
+		off = fdt_add_mem_rsv(blob, 0xfffff000ull, (u64)4096);
+		if (off < 0) {
+			printf("Failed to reserve memory for 0xfffff000: %s\n",
+				fdt_strerror(off));
+		}
+	}
+#endif
+
 	/* Reserve spin table page */
 	if (spin_tbl_addr < memory_limit) {
 		off = fdt_add_mem_rsv(blob,
@@ -591,13 +607,25 @@ void ft_cpu_setup(void *blob, bd_t *bd)
 	/* delete crypto node if not on an E-processor */
 	if (!IS_E_PROCESSOR(get_svr()))
 		fdt_fixup_crypto_node(blob, 0);
+#if CONFIG_SYS_FSL_SEC_COMPAT >= 4  /* SEC 4.x/5.x */
+	else {
+		ccsr_sec_t *sec;
+
+		sec = (void __iomem *)CONFIG_SYS_FSL_SEC_ADDR;
+		fdt_fixup_crypto_node(blob, in_be32(&sec->secvid_ms));
+	}
+#endif
 
 	fdt_fixup_ethernet(blob);
 
 	fdt_add_enet_stashing(blob);
 
+#ifndef CONFIG_FSL_TBCLK_EXTRA_DIV
+#define CONFIG_FSL_TBCLK_EXTRA_DIV 1
+#endif
 	do_fixup_by_prop_u32(blob, "device_type", "cpu", 4,
-		"timebase-frequency", get_tbclk(), 1);
+		"timebase-frequency", get_tbclk() / CONFIG_FSL_TBCLK_EXTRA_DIV,
+		1);
 	do_fixup_by_prop_u32(blob, "device_type", "cpu", 4,
 		"bus-frequency", bd->bi_busfreq, 1);
 	get_sys_info(&sysinfo);
@@ -639,6 +667,13 @@ void ft_cpu_setup(void *blob, bd_t *bd)
 #ifdef CONFIG_FSL_CORENET
 	do_fixup_by_compat_u32(blob, "fsl,qoriq-clockgen-1.0",
 		"clock-frequency", CONFIG_SYS_CLK_FREQ, 1);
+	do_fixup_by_compat_u32(blob, "fsl,qoriq-clockgen-2.0",
+		"clock-frequency", CONFIG_SYS_CLK_FREQ, 1);
+	do_fixup_by_compat_u32(blob, "fsl,mpic",
+		"clock-frequency", get_bus_freq(0)/2, 1);
+#else
+	do_fixup_by_compat_u32(blob, "fsl,mpic",
+		"clock-frequency", get_bus_freq(0), 1);
 #endif
 
 	fdt_fixup_memory(blob, (u64)bd->bi_memstart, (u64)bd->bi_memsize);
diff --git a/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.c b/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.c
index 01dcdf6..50dd6f4 100644
--- a/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.c
+++ b/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.c
@@ -163,8 +163,44 @@ u64 serdes_init(u32 sd, u32 sd_addr, u32 sd_prctl_mask, u32 sd_prctl_shift)
 		return 0;
 	}
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005475
+	/*
+	 * Use SRDSxPLLnCR0[PLL_LCK] to determine if the SerDes PLL has
+	 * locked. If not, a SerDes reset request should occur.
+	 */
+	if (SVR_MAJ(get_svr()) == 1) {
+		int pll;
+		u32 pll_status;
+		serdes_corenet_t *srds_regs = (void __iomem *)sd_addr;
+		unsigned long long end_tick;
+		u32 rstctl;
+
+		for (pll = 0; pll < SRDS_MAX_BANK; pll++) {
+			pll_status = in_be32(&srds_regs->bank[pll].pllcr0);
+
+			if (pll_status &
+				(SRDS_PLLCR0_POFF | SRDS_PLLCR0_PLL_LCK))
+				continue;
+			/* need to reset the PLL */
+			setbits_be32(&srds_regs->bank[pll].rstctl,
+					SRDS_RSTCTL_RST);
+
+			/* wait for reset complete or 1-second timeout */
+			end_tick = usec2ticks(1000000) + get_ticks();
+			do {
+				rstctl = in_be32(&srds_regs->bank[pll].rstctl);
+				if (rstctl & SRDS_RSTCTL_RSTDONE)
+					break;
+			} while (end_tick > get_ticks());
+
+			if (!(rstctl & SRDS_RSTCTL_RSTDONE))
+				printf("SERDES%d: timeout resetting PLL%d\n",
+						sd, pll + 1);
+		}
+	}
+#endif
 	cfg >>= sd_prctl_shift;
-	printf("Using SERDES%d Protocol: 0x%x\n", sd + 1, cfg);
+	printf("Using SERDES%d Protocol: %d (0x%x)\n", sd + 1, cfg, cfg);
 	if (!is_serdes_prtcl_valid(sd, cfg))
 		printf("SERDES%d[PRTCL] = 0x%x is not valid\n", sd + 1, cfg);
 
diff --git a/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.h b/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.h
index 2258f41..485427a 100644
--- a/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.h
+++ b/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.h
@@ -22,5 +22,4 @@
 
 int is_serdes_prtcl_valid(int serdes, u32 prtcl);
 int serdes_lane_enabled(int lane);
-enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane);
 #endif /* __FSL_CORENET2_SERDES_H */
diff --git a/arch/powerpc/cpu/mpc85xx/fsl_corenet_serdes.c b/arch/powerpc/cpu/mpc85xx/fsl_corenet_serdes.c
index 5495dc5..3d1394a 100644
--- a/arch/powerpc/cpu/mpc85xx/fsl_corenet_serdes.c
+++ b/arch/powerpc/cpu/mpc85xx/fsl_corenet_serdes.c
@@ -103,6 +103,10 @@ static const struct {
 	{ 22, 168, FSL_SRDS_BANK_3 },
 	{ 23, 169, FSL_SRDS_BANK_3 },
 #endif
+#if SRDS_MAX_BANK > 3
+	{ 24, 175, FSL_SRDS_BANK_4 },
+	{ 25, 176, FSL_SRDS_BANK_4 },
+#endif
 };
 
 int serdes_get_lane_idx(int lane)
@@ -533,7 +537,7 @@ void fsl_serdes_init(void)
 
 	srds_regs = (void *)(CONFIG_SYS_FSL_CORENET_SERDES_ADDR);
 	cfg = (in_be32(&gur->rcwsr[4]) & FSL_CORENET_RCWSR4_SRDS_PRTCL) >> 26;
-	debug("Using SERDES configuration 0x%x, lane settings:\n", cfg);
+	printf("Using SERDES configuration 0x%x, lane settings:\n", cfg);
 
 	if (!is_serdes_prtcl_valid(cfg)) {
 		printf("SERDES[PRTCL] = 0x%x is not valid\n", cfg);
@@ -655,38 +659,6 @@ void fsl_serdes_init(void)
 		}
 	}
 
-#ifdef CONFIG_SYS_FSL_ERRATUM_A004699
-	/*
-	 * To avoid the situation that resulted in the P4080 erratum
-	 * SERDES-8, a given SerDes bank will use the PLLs from the previous
-	 * bank if one of the PLL frequencies is a multiple of the other.  For
-	 * instance, if bank 3 is running at 2.5GHz and bank 2 is at 1.25GHz,
-	 * then bank 3 will use bank 2's PLL.  P5040 Erratum A-004699 says
-	 * that, in this situation, lane synchronization is not initiated.  So
-	 * when we detect a bank with a "borrowed" PLL, we have to manually
-	 * initiate lane synchronization.
-	 */
-	for (bank = FSL_SRDS_BANK_2; bank <= FSL_SRDS_BANK_3; bank++) {
-		/* Determine the first lane for this bank */
-		unsigned int lane;
-
-		for (lane = 0; lane < SRDS_MAX_LANES; lane++)
-			if (lanes[lane].bank == bank)
-				break;
-		idx = lanes[lane].idx;
-
-		/*
-		 * Check if the PLL for the bank is borrowed.  The UOTHL
-		 * bit of the first lane will tell us that.
-		 */
-		if (in_be32(&srds_regs->lane[idx].gcr0) & SRDS_GCR0_UOTHL) {
-			/* Manually start lane synchronization */
-			setbits_be32(&srds_regs->bank[bank].pllcr0,
-				     SRDS_PLLCR0_PVCOCNT_EN);
-		}
-	}
-#endif
-
 #if defined(CONFIG_SYS_P4080_ERRATUM_SERDES8) || defined (CONFIG_SYS_P4080_ERRATUM_SERDES9)
 	for (lane = 0; lane < SRDS_MAX_LANES; lane++) {
 		enum srds_prtcl lane_prtcl;
diff --git a/arch/powerpc/cpu/mpc85xx/fsl_sfp_snvs.c b/arch/powerpc/cpu/mpc85xx/fsl_sfp_snvs.c
new file mode 100644
index 0000000..7382eea
--- /dev/null
+++ b/arch/powerpc/cpu/mpc85xx/fsl_sfp_snvs.c
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/fsl_sfp_snvs.h>
+#include <configs/corenet_ds.h>
+#include <common.h>
+
+int change_sec_mon_state(u32 initial_state, u32 final_state)
+{
+	ccsr_snvs_regs_t *snvs_regs = (void *)(CONFIG_SYS_SNVS_ADDR);
+	u32 sts = in_be32(&snvs_regs->hp_stat);
+	int timeout = 10;
+
+	if ((sts & HPSR_SSM_ST_MASK) != initial_state)
+		return -1;
+
+	if (initial_state == HPSR_SSM_ST_TRUST) {
+		switch (final_state) {
+		case HPSR_SSM_ST_NON_SECURE:
+			printf("SNVS state transitioning to Soft Fail.\n");
+			setbits_be32(&snvs_regs->hp_com, HPCOMR_SW_SV);
+
+			/*
+			 * poll till SNVS is in
+			 * Soft Fail state
+			 */
+			while (((sts & HPSR_SSM_ST_MASK) !=
+				HPSR_SSM_ST_SOFT_FAIL)) {
+				while (timeout) {
+					sts = in_be32(&snvs_regs->hp_stat);
+
+					if ((sts & HPSR_SSM_ST_MASK) ==
+						HPSR_SSM_ST_SOFT_FAIL)
+						break;
+
+					udelay(10);
+					timeout--;
+				}
+			}
+
+			if (timeout == 0) {
+				printf("SNVS state transition timeout.\n");
+				branch_to_self();
+			}
+
+			timeout = 10;
+
+			printf("SNVS state transitioning to Non Secure.\n");
+			setbits_be32(&snvs_regs->hp_com, HPCOMR_SSM_ST);
+
+			/*
+			 * poll till SNVS is in
+			 * Non Secure state
+			 */
+			while (((sts & HPSR_SSM_ST_MASK) !=
+				HPSR_SSM_ST_NON_SECURE)) {
+				while (timeout) {
+					sts = in_be32(&snvs_regs->hp_stat);
+
+					if ((sts & HPSR_SSM_ST_MASK) ==
+						HPSR_SSM_ST_NON_SECURE)
+						break;
+
+					udelay(10);
+					timeout--;
+				}
+			}
+
+			if (timeout == 0) {
+				printf("SNVS state transition timeout.\n");
+				branch_to_self();
+			}
+			break;
+		case HPSR_SSM_ST_SOFT_FAIL:
+			printf("SNVS state transitioning to Soft Fail.\n");
+			setbits_be32(&snvs_regs->hp_com, HPCOMR_SW_FSV);
+
+			/*
+			 * polling loop till SNVS is in
+			 * Soft Fail state
+			 */
+			while (((sts & HPSR_SSM_ST_MASK) !=
+				HPSR_SSM_ST_SOFT_FAIL)) {
+				while (timeout) {
+					sts = in_be32(&snvs_regs->hp_stat);
+
+					if ((sts & HPSR_SSM_ST_MASK) ==
+						HPSR_SSM_ST_SOFT_FAIL)
+						break;
+
+					udelay(10);
+					timeout--;
+				}
+			}
+
+			if (timeout == 0) {
+				printf("SNVS state transition timeout.\n");
+				branch_to_self();
+			}
+			break;
+		default:
+			return -1;
+		}
+	} else if (initial_state == HPSR_SSM_ST_NON_SECURE) {
+		switch (final_state) {
+		case HPSR_SSM_ST_SOFT_FAIL:
+			printf("SNVS state transitioning to Soft Fail.\n");
+			setbits_be32(&snvs_regs->hp_com, HPCOMR_SW_FSV);
+
+			/*
+			 * polling loop till SNVS is in
+			 * Soft Fail state
+			 */
+			while (((sts & HPSR_SSM_ST_MASK) !=
+				HPSR_SSM_ST_SOFT_FAIL)) {
+				while (timeout) {
+					sts = in_be32(&snvs_regs->hp_stat);
+
+					if ((sts & HPSR_SSM_ST_MASK) ==
+						HPSR_SSM_ST_SOFT_FAIL)
+						break;
+
+					udelay(10);
+					timeout--;
+				}
+			}
+
+			if (timeout == 0) {
+				printf("SNVS state transition timeout.\n");
+				branch_to_self();
+			}
+			break;
+		default:
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+void generate_reset_req(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	printf("Generating reset request");
+	out_be32(&gur->rstcr, 0x2);	/* HRESET_REQ */
+	branch_to_self();
+}
diff --git a/arch/powerpc/cpu/mpc85xx/fsl_validate.c b/arch/powerpc/cpu/mpc85xx/fsl_validate.c
new file mode 100644
index 0000000..e668498
--- /dev/null
+++ b/arch/powerpc/cpu/mpc85xx/fsl_validate.c
@@ -0,0 +1,769 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <fsl_validate.h>
+#include <fsl_secboot_err.h>
+#include <asm/fsl_sfp_snvs.h>
+#include <command.h>
+#include <common.h>
+#include <malloc.h>
+#include <rsa_sec.h>
+#include <sha.h>
+#include <jr.h>
+#include <jobdesc.h>
+#include <asm/fsl_pamu.h>
+
+#define SHA256_BITS	256
+#define SHA256_BYTES	(256/8)
+#define SHA256_NIBBLES	(256/4)
+#define NUM_HEX_CHARS	(sizeof(ulong) * 2)
+
+extern struct jobring jr;
+
+/* This array contains DER value for SHA-256 */
+static const u8 hash_identifier[] = { 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60,
+		0x86, 0x48, 0x01, 0x65,	0x03, 0x04, 0x02, 0x01, 0x05, 0x00,
+		0x04, 0x20
+		};
+
+static u8 hash_val[SHA256_BYTES];
+static const u8 barker_code[ESBC_BARKER_LEN] = { 0x68, 0x39, 0x27, 0x81 };
+
+void branch_to_self(void) __attribute__ ((noreturn));
+
+/*
+ * This function will put core in infinite loop.
+ * This will be called when the ESBC can not proceed further due
+ * to some errors.
+ */
+void branch_to_self(void)
+{
+	printf("Core is in infinite loop due to errors.\n");
+	while (1);
+}
+
+/*
+ * Handles the ESBC uboot client header verification failure.
+ * This  function  handles all the errors which might occur in the
+ * parsing and checking of ESBC uboot client header. It will also
+ * set the error bits in the SNVS.
+ */
+static void fsl_secboot_header_verification_failure(void)
+{
+	ccsr_snvs_regs_t *snvs_regs = (void *)(CONFIG_SYS_SNVS_ADDR);
+	ccsr_sfp_regs_t *sfp_regs = (void *)(CONFIG_SYS_SFP_ADDR);
+	u32 sts = in_be32(&snvs_regs->hp_stat);
+
+	/* 29th bit of OSPR is ITS */
+	u32 its = in_be32(&sfp_regs->ospr) >> 2;
+
+	/*
+	 * Read the SNVS status register
+	 * Read SSM_ST field
+	 */
+	sts = in_be32(&snvs_regs->hp_stat);
+	if ((sts & HPSR_SSM_ST_MASK) == HPSR_SSM_ST_TRUST) {
+		if (its == 1)
+			change_sec_mon_state(HPSR_SSM_ST_TRUST,
+				HPSR_SSM_ST_SOFT_FAIL);
+		else
+			change_sec_mon_state(HPSR_SSM_ST_TRUST,
+				HPSR_SSM_ST_NON_SECURE);
+	}
+
+	generate_reset_req();
+}
+
+/*
+ * Handles the ESBC uboot client image verification failure.
+ * This  function  handles all the errors which might occur in the
+ * public key hash comparison and signature verification of
+ * ESBC uboot client image. It will also
+ * set the error bits in the SNVS.
+ */
+static void fsl_secboot_image_verification_failure(void)
+{
+	ccsr_snvs_regs_t *snvs_regs = (void *)(CONFIG_SYS_SNVS_ADDR);
+	ccsr_sfp_regs_t *sfp_regs = (void *)(CONFIG_SYS_SFP_ADDR);
+	u32 sts = in_be32(&snvs_regs->hp_stat);
+
+	u32 its = in_be32(&sfp_regs->ospr) & ITS_MASK >> ITS_BIT;
+
+	/*
+	 * Read the SNVS status register
+	 * Read SSM_ST field
+	 */
+	sts = in_be32(&snvs_regs->hp_stat);
+	if ((sts & HPSR_SSM_ST_MASK) == HPSR_SSM_ST_TRUST) {
+		if (its == 1) {
+			change_sec_mon_state(HPSR_SSM_ST_TRUST,
+				HPSR_SSM_ST_SOFT_FAIL);
+
+			generate_reset_req();
+		} else {
+			change_sec_mon_state(HPSR_SSM_ST_TRUST,
+				HPSR_SSM_ST_NON_SECURE);
+		}
+	}
+}
+
+static void fsl_secboot_bootscript_parse_failure(void)
+{
+	fsl_secboot_header_verification_failure();
+}
+
+/*
+ * Handles the errors in esbc boot.
+ * This  function  handles all the errors which might occur in the
+ * esbc boot phase. It will call the appropriate api to log the
+ * errors and set the error bits in the SNVS.
+ */
+void fsl_secboot_handle_error(int error)
+{
+	const struct fsl_secboot_errcode *e;
+
+	for (e = fsl_secboot_errcodes; e->errcode != ERROR_ESBC_CLIENT_MAX;
+		e++) {
+		if (e->errcode == error)
+			printf("ERROR :: %x :: %s\n", error, e->name);
+	}
+
+	switch (error) {
+	case ERROR_ESBC_CLIENT_HEADER_BARKER:
+	case ERROR_ESBC_CLIENT_HEADER_IMG_SIZE:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_SIG_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2:
+	case ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD:
+	case ERROR_ESBC_CLIENT_HEADER_SG_ESBC_EP:
+	case ERROR_ESBC_CLIENT_HEADER_SG_ENTIRES_BAD:
+		fsl_secboot_header_verification_failure();
+		break;
+	case ERROR_ESBC_SEC_RESET:
+	case ERROR_ESBC_SEC_DEQ:
+	case ERROR_ESBC_SEC_ENQ:
+	case ERROR_ESBC_SEC_DEQ_TO:
+	case ERROR_ESBC_SEC_JOBQ_STATUS:
+	case ERROR_ESBC_CLIENT_HASH_COMPARE_KEY:
+	case ERROR_ESBC_CLIENT_HASH_COMPARE_EM:
+		fsl_secboot_image_verification_failure();
+		break;
+	case ERROR_ESBC_MISSING_BOOTM:
+		fsl_secboot_bootscript_parse_failure();
+		break;
+	case ERROR_ESBC_WRONG_CMD:
+	default:
+		branch_to_self();
+		break;
+	}
+}
+
+static void fsl_secblk_handle_error(int error)
+{
+	switch (error) {
+	case ERROR_ESBC_SEC_ENQ:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_ENQ);
+		break;
+	case ERROR_ESBC_SEC_DEQ:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_DEQ);
+		break;
+	case ERROR_ESBC_SEC_DEQ_TO:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_DEQ_TO);
+		break;
+	default:
+		printf("Job Queue Output status %x\n", error);
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_JOBQ_STATUS);
+		break;
+	}
+}
+
+/*
+ * Calculate hash of key obtained via offset present in ESBC uboot
+ * client hdr. This function calculates the hash of key which is obtained
+ * through offset present in ESBC uboot client header.
+ */
+static int calc_img_key_hash(struct sha_ctx *ctx,
+				struct fsl_secboot_img_priv *img)
+{
+	int i;
+	int ret = 0;
+
+	/* calc hash of the esbc key */
+	sha_init(ctx, &jr);
+	sha_update(ctx, img->img_key, img->hdr.key_len);
+	ret = sha_final(ctx);
+	if (ret)
+		return ret;
+
+	ret = sha_digest(ctx, hash_val);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < SHA256_BYTES; i++)
+		img->img_key_hash[i] = hash_val[i];
+
+	return 0;
+}
+
+/*
+ * Calculate hash of ESBC hdr and ESBC. This function calculates the
+ * single hash of ESBC header and ESBC image. If SG flag is on, all
+ * SG entries are also hashed alongwith the complete SG table.
+ */
+static int calc_esbchdr_esbc_hash(struct sha_ctx *ctx,
+	struct fsl_secboot_img_priv *img)
+{
+	int i = 0;
+	int ret = 0;
+
+	/* calculate the hash of the CSF header */
+	sha_init(ctx, &jr);
+	sha_update(ctx, (u8 *) &img->hdr,
+		sizeof(struct fsl_secboot_img_hdr));
+	sha_update(ctx, img->img_key, img->hdr.key_len);
+
+	if (img->hdr.sg_flag) {
+		/* calculate hash of the SG table */
+		sha_update(ctx, (u8 *) &img->sgtbl,
+			img->hdr.sg_entries *
+			sizeof(struct fsl_secboot_sg_table));
+
+		/* calculate the hash of each entry in the table */
+		for (i = 0; i < img->hdr.sg_entries; i++)
+			sha_update(ctx, img->sgtbl[i].pdata,
+				img->sgtbl[i].len);
+	} else {
+		/* contiguous ESBC */
+		sha_update(ctx, (u8 *) img->hdr.pimg,
+			img->hdr.img_size);
+	}
+
+	ret = sha_final(ctx);
+	if (ret)
+		return ret;
+
+	ret = sha_digest(ctx, hash_val);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * Construct encoded hash EM' wrt PKCSv1.5. This function calculates the
+ * pointers for padding, DER value and hash. And finally, constructs EM'
+ * which includes hash of complete CSF header and ESBC image. If SG flag
+ * is on, hash of SG table and entries is also included.
+ */
+static void construct_img_encoded_hash_second(struct fsl_secboot_img_priv *img)
+{
+	/*
+	 * RSA PKCSv1.5 encoding format for encoded message is below
+	 * EM = 0x0 || 0x1 || PS || 0x0 || DER || Hash
+	 * PS is Padding String
+	 * DER is DER value for SHA-256
+	 * Hash is SHA-256 hash
+	 * *********************************************************
+	 * representative points to first byte of EM initially and is
+	 * filled with 0x0
+	 * representative is incremented by 1 and second byte is filled
+	 * with 0x1
+	 * padding points to third byte of EM
+	 * digest points to full length of EM - 32 bytes
+	 * hash_id (DER value) points to 19 bytes before pDigest
+	 * separator is one byte which separates padding and DER
+	 */
+
+	size_t len;
+	u8 *representative;
+	u8 *padding, *digest;
+	u8 *hash_id, *separator;
+	int i;
+
+	len = (img->hdr.key_len / 2) - 1;
+	representative = img->img_encoded_hash_second;
+	representative[0] = 0;
+	representative[1] = 1;  /* block type 1 */
+
+	padding = &representative[2];
+	digest = &representative[1] + len - 32;
+	hash_id = digest - sizeof(hash_identifier);
+	separator = hash_id - 1;
+
+	/* fill padding area pointed by padding with 0xff */
+	memset(padding, 0xff, separator - padding);
+
+	/* fill byte pointed by separator */
+	*separator = 0;
+
+	/* fill SHA-256 DER value  pointed by HashId */
+	memcpy(hash_id, hash_identifier, sizeof(hash_identifier));
+
+	/* fill hash pointed by Digest */
+	for (i = 0; i < SHA256_BYTES; i++)
+		digest[i] = hash_val[i];
+}
+
+/*
+ * Reads and validates the ESBC client header.
+ * This function reads key and signature from the ESBC client header.
+ * If Scatter/Gather flag is on, lengths and offsets of images
+ * present as SG entries are also read. This function also checks
+ * whether the header is valid or not.
+ */
+static int read_validate_esbc_client_header(struct fsl_secboot_img_priv *img)
+{
+	char buf[20];
+	struct fsl_secboot_img_hdr *hdr = &img->hdr;
+	void *esbc = (u8 *) img->ehdrloc;
+	u8 *k, *s;
+
+	/* check barker code */
+	if (memcmp(hdr->barker, barker_code, ESBC_BARKER_LEN))
+		return ERROR_ESBC_CLIENT_HEADER_BARKER;
+
+	sprintf(buf, "%p", hdr->pimg);
+	setenv("img_addr", buf);
+
+	if (!hdr->img_size)
+		return ERROR_ESBC_CLIENT_HEADER_IMG_SIZE;
+
+	/* key length should be twice of signature length */
+	if (hdr->key_len == 2 * hdr->sign_len) {
+		/* check key length */
+		if (!((hdr->key_len == 2 * KEY_SIZE_BYTES / 4) ||
+			(hdr->key_len == 2 * KEY_SIZE_BYTES / 2) ||
+			(hdr->key_len == 2 * KEY_SIZE_BYTES)))
+			return ERROR_ESBC_CLIENT_HEADER_KEY_LEN;
+
+		/* check signature length */
+		if (!((hdr->sign_len == KEY_SIZE_BYTES / 4) ||
+			(hdr->sign_len == KEY_SIZE_BYTES / 2) ||
+			(hdr->sign_len == KEY_SIZE_BYTES)))
+			return ERROR_ESBC_CLIENT_HEADER_SIG_LEN;
+	} else {
+		return ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN;
+	}
+
+	memcpy(&img->img_key, esbc + hdr->pkey, hdr->key_len);
+	memcpy(&img->img_sign, esbc + hdr->psign, hdr->sign_len);
+
+	/* No SG support */
+	if (hdr->sg_flag)
+		return ERROR_ESBC_CLIENT_HEADER_SG;
+
+	/* modulus most significant bit should be set */
+	k = (u8 *) &img->img_key;
+
+	if ((k[0] & 0x80) == 0)
+		return ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1;
+
+	/* modulus value should be odd */
+	if ((k[hdr->key_len / 2 - 1] & 0x1) == 0)
+		return ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2;
+
+	/* Check signature value < modulus value */
+	s = (u8 *) &img->img_sign;
+
+	if (!(memcmp(s, k, hdr->sign_len) < 0))
+		return ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD;
+
+	return ESBC_VALID_HDR;
+}
+
+static inline int str2long(const char *p, ulong *num)
+{
+	char *endptr;
+
+	if (!p)
+		return 0;
+	else
+		*num = simple_strtoul(p, &endptr, 16);
+
+	return *p != '\0' && *endptr == '\0';
+}
+
+void done(uint32_t desc, uint32_t status, void *arg)
+{
+	struct result *x = arg;
+	x->status = status;
+	x->err = caam_jr_strstatus(x->outstr, status);
+	x->done = 1;
+}
+
+int fsl_secboot_blob_decap(cmd_tbl_t *cmdtp, int flag, int argc,
+		char * const argv[])
+{
+	ulong enc_addr = simple_strtoul(argv[1], NULL, 16);
+	ulong blob_decap_addr = simple_strtoul(argv[2], NULL, 16);
+	ulong out_sz = simple_strtoul(argv[3], NULL, 16);
+
+	int ret;
+	uint32_t desc[64];
+	struct result op;
+	unsigned long long timeval;
+	unsigned long long timeout;
+	char key_str[NUM_HEX_CHARS + 1];
+	ulong key_id[16/sizeof(ulong)];
+
+#ifdef CONFIG_FSL_CORENET
+	pamu_enable();
+#endif
+	memset(&op, 0, sizeof(struct result));
+
+	if (argc == 5) {
+		char *cp = argv[4];
+		int i = 0;
+
+		if (*cp == '0' && *(cp + 1) == 'x')
+			cp += 2;
+
+		/* The input string expected is in hex, where
+		 * each 4 bits would be represented by a hex
+		 * sha256 hash is 256 bits long, which would mean
+		 * num of characters = 256 / 4
+		 */
+		if (strlen(cp) != 32) {
+			printf("%s is not a 16 byte hex string as expected\n",
+				argv[4]);
+			return -1;
+		}
+
+		for (i = 0; i < sizeof(key_id)/sizeof(ulong); i++) {
+			strncpy(key_str, cp + (i * NUM_HEX_CHARS),
+				NUM_HEX_CHARS);
+			key_str[NUM_HEX_CHARS] = '\0';
+			if (!str2long(key_str, &key_id[i])) {
+				printf("%s is not a 128 bit hex string\n",
+					argv[4]);
+				return -1;
+			}
+		}
+	}
+
+#ifdef DEBUG
+	printf("enc text at addr %lx" , enc_addr);
+	printf("blob_decap text at addr %lx" , blob_decap_addr);
+	printf("size %lx" , out_sz);
+#endif
+	printf("Decapsulating\n");
+
+	inline_cnstr_jobdesc_blob_decap(desc, (uint8_t *)key_id,
+		(uint8_t *)enc_addr, (uint8_t *)blob_decap_addr, out_sz);
+
+	ret = jr_enqueue(&jr, desc, done, &op);
+	if (ret) {
+		printf("enq failed with ret %d\n", ret);
+		fsl_secblk_handle_error(ret);
+		goto out;
+	}
+
+#ifdef DEBUG
+	printf("Descriptor\n");
+	for (i = 0; i < 16; i++)
+		printf("0x%x\n", desc[i]);
+#endif
+
+	timeval = get_ticks();
+	timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+
+	while (op.done != 1) {
+		if (jr_dequeue(&jr)) {
+			printf("Deq error ERROR_ESBC_SEC_DEQ\n");
+			fsl_secblk_handle_error(ERROR_ESBC_SEC_DEQ);
+			goto out;
+		}
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("SEC Dequeue timed out\n");
+			fsl_secblk_handle_error(ERROR_ESBC_SEC_DEQ_TO);
+			goto out;
+		}
+	}
+
+	if (op.err < 0) {
+		fsl_secblk_handle_error(op.status);
+		goto out;
+	}
+
+	printf("Decapsulation successful\n");
+
+out:
+#ifdef CONFIG_FSL_CORENET
+	pamu_disable();
+#endif
+	if (jr_reset(&jr) < 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_RESET);
+		return 0;
+	}
+	return 0;
+}
+
+int fsl_secboot_blob_encap(cmd_tbl_t *cmdtp, int flag, int argc,
+		char * const argv[])
+{
+	ulong plain_addr = simple_strtoul(argv[1], NULL, 16);
+	ulong enc_addr = simple_strtoul(argv[2], NULL, 16);
+	ulong in_sz = simple_strtoul(argv[3], NULL, 16);
+	int ret;
+	uint32_t desc[64];
+	struct result op;
+	unsigned long long timeval;
+	unsigned long long timeout;
+	int i = 0;
+#ifdef CONFIG_FSL_CORENET
+	pamu_enable();
+#endif
+	char key_str[NUM_HEX_CHARS + 1];
+	ulong key_id[KEY_IDNFR_SZ_BYTES/sizeof(ulong)];
+
+	memset(&op, 0, sizeof(struct result));
+
+	if (argc == 5) {
+		char *cp = argv[4];
+		int i = 0;
+
+		if (*cp == '0' && *(cp + 1) == 'x')
+			cp += 2;
+
+		/* The input string expected is in hex, where
+		 * each 4 bits would be represented by a hex
+		 * sha256 hash is 256 bits long, which would mean
+		 * num of characters = 256 / 4
+		 */
+		if (strlen(cp) != 32) {
+			printf("%s is not a 16 byte hex string as expected\n",
+				argv[4]);
+			return -1;
+		}
+
+		for (i = 0; i < sizeof(key_id)/sizeof(ulong); i++) {
+			strncpy(key_str, cp + (i * NUM_HEX_CHARS),
+				NUM_HEX_CHARS);
+			key_str[NUM_HEX_CHARS] = '\0';
+			if (!str2long(key_str, &key_id[i])) {
+				printf("%s is not a 128 bit hex string\n"
+					, argv[4]);
+				return -1;
+			}
+		}
+	}
+
+	printf("\nEncapsulating data\n");
+
+#ifdef DEBUG
+	printf("plain text at addr %lx\n" , plain_addr);
+	printf("enc text at addr %lx\n" , enc_addr);
+	printf("size %lx\n" , in_sz);
+	for (i = 0; i < 4; i++)
+		printf("%x\t", key_id[i]);
+#endif
+
+	inline_cnstr_jobdesc_blob_encap(desc, (uint8_t *)key_id,
+		(uint8_t *)plain_addr, (uint8_t *)enc_addr, in_sz);
+	ret = jr_enqueue(&jr, desc, done, &op);
+	if (ret) {
+		printf("enq failed with ret %d\n", ret);
+		fsl_secblk_handle_error(ret);
+		goto out;
+	}
+
+#ifdef DEBUG
+#endif
+
+	timeval = get_ticks();
+	timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+
+	while (op.done != 1) {
+		if (jr_dequeue(&jr)) {
+			printf("deq error ERROR_ESBC_SEC_DEQ\n");
+			fsl_secblk_handle_error(ERROR_ESBC_SEC_DEQ);
+			goto out;
+		}
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("SEC Dequeue timed out\n");
+			fsl_secblk_handle_error(ERROR_ESBC_SEC_DEQ_TO);
+			goto out;
+		}
+	}
+
+	if (op.err < 0) {
+		fsl_secblk_handle_error(op.status);
+		printf("Descriptor\n");
+		for (i = 0; i < 16; i++)
+			printf("0x%x\n", desc[i]);
+		goto out;
+	}
+
+	printf("Encapsulation succesful\n");
+
+out:
+#ifdef CONFIG_FSL_CORENET
+	pamu_disable();
+#endif
+	if (jr_reset(&jr) < 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_RESET);
+		return 0;
+	}
+	return 0;
+
+}
+
+int fsl_secboot_validate(cmd_tbl_t *cmdtp, int flag, int argc,
+		char * const argv[])
+{
+	int hash_srk = 1;
+	ccsr_sfp_regs_t *sfp_regs = (void *)(CONFIG_SYS_SFP_ADDR);
+	ulong hash[SHA256_BYTES/sizeof(ulong)];
+	char hash_str[NUM_HEX_CHARS + 1];
+	struct sha_ctx ctx;
+	struct rsa_context rsa_ctx;
+	ulong addr = simple_strtoul(argv[1], NULL, 16);
+	struct fsl_secboot_img_priv *img;
+	struct fsl_secboot_img_hdr *hdr;
+	void *esbc;
+	int ret, i;
+	u32 srk_hash[8];
+
+	if (argc == 3) {
+		char *cp = argv[2];
+		int i = 0;
+
+		if (*cp == '0' && *(cp + 1) == 'x')
+			cp += 2;
+
+		/* The input string expected is in hex, where
+		 * each 4 bits would be represented by a hex
+		 * sha256 hash is 256 bits long, which would mean
+		 * num of characters = 256 / 4
+		 */
+		if (strlen(cp) != SHA256_NIBBLES) {
+			printf("%s is not a 256 bits hex string as expected\n",
+				argv[2]);
+			return -1;
+		}
+
+		for (i = 0; i < sizeof(hash)/sizeof(ulong); i++) {
+			strncpy(hash_str, cp + (i * NUM_HEX_CHARS),
+				NUM_HEX_CHARS);
+			hash_str[NUM_HEX_CHARS] = '\0';
+			if (!str2long(hash_str, &hash[i])) {
+				printf("%s is not a 256 bits hex string "
+					"as expected\n", argv[2]);
+				return -1;
+			}
+		}
+
+		hash_srk = 0;
+	}
+
+#ifdef CONFIG_FSL_CORENET
+	pamu_enable();
+#endif
+	img = malloc(sizeof(struct fsl_secboot_img_priv));
+
+	if (!img)
+		return -1;
+
+	memset(img, 0, sizeof(struct fsl_secboot_img_priv));
+
+	hdr = &img->hdr;
+	img->ehdrloc = addr;
+	esbc = (u8 *) img->ehdrloc;
+
+	memcpy(hdr, esbc, sizeof(struct fsl_secboot_img_hdr));
+
+	/* read and validate esbc header */
+	ret = read_validate_esbc_client_header(img);
+
+	if (ret != ESBC_VALID_HDR) {
+		fsl_secboot_handle_error(ret);
+		goto exit1;
+	}
+
+	/* SRKH present in SFP */
+	for (i = 0; i < NUM_SRKH_REGS; i++)
+		srk_hash[i] = in_be32(&sfp_regs->srk_hash[i]);
+
+	/*
+	 * Calculate hash of key obtained via offset present in
+	 * ESBC uboot client hdr
+	 */
+	ret = calc_img_key_hash(&ctx, img);
+	if (ret) {
+		fsl_secblk_handle_error(ret);
+		goto exit;
+	}
+
+	/* Compare hash obtained above with SRK hash present in SFP */
+	if (hash_srk)
+		ret = memcmp(srk_hash, img->img_key_hash, SHA256_BYTES);
+	else
+		ret = memcmp(&hash, &img->img_key_hash, SHA256_BYTES);
+
+	if (ret != 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_CLIENT_HASH_COMPARE_KEY);
+		goto exit;
+	}
+
+	ret = calc_esbchdr_esbc_hash(&ctx, img);
+	if (ret) {
+		fsl_secblk_handle_error(ret);
+		goto exit;
+	}
+
+	/* Construct encoded hash EM' wrt PKCSv1.5 */
+	construct_img_encoded_hash_second(img);
+
+	ret = rsa_public_verif_sec(img->img_sign, img->img_encoded_hash,
+		img->img_key, img->hdr.key_len / 2, &rsa_ctx, &jr);
+	if (ret) {
+		fsl_secblk_handle_error(ret);
+		goto exit;
+	}
+
+	/*
+	 * compare the encoded messages EM' and EM wrt RSA PKCSv1.5
+	 * memcmp returns zero on success
+	 * memcmp returns non-zero on failure
+	 */
+	ret = memcmp(&img->img_encoded_hash_second, &img->img_encoded_hash,
+		img->hdr.sign_len);
+
+	if (ret) {
+		fsl_secboot_handle_error(ERROR_ESBC_CLIENT_HASH_COMPARE_EM);
+		goto exit;
+	}
+
+	printf("esbc_validate command successful\n");
+
+exit:
+	if (jr_reset(&jr) < 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_RESET);
+		return 0;
+	}
+exit1:
+#ifdef CONFIG_FSL_CORENET
+	pamu_disable();
+#endif
+	return 0;
+}
diff --git a/arch/powerpc/cpu/mpc85xx/liodn.c b/arch/powerpc/cpu/mpc85xx/liodn.c
index 2e53367..881cecc 100644
--- a/arch/powerpc/cpu/mpc85xx/liodn.c
+++ b/arch/powerpc/cpu/mpc85xx/liodn.c
@@ -137,6 +137,17 @@ static void setup_pme_liodn_base(void)
 #endif
 }
 
+static void setup_dce_liodn_base(void)
+{
+#ifdef CONFIG_SYS_DPAA_DCE
+	ccsr_dce_t *dce = (void *)CONFIG_SYS_FSL_CORENET_DCE_ADDR;
+	u32 base = (liodn_bases[FSL_HW_PORTAL_DCE].id[0] << 16) |
+			liodn_bases[FSL_HW_PORTAL_DCE].id[1];
+
+	out_be32(&dce->liodnbr, base);
+#endif
+}
+
 #ifdef CONFIG_SYS_FSL_RAID_ENGINE
 static void setup_raide_liodn_base(void)
 {
@@ -208,6 +219,8 @@ void set_liodns(void)
 #endif
 	/* setup PME liodn base */
 	setup_pme_liodn_base();
+	/* setup DCE liodn base */
+	setup_dce_liodn_base();
 
 #ifdef CONFIG_SYS_FSL_RAID_ENGINE
 	/* raid engine ccr addr code for liodn */
@@ -255,9 +268,9 @@ static void fdt_fixup_srio_liodn(void *blob, struct srio_liodn_id_table *tbl)
 #endif
 
 #define CONFIG_SYS_MAX_PCI_EPS		8
-#define CONFIG_SYS_PCI_EP_LIODN_START	256
 
-static void fdt_fixup_pci_liodn_offsets(void *fdt, const char *compat)
+static void fdt_fixup_pci_liodn_offsets(void *fdt, const char *compat,
+					int ep_liodn_start)
 {
 	int off, pci_idx = 0, pci_cnt = 0, i, rc;
 	const uint32_t *base_liodn;
@@ -287,7 +300,7 @@ static void fdt_fixup_pci_liodn_offsets(void *fdt, const char *compat)
 			continue;
 		}
 		for (i = 0; i < CONFIG_SYS_MAX_PCI_EPS; i++)
-			liodn_offs[i + 1] = CONFIG_SYS_PCI_EP_LIODN_START +
+			liodn_offs[i + 1] = ep_liodn_start +
 					i * pci_cnt + pci_idx - *base_liodn;
 		rc = fdt_setprop(fdt, off, "fsl,liodn-offset-list",
 				 liodn_offs, sizeof(liodn_offs));
@@ -354,5 +367,22 @@ void fdt_fixup_liodn(void *blob)
 	fdt_fixup_liodn_tbl(blob, rman_liodn_tbl, rman_liodn_tbl_sz);
 #endif
 
-	fdt_fixup_pci_liodn_offsets(blob, "fsl,qoriq-pcie-v2.4");
+	ccsr_pcix_t *pcix = (ccsr_pcix_t *)CONFIG_SYS_PCIE1_ADDR;
+	int pci_ver = pcix->ipver1 & 0xffff, liodn_base = 0;
+
+	if (pci_ver >= 0x0204) {
+		if (pci_ver >= 0x0300)
+			liodn_base = 1024;
+		else
+			liodn_base = 256;
+	}
+
+	if (liodn_base) {
+		char compat[32];
+
+		sprintf(compat, "fsl,qoriq-pcie-v%d.%d",
+			(pci_ver & 0xff00) >> 8, pci_ver & 0xff);
+		fdt_fixup_pci_liodn_offsets(blob, compat, liodn_base);
+		fdt_fixup_pci_liodn_offsets(blob, "fsl,qoriq-pcie", liodn_base);
+	}
 }
diff --git a/arch/powerpc/cpu/mpc85xx/mp.c b/arch/powerpc/cpu/mpc85xx/mp.c
index 43d4836..e93c0ff 100644
--- a/arch/powerpc/cpu/mpc85xx/mp.c
+++ b/arch/powerpc/cpu/mpc85xx/mp.c
@@ -80,6 +80,8 @@ int cpu_status(int nr)
 	if (nr == id) {
 		table = (u32 *)&__spin_table;
 		printf("table base @ 0x%p\n", table);
+	} else if (is_core_disabled(nr)) {
+		puts("Disabled\n");
 	} else {
 		table = (u32 *)&__spin_table + nr * NUM_BOOT_ENTRY;
 		printf("Running on cpu %d\n", id);
@@ -96,18 +98,35 @@ int cpu_status(int nr)
 #ifdef CONFIG_FSL_CORENET
 int cpu_disable(int nr)
 {
-	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006208
+	ccsr_rcpm_t *rcpm = (void __iomem *)(CONFIG_SYS_FSL_CORENET_RCPM_ADDR);
 
+	if (SVR_MAJ(get_svr()) == 1) {
+		setbits_be32(&rcpm->pcph30setr, 1 << nr);
+		return 0;
+	}
+#endif
 	setbits_be32(&gur->coredisrl, 1 << nr);
 
 	return 0;
 }
 
-int is_core_disabled(int nr) {
-	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
-	u32 coredisrl = in_be32(&gur->coredisrl);
+int is_core_disabled(int nr)
+{
+	u32 coredisrl;
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006208
+	ccsr_rcpm_t *rcpm = (void __iomem *)(CONFIG_SYS_FSL_CORENET_RCPM_ADDR);
+
+	if (SVR_MAJ(get_svr()) == 1) {
+		coredisrl = in_be32(&rcpm->pcph30sr);
+		return coredisrl & (1 << nr);
+	}
+#endif
+	coredisrl = in_be32(&gur->coredisrl);
 
-	return (coredisrl & (1 << nr));
+	return coredisrl & (1 << nr);
 }
 #else
 int cpu_disable(int nr)
diff --git a/arch/powerpc/cpu/mpc85xx/p2041_ids.c b/arch/powerpc/cpu/mpc85xx/p2041_ids.c
index 91d9cac..956c562 100644
--- a/arch/powerpc/cpu/mpc85xx/p2041_ids.c
+++ b/arch/powerpc/cpu/mpc85xx/p2041_ids.c
@@ -27,16 +27,16 @@
 #ifdef CONFIG_SYS_DPAA_QBMAN
 struct qportal_info qp_info[CONFIG_SYS_QMAN_NUM_PORTALS] = {
 	/* dqrr liodn, frame data liodn, liodn off, sdest */
-	SET_QP_INFO(1, 2, 1, 0),
-	SET_QP_INFO(3, 4, 2, 1),
-	SET_QP_INFO(5, 6, 3, 2),
-	SET_QP_INFO(7, 8, 4, 3),
-	SET_QP_INFO(9, 10, 5, 0),
-	SET_QP_INFO(11, 12, 1, 1),
-	SET_QP_INFO(13, 14, 2, 2),
-	SET_QP_INFO(15, 16, 3, 3),
-	SET_QP_INFO(17, 18, 4, 0), /* for now sdest to 0 */
-	SET_QP_INFO(19, 20, 5, 0), /* for now sdest to 0 */
+	SET_QP_INFO( 1,  2,  1, 0),
+	SET_QP_INFO( 3,  4,  2, 1),
+	SET_QP_INFO( 5,  6,  3, 2),
+	SET_QP_INFO( 7,  8,  4, 3),
+	SET_QP_INFO( 9, 10,  5, 0),
+	SET_QP_INFO(11, 12,  6, 1),
+	SET_QP_INFO(13, 14,  7, 2),
+	SET_QP_INFO(15, 16,  8, 3),
+	SET_QP_INFO(17, 18,  9, 0), /* for now sdest to 0 */
+	SET_QP_INFO(19, 20, 10, 0), /* for now sdest to 0 */
 };
 #endif
 
diff --git a/arch/powerpc/cpu/mpc85xx/p3041_ids.c b/arch/powerpc/cpu/mpc85xx/p3041_ids.c
index e46a714..57fe00f 100644
--- a/arch/powerpc/cpu/mpc85xx/p3041_ids.c
+++ b/arch/powerpc/cpu/mpc85xx/p3041_ids.c
@@ -27,16 +27,16 @@
 #ifdef CONFIG_SYS_DPAA_QBMAN
 struct qportal_info qp_info[CONFIG_SYS_QMAN_NUM_PORTALS] = {
 	/* dqrr liodn, frame data liodn, liodn off, sdest */
-	SET_QP_INFO(1, 2, 1, 0),
-	SET_QP_INFO(3, 4, 2, 1),
-	SET_QP_INFO(5, 6, 3, 2),
-	SET_QP_INFO(7, 8, 4, 3),
-	SET_QP_INFO(9, 10, 5, 0),
-	SET_QP_INFO(11, 12, 1, 1),
-	SET_QP_INFO(13, 14, 2, 2),
-	SET_QP_INFO(15, 16, 3, 3),
-	SET_QP_INFO(17, 18, 4, 0), /* for now sdest to 0 */
-	SET_QP_INFO(19, 20, 5, 0), /* for now sdest to 0 */
+	SET_QP_INFO( 1,  2,  1, 0),
+	SET_QP_INFO( 3,  4,  2, 1),
+	SET_QP_INFO( 5,  6,  3, 2),
+	SET_QP_INFO( 7,  8,  4, 3),
+	SET_QP_INFO( 9, 10,  5, 0),
+	SET_QP_INFO(11, 12,  6, 1),
+	SET_QP_INFO(13, 14,  7, 2),
+	SET_QP_INFO(15, 16,  8, 3),
+	SET_QP_INFO(17, 18,  9, 0), /* for now sdest to 0 */
+	SET_QP_INFO(19, 20, 10, 0), /* for now sdest to 0 */
 };
 #endif
 
diff --git a/arch/powerpc/cpu/mpc85xx/p5020_ids.c b/arch/powerpc/cpu/mpc85xx/p5020_ids.c
index e8c26bf..3f363d9 100644
--- a/arch/powerpc/cpu/mpc85xx/p5020_ids.c
+++ b/arch/powerpc/cpu/mpc85xx/p5020_ids.c
@@ -27,16 +27,16 @@
 #ifdef CONFIG_SYS_DPAA_QBMAN
 struct qportal_info qp_info[CONFIG_SYS_QMAN_NUM_PORTALS] = {
 	/* dqrr liodn, frame data liodn, liodn off, sdest */
-	SET_QP_INFO(1, 2, 1, 0),
-	SET_QP_INFO(3, 4, 2, 1),
-	SET_QP_INFO(5, 6, 3, 0),
-	SET_QP_INFO(7, 8, 4, 1),
-	SET_QP_INFO(9, 10, 5, 0),
-	SET_QP_INFO(11, 12, 1, 1),
-	SET_QP_INFO(13, 14, 2, 0),
-	SET_QP_INFO(15, 16, 3, 1),
-	SET_QP_INFO(17, 18, 4, 0),
-	SET_QP_INFO(19, 20, 5, 1),
+	SET_QP_INFO( 1,  2,  1, 0),
+	SET_QP_INFO( 3,  4,  2, 1),
+	SET_QP_INFO( 5,  6,  3, 0),
+	SET_QP_INFO( 7,  8,  4, 1),
+	SET_QP_INFO( 9, 10,  5, 0),
+	SET_QP_INFO(11, 12,  6, 1),
+	SET_QP_INFO(13, 14,  7, 0),
+	SET_QP_INFO(15, 16,  8, 1),
+	SET_QP_INFO(17, 18,  9, 0),
+	SET_QP_INFO(19, 20, 10, 1),
 };
 #endif
 
diff --git a/arch/powerpc/cpu/mpc85xx/p5040_ids.c b/arch/powerpc/cpu/mpc85xx/p5040_ids.c
index 878ee3e..dca0cae 100644
--- a/arch/powerpc/cpu/mpc85xx/p5040_ids.c
+++ b/arch/powerpc/cpu/mpc85xx/p5040_ids.c
@@ -65,23 +65,23 @@ int liodn_tbl_sz = ARRAY_SIZE(liodn_tbl);
 
 #ifdef CONFIG_SYS_DPAA_FMAN
 struct liodn_id_table fman1_liodn_tbl[] = {
-	SET_FMAN_RX_1G_LIODN(1, 0, 6),
-	SET_FMAN_RX_1G_LIODN(1, 1, 7),
-	SET_FMAN_RX_1G_LIODN(1, 2, 8),
-	SET_FMAN_RX_1G_LIODN(1, 3, 9),
-	SET_FMAN_RX_1G_LIODN(1, 4, 10),
-	SET_FMAN_RX_10G_LIODN(1, 0, 11),
+	SET_FMAN_RX_1G_LIODN(1, 0, 11),
+	SET_FMAN_RX_1G_LIODN(1, 1, 12),
+	SET_FMAN_RX_1G_LIODN(1, 2, 13),
+	SET_FMAN_RX_1G_LIODN(1, 3, 14),
+	SET_FMAN_RX_1G_LIODN(1, 4, 15),
+	SET_FMAN_RX_10G_LIODN(1, 0, 16),
 };
 int fman1_liodn_tbl_sz = ARRAY_SIZE(fman1_liodn_tbl);
 
 #if (CONFIG_SYS_NUM_FMAN == 2)
 struct liodn_id_table fman2_liodn_tbl[] = {
-	SET_FMAN_RX_1G_LIODN(2, 0, 12),
-	SET_FMAN_RX_1G_LIODN(2, 1, 13),
-	SET_FMAN_RX_1G_LIODN(2, 2, 14),
-	SET_FMAN_RX_1G_LIODN(2, 3, 15),
-	SET_FMAN_RX_1G_LIODN(2, 4, 16),
-	SET_FMAN_RX_10G_LIODN(2, 0, 17),
+	SET_FMAN_RX_1G_LIODN(2, 0, 17),
+	SET_FMAN_RX_1G_LIODN(2, 1, 18),
+	SET_FMAN_RX_1G_LIODN(2, 2, 19),
+	SET_FMAN_RX_1G_LIODN(2, 3, 20),
+	SET_FMAN_RX_1G_LIODN(2, 4, 21),
+	SET_FMAN_RX_10G_LIODN(2, 0, 22),
 };
 int fman2_liodn_tbl_sz = ARRAY_SIZE(fman2_liodn_tbl);
 #endif
diff --git a/arch/powerpc/cpu/mpc85xx/portals.c b/arch/powerpc/cpu/mpc85xx/portals.c
index b59ef69..6d0846a 100644
--- a/arch/powerpc/cpu/mpc85xx/portals.c
+++ b/arch/powerpc/cpu/mpc85xx/portals.c
@@ -30,11 +30,9 @@
 #include <asm/fsl_portals.h>
 #include <asm/fsl_liodn.h>
 
-static ccsr_qman_t *qman = (void *)CONFIG_SYS_FSL_QMAN_ADDR;
-static ccsr_bman_t *bman = (void *)CONFIG_SYS_FSL_BMAN_ADDR;
-
 void setup_portals(void)
 {
+	ccsr_qman_t *qman = (void *)CONFIG_SYS_FSL_QMAN_ADDR;
 #ifdef CONFIG_FSL_CORENET
 	int i;
 
@@ -130,24 +128,32 @@ static int fdt_qportal(void *blob, int off, int id, char *name,
 
 	childoff = fdt_subnode_offset(blob, off, name);
 	if (create) {
-		if (childoff <= 0)
-			childoff = fdt_add_subnode(blob, off, name);
+		char handle[64], *p;
 
-		if (childoff > 0) {
-			char handle[64], *p;
+		strncpy(handle, name, sizeof(handle));
+		p = strchr(handle, '@');
+		if (!strncmp(name, "fman", 4)) {
+			*p = *(p + 1);
+			p++;
+		}
+		*p = '\0';
 
-			strncpy(handle, name, sizeof(handle));
-			p = strchr(handle, '@');
-			if (!strncmp(name, "fman", 4)) {
-				*p = *(p + 1);
-				p++;
-			}
-			*p = '\0';
+		dev_off = fdt_path_offset(blob, handle);
+		/* skip this node if alias is not found */
+		if (dev_off == -FDT_ERR_BADPATH)
+			return 0;
+		if (dev_off < 0)
+			return dev_off;
 
-			dev_off = fdt_path_offset(blob, handle);
-			if (dev_off < 0)
-				return dev_off;
+		if (childoff <= 0)
+			childoff = fdt_add_subnode(blob, off, name);
 
+		/* need to update the dev_off after adding a subnode */
+		dev_off = fdt_path_offset(blob, handle);
+		if (dev_off < 0)
+			return dev_off;
+
+		if (childoff > 0) {
 			dev_handle = fdt_get_phandle(blob, dev_off);
 			if (dev_handle <= 0) {
 				dev_handle = fdt_alloc_phandle(blob);
@@ -166,6 +172,33 @@ static int fdt_qportal(void *blob, int off, int id, char *name,
 			num = get_dpaa_liodn(dev, &liodns[0], id);
 			ret = fdt_setprop(blob, childoff, "fsl,liodn",
 					  &liodns[0], sizeof(u32) * num);
+			if (!strncmp(name, "pme", 3)) {
+				u32 pme_rev1, pme_rev2;
+				ccsr_pme_t *pme_regs =
+					(void *)CONFIG_SYS_FSL_CORENET_PME_ADDR;
+
+				pme_rev1 = in_be32(&pme_regs->pm_ip_rev_1);
+				pme_rev2 = in_be32(&pme_regs->pm_ip_rev_2);
+				ret = fdt_setprop(blob, childoff,
+					"fsl,pme-rev1", &pme_rev1, sizeof(u32));
+				if (ret < 0)
+					return ret;
+				ret = fdt_setprop(blob, childoff,
+					"fsl,pme-rev2", &pme_rev2, sizeof(u32));
+			} else if (!strncmp(name, "dce", 3)) {
+				u32 dce_rev1, dce_rev2;
+				ccsr_dce_t *dce_regs =
+					(void *)CONFIG_SYS_FSL_CORENET_DCE_ADDR;
+
+				dce_rev1 = in_be32(&dce_regs->dce_ip_rev_1);
+				dce_rev2 = in_be32(&dce_regs->dce_ip_rev_2);
+				ret = fdt_setprop(blob, childoff,
+					"fsl,dce-rev1", &dce_rev1, sizeof(u32));
+				if (ret < 0)
+					return ret;
+				ret = fdt_setprop(blob, childoff,
+					"fsl,dce-rev2", &dce_rev2, sizeof(u32));
+			}
 #endif
 		} else {
 			return childoff;
@@ -183,6 +216,7 @@ void fdt_fixup_qportals(void *blob)
 	int off, err;
 	unsigned int maj, min;
 	unsigned int ip_cfg;
+	ccsr_qman_t *qman = (void *)CONFIG_SYS_FSL_QMAN_ADDR;
 	u32 rev_1 = in_be32(&qman->ip_rev_1);
 	u32 rev_2 = in_be32(&qman->ip_rev_2);
 	char compat[64];
@@ -228,14 +262,16 @@ void fdt_fixup_qportals(void *blob)
 		if (err < 0)
 			goto err;
 
-#ifdef CONFIG_FSL_CORENET
 #ifdef CONFIG_SYS_DPAA_PME
 		err = fdt_qportal(blob, off, i, "pme@0", FSL_HW_PORTAL_PME, 1);
 		if (err < 0)
 			goto err;
-#else
-		fdt_qportal(blob, off, i, "pme@0", FSL_HW_PORTAL_PME, 0);
 #endif
+
+#ifdef CONFIG_SYS_DPAA_DCE
+		err = fdt_qportal(blob, off, i, "dce@0", FSL_HW_PORTAL_DCE, 1);
+		if (err < 0)
+			goto err;
 #endif
 
 #ifdef CONFIG_SYS_DPAA_FMAN
@@ -272,6 +308,7 @@ void fdt_fixup_bportals(void *blob)
 	int off, err;
 	unsigned int maj, min;
 	unsigned int ip_cfg;
+	ccsr_bman_t *bman = (void *)CONFIG_SYS_FSL_BMAN_ADDR;
 	u32 rev_1 = in_be32(&bman->ip_rev_1);
 	u32 rev_2 = in_be32(&bman->ip_rev_2);
 	char compat[64];
diff --git a/arch/powerpc/cpu/mpc85xx/release.S b/arch/powerpc/cpu/mpc85xx/release.S
index 5c4b1e3..c9d0e52 100644
--- a/arch/powerpc/cpu/mpc85xx/release.S
+++ b/arch/powerpc/cpu/mpc85xx/release.S
@@ -68,16 +68,99 @@ __secondary_start_page:
 	mtspr	SPRN_HID1,r3
 #endif
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004809
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR0
+	oris	r3, r3, 0x0100
+	ori	r3, r3, 0x8000
+	mtspr	SPRN_HDBCR0, r3
+1:
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004792
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR0
+	ori	r3, r3, 0x4000
+	mtspr	SPRN_HDBCR0, r3
+1:
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004779
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR2
+	/*
+	 * Set HDBCR2[32]=1
+	 * Set HDBCR2[33:39]=3
+	 * Set HDBCR2[41:47]=3
+	 * So, create a mask of bits we want to set, and clear them,
+	 * then set them as specified
+	 */
+	lis	r4, 0xff7f
+	andc	r3, r3, r4
+	oris	r3, r3, 0x8303
+	mtspr	SPRN_HDBCR2, r3
+	isync
+1:
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004786
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR7
+	oris	r3, r3, 0x8000
+	mtspr	SPRN_HDBCR7, r3
+	isync
+1:
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004806
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR7
+	oris	r3, r3, 0x2000
+	mtspr	SPRN_HDBCR7, r3
+	isync
+1:
+#endif
+
 #ifdef CONFIG_SYS_FSL_ERRATUM_CPU_A003999
-	mfspr	r3,977
+	mfspr	r3,SPRN_HDBCR1
 	oris	r3,r3,0x0100
-	mtspr	977,r3
+	mtspr	SPRN_HDBCR1,r3
 #endif
 
 #ifdef CONFIG_SYS_FSL_ERRATUM_A004510
 	mfspr	r3,SPRN_SVR
 	rlwinm	r3,r3,0,0xff
-	li	r4,CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV
+	li	r4,CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV
 	cmpw	r3,r4
 	beq	1f
 
@@ -93,10 +176,10 @@ __secondary_start_page:
 1:	/* Erratum says set bits 55:60 to 001001 */
 	msync
 	isync
-	mfspr	r3,976
+	mfspr	r3,SPRN_HDBCR0
 	li	r4,0x48
 	rlwimi	r3,r4,0,0x1f8
-	mtspr	976,r3
+	mtspr	SPRN_HDBCR0,r3
 	isync
 2:
 #endif
@@ -154,16 +237,12 @@ __secondary_start_page:
 	ori	r3,r3,toreset(__spin_table_addr)@l
 	lwz	r3,0(r3)
 
-	/*
-	 * r10 has the base address for the entry.
-	 * we cannot access it yet before setting up a new TLB
-	 */
 	mfspr	r0,SPRN_PIR
-#if	defined(CONFIG_E6500)
+#ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
 /*
- * PIR definition for E6500
+ * PIR definition for Chassis 2
  * 0-17 Reserved (logic 0s)
- * 8-19 CHIP_ID,    2'b00      - SoC 1
+ * 18-19 CHIP_ID,    2'b00      - SoC 1
  *                  all others - reserved
  * 20-24 CLUSTER_ID 5'b00000   - CCM 1
  *                  all others - reserved
@@ -177,32 +256,33 @@ __secondary_start_page:
  *                       2'b11 - core 3
  * 29-31 THREAD_ID       3'b000 - thread 0
  *                       3'b001 - thread 1
+ *
+ * Power-on PIR increments threads by 0x01, cores within a cluster by 0x08
+ * and clusters by 0x20.
+ *
+ * We renumber PIR so that all threads in the system are consecutive.
  */
-	rlwinm  r4,r0,29,25,31
+
+	rlwinm	r8,r0,29,0x03	/* r8 = core within cluster */
+	srwi	r10,r0,5	/* r10 = cluster */
+
+	mulli	r5,r10,CONFIG_SYS_FSL_CORES_PER_CLUSTER
+	add	r5,r5,r8	/* for spin table index */
+	mulli	r4,r5,CONFIG_SYS_FSL_THREADS_PER_CORE	/* for PIR */
 #elif	defined(CONFIG_E500MC)
 	rlwinm	r4,r0,27,27,31
+	mr	r5,r4
 #else
 	mr	r4,r0
+	mr	r5,r4
 #endif
-	slwi	r8,r4,6	/* spin table is padded to 64 byte */
-	add	r10,r3,r8
 
-#ifdef CONFIG_E6500
-	mfspr	r0,SPRN_PIR
 	/*
-	 * core 0 thread 0: pir reset value 0x00, new pir 0
-	 * core 0 thread 1: pir reset value 0x01, new pir 1
-	 * core 1 thread 0: pir reset value 0x08, new pir 2
-	 * core 1 thread 1: pir reset value 0x09, new pir 3
-	 * core 2 thread 0: pir reset value 0x10, new pir 4
-	 * core 2 thread 1: pir reset value 0x11, new pir 5
-	 * etc.
-	 *
-	 * Only thread 0 of each core will be running, updating PIR doesn't
-	 * need to deal with the thread bits.
+	 * r10 has the base address for the entry.
+	 * we cannot access it yet before setting up a new TLB
 	 */
-	rlwinm	r4,r0,30,24,30
-#endif
+	slwi	r8,r5,6	/* spin table is padded to 64 byte */
+	add	r10,r3,r8
 
 	mtspr	SPRN_PIR,r4	/* write to PIR register */
 
@@ -245,6 +325,21 @@ __secondary_start_page:
 2:
 #endif
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005812
+	/*
+	 * A-005812 workaround sets bit 32 of SPR 976 for SoCs running in
+	 * write shadow mode. This code should run after other code setting
+	 * DCWS.
+	 */
+	mfspr	r3,L1CSR2
+	andis.	r3,r3,(L1CSR2_DCWS)@h
+	beq	1f
+	mfspr	r3, SPRN_HDBCR0
+	oris	r3, r3, 0x8000
+	mtspr	SPRN_HDBCR0, r3
+1:
+#endif
+
 #ifdef CONFIG_BACKSIDE_L2_CACHE
 	/* skip L2 setup on P2040/P2040E as they have no L2 */
 	mfspr	r3,SPRN_SVR
diff --git a/arch/powerpc/cpu/mpc85xx/speed.c b/arch/powerpc/cpu/mpc85xx/speed.c
index c3ef199..1e080f8 100644
--- a/arch/powerpc/cpu/mpc85xx/speed.c
+++ b/arch/powerpc/cpu/mpc85xx/speed.c
@@ -112,30 +112,32 @@ void get_sys_info (sys_info_t * sysInfo)
 #ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
 	/*
 	 * Each cluster has up to 4 cores, sharing the same PLL selection.
-	 * The cluster assignment is fixed per SoC. There is no way identify the
-	 * assignment so far, presuming the "first configuration" which is to
-	 * fill the lower cluster group first before moving up to next group.
-	 * PLL1, PLL2, PLL3 are cluster group A, feeding core 0~3 on cluster 1
-	 * and core 4~7 on cluster 2
-	 * PLL4, PLL5, PLL6 are cluster group B, feeding core 8~11 on cluster 3
-	 * and core 12~15 on cluster 4 if existing
+	 * The cluster assignment is fixed per SoC. PLL1, PLL2, PLL3 are
+	 * cluster group A, feeding cores on cluster 1 and cluster 2.
+	 * PLL4, PLL5, PLL6 are cluster group B, feeding cores on cluster 3
+	 * and cluster 4 if existing.
 	 */
 	for_each_cpu(i, cpu, cpu_numcores(), cpu_mask()) {
-		u32 c_pll_sel = (in_be32(&clk->clkc0csr + (cpu / 4) * 8) >> 27)
+		int cluster = fsl_qoriq_core_to_cluster(cpu);
+		u32 c_pll_sel = (in_be32(&clk->clkcsr[cluster].clkcncsr) >> 27)
 				& 0xf;
 		u32 cplx_pll = core_cplx_PLL[c_pll_sel];
 		if (cplx_pll > 3)
 			printf("Unsupported architecture configuration"
 				" in function %s\n", __func__);
-		cplx_pll += (cpu / 8) * 3;
-
+		cplx_pll += (cluster / 2) * 3;
 		sysInfo->freqProcessor[cpu] =
 			 freqCC_PLL[cplx_pll] / core_cplx_PLL_div[c_pll_sel];
 	}
+#if defined(CONFIG_PPC_B4860) || defined(CONFIG_PPC_B4420)
+#define FM1_CLK_SEL	0xe0000000
+#define FM1_CLK_SHIFT	29
+#else
 #define PME_CLK_SEL	0xe0000000
 #define PME_CLK_SHIFT	29
 #define FM1_CLK_SEL	0x1c000000
 #define FM1_CLK_SHIFT	26
+#endif
 	rcw_tmp = in_be32(&gur->rcwsr[7]);
 
 #ifdef CONFIG_SYS_DPAA_PME
@@ -185,6 +187,9 @@ void get_sys_info (sys_info_t * sysInfo)
 	case 4:
 		sysInfo->freqFMan[0] = freqCC_PLL[3] / 4;
 		break;
+	case 5:
+		sysInfo->freqFMan[0] = sysInfo->freqSystemBus;
+		break;
 	case 6:
 		sysInfo->freqFMan[0] = freqCC_PLL[4] / 2;
 		break;
@@ -232,7 +237,8 @@ void get_sys_info (sys_info_t * sysInfo)
 #else /* CONFIG_SYS_FSL_QORIQ_CHASSIS2 */
 
 	for_each_cpu(i, cpu, cpu_numcores(), cpu_mask()) {
-		u32 c_pll_sel = (in_be32(&clk->clkc0csr + cpu*8) >> 27) & 0xf;
+		u32 c_pll_sel = (in_be32(&clk->clkcsr[cpu].clkcncsr) >> 27)
+				& 0xf;
 		u32 cplx_pll = core_cplx_PLL[c_pll_sel];
 
 		sysInfo->freqProcessor[cpu] =
@@ -285,6 +291,10 @@ void get_sys_info (sys_info_t * sysInfo)
 #endif
 #endif
 
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	sysInfo->freqQMAN = sysInfo->freqSystemBus / 2;
+#endif
+
 #endif /* CONFIG_SYS_FSL_QORIQ_CHASSIS2 */
 
 #else /* CONFIG_FSL_CORENET */
diff --git a/arch/powerpc/cpu/mpc85xx/start.S b/arch/powerpc/cpu/mpc85xx/start.S
index bb0dc1a..9b043f5 100644
--- a/arch/powerpc/cpu/mpc85xx/start.S
+++ b/arch/powerpc/cpu/mpc85xx/start.S
@@ -49,7 +49,8 @@
 #define MINIMAL_SPL
 #endif
 
-#if !defined(CONFIG_SPL) && !defined(CONFIG_SYS_RAMBOOT) && !defined(CONFIG_SECURE_BOOT)
+#if !defined(CONFIG_SPL) && !defined(CONFIG_SYS_RAMBOOT) && \
+					!defined(CONFIG_SECURE_BOOT)
 #define NOR_BOOT
 #endif
 
@@ -95,10 +96,94 @@ _start_e500:
 	li	r1,MSR_DE
 	mtmsr 	r1
 
-#ifdef CONFIG_SYS_FSL_ERRATUM_A004510
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004809
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR0
+	oris	r3, r3, 0x0100
+	ori	r3, r3, 0x8000
+	mtspr	SPRN_HDBCR0, r3
+1:
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004792
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR0
+	ori	r3, r3, 0x4000
+	mtspr	SPRN_HDBCR0, r3
+1:
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004779
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR2
+	/*
+	 * Set HDBCR2[32]=1
+	 * Set HDBCR2[33:39]=3
+	 * Set HDBCR2[41:47]=3
+	 * So, create a mask of bits we want to set, and clear them,
+	 * then set them as specified
+	 */
+	lis	r4, 0xff7f
+	andc	r3, r3, r4
+	oris	r3, r3, 0x8303
+	mtspr	SPRN_HDBCR2, r3
+	isync
+1:
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004786
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR7
+	oris	r3, r3, 0x8000
+	mtspr	SPRN_HDBCR7, r3
+	isync
+1:
+#endif
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004806
+	mfspr	r3,PVR
+	rlwinm	r3,r3,28,0xf	/* major_rev */
+	cmpwi	r3,0x1		/* is rev 1? */
+	bne	1f
+
+	msync
+	isync
+	mfspr	r3, SPRN_HDBCR7
+	oris	r3, r3, 0x2000
+	mtspr	SPRN_HDBCR7, r3
+	isync
+1:
+#endif
+
+#if defined(CONFIG_SYS_FSL_ERRATUM_A004510) || \
+		defined(CONFIG_SYS_FSL_ERRATUM_A004511)
 	mfspr	r3,SPRN_SVR
 	rlwinm	r3,r3,0,0xff
-	li	r4,CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV
+	li	r4,CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV
 	cmpw	r3,r4
 	beq	1f
 
@@ -113,18 +198,37 @@ _start_e500:
 	b	2f
 
 1:	li	r27,1	/* Remember for later that we have the erratum */
+#if defined(CONFIG_SYS_FSL_ERRATUM_A004510)
 	/* Erratum says set bits 55:60 to 001001 */
 	msync
 	isync
-	mfspr	r3,976
+	mfspr	r3,SPRN_HDBCR0
 	li	r4,0x48
 	rlwimi	r3,r4,0,0x1f8
-	mtspr	976,r3
+	mtspr	SPRN_HDBCR0,r3
 	isync
+#endif
 2:
 #endif
 
-#if defined(CONFIG_SECURE_BOOT) && defined(CONFIG_E500MC)
+#if defined(CONFIG_SECURE_BOOT) && defined(CONFIG_E500) && \
+						!defined(CONFIG_E500MC)
+	/* ISBC creates a LAW 0 entry for non PBL platforms,
+	 * which is not disabled before transferring the control to uboot.
+	 * Disable the LAW 0 entry here.
+	 * TLB entry for CONFIG_SYS_CCSRBAR_DEFAULT is already created
+	 * by the BOOT ROM code.
+	 */
+	lis     r3, CONFIG_SYS_CCSRBAR_DEFAULT@h
+	ori     r3, r3, CONFIG_SYS_CCSRBAR_DEFAULT@l
+	li	r4, 0x0
+
+	stw     r4, 0xc10(r3)	/* LAWAR0 */
+	sync
+#endif
+
+#if defined(CONFIG_SECURE_BOOT) && defined(CONFIG_E500MC) && \
+						!defined(CONFIG_E6500)
 	/* ISBC uses L2 as stack.
 	 * Disable L2 cache here so that u-boot can enable it later
 	 * as part of it's normal flow
@@ -173,52 +277,6 @@ l2_disabled:
 	mfspr	r1,DBSR
 	mtspr	DBSR,r1		/* Clear all valid bits */
 
-	/*
-	 *	Enable L1 Caches early
-	 *
-	 */
-
-#ifdef CONFIG_SYS_CACHE_STASHING
-	/* set stash id to (coreID) * 2 + 32 + L1 CT (0) */
-	li	r2,(32 + 0)
-	mtspr	L1CSR2,r2
-#endif
-
-	/* Enable/invalidate the I-Cache */
-	lis	r2,(L1CSR1_ICFI|L1CSR1_ICLFR)@h
-	ori	r2,r2,(L1CSR1_ICFI|L1CSR1_ICLFR)@l
-	mtspr	SPRN_L1CSR1,r2
-1:
-	mfspr	r3,SPRN_L1CSR1
-	and.	r1,r3,r2
-	bne	1b
-
-	lis	r3,(L1CSR1_CPE|L1CSR1_ICE)@h
-	ori	r3,r3,(L1CSR1_CPE|L1CSR1_ICE)@l
-	mtspr	SPRN_L1CSR1,r3
-	isync
-2:
-	mfspr	r3,SPRN_L1CSR1
-	andi.	r1,r3,L1CSR1_ICE@l
-	beq	2b
-
-	/* Enable/invalidate the D-Cache */
-	lis	r2,(L1CSR0_DCFI|L1CSR0_DCLFR)@h
-	ori	r2,r2,(L1CSR0_DCFI|L1CSR0_DCLFR)@l
-	mtspr	SPRN_L1CSR0,r2
-1:
-	mfspr	r3,SPRN_L1CSR0
-	and.	r1,r3,r2
-	bne	1b
-
-	lis	r3,(L1CSR0_CPE|L1CSR0_DCE)@h
-	ori	r3,r3,(L1CSR0_CPE|L1CSR0_DCE)@l
-	mtspr	SPRN_L1CSR0,r3
-	isync
-2:
-	mfspr	r3,SPRN_L1CSR0
-	andi.	r1,r3,L1CSR0_DCE@l
-	beq	2b
 
 	.macro	create_tlb1_entry esel ts tsize epn wimg rpn perm phy_high scratch
 	lis	\scratch, FSL_BOOKE_MAS0(1, \esel, 0)@h
@@ -372,9 +430,9 @@ l2_disabled:
 #endif
 
 #ifdef CONFIG_SYS_FSL_ERRATUM_CPU_A003999
-	mfspr	r3,977
+	mfspr	r3,SPRN_HDBCR1
 	oris	r3,r3,0x0100
-	mtspr	977,r3
+	mtspr	SPRN_HDBCR1,r3
 #endif
 
 	/* Enable Branch Prediction */
@@ -449,7 +507,7 @@ nexti:	mflr	r1		/* R1 = our PC */
 
 	/* Set the size of the TLB to 4KB */
 	mfspr	r3, MAS1
-	li	r2, 0xF00
+	li	r2, 0xF80
 	andc	r3, r3, r2	/* Clear the TSIZE bits */
 	ori	r3, r3, MAS1_TSIZE(BOOKE_PAGESZ_4K)@l
 	oris	r3, r3, MAS1_IPROT@h
@@ -467,7 +525,8 @@ nexti:	mflr	r1		/* R1 = our PC */
 	mfspr	r2, MAS2
 	andc	r2, r2, r3
 	or	r2, r2, r1
-#ifdef CONFIG_SYS_FSL_ERRATUM_A004510
+#if defined(CONFIG_SYS_FSL_ERRATUM_A004510) || \
+		defined(CONFIG_SYS_FSL_ERRATUM_A004511)
 	cmpwi	r27,0
 	beq	1f
 	andi.	r15, r2, MAS2_I|MAS2_G /* save the old I/G for later */
@@ -490,9 +549,14 @@ nexti:	mflr	r1		/* R1 = our PC */
  * Clear out any other TLB entries that may exist, to avoid conflicts.
  * Our TLB entry is in r14.
  */
+#ifdef CONFIG_E500MC
+	/* Erratum A-004827 on some chips means tlbivax/tlbsync is unusable */
+	tlbilxlpid
+#else
 	li	r0, TLBIVAX_ALL | TLBIVAX_TLB0
 	tlbivax 0, r0
 	tlbsync
+#endif
 
 	mfspr	r4, SPRN_TLB1CFG
 	rlwinm	r4, r4, 0, TLBnCFG_NENTRY_MASK
@@ -515,7 +579,8 @@ nexti:	mflr	r1		/* R1 = our PC */
 2:	cmpw	r3, r4
 	blt	1b
 
-#if defined(CONFIG_SYS_PPC_E500_DEBUG_TLB) && !defined(MINIMAL_SPL)
+#if defined(CONFIG_SYS_PPC_E500_DEBUG_TLB) && !defined(MINIMAL_SPL) && \
+					!defined(CONFIG_SECURE_BOOT)
 /*
  * TLB entry for debuggging in AS1
  * Create temporary TLB entry in AS0 to handle debug exception
@@ -536,12 +601,6 @@ nexti:	mflr	r1		/* R1 = our PC */
 		0xffc00000, MAS3_SX|MAS3_SW|MAS3_SR, \
 		0, r6
 
-#elif !defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SECURE_BOOT)
-	create_tlb1_entry CONFIG_SYS_PPC_E500_DEBUG_TLB, \
-		0, BOOKE_PAGESZ_1M, \
-		CONFIG_SYS_MONITOR_BASE, MAS2_I|MAS2_G, \
-		CONFIG_SYS_PBI_FLASH_WINDOW, MAS3_SX|MAS3_SW|MAS3_SR, \
-		0, r6
 #else
 /*
  * TLB entry is created for IVPR + IVOR15 to map on valid OP code address
@@ -780,14 +839,88 @@ enable_l2_cluster_l2:
 	isync
 	and.	r1, r0, r4
 	bne	1b
-	lis	r4, L2CSR0_L2E@h
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004857
+	mfspr	r4,PVR
+	rlwinm	r4,r4,28,0xf	/* major_rev */
+	cmpwi	r4,0x1		/* is rev 1? */
+	bne	1f
+
+	lwz	r0, 0xf04(r3)
+	li	r1,1
+	rlwimi	r0,r1,64-(40+2),40-32,(40+2)-33	/* set 0xf04[40:41] = 1 */
+	stw	r0, 0xf04(r3)
+1:
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005553
+	mfspr	r4,PVR
+	rlwinm	r4,r4,28,0xf	/* major_rev */
+	cmpwi	r4,0x1		/* is rev 1? */
+	bne	1f
+
+	lwz	r0, 0xf04(r3)
+	ori	r0,r0,(1 << (63-54))		/* set 0xf04[54] to 1 */
+	stw	r0, 0xf04(r3)
+	lwz	r0, 0xf00(r3)
+	oris	r0,r0,(1 << (63-41))@h		/* set 0xf00[41] to 1 */
+	stw	r0, 0xf00(r3)
+1:
+#endif
+	lis	r4, (L2CSR0_L2E|L2CSR0_L2PE)@h
+	ori	r4, r4, (L2CSR0_L2REP_MODE)@l
 	sync
-	stw	r4, 0(r3)	/* eanble L2 */
+	stw	r4, 0(r3)	/* enable L2 */
 delete_ccsr_l2_tlb:
 	delete_tlb0_entry 0, CONFIG_SYS_CCSRBAR + 0xC20000, MAS2_I|MAS2_G, r3
 #endif
 
-#ifdef CONFIG_SYS_FSL_ERRATUM_A004510
+	/*
+	 * Enable the L1. On e6500, this has to be done
+	 * after the L2 is up.
+	 */
+
+#ifdef CONFIG_SYS_CACHE_STASHING
+	/* set stash id to (coreID) * 2 + 32 + L1 CT (0) */
+	li	r2,(32 + 0)
+	mtspr	L1CSR2,r2
+#endif
+
+	/* Enable/invalidate the I-Cache */
+	lis	r2,(L1CSR1_ICFI|L1CSR1_ICLFR)@h
+	ori	r2,r2,(L1CSR1_ICFI|L1CSR1_ICLFR)@l
+	mtspr	SPRN_L1CSR1,r2
+1:
+	mfspr	r3,SPRN_L1CSR1
+	and.	r1,r3,r2
+	bne	1b
+
+	lis	r3,(L1CSR1_CPE|L1CSR1_ICE)@h
+	ori	r3,r3,(L1CSR1_CPE|L1CSR1_ICE)@l
+	mtspr	SPRN_L1CSR1,r3
+	isync
+2:
+	mfspr	r3,SPRN_L1CSR1
+	andi.	r1,r3,L1CSR1_ICE@l
+	beq	2b
+
+	/* Enable/invalidate the D-Cache */
+	lis	r2,(L1CSR0_DCFI|L1CSR0_DCLFR)@h
+	ori	r2,r2,(L1CSR0_DCFI|L1CSR0_DCLFR)@l
+	mtspr	SPRN_L1CSR0,r2
+1:
+	mfspr	r3,SPRN_L1CSR0
+	and.	r1,r3,r2
+	bne	1b
+
+	lis	r3,(L1CSR0_CPE|L1CSR0_DCE)@h
+	ori	r3,r3,(L1CSR0_CPE|L1CSR0_DCE)@l
+	mtspr	SPRN_L1CSR0,r3
+	isync
+2:
+	mfspr	r3,SPRN_L1CSR0
+	andi.	r1,r3,L1CSR0_DCE@l
+	beq	2b
+#if defined(CONFIG_SYS_FSL_ERRATUM_A004510) || \
+		defined(CONFIG_SYS_FSL_ERRATUM_A004511)
 #define DCSR_LAWBARH0	(CONFIG_SYS_CCSRBAR + 0x1000)
 #define LAW_SIZE_1M	0x13
 #define DCSRBAR_LAWAR	(LAW_EN | (0x1d << 20) | LAW_SIZE_1M)
@@ -862,7 +995,11 @@ delete_ccsr_l2_tlb:
 	msync
 
 	/* enable the timebase */
+#ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
+#define CTBENR	0xe21a0
+#else
 #define CTBENR	0xe2084
+#endif
 	li	r3, 1
 	addis	r4, r7, CTBENR@ha
 	stw	r3, CTBENR@l(r4)
@@ -886,14 +1023,32 @@ delete_ccsr_l2_tlb:
 	bl	erratum_set_value
 	.endm
 
+	.macro	erratum_clr_dcsr offset value
+	addis	r3, r6, \offset@ha
+	lis	r0, \value@h
+	addi	r3, r3, \offset@l
+	ori	r0, r0, \value@l
+	lwz	r4, 0(r3)
+	andc	r4, r4, r0
+	bl	erratum_set_value
+	.endm
+
+#if defined(CONFIG_SYS_FSL_ERRATUM_A004510)
 	erratum_set_dcsr 0xb0e08 0xe0201800
 	erratum_set_dcsr 0xb0e18 0xe0201800
 	erratum_set_dcsr 0xb0e38 0xe0400000
 	erratum_set_dcsr 0xb0008 0x00900000
 	erratum_set_dcsr 0xb0e40 0xe00a0000
 	erratum_set_ccsr 0x18600 CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY
+#ifdef	CONFIG_RAMBOOT_PBL
+	erratum_set_ccsr 0x10f00 0x495e5000
+#else
 	erratum_set_ccsr 0x10f00 0x415e5000
+#endif
 	erratum_set_ccsr 0x11f00 0x415e5000
+#elif defined(CONFIG_SYS_FSL_ERRATUM_A004511)
+	erratum_clr_dcsr 0xb0008 0x01000000
+#endif
 
 	/* Make temp mapping uncacheable again, if it was initially */
 	bl	2f
@@ -1905,6 +2060,7 @@ unlock_ram_in_cache:
 	slwi	r4,r4,(10 - 1 - L1_CACHE_SHIFT)
 	mtctr	r4
 1:	dcbi	r0,r3
+	dcblc	r0,r3
 	addi	r3,r3,CONFIG_SYS_CACHELINE_SIZE
 	bdnz	1b
 	sync
@@ -1912,6 +2068,16 @@ unlock_ram_in_cache:
 	/* Invalidate the TLB entries for the cache */
 	lis	r3,CONFIG_SYS_INIT_RAM_ADDR@h
 	ori	r3,r3,CONFIG_SYS_INIT_RAM_ADDR@l
+#ifdef CONFIG_E500MC
+	/* Erratum A-004827 on some chips means tlbivax/tlbsync is unusable */
+	tlbilxva 0,r3
+	addi	r3,r3,0x1000
+	tlbilxva 0,r3
+	addi	r3,r3,0x1000
+	tlbilxva 0,r3
+	addi	r3,r3,0x1000
+	tlbilxva 0,r3
+#else
 	tlbivax	0,r3
 	addi	r3,r3,0x1000
 	tlbivax	0,r3
@@ -1919,6 +2085,7 @@ unlock_ram_in_cache:
 	tlbivax	0,r3
 	addi	r3,r3,0x1000
 	tlbivax	0,r3
+#endif
 	isync
 	blr
 
diff --git a/arch/powerpc/cpu/mpc85xx/t1040_ids.c b/arch/powerpc/cpu/mpc85xx/t1040_ids.c
new file mode 100644
index 0000000..ed61599
--- /dev/null
+++ b/arch/powerpc/cpu/mpc85xx/t1040_ids.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+
+#ifdef CONFIG_SYS_DPAA_QBMAN
+struct qportal_info qp_info[CONFIG_SYS_QMAN_NUM_PORTALS] = {
+	/* dqrr liodn, frame data liodn, liodn off, sdest */
+	SET_QP_INFO(1, 27, 1, 0),
+	SET_QP_INFO(2, 28, 1, 0),
+	SET_QP_INFO(3, 29, 1, 1),
+	SET_QP_INFO(4, 30, 1, 1),
+	SET_QP_INFO(5, 31, 1, 2),
+	SET_QP_INFO(6, 32, 1, 2),
+	SET_QP_INFO(7, 33, 1, 3),
+	SET_QP_INFO(8, 34, 1, 3),
+	SET_QP_INFO(9, 35, 1, 0),
+	SET_QP_INFO(10, 36, 1, 0),
+	SET_QP_INFO(11, 37, 1, 1),
+	SET_QP_INFO(12, 38, 1, 1),
+	SET_QP_INFO(13, 39, 1, 2),
+	SET_QP_INFO(14, 40, 1, 2),
+	SET_QP_INFO(15, 41, 1, 3),
+	SET_QP_INFO(16, 42, 1, 3),
+	SET_QP_INFO(17, 43, 1, 0),
+	SET_QP_INFO(18, 44, 1, 0),
+	SET_QP_INFO(19, 45, 1, 1),
+	SET_QP_INFO(20, 46, 1, 1),
+	SET_QP_INFO(21, 47, 1, 2),
+	SET_QP_INFO(22, 48, 1, 2),
+	SET_QP_INFO(23, 49, 1, 3),
+	SET_QP_INFO(24, 50, 1, 3),
+	SET_QP_INFO(25, 51, 1, 0),
+};
+#endif
+
+struct srio_liodn_id_table srio_liodn_tbl[] = {
+	SET_SRIO_LIODN_1(1, 307),
+	SET_SRIO_LIODN_1(2, 387),
+};
+int srio_liodn_tbl_sz = ARRAY_SIZE(srio_liodn_tbl);
+
+struct liodn_id_table liodn_tbl[] = {
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	SET_QMAN_LIODN(62),
+	SET_BMAN_LIODN(63),
+#endif
+
+	SET_SDHC_LIODN(1, 552),
+
+	SET_USB_LIODN(1, "fsl-usb2-mph", 553),
+
+	SET_PCI_LIODN("fsl,qoriq-pcie-v2.2", 1, 148),
+
+	SET_DMA_LIODN(1, 147),
+	SET_DMA_LIODN(2, 227),
+
+	SET_GUTS_LIODN("fsl,rapidio-delta", 199, rio1liodnr, 0),
+	SET_GUTS_LIODN(NULL, 200, rio2liodnr, 0),
+	SET_GUTS_LIODN(NULL, 201, rio1maintliodnr, 0),
+	SET_GUTS_LIODN(NULL, 202, rio2maintliodnr, 0),
+
+	/* SET_NEXUS_LIODN(557), -- not yet implemented */
+};
+int liodn_tbl_sz = ARRAY_SIZE(liodn_tbl);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+struct liodn_id_table fman1_liodn_tbl[] = {
+	SET_FMAN_RX_1G_LIODN(1, 0, 88),
+	SET_FMAN_RX_1G_LIODN(1, 1, 89),
+	SET_FMAN_RX_1G_LIODN(1, 2, 90),
+	SET_FMAN_RX_1G_LIODN(1, 3, 91),
+	SET_FMAN_RX_1G_LIODN(1, 4, 92),
+	SET_FMAN_RX_1G_LIODN(1, 5, 93),
+	SET_FMAN_RX_10G_LIODN(1, 0, 94),
+	SET_FMAN_RX_10G_LIODN(1, 1, 95),
+};
+int fman1_liodn_tbl_sz = ARRAY_SIZE(fman1_liodn_tbl);
+#endif
+
+struct liodn_id_table sec_liodn_tbl[] = {
+	SET_SEC_JR_LIODN_ENTRY(0, 454, 458),
+	SET_SEC_JR_LIODN_ENTRY(1, 455, 459),
+	SET_SEC_JR_LIODN_ENTRY(2, 456, 460),
+	SET_SEC_JR_LIODN_ENTRY(3, 457, 461),
+	SET_SEC_RTIC_LIODN_ENTRY(a, 453),
+	SET_SEC_RTIC_LIODN_ENTRY(b, 549),
+	SET_SEC_RTIC_LIODN_ENTRY(c, 550),
+	SET_SEC_RTIC_LIODN_ENTRY(d, 551),
+	SET_SEC_DECO_LIODN_ENTRY(0, 541, 610),
+	SET_SEC_DECO_LIODN_ENTRY(1, 542, 611),
+};
+int sec_liodn_tbl_sz = ARRAY_SIZE(sec_liodn_tbl);
+
+#ifdef CONFIG_SYS_DPAA_RMAN
+struct liodn_id_table rman_liodn_tbl[] = {
+	/* Set RMan block 0-3 liodn offset */
+	SET_RMAN_LIODN(0, 678),
+	SET_RMAN_LIODN(1, 679),
+	SET_RMAN_LIODN(2, 680),
+	SET_RMAN_LIODN(3, 681),
+};
+int rman_liodn_tbl_sz = ARRAY_SIZE(rman_liodn_tbl);
+#endif
+
+struct liodn_id_table liodn_bases[] = {
+	[FSL_HW_PORTAL_SEC]  = SET_LIODN_BASE_2(462, 558),
+#ifdef CONFIG_SYS_DPAA_FMAN
+	[FSL_HW_PORTAL_FMAN1] = SET_LIODN_BASE_1(973),
+#endif
+#ifdef CONFIG_SYS_DPAA_RMAN
+	[FSL_HW_PORTAL_RMAN] = SET_LIODN_BASE_1(922),
+#endif
+};
diff --git a/arch/powerpc/cpu/mpc85xx/t1040_serdes.c b/arch/powerpc/cpu/mpc85xx/t1040_serdes.c
new file mode 100644
index 0000000..0dc50c0
--- /dev/null
+++ b/arch/powerpc/cpu/mpc85xx/t1040_serdes.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_serdes.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+#include "fsl_corenet2_serdes.h"
+
+static u8 serdes_cfg_tbl[MAX_SERDES][0xC4][SRDS_MAX_LANES] = {
+	{	/* SerDes 1 */
+	[0x69] = {PCIE1, SGMII_FM1_DTSEC3, QSGMII_SW1_A, QSGMII_SW1_B,
+		PCIE2, PCIE3, SGMII_FM1_DTSEC4, SATA1},
+	[0x66] = {PCIE1, SGMII_FM1_DTSEC3, QSGMII_SW1_A, QSGMII_SW1_B,
+		PCIE2, PCIE3, PCIE4, SATA1},
+	[0x67] = {PCIE1, SGMII_FM1_DTSEC3, QSGMII_SW1_A, QSGMII_SW1_B,
+		PCIE2, PCIE3, PCIE4, SGMII_FM1_DTSEC5},
+	[0x60] = {PCIE1, SGMII_FM1_DTSEC3, QSGMII_SW1_A, QSGMII_SW1_B,
+		PCIE2, PCIE2, PCIE2, PCIE2},
+	[0x8D] = {PCIE1, SGMII_SW1_DTSEC3, SGMII_SW1_DTSEC1, SGMII_SW1_DTSEC2,
+		PCIE2, SGMII_SW1_DTSEC6, SGMII_SW1_DTSEC4, SGMII_SW1_DTSEC5},
+	[0x89] = {PCIE1, SGMII_SW1_DTSEC3, SGMII_SW1_DTSEC1, SGMII_SW1_DTSEC2,
+		PCIE2, PCIE3, SGMII_SW1_DTSEC4, SATA1},
+	[0x86] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		PCIE2, PCIE3, PCIE4, SATA1},
+	[0x87] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		PCIE2, PCIE3, PCIE4, SGMII_FM1_DTSEC5},
+	[0xA7] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		 PCIE2, PCIE3, PCIE4, SGMII_FM1_DTSEC5},
+	[0xAA] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		 PCIE2, PCIE3, SGMII_FM1_DTSEC4, SGMII_FM1_DTSEC5},
+	[0x40] = {PCIE1, PCIE1, SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		PCIE2, PCIE2, PCIE2, PCIE2},
+	[0x06] = {PCIE1, PCIE1, PCIE1, PCIE1,
+		PCIE2, PCIE3, PCIE4, SATA1},
+	[0x08] = {PCIE1, PCIE1, PCIE1, PCIE1,
+		PCIE2, PCIE3, SATA2, SATA1},
+	[0x8F] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		AURORA, NONE, SGMII_FM1_DTSEC4, SGMII_FM1_DTSEC5},
+	[0x85] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		PCIE2, PCIE2, SGMII_FM1_DTSEC4, SGMII_FM1_DTSEC5},
+	[0xA5] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		PCIE2, PCIE2, SGMII_FM1_DTSEC4, SGMII_FM1_DTSEC5},
+	[0x00] = {PCIE1, PCIE1, PCIE1, PCIE1,
+		PCIE2, PCIE2, PCIE2, PCIE2},
+	},
+	{
+	},
+	{
+	},
+	{
+	},
+};
+
+
+enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane)
+{
+
+	return serdes_cfg_tbl[serdes][cfg][lane];
+}
+
+int is_serdes_prtcl_valid(int serdes, u32 prtcl)
+{
+	int i;
+
+	if (prtcl > (ARRAY_SIZE(serdes_cfg_tbl[serdes])))
+		return 0;
+
+	for (i = 0; i < SRDS_MAX_LANES; i++) {
+		if (serdes_cfg_tbl[serdes][prtcl][i] != NONE)
+			return 1;
+	}
+
+	return 0;
+}
diff --git a/arch/powerpc/cpu/mpc85xx/t4240_ids.c b/arch/powerpc/cpu/mpc85xx/t4240_ids.c
index a8f16b1..fe99972 100644
--- a/arch/powerpc/cpu/mpc85xx/t4240_ids.c
+++ b/arch/powerpc/cpu/mpc85xx/t4240_ids.c
@@ -81,8 +81,8 @@ struct qportal_info qp_info[CONFIG_SYS_QMAN_NUM_PORTALS] = {
 #endif
 
 struct srio_liodn_id_table srio_liodn_tbl[] = {
-	SET_SRIO_LIODN_1(1, 307),
-	SET_SRIO_LIODN_1(2, 387),
+	SET_SRIO_LIODN_BASE(1, 307),
+	SET_SRIO_LIODN_BASE(2, 387),
 };
 int srio_liodn_tbl_sz = ARRAY_SIZE(srio_liodn_tbl);
 
@@ -102,10 +102,10 @@ struct liodn_id_table liodn_tbl[] = {
 	SET_SATA_LIODN(1, 555),
 	SET_SATA_LIODN(2, 556),
 
-	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 1, 148),
-	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 2, 228),
-	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 308),
-	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 4, 388),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 1, 148),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 2, 228),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 308),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 4, 388),
 
 	SET_DMA_LIODN(1, 147),
 	SET_DMA_LIODN(2, 227),
@@ -175,10 +175,10 @@ int sec_liodn_tbl_sz = ARRAY_SIZE(sec_liodn_tbl);
 #ifdef CONFIG_SYS_DPAA_RMAN
 struct liodn_id_table rman_liodn_tbl[] = {
 	/* Set RMan block 0-3 liodn offset */
-	SET_RMAN_LIODN(0, 678),
-	SET_RMAN_LIODN(1, 679),
-	SET_RMAN_LIODN(2, 680),
-	SET_RMAN_LIODN(3, 681),
+	SET_RMAN_LIODN(0, 6),
+	SET_RMAN_LIODN(1, 7),
+	SET_RMAN_LIODN(2, 8),
+	SET_RMAN_LIODN(3, 9),
 };
 int rman_liodn_tbl_sz = ARRAY_SIZE(rman_liodn_tbl);
 #endif
diff --git a/arch/powerpc/cpu/mpc85xx/t4240_serdes.c b/arch/powerpc/cpu/mpc85xx/t4240_serdes.c
index 102defa..ba7d668 100644
--- a/arch/powerpc/cpu/mpc85xx/t4240_serdes.c
+++ b/arch/powerpc/cpu/mpc85xx/t4240_serdes.c
@@ -31,7 +31,8 @@ struct serdes_config {
 	u8 lanes[SRDS_MAX_LANES];
 };
 
-static struct serdes_config serdes1_cfg_tbl[] = {
+#ifdef CONFIG_PPC_T4240
+static const struct serdes_config serdes1_cfg_tbl[] = {
 	/* SerDes 1 */
 	{1, {XAUI_FM1_MAC9, XAUI_FM1_MAC9,
 		XAUI_FM1_MAC9, XAUI_FM1_MAC9,
@@ -66,7 +67,7 @@ static struct serdes_config serdes1_cfg_tbl[] = {
 		NONE, NONE, QSGMII_FM1_A, NONE}},
 	{}
 };
-static struct serdes_config serdes2_cfg_tbl[] = {
+static const struct serdes_config serdes2_cfg_tbl[] = {
 	/* SerDes 2 */
 	{1, {XAUI_FM2_MAC9, XAUI_FM2_MAC9,
 		XAUI_FM2_MAC9, XAUI_FM2_MAC9,
@@ -150,7 +151,7 @@ static struct serdes_config serdes2_cfg_tbl[] = {
 		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4}},
 	{}
 };
-static struct serdes_config serdes3_cfg_tbl[] = {
+static const struct serdes_config serdes3_cfg_tbl[] = {
 	/* SerDes 3 */
 	{2, {PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1}},
 	{4, {PCIE1, PCIE1, PCIE1, PCIE1, PCIE2, PCIE2, PCIE2, PCIE2}},
@@ -174,20 +175,151 @@ static struct serdes_config serdes3_cfg_tbl[] = {
 		SRIO1, SRIO1, SRIO1, SRIO1}},
 	{}
 };
-static struct serdes_config serdes4_cfg_tbl[] = {
+static const struct serdes_config serdes4_cfg_tbl[] = {
 	/* SerDes 4 */
 	{2, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3}},
 	{4, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, PCIE4, PCIE4}},
 	{6, {PCIE3, PCIE3, PCIE3, PCIE3, SRIO2, SRIO2, SRIO2, SRIO2}},
 	{8, {PCIE3, PCIE3, PCIE3, PCIE3, SRIO2, SRIO2, SRIO2, SRIO2}},
-	{10, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, SATA1, SATA1}},
-	{12, {PCIE3, PCIE3, PCIE3, PCIE3, AURORA, AURORA, SATA1, SATA1}},
+	{10, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, SATA1, SATA2}},
+	{12, {PCIE3, PCIE3, PCIE3, PCIE3, AURORA, AURORA, SATA1, SATA2}},
 	{14, {PCIE3, PCIE3, PCIE3, PCIE3, AURORA, AURORA, SRIO2, SRIO2}},
 	{16, {PCIE3, PCIE3, PCIE3, PCIE3, AURORA, AURORA, SRIO2, SRIO2}},
 	{18, {PCIE3, PCIE3, PCIE3, PCIE3, AURORA, AURORA, AURORA, AURORA}},
 	{}
 };
-static struct serdes_config *serdes_cfg_tbl[] = {
+#elif defined(CONFIG_PPC_T4160)
+static const struct serdes_config serdes1_cfg_tbl[] = {
+	/* SerDes 1 */
+	{1, {XAUI_FM1_MAC9, XAUI_FM1_MAC9,
+		XAUI_FM1_MAC9, XAUI_FM1_MAC9,
+		XAUI_FM1_MAC10, XAUI_FM1_MAC10,
+		XAUI_FM1_MAC10, XAUI_FM1_MAC10} },
+	{2, {HIGIG_FM1_MAC9, HIGIG_FM1_MAC9,
+		HIGIG_FM1_MAC9, HIGIG_FM1_MAC9,
+		HIGIG_FM1_MAC10, HIGIG_FM1_MAC10,
+		HIGIG_FM1_MAC10, HIGIG_FM1_MAC10} },
+	{4, {HIGIG_FM1_MAC9, HIGIG_FM1_MAC9,
+		HIGIG_FM1_MAC9, HIGIG_FM1_MAC9,
+		HIGIG_FM1_MAC10, HIGIG_FM1_MAC10,
+		HIGIG_FM1_MAC10, HIGIG_FM1_MAC10} },
+	{28, {SGMII_FM1_DTSEC5, SGMII_FM1_DTSEC6,
+		SGMII_FM1_DTSEC10, SGMII_FM1_DTSEC9,
+		SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4} },
+	{36, {SGMII_FM1_DTSEC5, SGMII_FM1_DTSEC6,
+		SGMII_FM1_DTSEC10, SGMII_FM1_DTSEC9,
+		SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4} },
+	{38, {NONE, NONE, QSGMII_FM1_B, NONE,
+		NONE, NONE, QSGMII_FM1_A, NONE} },
+	{}
+};
+static const struct serdes_config serdes2_cfg_tbl[] = {
+	/* SerDes 2 */
+	{7, {XAUI_FM2_MAC9, XAUI_FM2_MAC9,
+		XAUI_FM2_MAC9, XAUI_FM2_MAC9,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4} },
+	{13, {XAUI_FM2_MAC9, XAUI_FM2_MAC9,
+		XAUI_FM2_MAC9, XAUI_FM2_MAC9,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4} },
+	{16, {HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4} },
+	{22, {HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4} },
+	{25, {HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4} },
+	{26, {HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		NONE, NONE} },
+	{28, {SGMII_FM2_DTSEC5, SGMII_FM2_DTSEC6,
+		SGMII_FM2_DTSEC10, SGMII_FM2_DTSEC9,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4} },
+	{36, {SGMII_FM2_DTSEC5, SGMII_FM2_DTSEC6,
+		SGMII_FM2_DTSEC10, SGMII_FM2_DTSEC9,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4} },
+	{38, {NONE, NONE, QSGMII_FM2_B, NONE,
+		NONE, QSGMII_FM1_A, NONE, NONE} },
+	{40, {SGMII_FM2_DTSEC5, SGMII_FM2_DTSEC6,
+		SGMII_FM2_DTSEC10, SGMII_FM2_DTSEC9,
+		NONE, QSGMII_FM1_A, NONE, NONE} },
+	{46, {SGMII_FM2_DTSEC5, SGMII_FM2_DTSEC6,
+		SGMII_FM2_DTSEC10, SGMII_FM2_DTSEC9,
+		NONE, QSGMII_FM1_A, NONE, NONE} },
+	{48, {SGMII_FM2_DTSEC5, SGMII_FM2_DTSEC6,
+		SGMII_FM2_DTSEC10, SGMII_FM2_DTSEC9,
+		NONE, QSGMII_FM1_A, NONE, NONE} },
+	{50, {XAUI_FM2_MAC9, XAUI_FM2_MAC9,
+		XAUI_FM2_MAC9, XAUI_FM2_MAC9,
+		NONE, NONE, NONE, NONE} },
+	{52, {HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		NONE, NONE, NONE, NONE} },
+	{54, {HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		HIGIG_FM2_MAC9, HIGIG_FM2_MAC9,
+		NONE, NONE, NONE, NONE} },
+	{56, {NONE, XFI_FM1_MAC10,
+		XFI_FM2_MAC10, NONE,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		SGMII_FM2_DTSEC3, SGMII_FM2_DTSEC4} },
+	{57, {NONE, XFI_FM1_MAC10,
+		XFI_FM2_MAC10, NONE,
+		SGMII_FM2_DTSEC1, SGMII_FM2_DTSEC2,
+		NONE, NONE} },
+	{}
+};
+static const struct serdes_config serdes3_cfg_tbl[] = {
+	/* SerDes 3 */
+	{2, {PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1} },
+	{4, {PCIE1, PCIE1, PCIE1, PCIE1, PCIE2, PCIE2, PCIE2, PCIE2} },
+	{6, {PCIE1, PCIE1, PCIE1, PCIE1, SRIO1, SRIO1, SRIO1, SRIO1} },
+	{8, {PCIE1, PCIE1, PCIE1, PCIE1, SRIO1, NONE, NONE, NONE} },
+	{9, {INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN,
+		INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN} },
+	{10, {INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN,
+		INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN} },
+	{12, {INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN,
+		PCIE2, PCIE2, PCIE2, PCIE2} },
+	{14, {INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN,
+		PCIE2, PCIE2, PCIE2, PCIE2} },
+	{16, {INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN,
+		SRIO1, SRIO1, SRIO1, SRIO1} },
+	{17, {INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN,
+		SRIO1, SRIO1, SRIO1, SRIO1} },
+	{19, {INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN,
+		SRIO1, SRIO1, SRIO1, SRIO1} },
+	{20, {INTERLAKEN, INTERLAKEN, INTERLAKEN, INTERLAKEN,
+			NONE, NONE, NONE, NONE} },
+	{}
+};
+static const struct serdes_config serdes4_cfg_tbl[] = {
+	/* SerDes 4 */
+	{4, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, PCIE4, PCIE4} },
+	{6, {SRIO2, SRIO2, SRIO2, SRIO2, SRIO2, SRIO2, SRIO2, SRIO2} },
+	{8, {SRIO2, SRIO2, SRIO2, SRIO2, SRIO2, SRIO2, SRIO2, SRIO2} },
+	{10, {PCIE3, PCIE3, PCIE3, PCIE3, SATA1, SATA1, SATA2, SATA2} },
+	{12, {AURORA, AURORA, AURORA, AURORA, SATA1, SATA1, SATA2, SATA2} },
+	{14, {AURORA, AURORA, AURORA, AURORA, SRIO2, SRIO2, SRIO2, SRIO2} },
+	{16, {AURORA, AURORA, AURORA, AURORA, SRIO2, SRIO2, SRIO2, SRIO2} },
+	{18, {AURORA, AURORA, AURORA, AURORA, AURORA, AURORA, AURORA, AURORA} },
+	{}
+}
+;
+#else
+#error "Need to define SerDes protocol"
+#endif
+static const struct serdes_config *serdes_cfg_tbl[] = {
 	serdes1_cfg_tbl,
 	serdes2_cfg_tbl,
 	serdes3_cfg_tbl,
@@ -196,7 +328,7 @@ static struct serdes_config *serdes_cfg_tbl[] = {
 
 enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane)
 {
-	struct serdes_config *ptr;
+	const struct serdes_config *ptr;
 
 	if (serdes >= ARRAY_SIZE(serdes_cfg_tbl))
 		return 0;
@@ -213,7 +345,7 @@ enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane)
 int is_serdes_prtcl_valid(int serdes, u32 prtcl)
 {
 	int i;
-	struct serdes_config *ptr;
+	const struct serdes_config *ptr;
 
 	if (serdes >= ARRAY_SIZE(serdes_cfg_tbl))
 		return 0;
diff --git a/arch/powerpc/cpu/mpc85xx/tlb.c b/arch/powerpc/cpu/mpc85xx/tlb.c
index f44fadc..de65f30 100644
--- a/arch/powerpc/cpu/mpc85xx/tlb.c
+++ b/arch/powerpc/cpu/mpc85xx/tlb.c
@@ -66,7 +66,7 @@ void read_tlbcam_entry(int idx, u32 *valid, u32 *tsize, unsigned long *epn,
 	_mas1 = mfspr(MAS1);
 
 	*valid = (_mas1 & MAS1_VALID);
-	*tsize = (_mas1 >> 8) & 0xf;
+	*tsize = (_mas1 >> 7) & 0x1f;
 	*epn = mfspr(MAS2) & MAS2_EPN;
 	*rpn = mfspr(MAS3) & MAS3_RPN;
 #ifdef CONFIG_ENABLE_36BIT_PHYS
@@ -156,6 +156,15 @@ void set_tlb(u8 tlb, u32 epn, u64 rpn,
 	if (tlb == 1)
 		use_tlb_cam(esel);
 
+	if ((mfspr(SPRN_MMUCFG) & MMUCFG_MAVN) == MMUCFG_MAVN_V1 &&
+	    tsize & 1) {
+#ifndef CONFIG_SPL_MINIMAL
+		printf("%s: bad tsize %d on entry %d at 0x%08x\n",
+			__func__, tsize, tlb, epn);
+#endif
+		return;
+	}
+
 	_mas0 = FSL_BOOKE_MAS0(tlb, esel, 0);
 	_mas1 = FSL_BOOKE_MAS1(1, iprot, 0, ts, tsize);
 	_mas2 = FSL_BOOKE_MAS2(epn, wimge);
@@ -251,7 +260,7 @@ setup_ddr_tlbs_phys(phys_addr_t p_addr, unsigned int memsize_in_meg)
 	unsigned int tlb_size;
 	unsigned int wimge = MAS2_M;
 	unsigned int ram_tlb_address = (unsigned int)CONFIG_SYS_DDR_SDRAM_BASE;
-	unsigned int max_cam;
+	unsigned int max_cam, tsize_mask;
 	u64 size, memsize = (u64)memsize_in_meg << 20;
 
 #ifdef CONFIG_SYS_PPC_DDR_WIMGE
@@ -261,15 +270,17 @@ setup_ddr_tlbs_phys(phys_addr_t p_addr, unsigned int memsize_in_meg)
 	if ((mfspr(SPRN_MMUCFG) & MMUCFG_MAVN) == MMUCFG_MAVN_V1) {
 		/* Convert (4^max) kB to (2^max) bytes */
 		max_cam = ((mfspr(SPRN_TLB1CFG) >> 16) & 0xf) * 2 + 10;
+		tsize_mask = ~1U;
 	} else {
 		/* Convert (2^max) kB to (2^max) bytes */
 		max_cam = __ilog2(mfspr(SPRN_TLB1PS)) + 10;
+		tsize_mask = ~0U;
 	}
 
 	for (i = 0; size && i < 8; i++) {
 		int ram_tlb_index = find_free_tlbcam();
-		u32 camsize = __ilog2_u64(size) & ~1U;
-		u32 align = __ilog2(ram_tlb_address) & ~1U;
+		u32 camsize = __ilog2_u64(size) & tsize_mask;
+		u32 align = __ilog2(ram_tlb_address) & tsize_mask;
 
 		if (ram_tlb_index == -1)
 			break;
@@ -281,7 +292,7 @@ setup_ddr_tlbs_phys(phys_addr_t p_addr, unsigned int memsize_in_meg)
 		if (camsize > max_cam)
 			camsize = max_cam;
 
-		tlb_size = (camsize - 10) / 2;
+		tlb_size = camsize - 10;
 
 		set_tlb(1, ram_tlb_address, p_addr,
 			MAS3_SX|MAS3_SW|MAS3_SR, wimge,
diff --git a/arch/powerpc/cpu/mpc85xx/u-boot-spl.lds b/arch/powerpc/cpu/mpc85xx/u-boot-spl.lds
index 1c408e2..d3e430c 100644
--- a/arch/powerpc/cpu/mpc85xx/u-boot-spl.lds
+++ b/arch/powerpc/cpu/mpc85xx/u-boot-spl.lds
@@ -60,7 +60,7 @@ SECTIONS
 #if defined(CONFIG_FSL_IFC) /* Restrict bootpg at 4K boundry for IFC */
 	.bootpg ADDR(.text) + 0x1000 :
 	{
-		start.o	(.bootpg)
+		arch/powerpc/cpu/mpc85xx/start.o (.bootpg)
 	}
 #define RESET_VECTOR_OFFSET 0x1ffc /* IFC has 8K sram */
 #elif defined(CONFIG_FSL_ELBC)
diff --git a/arch/powerpc/cpu/mpc86xx/ddr-8641.c b/arch/powerpc/cpu/mpc86xx/ddr-8641.c
index 92ba26d..33a91f9 100644
--- a/arch/powerpc/cpu/mpc86xx/ddr-8641.c
+++ b/arch/powerpc/cpu/mpc86xx/ddr-8641.c
@@ -15,7 +15,7 @@
 #endif
 
 void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
-			     unsigned int ctrl_num)
+			     unsigned int ctrl_num, int step)
 {
 	unsigned int i;
 	volatile ccsr_ddr_t *ddr;
diff --git a/arch/powerpc/cpu/mpc8xxx/Makefile b/arch/powerpc/cpu/mpc8xxx/Makefile
index 3dc8e05..3c50b29 100644
--- a/arch/powerpc/cpu/mpc8xxx/Makefile
+++ b/arch/powerpc/cpu/mpc8xxx/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright 2009-2010 Freescale Semiconductor, Inc.
+# Copyright 2009-2010, 2012 Freescale Semiconductor, Inc.
 #
 # This program is free software; you can redistribute it and/or
 # modify it under the terms of the GNU General Public License
@@ -33,6 +33,7 @@ COBJS-$(CONFIG_FSL_IFC) += fsl_ifc.o
 COBJS-$(CONFIG_FSL_LBC) += fsl_lbc.o
 COBJS-$(CONFIG_SYS_SRIO) += srio.o
 COBJS-$(CONFIG_FSL_LAW) += law.o
+COBJS-$(CONFIG_FSL_CORENET) += fsl_pamu.o pamu_table.o
 
 endif
 
diff --git a/arch/powerpc/cpu/mpc8xxx/cpu.c b/arch/powerpc/cpu/mpc8xxx/cpu.c
index e8613be..f3bedb0 100644
--- a/arch/powerpc/cpu/mpc8xxx/cpu.c
+++ b/arch/powerpc/cpu/mpc8xxx/cpu.c
@@ -77,6 +77,7 @@ static struct cpu_type cpu_type_list[] = {
 	CPU_TYPE_ENTRY(P5040, P5040, 4),
 	CPU_TYPE_ENTRY(T4240, T4240, 0),
 	CPU_TYPE_ENTRY(T4120, T4120, 0),
+	CPU_TYPE_ENTRY(T4160, T4160, 0),
 	CPU_TYPE_ENTRY(B4860, B4860, 0),
 	CPU_TYPE_ENTRY(G4860, G4860, 0),
 	CPU_TYPE_ENTRY(G4060, G4060, 0),
@@ -84,8 +85,19 @@ static struct cpu_type cpu_type_list[] = {
 	CPU_TYPE_ENTRY(G4440, G4440, 0),
 	CPU_TYPE_ENTRY(B4420, B4420, 0),
 	CPU_TYPE_ENTRY(B4220, B4220, 0),
+	CPU_TYPE_ENTRY(T1040, T1040, 0),
+	CPU_TYPE_ENTRY(T1041, T1041, 0),
+	CPU_TYPE_ENTRY(T1042, T1042, 0),
+	CPU_TYPE_ENTRY(T1020, T1020, 0),
+	CPU_TYPE_ENTRY(T1021, T1021, 0),
+	CPU_TYPE_ENTRY(T1022, T1022, 0),
 	CPU_TYPE_ENTRY(BSC9130, 9130, 1),
 	CPU_TYPE_ENTRY(BSC9131, 9131, 1),
+	CPU_TYPE_ENTRY(BSC9132, 9132, 2),
+	CPU_TYPE_ENTRY(BSC9232, 9232, 2),
+	CPU_TYPE_ENTRY(C291, C291, 1),
+	CPU_TYPE_ENTRY(C292, C292, 1),
+	CPU_TYPE_ENTRY(C293, C293, 1),
 #elif defined(CONFIG_MPC86xx)
 	CPU_TYPE_ENTRY(8610, 8610, 1),
 	CPU_TYPE_ENTRY(8641, 8641, 2),
@@ -94,35 +106,70 @@ static struct cpu_type cpu_type_list[] = {
 };
 
 #ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
+static inline u32 init_type(u32 cluster, int init_id)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 idx = (cluster >> (init_id * 8)) & TP_CLUSTER_INIT_MASK;
+	u32 type = in_be32(&gur->tp_ityp[idx]);
+
+	if (type & TP_ITYP_AV)
+		return type;
+
+	return 0;
+}
+
 u32 compute_ppc_cpumask(void)
 {
-	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 	int i = 0, count = 0;
-	u32 cluster, mask = 0;
+	u32 cluster, type, mask = 0;
 
 	do {
 		int j;
-		cluster = in_be32(&gur->tp_cluster[i++].lower);
-		for (j = 0; j < 4; j++) {
-			u32 idx = (cluster >> (j*8)) & TP_CLUSTER_INIT_MASK;
-			u32 type = in_be32(&gur->tp_ityp[idx]);
-
-			if (type & TP_ITYP_AV) {
+		cluster = in_be32(&gur->tp_cluster[i].lower);
+		for (j = 0; j < TP_INIT_PER_CLUSTER; j++) {
+			type = init_type(cluster, j);
+			if (type) {
 				if (TP_ITYP_TYPE(type) == TP_ITYP_TYPE_PPC)
 					mask |= 1 << count;
+				count++;
 			}
-			count++;
 		}
+		i++;
 	} while ((cluster & TP_CLUSTER_EOC) != TP_CLUSTER_EOC);
 
 	return mask;
 }
+
+int fsl_qoriq_core_to_cluster(unsigned int core)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	int i = 0, count = 0;
+	u32 cluster;
+
+	do {
+		int j;
+		cluster = in_be32(&gur->tp_cluster[i].lower);
+		for (j = 0; j < TP_INIT_PER_CLUSTER; j++) {
+			if (init_type(cluster, j)) {
+				if (count == core)
+					return i;
+				count++;
+			}
+		}
+		i++;
+	} while ((cluster & TP_CLUSTER_EOC) != TP_CLUSTER_EOC);
+
+	return -1;	/* cannot identify the cluster */
+}
+
 #else /* CONFIG_SYS_FSL_QORIQ_CHASSIS2 */
 /*
  * Before chassis genenration 2, the cpumask should be hard-coded.
  * In case of cpu type unknown or cpumask unset, use 1 as fail save.
  */
 #define compute_ppc_cpumask()	1
+#define fsl_qoriq_core_to_cluster(x) x
 #endif /* CONFIG_SYS_FSL_QORIQ_CHASSIS2 */
 
 static struct cpu_type cpu_type_unknown = CPU_TYPE_ENTRY(Unknown, Unknown, 0);
diff --git a/arch/powerpc/cpu/mpc8xxx/ddr/ctrl_regs.c b/arch/powerpc/cpu/mpc8xxx/ddr/ctrl_regs.c
index 2c71089..81971d6 100644
--- a/arch/powerpc/cpu/mpc8xxx/ddr/ctrl_regs.c
+++ b/arch/powerpc/cpu/mpc8xxx/ddr/ctrl_regs.c
@@ -375,7 +375,7 @@ static void set_timing_cfg_3(fsl_ddr_cfg_regs_t *ddr,
 
 	ddr->timing_cfg_3 = (0
 		| ((ext_pretoact & 0x1) << 28)
-		| ((ext_acttopre & 0x2) << 24)
+		| ((ext_acttopre & 0x3) << 24)
 		| ((ext_acttorw & 0x1) << 22)
 		| ((ext_refrec & 0x1F) << 16)
 		| ((ext_caslat & 0x3) << 12)
@@ -692,6 +692,7 @@ static void set_ddr_sdram_cfg_2(fsl_ddr_cfg_regs_t *ddr,
 	unsigned int odt_cfg = 0;	/* ODT configuration */
 	unsigned int num_pr;		/* Number of posted refreshes */
 	unsigned int slow = 0;		/* DDR will be run less than 1250 */
+	unsigned int x4_en = 0;		/* x4 DRAM enable */
 	unsigned int obc_cfg;		/* On-The-Fly Burst Chop Cfg */
 	unsigned int ap_en;		/* Address Parity Enable */
 	unsigned int d_init;		/* DRAM data initialization */
@@ -736,6 +737,8 @@ static void set_ddr_sdram_cfg_2(fsl_ddr_cfg_regs_t *ddr,
 		ap_en = 0;
 	}
 
+	x4_en = popts->x4_en ? 1 : 0;
+
 #if defined(CONFIG_ECC_INIT_VIA_DDRCONTROLLER)
 	/* Use the DDR controller to auto initialize memory. */
 	d_init = popts->ECC_init_using_memctl;
@@ -758,6 +761,7 @@ static void set_ddr_sdram_cfg_2(fsl_ddr_cfg_regs_t *ddr,
 		| ((odt_cfg & 0x3) << 21)
 		| ((num_pr & 0xf) << 12)
 		| ((slow & 1) << 11)
+		| (x4_en << 10)
 		| (qd_en << 9)
 		| (unq_mrs_en << 8)
 		| ((obc_cfg & 0x1) << 6)
@@ -1350,9 +1354,9 @@ static void set_ddr_wrlvl_cntl(fsl_ddr_cfg_regs_t *ddr, unsigned int wrlvl_en,
 		wrlvl_mrd = 0x6;
 		/* tWL_ODTEN 128 */
 		wrlvl_odten = 0x7;
-		if (popts->wrlvl_odten_override) {
-			wrlvl_odten = popts->wrlvl_odten;
-		}
+        if (popts->wrlvl_odten_override) {
+            wrlvl_odten = popts->wrlvl_odten;
+        }
 		/* tWL_DQSEN min = 25 nCK, we set it 32 */
 		wrlvl_dqsen = 0x5;
 		/*
@@ -1601,8 +1605,8 @@ compute_fsl_memctl_config_regs(const memctl_options_t *popts,
 				| ((ea & 0xFFF) << 0)	/* ending address MSB */
 				);
 		} else {
-			debug("FSLDDR: setting bnds to 0 for inactive CS\n");
-			ddr->cs[i].bnds = 0;
+			/* setting bnds to 0xffffffff for inactive CS */
+			ddr->cs[i].bnds = 0xffffffff;
 		}
 
 		debug("FSLDDR: cs[%d]_bnds = 0x%08x\n", i, ddr->cs[i].bnds);
@@ -1654,5 +1658,10 @@ compute_fsl_memctl_config_regs(const memctl_options_t *popts,
 
 	set_ddr_sdram_rcw(ddr, popts, common_dimm);
 
+#ifdef CONFIG_SYS_FSL_DDR_EMU
+	/* disble DDR training for emulator */
+	ddr->debug[2] = 0x00000400;
+	ddr->debug[4] = 0xff800000;
+#endif
 	return check_fsl_memctl_config_regs(ddr);
 }
diff --git a/arch/powerpc/cpu/mpc8xxx/ddr/ddr.h b/arch/powerpc/cpu/mpc8xxx/ddr/ddr.h
index c8b0f91..c173a5a 100644
--- a/arch/powerpc/cpu/mpc8xxx/ddr/ddr.h
+++ b/arch/powerpc/cpu/mpc8xxx/ddr/ddr.h
@@ -86,7 +86,8 @@ void fsl_ddr_set_lawbar(
 		unsigned int memctl_interleaved,
 		unsigned int ctrl_num);
 
-unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo);
+int fsl_ddr_interactive_env_var_exists(void);
+unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo, int var_is_set);
 void fsl_ddr_get_spd(generic_spd_eeprom_t *ctrl_dimms_spd,
 			   unsigned int ctrl_num);
 
@@ -95,7 +96,7 @@ unsigned int check_fsl_memctl_config_regs(const fsl_ddr_cfg_regs_t *ddr);
 
 /* processor specific function */
 void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
-				   unsigned int ctrl_num);
+				   unsigned int ctrl_num, int step);
 
 /* board specific function */
 int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
diff --git a/arch/powerpc/cpu/mpc8xxx/ddr/ddr3_dimm_params.c b/arch/powerpc/cpu/mpc8xxx/ddr/ddr3_dimm_params.c
index 3e7c269..b67158c 100644
--- a/arch/powerpc/cpu/mpc8xxx/ddr/ddr3_dimm_params.c
+++ b/arch/powerpc/cpu/mpc8xxx/ddr/ddr3_dimm_params.c
@@ -129,6 +129,7 @@ ddr_compute_dimm_parameters(const ddr3_spd_eeprom_t *spd,
 		pdimm->ec_sdram_width = 0;
 	pdimm->data_width = pdimm->primary_sdram_width
 			  + pdimm->ec_sdram_width;
+	pdimm->device_width = 1 << ((spd->organization & 0x7) + 2);
 
 	/* These are the types defined by the JEDEC DDR3 SPD spec */
 	pdimm->mirrored_dimm = 0;
diff --git a/arch/powerpc/cpu/mpc8xxx/ddr/interactive.c b/arch/powerpc/cpu/mpc8xxx/ddr/interactive.c
index cb71f94..765083b 100644
--- a/arch/powerpc/cpu/mpc8xxx/ddr/interactive.c
+++ b/arch/powerpc/cpu/mpc8xxx/ddr/interactive.c
@@ -207,6 +207,7 @@ static void fsl_ddr_dimm_parameters_edit(fsl_ddr_info_t *pinfo,
 		DIMM_PARM(primary_sdram_width),
 		DIMM_PARM(ec_sdram_width),
 		DIMM_PARM(registered_dimm),
+		DIMM_PARM(device_width),
 
 		DIMM_PARM(n_row_addr),
 		DIMM_PARM(n_col_addr),
@@ -265,6 +266,7 @@ static void print_dimm_parameters(const dimm_params_t *pdimm)
 		DIMM_PARM(primary_sdram_width),
 		DIMM_PARM(ec_sdram_width),
 		DIMM_PARM(registered_dimm),
+		DIMM_PARM(device_width),
 
 		DIMM_PARM(n_row_addr),
 		DIMM_PARM(n_col_addr),
@@ -445,6 +447,7 @@ static void fsl_ddr_options_edit(fsl_ddr_info_t *pinfo,
 		CTRL_OPTIONS(twoT_en),
 		CTRL_OPTIONS(threeT_en),
 		CTRL_OPTIONS(ap_en),
+		CTRL_OPTIONS(x4_en),
 		CTRL_OPTIONS(bstopre),
 		CTRL_OPTIONS(wrlvl_override),
 		CTRL_OPTIONS(wrlvl_sample),
@@ -689,6 +692,7 @@ static void print_memctl_options(const memctl_options_t *popts)
 		CTRL_OPTIONS(threeT_en),
 		CTRL_OPTIONS(registered_dimm_en),
 		CTRL_OPTIONS(ap_en),
+		CTRL_OPTIONS(x4_en),
 		CTRL_OPTIONS(bstopre),
 		CTRL_OPTIONS(wrlvl_override),
 		CTRL_OPTIONS(wrlvl_sample),
@@ -1369,14 +1373,15 @@ struct data_strings {
 
 #define DATA_OPTIONS(name, step, dimm) {#name, step, dimm}
 
-unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo)
-{
-	unsigned long long ddrsize;
-	const char *prompt = "FSL DDR>";
-	char buffer[CONFIG_SYS_CBSIZE];
-	char *argv[CONFIG_SYS_MAXARGS + 1];	/* NULL terminated */
-	int argc;
-	unsigned int next_step = STEP_GET_SPD;
+static unsigned int fsl_ddr_parse_interactive_cmd (
+	char **argv,
+	int argc,
+	unsigned int *pstep_mask,
+	unsigned int *pctlr_mask,
+	unsigned int *pdimm_mask,
+	unsigned int *pdimm_number_required
+	 ) {
+
 	static const struct data_strings options[] = {
 		DATA_OPTIONS(spd, STEP_GET_SPD, 1),
 		DATA_OPTIONS(dimmparms, STEP_COMPUTE_DIMM_PARMS, 1),
@@ -1386,6 +1391,69 @@ unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo)
 		DATA_OPTIONS(regs, STEP_COMPUTE_REGS, 0),
 	};
 	static const unsigned int n_opts = ARRAY_SIZE(options);
+
+	unsigned int i, j;
+	unsigned int error = 0;
+
+	for (i = 1; i < argc; i++) {
+		unsigned int matched = 0;
+
+		for (j = 0; j < n_opts; j++) {
+			if (strcmp(options[j].data_name, argv[i]) != 0)
+				continue;
+			*pstep_mask |= options[j].step_mask;
+			*pdimm_number_required =
+				options[j].dimm_number_required;
+			matched = 1;
+			break;
+		}
+
+		if (matched)
+			continue;
+
+		if (argv[i][0] == 'c') {
+			char c = argv[i][1];
+			if (isdigit(c))
+				*pctlr_mask |= 1 << (c - '0');
+			continue;
+		}
+
+		if (argv[i][0] == 'd') {
+			char c = argv[i][1];
+			if (isdigit(c))
+				*pdimm_mask |= 1 << (c - '0');
+			continue;
+		}
+
+		printf("unknown arg %s\n", argv[i]);
+		*pstep_mask = 0;
+		error = 1;
+		break;
+	}
+
+	return error;
+}
+
+int fsl_ddr_interactive_env_var_exists(void)
+{
+	char buffer[CONFIG_SYS_CBSIZE];
+
+	if (getenv_f("ddr_interactive", buffer, CONFIG_SYS_CBSIZE) >= 0)
+		return 1;
+
+	return 0;
+}
+
+unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo, int var_is_set)
+{
+	unsigned long long ddrsize;
+	const char *prompt = "FSL DDR>";
+	char buffer[CONFIG_SYS_CBSIZE];
+	char buffer2[CONFIG_SYS_CBSIZE];
+	char *p = NULL;
+	char *argv[CONFIG_SYS_MAXARGS + 1];	/* NULL terminated */
+	int argc;
+	unsigned int next_step = STEP_GET_SPD;
 	const char *usage = {
 		"commands:\n"
 		"print      print SPD and intermediate computed data\n"
@@ -1393,21 +1461,45 @@ unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo)
 		"recompute  reload SPD and options to default and recompute regs\n"
 		"edit       modify spd, parameter, or option\n"
 		"compute    recompute registers from current next_step to end\n"
+		"copy       copy parameters\n"
 		"next_step  shows current next_step\n"
 		"help       this message\n"
 		"go         program the memory controller and continue with u-boot\n"
 	};
 
+	if (var_is_set) {
+		if (getenv_f("ddr_interactive", buffer2, CONFIG_SYS_CBSIZE) > 0) {
+			p = buffer2;
+		} else {
+			var_is_set = 0;
+		}
+	}
+
 	/*
 	 * The strategy for next_step is that it points to the next
 	 * step in the computation process that needs to be done.
 	 */
 	while (1) {
-		/*
-		 * No need to worry for buffer overflow here in
-		 * this function;  readline() maxes out at CFG_CBSIZE
-		 */
-		readline_into_buffer(prompt, buffer, 0);
+		if (var_is_set) {
+			char *pend = strchr(p, ';');
+			if (pend) {
+				/* found command separator, copy sub-command */
+				*pend = '\0';
+				strcpy(buffer, p);
+				p = pend + 1;
+			} else {
+				/* separator not found, copy whole string */
+				strcpy(buffer, p);
+				p = NULL;
+				var_is_set = 0;
+			}
+		} else {
+			/*
+			 * No need to worry for buffer overflow here in
+			 * this function;  readline() maxes out at CFG_CBSIZE
+			 */
+			readline_into_buffer(prompt, buffer, 0);
+		}
 		argc = parse_line(buffer, argv);
 		if (argc == 0)
 			continue;
@@ -1425,64 +1517,160 @@ unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo)
 			continue;
 		}
 
-		if (strcmp(argv[0], "edit") == 0) {
-			unsigned int i, j;
+		if (strcmp(argv[0], "copy") == 0) {
 			unsigned int error = 0;
 			unsigned int step_mask = 0;
-			unsigned int ctlr_mask = 0;
-			unsigned int dimm_mask = 0;
-			char *p_element = NULL;
-			char *p_value = NULL;
+			unsigned int src_ctlr_mask = 0;
+			unsigned int src_dimm_mask = 0;
 			unsigned int dimm_number_required = 0;
-			unsigned int ctrl_num;
-			unsigned int dimm_num;
-			unsigned int matched = 0;
+			unsigned int src_ctlr_num = 0;
+			unsigned int src_dimm_num = 0;
+			unsigned int dst_ctlr_num = -1;
+			unsigned int dst_dimm_num = -1;
+			unsigned int i, num_dest_parms;
 
 			if (argc == 1) {
-				/* Only the element and value must be last */
-				printf("edit <c#> <d#> "
-					"<spd|dimmparms|commonparms|opts|"
-					"addresses|regs> <element> <value>\n");
-				printf("for spd, specify byte number for "
-					"element\n");
+				printf("copy <src c#> <src d#> <spd|dimmparms|commonparms|opts|addresses|regs> <dst c#> <dst d#>\n");
 				continue;
 			}
 
-			for (i = 1; i < argc - 2; i++) {
-				for (j = 0; j < n_opts; j++) {
-					if (strcmp(options[j].data_name,
-						argv[i]) != 0)
-						continue;
-					step_mask |= options[j].step_mask;
-					dimm_number_required =
-						options[j].dimm_number_required;
-					matched = 1;
-					break;
+			error = fsl_ddr_parse_interactive_cmd(
+				argv, argc,
+				&step_mask,
+				&src_ctlr_mask,
+				&src_dimm_mask,
+				&dimm_number_required
+			);
+
+			/* XXX: only dimm_number_required and step_mask will
+			   be used by this function.  Parse the controller and
+			   DIMM number separately because it is easier.  */
+
+			if (error)
+				continue;
+
+			/* parse source destination controller / DIMM */
+
+			num_dest_parms = dimm_number_required ? 2 : 1;
+
+			for (i = 0; i < argc; i++) {
+				if (argv[i][0] == 'c') {
+					char c = argv[i][1];
+					if (isdigit(c)) {
+						src_ctlr_num = (c - '0');
+						break;
+					}
 				}
+			}
 
-				if (matched)
-					continue;
+			for (i = 0; i < argc; i++) {
+				if (argv[i][0] == 'd') {
+					char c = argv[i][1];
+					if (isdigit(c)) {
+						src_dimm_num = (c - '0');
+						break;
+					}
+				}
+			}
+
+			/* parse destination controller / DIMM */
 
+			for (i = argc - 1; i >= argc - num_dest_parms; i--) {
 				if (argv[i][0] == 'c') {
 					char c = argv[i][1];
-					if (isdigit(c))
-						ctlr_mask |= 1 << (c - '0');
-					continue;
+					if (isdigit(c)) {
+						dst_ctlr_num = (c - '0');
+						break;
+					}
 				}
+			}
 
+			for (i = argc - 1; i >= argc - num_dest_parms; i--) {
 				if (argv[i][0] == 'd') {
 					char c = argv[i][1];
-					if (isdigit(c))
-						dimm_mask |= 1 << (c - '0');
-					continue;
+					if (isdigit(c)) {
+						dst_dimm_num = (c - '0');
+						break;
+					}
 				}
+			}
+
+			/* TODO: validate inputs */
+
+			debug("src_ctlr_num = %u, src_dimm_num = %u, dst_ctlr_num = %u, dst_dimm_num = %u, step_mask = %x\n",
+				src_ctlr_num, src_dimm_num, dst_ctlr_num, dst_dimm_num, step_mask);
 
-				printf("unknown arg %s\n", argv[i]);
-				step_mask = 0;
-				error = 1;
+
+			switch (step_mask) {
+
+			case STEP_GET_SPD:
+				memcpy(&(pinfo->spd_installed_dimms[dst_ctlr_num][dst_dimm_num]),
+					&(pinfo->spd_installed_dimms[src_ctlr_num][src_dimm_num]),
+					sizeof(pinfo->spd_installed_dimms[0][0]));
 				break;
+
+			case STEP_COMPUTE_DIMM_PARMS:
+				memcpy(&(pinfo->dimm_params[dst_ctlr_num][dst_dimm_num]),
+					&(pinfo->dimm_params[src_ctlr_num][src_dimm_num]),
+					sizeof(pinfo->dimm_params[0][0]));
+				break;
+
+			case STEP_COMPUTE_COMMON_PARMS:
+				memcpy(&(pinfo->common_timing_params[dst_ctlr_num]),
+					&(pinfo->common_timing_params[src_ctlr_num]),
+					sizeof(pinfo->common_timing_params[0]));
+				break;
+
+			case STEP_GATHER_OPTS:
+				memcpy(&(pinfo->memctl_opts[dst_ctlr_num]),
+					&(pinfo->memctl_opts[src_ctlr_num]),
+					sizeof(pinfo->memctl_opts[0]));
+				break;
+
+			/* someday be able to have addresses to copy addresses... */
+
+			case STEP_COMPUTE_REGS:
+				memcpy(&(pinfo->fsl_ddr_config_reg[dst_ctlr_num]),
+					&(pinfo->fsl_ddr_config_reg[src_ctlr_num]),
+					sizeof(pinfo->memctl_opts[0]));
+				break;
+
+			default:
+				printf("unexpected step_mask value\n");
+			}
+
+			continue;
+
+		}
+
+		if (strcmp(argv[0], "edit") == 0) {
+			unsigned int error = 0;
+			unsigned int step_mask = 0;
+			unsigned int ctlr_mask = 0;
+			unsigned int dimm_mask = 0;
+			char *p_element = NULL;
+			char *p_value = NULL;
+			unsigned int dimm_number_required = 0;
+			unsigned int ctrl_num;
+			unsigned int dimm_num;
+
+			if (argc == 1) {
+				/* Only the element and value must be last */
+				printf("edit <c#> <d#> "
+					"<spd|dimmparms|commonparms|opts|"
+					"addresses|regs> <element> <value>\n");
+				printf("for spd, specify byte number for "
+					"element\n");
+				continue;
 			}
 
+			error = fsl_ddr_parse_interactive_cmd(
+				argv, argc - 2,
+				&step_mask,
+				&ctlr_mask,
+				&dimm_mask,
+				&dimm_number_required
+			);
 
 			if (error)
 				continue;
@@ -1629,12 +1817,11 @@ unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo)
 		}
 
 		if (strcmp(argv[0], "print") == 0) {
-			unsigned int i, j;
 			unsigned int error = 0;
 			unsigned int step_mask = 0;
 			unsigned int ctlr_mask = 0;
 			unsigned int dimm_mask = 0;
-			unsigned int matched = 0;
+			unsigned int dimm_number_required = 0;
 
 			if (argc == 1) {
 				printf("print [c<n>] [d<n>] [spd] [dimmparms] "
@@ -1642,38 +1829,13 @@ unsigned long long fsl_ddr_interactive(fsl_ddr_info_t *pinfo)
 				continue;
 			}
 
-			for (i = 1; i < argc; i++) {
-				for (j = 0; j < n_opts; j++) {
-					if (strcmp(options[j].data_name,
-						argv[i]) != 0)
-						continue;
-					step_mask |= options[j].step_mask;
-					matched = 1;
-					break;
-				}
-
-				if (matched)
-					continue;
-
-				if (argv[i][0] == 'c') {
-					char c = argv[i][1];
-					if (isdigit(c))
-						ctlr_mask |= 1 << (c - '0');
-					continue;
-				}
-
-				if (argv[i][0] == 'd') {
-					char c = argv[i][1];
-					if (isdigit(c))
-						dimm_mask |= 1 << (c - '0');
-					continue;
-				}
-
-				printf("unknown arg %s\n", argv[i]);
-				step_mask = 0;
-				error = 1;
-				break;
-			}
+			error = fsl_ddr_parse_interactive_cmd(
+				argv, argc,
+				&step_mask,
+				&ctlr_mask,
+				&dimm_mask,
+				&dimm_number_required
+			);
 
 			if (error)
 				continue;
diff --git a/arch/powerpc/cpu/mpc8xxx/ddr/lc_common_dimm_params.c b/arch/powerpc/cpu/mpc8xxx/ddr/lc_common_dimm_params.c
index 9adde31..e958e13 100644
--- a/arch/powerpc/cpu/mpc8xxx/ddr/lc_common_dimm_params.c
+++ b/arch/powerpc/cpu/mpc8xxx/ddr/lc_common_dimm_params.c
@@ -44,7 +44,6 @@ compute_cas_latency_ddr3(const dimm_params_t *dimm_params,
 		printf("DDR clock (MCLK cycle %u ps) is faster than "
 			"the slowest DIMM(s) (tCKmin %u ps) can support.\n",
 			mclk_ps, tCKmin_X_ps);
-		return 1;
 	}
 	/* determine the acutal cas latency */
 	caslat_actual = (tAAmin_ps + mclk_ps - 1) / mclk_ps;
@@ -60,7 +59,6 @@ compute_cas_latency_ddr3(const dimm_params_t *dimm_params,
 	if (caslat_actual * mclk_ps > 20000) {
 		printf("The choosen cas latency %d is too large\n",
 			caslat_actual);
-		return 1;
 	}
 	outpdimm->lowest_common_SPD_caslat = caslat_actual;
 
diff --git a/arch/powerpc/cpu/mpc8xxx/ddr/main.c b/arch/powerpc/cpu/mpc8xxx/ddr/main.c
index d6b73c7..9f4f253 100644
--- a/arch/powerpc/cpu/mpc8xxx/ddr/main.c
+++ b/arch/powerpc/cpu/mpc8xxx/ddr/main.c
@@ -25,10 +25,6 @@ void fsl_ddr_set_lawbar(
 		unsigned int ctrl_num);
 void fsl_ddr_set_intl3r(const unsigned int granule_size);
 
-/* processor specific function */
-extern void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
-				   unsigned int ctrl_num);
-
 #if defined(SPD_EEPROM_ADDRESS) || \
     defined(SPD_EEPROM_ADDRESS1) || defined(SPD_EEPROM_ADDRESS2) || \
     defined(SPD_EEPROM_ADDRESS3) || defined(SPD_EEPROM_ADDRESS4)
@@ -186,7 +182,7 @@ const char * step_to_string(unsigned int step) {
 	return step_string_tbl[s];
 }
 
-unsigned long long step_assign_addresses(fsl_ddr_info_t *pinfo,
+static unsigned long long __step_assign_addresses(fsl_ddr_info_t *pinfo,
 			  unsigned int dbw_cap_adj[])
 {
 	int i, j;
@@ -354,15 +350,22 @@ unsigned long long step_assign_addresses(fsl_ddr_info_t *pinfo,
 	return total_mem;
 }
 
+/* Use weak function to allow board file to override the address assignment */
+__attribute__((weak, alias("__step_assign_addresses")))
+unsigned long long step_assign_addresses(fsl_ddr_info_t *pinfo,
+			  unsigned int dbw_cap_adj[]);
+
 unsigned long long
 fsl_ddr_compute(fsl_ddr_info_t *pinfo, unsigned int start_step,
 				       unsigned int size_only)
 {
 	unsigned int i, j;
 	unsigned long long total_mem = 0;
+	int assert_reset;
 
 	fsl_ddr_cfg_regs_t *ddr_reg = pinfo->fsl_ddr_config_reg;
 	common_timing_params_t *timing_params = pinfo->common_timing_params;
+	assert_reset = board_need_mem_reset();
 
 	/* data bus width capacity adjust shift amount */
 	unsigned int dbw_capacity_adjust[CONFIG_NUM_DDR_CONTROLLERS];
@@ -457,7 +460,20 @@ fsl_ddr_compute(fsl_ddr_info_t *pinfo, unsigned int start_step,
 					timing_params[i].all_DIMMs_registered,
 					&pinfo->memctl_opts[i],
 					pinfo->dimm_params[i], i);
+			/*
+			 * For RDIMMs, JEDEC spec requires clocks to be stable
+			 * before reset signal is deasserted. For the boards
+			 * using fixed parameters, this function should be
+			 * be called from board init file.
+			 */
+			if (timing_params[i].all_DIMMs_registered)
+				assert_reset = 1;
+		}
+		if (assert_reset) {
+			debug("Asserting mem reset\n");
+			board_assert_mem_reset();
 		}
+
 	case STEP_ASSIGN_ADDRESSES:
 		/* STEP 5:  Assign addresses to chip selects */
 		check_interleaving_options(pinfo);
@@ -499,7 +515,13 @@ fsl_ddr_compute(fsl_ddr_info_t *pinfo, unsigned int start_step,
 				fsl_ddr_cfg_regs_t *reg = &ddr_reg[i];
 				if (reg->cs[j].config & 0x80000000) {
 					unsigned int end;
-					end = reg->cs[j].bnds & 0xFFF;
+					/*
+					 * 0xfffffff is a special value we put
+					 * for unused bnds
+					 */
+					if (reg->cs[j].bnds == 0xffffffff)
+						continue;
+					end = reg->cs[j].bnds & 0xffff;
 					if (end > max_end) {
 						max_end = end;
 					}
@@ -526,30 +548,50 @@ phys_size_t fsl_ddr_sdram(void)
 	unsigned int law_memctl = LAW_TRGT_IF_DDR_1;
 	unsigned long long total_memory;
 	fsl_ddr_info_t info;
+	int deassert_reset;
 
 	/* Reset info structure. */
 	memset(&info, 0, sizeof(fsl_ddr_info_t));
 
 	/* Compute it once normally. */
 #ifdef CONFIG_FSL_DDR_INTERACTIVE
-	if (getenv("ddr_interactive"))
-		total_memory = fsl_ddr_interactive(&info);
-	else
+	if (tstc() && (getc() == 'd')) {	/* we got a key press of 'd' */
+		total_memory = fsl_ddr_interactive(&info, 0);
+	} else if (fsl_ddr_interactive_env_var_exists()) {
+		total_memory = fsl_ddr_interactive(&info, 1);
+	} else
 #endif
 		total_memory = fsl_ddr_compute(&info, STEP_GET_SPD, 0);
 
 	/* setup 3-way interleaving before enabling DDRC */
-	switch (info.memctl_opts[0].memctl_interleaving_mode) {
-	case FSL_DDR_3WAY_1KB_INTERLEAVING:
-	case FSL_DDR_3WAY_4KB_INTERLEAVING:
-	case FSL_DDR_3WAY_8KB_INTERLEAVING:
-		fsl_ddr_set_intl3r(info.memctl_opts[0].memctl_interleaving_mode);
-		break;
-	default:
-		break;
+	if (info.memctl_opts[0].memctl_interleaving) {
+		switch (info.memctl_opts[0].memctl_interleaving_mode) {
+		case FSL_DDR_3WAY_1KB_INTERLEAVING:
+		case FSL_DDR_3WAY_4KB_INTERLEAVING:
+		case FSL_DDR_3WAY_8KB_INTERLEAVING:
+			fsl_ddr_set_intl3r(
+				info.memctl_opts[0].memctl_interleaving_mode);
+			break;
+		default:
+			break;
+		}
 	}
 
-	/* Program configuration registers. */
+	/*
+	 * Program configuration registers.
+	 * JEDEC specs requires clocks to be stable before deasserting reset
+	 * for RDIMMs. Clocks start after chip select is enabled and clock
+	 * control register is set. During step 1, all controllers have their
+	 * registers set but not enabled. Step 2 proceeds after deasserting
+	 * reset through board FPGA or GPIO.
+	 * For non-registered DIMMs, initialization can go through but it is
+	 * also OK to follow the same flow.
+	 */
+	deassert_reset = board_need_mem_reset();
+	for (i = 0; i < CONFIG_NUM_DDR_CONTROLLERS; i++) {
+		if (info.common_timing_params[i].all_DIMMs_registered)
+			deassert_reset = 1;
+	}
 	for (i = 0; i < CONFIG_NUM_DDR_CONTROLLERS; i++) {
 		debug("Programming controller %u\n", i);
 		if (info.common_timing_params[i].ndimms_present == 0) {
@@ -557,8 +599,22 @@ phys_size_t fsl_ddr_sdram(void)
 					"skipping programming\n", i);
 			continue;
 		}
-
-		fsl_ddr_set_memctl_regs(&(info.fsl_ddr_config_reg[i]), i);
+		/*
+		 * The following call with step = 1 returns before enabling
+		 * the controller. It has to finish with step = 2 later.
+		 */
+		fsl_ddr_set_memctl_regs(&(info.fsl_ddr_config_reg[i]), i,
+					deassert_reset ? 1 : 0);
+	}
+	if (deassert_reset) {
+		/* Use board FPGA or GPIO to deassert reset signal */
+		debug("Deasserting mem reset\n");
+		board_deassert_mem_reset();
+		for (i = 0; i < CONFIG_NUM_DDR_CONTROLLERS; i++) {
+			/* Call with step = 2 to continue initialization */
+			fsl_ddr_set_memctl_regs(&(info.fsl_ddr_config_reg[i]),
+						i, 2);
+		}
 	}
 
 	/* program LAWs */
diff --git a/arch/powerpc/cpu/mpc8xxx/ddr/options.c b/arch/powerpc/cpu/mpc8xxx/ddr/options.c
index 2f13b8f..e02d76d 100644
--- a/arch/powerpc/cpu/mpc8xxx/ddr/options.c
+++ b/arch/powerpc/cpu/mpc8xxx/ddr/options.c
@@ -703,6 +703,8 @@ unsigned int populate_memctl_options(int all_DIMMs_registered,
 	}
 #endif
 
+	popts->x4_en = (pdimm[0].device_width == 4) ? 1 : 0;
+
 	/* Choose burst length. */
 #if defined(CONFIG_FSL_DDR3)
 #if defined(CONFIG_E500MC)
diff --git a/arch/powerpc/cpu/mpc8xxx/fdt.c b/arch/powerpc/cpu/mpc8xxx/fdt.c
index 1986fea..b821f3f 100644
--- a/arch/powerpc/cpu/mpc8xxx/fdt.c
+++ b/arch/powerpc/cpu/mpc8xxx/fdt.c
@@ -4,23 +4,7 @@
  * This file is derived from arch/powerpc/cpu/mpc85xx/cpu.c and
  * arch/powerpc/cpu/mpc86xx/cpu.c. Basically this file contains
  * cpu specific common code for 85xx/86xx processors.
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -28,10 +12,13 @@
 #include <fdt_support.h>
 #include <asm/mp.h>
 #include <asm/fsl_serdes.h>
+#include <asm/fsl_usb.h>
 #include <phy.h>
 #include <hwconfig.h>
 
-#define FSL_MAX_NUM_USB_CTRLS	2
+#ifndef CONFIG_USB_MAX_CONTROLLER_COUNT
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#endif
 
 #if defined(CONFIG_MP) && (defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx))
 static int ft_del_cpuhandle(void *blob, int cpuhandle)
@@ -137,17 +124,14 @@ void fdt_fixup_dr_usb(void *blob, bd_t *bd)
 {
 	const char *modes[] = { "host", "peripheral", "otg" };
 	const char *phys[] = { "ulpi", "utmi" };
-	const char *mode = NULL;
-	const char *phy_type = NULL;
 	const char *dr_mode_type = NULL;
 	const char *dr_phy_type = NULL;
-	char usb1_defined = 0;
 	int usb_mode_off = -1;
 	int usb_phy_off = -1;
 	char str[5];
 	int i, j;
 
-	for (i = 1; i <= FSL_MAX_NUM_USB_CTRLS; i++) {
+	for (i = 1; i <= CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
 		int mode_idx = -1, phy_idx = -1;
 		snprintf(str, 5, "%s%d", "usb", i);
 		if (hwconfig(str)) {
@@ -167,15 +151,14 @@ void fdt_fixup_dr_usb(void *blob, bd_t *bd)
 				}
 			}
 
+			if (mode_idx < 0 || phy_idx < 0) {
+				puts("ERROR: wrong usb mode/phy defined!!\n");
+				return;
+			}
+
 			dr_mode_type = modes[mode_idx];
 			dr_phy_type = phys[phy_idx];
 
-			/* use usb_dr_mode and usb_phy_type if
-			   usb1_defined = 0; these variables are to
-			   be deprecated */
-			if (!strcmp(str, "usb1"))
-				usb1_defined = 1;
-
 			if (mode_idx < 0 && phy_idx < 0) {
 				printf("WARNING: invalid phy or mode\n");
 				return;
@@ -184,29 +167,14 @@ void fdt_fixup_dr_usb(void *blob, bd_t *bd)
 
 		usb_mode_off = fdt_fixup_usb_mode_phy_type(blob,
 			dr_mode_type, NULL, usb_mode_off);
-
 		if (usb_mode_off < 0)
 			return;
 
 		usb_phy_off = fdt_fixup_usb_mode_phy_type(blob,
 			NULL, dr_phy_type, usb_phy_off);
-
 		if (usb_phy_off < 0)
 			return;
 	}
-
-	if (!usb1_defined) {
-		int usb_off = -1;
-		mode = getenv("usb_dr_mode");
-		phy_type = getenv("usb_phy_type");
-		if (mode || phy_type) {
-			printf("WARNING: usb_dr_mode and usb_phy_type "
-				"are to be deprecated soon. Use "
-				"hwconfig to set these values instead!!\n");
-			fdt_fixup_usb_mode_phy_type(blob, mode,
-				phy_type, usb_off);
-		}
-	}
 }
 #endif /* defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB) */
 
@@ -297,10 +265,86 @@ void fdt_fixup_crypto_node(void *blob, int sec_rev)
 		       fdt_strerror(err));
 }
 #elif CONFIG_SYS_FSL_SEC_COMPAT >= 4  /* SEC4 */
+static u8 caam_get_era(void)
+{
+	static const struct {
+		u16 ip_id;
+		u8 maj_rev;
+		u8 era;
+	} caam_eras[] = {
+		{0x0A10, 1, 1},
+		{0x0A10, 2, 2},
+		{0x0A12, 1, 3},
+		{0x0A14, 1, 3},
+		{0x0A14, 2, 4},
+		{0x0A16, 1, 4},
+		{0x0A10, 3, 4},
+		{0x0A11, 1, 4},
+		{0x0A18, 1, 4},
+		{0x0A11, 2, 5},
+		{0x0A12, 2, 5},
+		{0x0A13, 1, 5},
+		{0x0A1C, 1, 5}
+	};
+
+	ccsr_sec_t __iomem *sec = (void __iomem *)CONFIG_SYS_FSL_SEC_ADDR;
+	u32 secvid_ms = in_be32(&sec->secvid_ms);
+	u32 ccbvid = in_be32(&sec->ccbvid);
+	u16 ip_id = (secvid_ms & SEC_SECVID_MS_IPID_MASK) >>
+				SEC_SECVID_MS_IPID_SHIFT;
+	u8 maj_rev = (secvid_ms & SEC_SECVID_MS_MAJ_REV_MASK) >>
+				SEC_SECVID_MS_MAJ_REV_SHIFT;
+	u8 era = (ccbvid & SEC_CCBVID_ERA_MASK) >> SEC_CCBVID_ERA_SHIFT;
+
+	int i;
+
+	if (era)	/* This is '0' prior to CAAM ERA-6 */
+		return era;
+
+	for (i = 0; i < ARRAY_SIZE(caam_eras); i++)
+		if (caam_eras[i].ip_id == ip_id &&
+		    caam_eras[i].maj_rev == maj_rev)
+			return caam_eras[i].era;
+
+	return 0;
+}
+
+static void fdt_fixup_crypto_era(void *blob, u32 era)
+{
+	int err;
+	int crypto_node;
+
+	crypto_node = fdt_path_offset(blob, "crypto");
+	if (crypto_node < 0) {
+		printf("WARNING: Missing crypto node\n");
+		return;
+	}
+
+	err = fdt_setprop(blob, crypto_node, "fsl,sec-era", &era,
+			  sizeof(era));
+	if (err < 0) {
+		printf("ERROR: could not set fsl,sec-era property: %s\n",
+		       fdt_strerror(err));
+	}
+}
+
 void fdt_fixup_crypto_node(void *blob, int sec_rev)
 {
-	if (!sec_rev)
+	u8 era;
+
+	if (!sec_rev) {
 		fdt_del_node_and_alias(blob, "crypto");
+		return;
+	}
+
+	/* Add SEC ERA information in compatible */
+	era = caam_get_era();
+	if (era) {
+		fdt_fixup_crypto_era(blob, era);
+	} else {
+		printf("WARNING: Unable to get ERA for CAAM rev: %d\n",
+			sec_rev);
+	}
 }
 #endif
 
diff --git a/arch/powerpc/cpu/mpc8xxx/fsl_ifc.c b/arch/powerpc/cpu/mpc8xxx/fsl_ifc.c
index 56b319f..4e8a441 100644
--- a/arch/powerpc/cpu/mpc8xxx/fsl_ifc.c
+++ b/arch/powerpc/cpu/mpc8xxx/fsl_ifc.c
@@ -26,7 +26,7 @@ void print_ifc_regs(void)
 	int i, j;
 
 	printf("IFC Controller Registers\n");
-	for (i = 0; i < FSL_IFC_BANK_COUNT; i++) {
+	for (i = 0; i < CONFIG_SYS_FSL_IFC_BANK_COUNT; i++) {
 		printf("CSPR%d:0x%08X\tAMASK%d:0x%08X\tCSOR%d:0x%08X\n",
 			i, get_ifc_cspr(i), i, get_ifc_amask(i),
 			i, get_ifc_csor(i));
@@ -43,7 +43,7 @@ void init_early_memctl_regs(void)
 	set_ifc_ftim(IFC_CS0, IFC_FTIM2, CONFIG_SYS_CS0_FTIM2);
 	set_ifc_ftim(IFC_CS0, IFC_FTIM3, CONFIG_SYS_CS0_FTIM3);
 
-#if !defined(CONFIG_SYS_FSL_ERRATUM_IFC_A003399) || defined(CONFIG_SYS_RAMBOOT)
+#ifndef CONFIG_A003399_NOR_WORKAROUND
 #ifdef CONFIG_SYS_CSPR0_EXT
 	set_ifc_cspr_ext(IFC_CS0, CONFIG_SYS_CSPR0_EXT);
 #endif
@@ -94,4 +94,60 @@ void init_early_memctl_regs(void)
 	set_ifc_amask(IFC_CS3, CONFIG_SYS_AMASK3);
 	set_ifc_csor(IFC_CS3, CONFIG_SYS_CSOR3);
 #endif
+
+#ifdef CONFIG_SYS_CSPR4_EXT
+	set_ifc_cspr_ext(IFC_CS4, CONFIG_SYS_CSPR4_EXT);
+#endif
+#if defined(CONFIG_SYS_CSPR4) && defined(CONFIG_SYS_CSOR4)
+	set_ifc_ftim(IFC_CS4, IFC_FTIM0, CONFIG_SYS_CS4_FTIM0);
+	set_ifc_ftim(IFC_CS4, IFC_FTIM1, CONFIG_SYS_CS4_FTIM1);
+	set_ifc_ftim(IFC_CS4, IFC_FTIM2, CONFIG_SYS_CS4_FTIM2);
+	set_ifc_ftim(IFC_CS4, IFC_FTIM3, CONFIG_SYS_CS4_FTIM3);
+
+	set_ifc_cspr(IFC_CS4, CONFIG_SYS_CSPR4);
+	set_ifc_amask(IFC_CS4, CONFIG_SYS_AMASK4);
+	set_ifc_csor(IFC_CS4, CONFIG_SYS_CSOR4);
+#endif
+
+#ifdef CONFIG_SYS_CSPR5_EXT
+	set_ifc_cspr_ext(IFC_CS5, CONFIG_SYS_CSPR5_EXT);
+#endif
+#if defined(CONFIG_SYS_CSPR5) && defined(CONFIG_SYS_CSOR5)
+	set_ifc_ftim(IFC_CS5, IFC_FTIM0, CONFIG_SYS_CS5_FTIM0);
+	set_ifc_ftim(IFC_CS5, IFC_FTIM1, CONFIG_SYS_CS5_FTIM1);
+	set_ifc_ftim(IFC_CS5, IFC_FTIM2, CONFIG_SYS_CS5_FTIM2);
+	set_ifc_ftim(IFC_CS5, IFC_FTIM3, CONFIG_SYS_CS5_FTIM3);
+
+	set_ifc_cspr(IFC_CS5, CONFIG_SYS_CSPR5);
+	set_ifc_amask(IFC_CS5, CONFIG_SYS_AMASK5);
+	set_ifc_csor(IFC_CS5, CONFIG_SYS_CSOR5);
+#endif
+
+#ifdef CONFIG_SYS_CSPR6_EXT
+	set_ifc_cspr_ext(IFC_CS6, CONFIG_SYS_CSPR6_EXT);
+#endif
+#if defined(CONFIG_SYS_CSPR6) && defined(CONFIG_SYS_CSOR6)
+	set_ifc_ftim(IFC_CS6, IFC_FTIM0, CONFIG_SYS_CS6_FTIM0);
+	set_ifc_ftim(IFC_CS6, IFC_FTIM1, CONFIG_SYS_CS6_FTIM1);
+	set_ifc_ftim(IFC_CS6, IFC_FTIM2, CONFIG_SYS_CS6_FTIM2);
+	set_ifc_ftim(IFC_CS6, IFC_FTIM3, CONFIG_SYS_CS6_FTIM3);
+
+	set_ifc_cspr(IFC_CS6, CONFIG_SYS_CSPR6);
+	set_ifc_amask(IFC_CS6, CONFIG_SYS_AMASK6);
+	set_ifc_csor(IFC_CS6, CONFIG_SYS_CSOR6);
+#endif
+
+#ifdef CONFIG_SYS_CSPR7_EXT
+	set_ifc_cspr_ext(IFC_CS7, CONFIG_SYS_CSPR7_EXT);
+#endif
+#if defined(CONFIG_SYS_CSPR7) && defined(CONFIG_SYS_CSOR7)
+	set_ifc_ftim(IFC_CS7, IFC_FTIM0, CONFIG_SYS_CS7_FTIM0);
+	set_ifc_ftim(IFC_CS7, IFC_FTIM1, CONFIG_SYS_CS7_FTIM1);
+	set_ifc_ftim(IFC_CS7, IFC_FTIM2, CONFIG_SYS_CS7_FTIM2);
+	set_ifc_ftim(IFC_CS7, IFC_FTIM3, CONFIG_SYS_CS7_FTIM3);
+
+	set_ifc_cspr(IFC_CS7, CONFIG_SYS_CSPR7);
+	set_ifc_amask(IFC_CS7, CONFIG_SYS_AMASK7);
+	set_ifc_csor(IFC_CS7, CONFIG_SYS_CSOR7);
+#endif
 }
diff --git a/arch/powerpc/cpu/mpc8xxx/fsl_pamu.c b/arch/powerpc/cpu/mpc8xxx/fsl_pamu.c
new file mode 100644
index 0000000..a1887b6
--- /dev/null
+++ b/arch/powerpc/cpu/mpc8xxx/fsl_pamu.c
@@ -0,0 +1,459 @@
+/*
+ * FSL PAMU driver
+ *
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/fsl_pamu.h>
+
+paace_t *ppaact;
+paace_t *sec;
+unsigned long fspi;
+
+static inline int __ilog2_roundup_64(uint64_t val)
+{
+
+	if ((val & (val - 1)) == 0)
+		return __ilog2_u64(val);
+	else
+		return  __ilog2_u64(val) + 1;
+}
+
+
+static inline int count_lsb_zeroes(unsigned long val)
+{
+	return ffs(val) - 1;
+}
+
+static unsigned int map_addrspace_size_to_wse(uint64_t addrspace_size)
+{
+	/* window size is 2^(WSE+1) bytes */
+	return count_lsb_zeroes(addrspace_size >> PAMU_PAGE_SHIFT) +
+		PAMU_PAGE_SHIFT - 1;
+}
+
+static unsigned int map_subwindow_cnt_to_wce(uint32_t subwindow_cnt)
+{
+       /* window count is 2^(WCE+1) bytes */
+	return count_lsb_zeroes(subwindow_cnt) - 1;
+}
+
+static void pamu_setup_default_xfer_to_host_ppaace(paace_t *ppaace)
+{
+	set_bf(ppaace->addr_bitfields, PAACE_AF_PT, PAACE_PT_PRIMARY);
+	set_bf(ppaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,
+		PAACE_M_COHERENCE_REQ);
+}
+
+static void pamu_setup_default_xfer_to_host_spaace(paace_t *spaace)
+{
+	set_bf(spaace->addr_bitfields, PAACE_AF_PT, PAACE_PT_SECONDARY);
+	set_bf(spaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,
+	       PAACE_M_COHERENCE_REQ);
+}
+
+/** Sets up PPAACE entry for specified liodn
+ *
+ * @param[in] liodn      Logical IO device number
+ * @param[in] win_addr   starting address of DSA window
+ * @param[in] win-size   size of DSA window
+ * @param[in] omi        Operation mapping index -- if ~omi == 0 then omi
+				not defined
+ * @param[in] stashid    cache stash id for associated cpu -- if ~stashid == 0
+				then stashid not defined
+ * @param[in] snoopid    snoop id for hardware coherency -- if ~snoopid == 0
+				then snoopid not defined
+ * @param[in] subwin_cnt number of sub-windows
+ *
+ * @return Returns 0 upon success else error code < 0 returned
+ */
+static int pamu_config_ppaace(uint32_t liodn, uint64_t win_addr,
+	uint64_t win_size, uint32_t omi,
+	uint32_t snoopid, uint32_t stashid,
+	uint32_t subwin_cnt)
+{
+	paace_t *ppaace;
+
+	if ((win_size & (win_size - 1)) || win_size < PAMU_PAGE_SIZE)
+		return -1;
+
+	if (win_addr & (win_size - 1))
+		return -2;
+
+	if (liodn > NUM_PPAACT_ENTRIES) {
+		printf("Entries in PPACT not sufficient\n");
+		return -3;
+	}
+
+	ppaace = &ppaact[liodn];
+
+	/* window size is 2^(WSE+1) bytes */
+	set_bf(ppaace->addr_bitfields, PPAACE_AF_WSE,
+		map_addrspace_size_to_wse(win_size));
+
+	pamu_setup_default_xfer_to_host_ppaace(ppaace);
+
+	if (sizeof(phys_addr_t) > 4)
+		ppaace->wbah = (u64)win_addr >> (PAMU_PAGE_SHIFT + 20);
+	else
+		ppaace->wbah = 0;
+
+	set_bf(ppaace->addr_bitfields, PPAACE_AF_WBAL,
+	       (win_addr >> PAMU_PAGE_SHIFT));
+
+	/* set up operation mapping if it's configured */
+	if (omi < OME_NUMBER_ENTRIES) {
+		set_bf(ppaace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);
+		ppaace->op_encode.index_ot.omi = omi;
+	} else if (~omi != 0)
+		return -3;
+
+	/* configure stash id */
+	if (~stashid != 0)
+		set_bf(ppaace->impl_attr, PAACE_IA_CID, stashid);
+
+	/* configure snoop id */
+	if (~snoopid != 0)
+		ppaace->domain_attr.to_host.snpid = snoopid;
+
+	if (subwin_cnt) {
+		/* window count is 2^(WCE+1) bytes */
+		set_bf(ppaace->impl_attr, PAACE_IA_WCE,
+		       map_subwindow_cnt_to_wce(subwin_cnt));
+		set_bf(ppaace->addr_bitfields, PPAACE_AF_MW, 0x1);
+		ppaace->fspi = fspi;
+		fspi = fspi + DEFAULT_NUM_SUBWINDOWS - 1;
+	} else
+		set_bf(ppaace->addr_bitfields, PAACE_AF_AP, PAACE_AP_PERMS_ALL);
+
+	asm volatile("sync" : : : "memory");
+	/* Mark the ppace entry valid */
+	ppaace->addr_bitfields |= PAACE_V_VALID;
+	asm volatile("sync" : : : "memory");
+
+	return 0;
+}
+
+static int pamu_config_spaace(uint32_t liodn,
+	uint64_t subwin_size, uint64_t subwin_addr, uint64_t size,
+	uint32_t omi, uint32_t snoopid, uint32_t stashid)
+{
+	paace_t *paace;
+	/* Align start addr of subwin to subwindoe size */
+	uint64_t sec_addr = subwin_addr & ~(subwin_size - 1);
+	uint64_t end_addr = subwin_addr + size;
+	int size_shift = __ilog2_u64(subwin_size);
+	uint64_t win_size = 0;
+	uint32_t index, swse;
+	unsigned long fspi_idx;
+
+	/* Recalculate the size */
+	size = end_addr - sec_addr;
+
+	if (!subwin_size)
+		return -1;
+
+	if (liodn > NUM_PPAACT_ENTRIES) {
+		printf("LIODN No programmed %d > no. of PPAACT entries %d\n",
+						liodn, NUM_PPAACT_ENTRIES);
+		return -1;
+	}
+
+	while (sec_addr < end_addr) {
+#ifdef DEBUG
+		printf("sec_addr < end_addr is %llx < %llx\n", sec_addr,
+			end_addr);
+#endif
+		paace = &ppaact[liodn];
+		if (!paace)
+			return -1;
+		fspi_idx = paace->fspi;
+
+		/* Calculating the win_size here as if we map in index 0,
+			paace entry woudl need to  be programmed for SWSE */
+		win_size = end_addr - sec_addr;
+		win_size = 1 << __ilog2_roundup_64(win_size);
+
+		if (win_size > subwin_size)
+			win_size = subwin_size;
+		else if (win_size < PAMU_PAGE_SIZE)
+			win_size = PAMU_PAGE_SIZE;
+
+#ifdef DEBUG
+		printf("win_size is %x\n", win_size);
+#endif
+
+		swse = map_addrspace_size_to_wse(win_size);
+		index = sec_addr >> size_shift;
+
+		if (index == 0) {
+			set_bf(paace->win_bitfields, PAACE_WIN_SWSE, swse);
+			set_bf(paace->addr_bitfields, PAACE_AF_AP,
+				PAACE_AP_PERMS_ALL);
+			sec_addr += subwin_size;
+			continue;
+		}
+
+		paace = sec + fspi_idx + index - 1;
+
+#ifdef DEBUG
+		printf("SPAACT:Writing at location %p, index %d\n", paace,
+			index);
+#endif
+
+		pamu_setup_default_xfer_to_host_spaace(paace);
+		set_bf(paace->addr_bitfields, SPAACE_AF_LIODN, liodn);
+		set_bf(paace->addr_bitfields, PAACE_AF_AP, PAACE_AP_PERMS_ALL);
+
+		/* configure snoop id */
+		if (~snoopid != 0)
+			paace->domain_attr.to_host.snpid = snoopid;
+
+		if (paace->addr_bitfields & PAACE_V_VALID) {
+#ifdef DEBUG
+			printf("Reached overlap condition\n");
+			printf("%d < %d\n", get_bf(paace->win_bitfields,
+				PAACE_WIN_SWSE), swse);
+#endif
+			if (get_bf(paace->win_bitfields, PAACE_WIN_SWSE) < swse)
+				set_bf(paace->win_bitfields, PAACE_WIN_SWSE,
+					swse);
+		} else
+			set_bf(paace->win_bitfields, PAACE_WIN_SWSE, swse);
+
+		paace->addr_bitfields |= PAACE_V_VALID;
+		sec_addr += subwin_size;
+	}
+
+	return 0;
+}
+
+int pamu_init(void)
+{
+	u32 base_addr = CONFIG_SYS_PAMU_ADDR;
+	ccsr_pamu_t *regs;
+	u32 i = 0;
+	u64 ppaact_phys, ppaact_lim, ppaact_size;
+	u64 spaact_phys, spaact_lim, spaact_size;
+
+	ppaact_size = sizeof(paace_t) * NUM_PPAACT_ENTRIES;
+	spaact_size = sizeof(paace_t) * NUM_SPAACT_ENTRIES;
+
+	/* Allocate space for Primary PAACT Table */
+	ppaact = memalign(PAMU_TABLE_ALIGNMENT, ppaact_size);
+	if (!ppaact)
+		return -1;
+	memset(ppaact, 0, ppaact_size);
+
+	/* Allocate space for Secondary PAACT Table */
+	sec = memalign(PAMU_TABLE_ALIGNMENT, spaact_size);
+	if (!sec)
+		return -1;
+	memset(sec, 0, spaact_size);
+
+	ppaact_phys = virt_to_phys((void *)ppaact);
+	ppaact_lim = ppaact_phys + ppaact_size;
+
+	spaact_phys = (uint64_t)virt_to_phys((void *)sec);
+	spaact_lim = spaact_phys + spaact_size;
+
+	/* Configure all PAMU's */
+	for (i = 0; i < CONFIG_NUM_PAMU; i++) {
+		regs = (ccsr_pamu_t *)base_addr;
+
+		out_be32(&regs->ppbah, ppaact_phys >> 32);
+		out_be32(&regs->ppbal, (uint32_t)ppaact_phys);
+
+		out_be32(&regs->pplah, (ppaact_lim) >> 32);
+		out_be32(&regs->pplal, (uint32_t)ppaact_lim);
+
+		if (sec != NULL) {
+			out_be32(&regs->spbah, spaact_phys >> 32);
+			out_be32(&regs->spbal, (uint32_t)spaact_phys);
+			out_be32(&regs->splah, spaact_lim >> 32);
+			out_be32(&regs->splal, (uint32_t)spaact_lim);
+		}
+		asm volatile("sync" : : : "memory");
+
+		base_addr += PAMU_OFFSET;
+	}
+
+	return 0;
+}
+
+void pamu_enable(void)
+{
+	u32 i = 0;
+	u32 base_addr = CONFIG_SYS_PAMU_ADDR;
+	for (i = 0; i < CONFIG_NUM_PAMU; i++) {
+		setbits_be32((void *)base_addr + PAMU_PCR_OFFSET,
+			PAMU_PCR_PE);
+		asm volatile("sync" : : : "memory");
+		base_addr += PAMU_OFFSET;
+	}
+}
+
+void pamu_reset(void)
+{
+	u32 i  = 0;
+	u32 base_addr = CONFIG_SYS_PAMU_ADDR;
+	ccsr_pamu_t *regs;
+
+	for (i = 0; i < CONFIG_NUM_PAMU; i++) {
+		regs = (ccsr_pamu_t *)base_addr;
+	/* Clear PPAACT Base register */
+		out_be32(&regs->ppbah, 0);
+		out_be32(&regs->ppbal, 0);
+		out_be32(&regs->pplah, 0);
+		out_be32(&regs->pplal, 0);
+		out_be32(&regs->spbah, 0);
+		out_be32(&regs->spbal, 0);
+		out_be32(&regs->splah, 0);
+		out_be32(&regs->splal, 0);
+
+		clrbits_be32((void *)regs + PAMU_PCR_OFFSET, PAMU_PCR_PE);
+		asm volatile("sync" : : : "memory");
+		base_addr += PAMU_OFFSET;
+	}
+}
+
+void pamu_disable(void)
+{
+	u32 i  = 0;
+	u32 base_addr = CONFIG_SYS_PAMU_ADDR;
+
+
+	for (i = 0; i < CONFIG_NUM_PAMU; i++) {
+		clrbits_be32((void *)base_addr + PAMU_PCR_OFFSET, PAMU_PCR_PE);
+		asm volatile("sync" : : : "memory");
+		base_addr += PAMU_OFFSET;
+	}
+}
+
+
+static uint64_t find_max(uint64_t arr[], int num)
+{
+	int i = 0;
+	int max = 0;
+	for (i = 1 ; i < num; i++)
+		if (arr[max] < arr[i])
+			max = i;
+
+	return arr[max];
+}
+
+static uint64_t find_min(uint64_t arr[], int num)
+{
+	int i = 0;
+	int min = 0;
+	for (i = 1 ; i < num; i++)
+		if (arr[min] > arr[i])
+			min = i;
+
+	return arr[min];
+}
+
+static uint32_t get_win_cnt(uint64_t size)
+{
+	uint32_t win_cnt = DEFAULT_NUM_SUBWINDOWS;
+
+	while (win_cnt && (size/win_cnt) < PAMU_PAGE_SIZE)
+		win_cnt >>= 1;
+
+	return win_cnt;
+}
+
+int config_pamu(struct pamu_addr_tbl *tbl, int num_entries, uint32_t liodn)
+{
+	int i = 0;
+	int ret = 0;
+	uint32_t num_sec_windows = 0;
+	uint32_t num_windows = 0;
+	uint64_t min_addr, max_addr;
+	uint64_t size;
+	uint64_t subwin_size;
+	int sizebit;
+
+	min_addr = find_min(tbl->start_addr, num_entries);
+	max_addr = find_max(tbl->end_addr, num_entries);
+	size = max_addr - min_addr + 1;
+
+	if (!size)
+		return -1;
+
+	sizebit = __ilog2_roundup_64(size);
+	size = 1 << sizebit;
+#ifdef DEBUG
+	printf("min start_addr is %llx\n", min_addr);
+	printf("max end_addr is %llx\n", max_addr);
+	printf("size found is  %llx\n", size);
+#endif
+
+	if (size < PAMU_PAGE_SIZE)
+		size = PAMU_PAGE_SIZE;
+
+	while (1) {
+		min_addr = min_addr & ~(size - 1);
+		if (min_addr + size > max_addr)
+			break;
+		size <<= 1;
+		if (!size)
+			return -1;
+	}
+#ifdef DEBUG
+	printf("PAACT :Base addr is %llx\n", min_addr);
+	printf("PAACT : Size is %llx\n", size);
+#endif
+	num_windows = get_win_cnt(size);
+	/* For a single window, no spaact entries are required
+	 * sec_sub_window count = 0 */
+	if (num_windows > 1)
+		num_sec_windows = num_windows;
+	else
+		num_sec_windows = 0;
+
+	ret = pamu_config_ppaace(liodn, min_addr,
+			size , -1, -1, -1, num_sec_windows);
+
+	if (ret < 0)
+		return ret;
+
+#ifdef DEBUG
+	printf("configured ppace\n");
+#endif
+
+	if (num_sec_windows) {
+		subwin_size = size >> count_lsb_zeroes(num_sec_windows);
+#ifdef DEBUG
+		printf("subwin_size is %llx\n", subwin_size);
+#endif
+
+		for (i = 0; i < num_entries; i++) {
+			ret = pamu_config_spaace(liodn,
+				subwin_size, tbl->start_addr[i] - min_addr,
+				tbl->size[i], -1, -1, -1);
+
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return ret;
+}
diff --git a/arch/powerpc/cpu/mpc8xxx/pamu_table.c b/arch/powerpc/cpu/mpc8xxx/pamu_table.c
new file mode 100644
index 0000000..44cceee
--- /dev/null
+++ b/arch/powerpc/cpu/mpc8xxx/pamu_table.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_pamu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void construct_pamu_addr_table(struct pamu_addr_tbl *tbl, int *num_entries)
+{
+	int i  = 0;
+
+	tbl->start_addr[i] =
+			(uint64_t)virt_to_phys((void *)CONFIG_SYS_SDRAM_BASE);
+	tbl->size[i] = (phys_size_t)(min(gd->ram_size, CONFIG_MAX_MEM_MAPPED));
+	tbl->end_addr[i] = tbl->start_addr[i] +  tbl->size[i] - 1;
+
+	i++;
+	tbl->start_addr[i] =
+		(uint64_t)virt_to_phys((void *)CONFIG_SYS_FLASH_BASE_PHYS);
+	tbl->size[i] = 256 * 1024 * 1024; /* 256MB flash */
+	tbl->end_addr[i] = tbl->start_addr[i] +  tbl->size[i] - 1;
+
+	i++;
+#ifdef DEBUG
+	int j;
+	printf("address\t\t\tsize\n");
+	for (j = 0; j < i ; j++)
+		printf("%llx \t\t\t%llx\n",  tbl->start_addr[j],  tbl->size[j]);
+#endif
+
+	*num_entries = i;
+}
+
+int sec_config_pamu_table(uint32_t liodn_ns, uint32_t liodn_s)
+{
+	struct pamu_addr_tbl tbl;
+	int num_entries = 0;
+	int ret = 0;
+
+	construct_pamu_addr_table(&tbl, &num_entries);
+
+	ret = config_pamu(&tbl, num_entries, liodn_ns);
+	if (ret)
+		return ret;
+
+	ret = config_pamu(&tbl, num_entries, liodn_s);
+	if (ret)
+		return ret;
+
+	return ret;
+}
diff --git a/arch/powerpc/cpu/mpc8xxx/srio.c b/arch/powerpc/cpu/mpc8xxx/srio.c
index 6e6f7dc..90d1065 100644
--- a/arch/powerpc/cpu/mpc8xxx/srio.c
+++ b/arch/powerpc/cpu/mpc8xxx/srio.c
@@ -24,7 +24,7 @@
 #include <asm/fsl_srio.h>
 #include <asm/errno.h>
 
-#ifdef CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
+#ifdef CONFIG_SRIO_PCIE_BOOT_MASTER
 #define SRIO_PORT_ACCEPT_ALL 0x10000001
 #define SRIO_IB_ATMU_AR 0x80f55000
 #define SRIO_OB_ATMU_AR_MAINT 0x80077000
@@ -299,7 +299,7 @@ void srio_init(void)
 	}
 }
 
-#ifdef CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
+#ifdef CONFIG_SRIO_PCIE_BOOT_MASTER
 void srio_boot_master(int port)
 {
 	struct ccsr_rio *srio = (void *)CONFIG_SYS_FSL_SRIO_ADDR;
diff --git a/arch/powerpc/include/asm/config_mpc85xx.h b/arch/powerpc/include/asm/config_mpc85xx.h
index 0b9638b..fb627e2 100644
--- a/arch/powerpc/include/asm/config_mpc85xx.h
+++ b/arch/powerpc/include/asm/config_mpc85xx.h
@@ -81,6 +81,7 @@
 #define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
 #define CONFIG_SYS_FSL_RMU
 #define CONFIG_SYS_FSL_SRIO_MSG_UNIT_NUM	2
+#define CONFIG_SYS_FSL_ERRATUM_I2C_A004447
 
 #elif defined(CONFIG_MPC8555)
 #define CONFIG_MAX_CPUS			1
@@ -138,13 +139,18 @@
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	4
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
+#define CONFIG_SYS_FSL_ESDHC_P1010_BROKEN_SDCLK
 #define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT	4
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.2"
 #define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
 #define CONFIG_SYS_FSL_ERRATUM_IFC_A002769
 #define CONFIG_SYS_FSL_ERRATUM_P1010_A003549
 #define CONFIG_SYS_FSL_ERRATUM_IFC_A003399
+#define CONFIG_SYS_FSL_ERRATUM_I2C_A004447
+#define CONFIG_SYS_FSL_ISBC_VER		1
 
 /* P1011 is single core version of P1020 */
 #elif defined(CONFIG_P1011)
@@ -154,6 +160,7 @@
 #define CONFIG_TSECV2
 #define CONFIG_FSL_PCIE_DISABLE_ASPM
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_SYS_FSL_ERRATUM_ELBC_A001
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
@@ -162,6 +169,7 @@
 #elif defined(CONFIG_P1012)
 #define CONFIG_MAX_CPUS			1
 #define CONFIG_SYS_FSL_NUM_LAWS		12
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_PPC_E500_DEBUG_TLB	2
 #define CONFIG_TSECV2
 #define CONFIG_FSL_PCIE_DISABLE_ASPM
@@ -177,6 +185,7 @@
 #elif defined(CONFIG_P1013)
 #define CONFIG_MAX_CPUS			1
 #define CONFIG_SYS_FSL_NUM_LAWS		12
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_PPC_E500_DEBUG_TLB	2
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
@@ -193,7 +202,9 @@
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	4
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
+#define CONFIG_SYS_FSL_ESDHC_P1010_BROKEN_SDCLK
 #define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
 #define CONFIG_SYS_FSL_ERRATUM_IFC_A002769
@@ -208,6 +219,7 @@
 #define CONFIG_SYS_NUM_FMAN		1
 #define CONFIG_SYS_NUM_FM1_DTSEC	2
 #define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
 #define CONFIG_SYS_QMAN_NUM_PORTALS	3
 #define CONFIG_SYS_BMAN_NUM_PORTALS	3
 #define CONFIG_SYS_FM_MURAM_SIZE	0x10000
@@ -224,6 +236,7 @@
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_SYS_FSL_ERRATUM_ELBC_A001
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 
 #elif defined(CONFIG_P1021)
 #define CONFIG_MAX_CPUS			2
@@ -238,6 +251,7 @@
 #define QE_MURAM_SIZE			0x6000UL
 #define MAX_QE_RISC			1
 #define QE_NUM_OF_SNUM			28
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
 
 #elif defined(CONFIG_P1022)
 #define CONFIG_MAX_CPUS			2
@@ -245,6 +259,7 @@
 #define CONFIG_SYS_PPC_E500_DEBUG_TLB	2
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_SYS_FSL_ERRATUM_ELBC_A001
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
@@ -257,11 +272,13 @@
 #define CONFIG_SYS_NUM_FMAN		1
 #define CONFIG_SYS_NUM_FM1_DTSEC	2
 #define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
 #define CONFIG_SYS_QMAN_NUM_PORTALS	3
 #define CONFIG_SYS_BMAN_NUM_PORTALS	3
 #define CONFIG_SYS_FM_MURAM_SIZE	0x10000
 #define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.2"
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff600000
+#define CONFIG_SYS_FSL_ERRATUM_I2C_A004447
 
 /* P1024 is lower end variant of P1020 */
 #elif defined(CONFIG_P1024)
@@ -271,6 +288,7 @@
 #define CONFIG_TSECV2
 #define CONFIG_FSL_PCIE_DISABLE_ASPM
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_SYS_FSL_ERRATUM_ELBC_A001
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
@@ -279,6 +297,7 @@
 #elif defined(CONFIG_P1025)
 #define CONFIG_MAX_CPUS			2
 #define CONFIG_SYS_FSL_NUM_LAWS		12
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_PPC_E500_DEBUG_TLB	2
 #define CONFIG_TSECV2
 #define CONFIG_FSL_PCIE_DISABLE_ASPM
@@ -296,6 +315,7 @@
 #define CONFIG_SYS_FSL_NUM_LAWS		12
 #define CONFIG_SYS_PPC_E500_DEBUG_TLB	2
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC_A001
@@ -313,9 +333,11 @@
 #define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
 #define CONFIG_SYS_FSL_RMU
 #define CONFIG_SYS_FSL_SRIO_MSG_UNIT_NUM	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
 
 #elif defined(CONFIG_PPC_P2041) /* also supports P2040 */
 #define CONFIG_SYS_FSL_QORIQ_CHASSIS1
+#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_MAX_CPUS			4
 #define CONFIG_SYS_FSL_NUM_CC_PLLS	2
 #define CONFIG_SYS_FSL_NUM_LAWS		32
@@ -324,6 +346,7 @@
 #define CONFIG_SYS_NUM_FM1_DTSEC	5
 #define CONFIG_SYS_NUM_FM1_10GEC	1
 #define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_FM_MURAM_SIZE	0x28000
 #define CONFIG_SYS_FSL_TBCLK_DIV	32
 #define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.2"
@@ -333,21 +356,24 @@
 #define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
 #define CONFIG_SYS_FSL_ERRATUM_NMG_CPU_A011
+#define CONFIG_SYS_FSL_ERRATUM_USB138
 #define CONFIG_SYS_FSL_ERRATUM_CPU_A003999
+#define CONFIG_SYS_FSL_ERRATUM_DDR_A003
 #define CONFIG_SYS_FSL_ERRATUM_DDR_A003474
-#define CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
 #define CONFIG_SYS_FSL_SRIO_MAX_PORTS	2
 #define CONFIG_SYS_FSL_SRIO_OB_WIN_NUM	9
 #define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
 #define CONFIG_SYS_FSL_ERRATUM_A004510
-#define CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV	0x10
+#define CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV	0x10
 #define CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV2	0x11
 #define CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY 0xf0000000
 #define CONFIG_SYS_FSL_ERRATUM_SRIO_A004034
 #define CONFIG_SYS_FSL_ERRATUM_A004849
+#define CONFIG_SYS_FSL_ISBC_VER		1
 
 #elif defined(CONFIG_PPC_P3041)
 #define CONFIG_SYS_FSL_QORIQ_CHASSIS1
+#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_MAX_CPUS			4
 #define CONFIG_SYS_FSL_NUM_CC_PLLS	2
 #define CONFIG_SYS_FSL_NUM_LAWS		32
@@ -355,7 +381,9 @@
 #define CONFIG_SYS_NUM_FMAN		1
 #define CONFIG_SYS_NUM_FM1_DTSEC	5
 #define CONFIG_SYS_NUM_FM1_10GEC	1
+#define CONFIG_SYS_FSL_ELBC_MULTIBIT_ECC
 #define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_FM_MURAM_SIZE	0x28000
 #define CONFIG_SYS_FSL_TBCLK_DIV	32
 #define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.2"
@@ -365,24 +393,31 @@
 #define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
 #define CONFIG_SYS_FSL_ERRATUM_NMG_CPU_A011
+#define CONFIG_SYS_FSL_ERRATUM_USB138
+#define CONFIG_SYS_FSL_ERRATUM_NMG_CPU_A011
 #define CONFIG_SYS_FSL_ERRATUM_CPU_A003999
+#define CONFIG_SYS_FSL_ERRATUM_DDR_A003
 #define CONFIG_SYS_FSL_ERRATUM_DDR_A003474
-#define CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
 #define CONFIG_SYS_FSL_SRIO_MAX_PORTS	2
 #define CONFIG_SYS_FSL_SRIO_OB_WIN_NUM	9
 #define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
 #define CONFIG_SYS_FSL_ERRATUM_A004510
-#define CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV	0x10
+#define CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV	0x10
 #define CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV2	0x11
 #define CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY 0xf0000000
 #define CONFIG_SYS_FSL_ERRATUM_SRIO_A004034
 #define CONFIG_SYS_FSL_ERRATUM_A004849
+#define CONFIG_SYS_FSL_ERRATUM_I2C_A004447
+#define CONFIG_SYS_FSL_ERRATUM_A005812
+#define CONFIG_SYS_FSL_ISBC_VER		1
 
 #elif defined(CONFIG_PPC_P4080) /* also supports P4040 */
 #define CONFIG_SYS_FSL_QORIQ_CHASSIS1
+#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_MAX_CPUS			8
 #define CONFIG_SYS_FSL_NUM_CC_PLLS	4
 #define CONFIG_SYS_FSL_NUM_LAWS		32
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_FSL_SEC_COMPAT	4
 #define CONFIG_SYS_NUM_FMAN		2
 #define CONFIG_SYS_NUM_FM1_DTSEC	4
@@ -409,23 +444,26 @@
 #define CONFIG_SYS_P4080_ERRATUM_SERDES_A005
 #define CONFIG_SYS_FSL_ERRATUM_CPU_A003999
 #define CONFIG_SYS_FSL_ERRATUM_DDR_A003474
-#define CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
 #define CONFIG_SYS_FSL_SRIO_MAX_PORTS	2
 #define CONFIG_SYS_FSL_SRIO_OB_WIN_NUM	9
 #define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
 #define CONFIG_SYS_FSL_RMU
 #define CONFIG_SYS_FSL_SRIO_MSG_UNIT_NUM	2
 #define CONFIG_SYS_FSL_ERRATUM_A004510
-#define CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV	0x20
+#define CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV	0x20
 #define CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY 0xff000000
 #define CONFIG_SYS_FSL_ERRATUM_SRIO_A004034
 #define CONFIG_SYS_FSL_ERRATUM_A004849
 #define CONFIG_SYS_FSL_ERRATUM_A004580
 #define CONFIG_SYS_P4080_ERRATUM_PCIE_A003
+#define CONFIG_SYS_FSL_ERRATUM_I2C_A004447
+#define CONFIG_SYS_FSL_ERRATUM_A005812
+#define CONFIG_SYS_FSL_ISBC_VER		1
 
 #elif defined(CONFIG_PPC_P5020) /* also supports P5010 */
 #define CONFIG_SYS_PPC64		/* 64-bit core */
 #define CONFIG_SYS_FSL_QORIQ_CHASSIS1
+#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_MAX_CPUS			2
 #define CONFIG_SYS_FSL_NUM_CC_PLLS	2
 #define CONFIG_SYS_FSL_NUM_LAWS		32
@@ -434,6 +472,7 @@
 #define CONFIG_SYS_NUM_FM1_DTSEC	5
 #define CONFIG_SYS_NUM_FM1_10GEC	1
 #define CONFIG_NUM_DDR_CONTROLLERS	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_FM_MURAM_SIZE	0x28000
 #define CONFIG_SYS_FSL_TBCLK_DIV	32
 #define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.2"
@@ -442,19 +481,24 @@
 #define CONFIG_SYS_FSL_USB2_PHY_ENABLE
 #define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
+#define CONFIG_SYS_FSL_ERRATUM_USB138
+#define CONFIG_SYS_FSL_ERRATUM_DDR_A003
 #define CONFIG_SYS_FSL_ERRATUM_DDR_A003474
-#define CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
 #define CONFIG_SYS_FSL_SRIO_MAX_PORTS	2
 #define CONFIG_SYS_FSL_SRIO_OB_WIN_NUM	9
 #define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
 #define CONFIG_SYS_FSL_ERRATUM_A004510
-#define CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV	0x10
+#define CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV	0x10
 #define CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY 0xc0000000
 #define CONFIG_SYS_FSL_ERRATUM_SRIO_A004034
+#define CONFIG_SYS_FSL_ELBC_MULTIBIT_ECC
+#define CONFIG_SYS_FSL_ERRATUM_I2C_A004447
+#define CONFIG_SYS_FSL_ISBC_VER		1
 
 #elif defined(CONFIG_PPC_P5040)
 #define CONFIG_SYS_PPC64
 #define CONFIG_SYS_FSL_QORIQ_CHASSIS1
+#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_MAX_CPUS			4
 #define CONFIG_SYS_FSL_NUM_CC_PLLS	3
 #define CONFIG_SYS_FSL_NUM_LAWS		32
@@ -465,6 +509,7 @@
 #define CONFIG_SYS_NUM_FM2_DTSEC	5
 #define CONFIG_SYS_NUM_FM2_10GEC	1
 #define CONFIG_NUM_DDR_CONTROLLERS	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_SYS_FM_MURAM_SIZE	0x28000
 #define CONFIG_SYS_FSL_TBCLK_DIV	16
 #define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.4"
@@ -476,10 +521,11 @@
 #define CONFIG_SYS_FSL_ERRATUM_USB138
 #define CONFIG_SYS_FSL_ERRATUM_DDR_A003
 #define CONFIG_SYS_FSL_ERRATUM_DDR_A003474
-#define CONFIG_SYS_FSL_ERRATUM_A004699
 #define CONFIG_SYS_FSL_ERRATUM_A004510
-#define CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV	0x10
+#define CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV	0x10
 #define CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY 0xf0000000
+#define CONFIG_SYS_FSL_ERRATUM_A005812
+#define CONFIG_SYS_FSL_ISBC_VER		1
 
 #elif defined(CONFIG_BSC9131)
 #define CONFIG_MAX_CPUS			1
@@ -488,29 +534,72 @@
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	4
 #define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT	3
+#define CONFIG_SYS_FSL_DSP_M2_RAM_ADDR	0xb0000000
+#define CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT	0xff600000
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_NAND_FSL_IFC
-#define CONFIG_SYS_FSL_ERRATUM_IFC_A003399
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
+#define CONFIG_SYS_FSL_ERRATUM_I2C_A004447
+#define CONFIG_SYS_FSL_ISBC_VER		1
+
+#elif defined(CONFIG_BSC9132)
+#define CONFIG_MAX_CPUS			2
+#define CONFIG_SYS_PPC_E500_DEBUG_TLB	3
+#define CONFIG_FSL_SDHC_V2_3
+#define CONFIG_SYS_FSL_NUM_LAWS		12
+#define CONFIG_TSECV2
+#define CONFIG_SYS_FSL_SEC_COMPAT	4
+#define CONFIG_NUM_DDR_CONTROLLERS	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT	3
+#define CONFIG_SYS_FSL_DSP_DDR_ADDR	0x40000000
+#define CONFIG_SYS_FSL_DSP_M2_RAM_ADDR	0xb0000000
+#define CONFIG_SYS_FSL_DSP_M3_RAM_ADDR	0xc0000000
+#define CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT	0xff600000
+#define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_FSL_ERRATUM_ESDHC111
+#define CONFIG_SYS_FSL_ESDHC_P1010_BROKEN_SDCLK
+#define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.2"
+#define CONFIG_SYS_FSL_ISBC_VER		1
 
-#elif defined(CONFIG_PPC_T4240)
+#elif defined(CONFIG_PPC_T4240) || defined(CONFIG_PPC_T4160)
+#define CONFIG_E6500
 #define CONFIG_SYS_PPC64		/* 64-bit core */
 #define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_SYS_FSL_QORIQ_CHASSIS2	/* Freescale Chassis generation 2 */
+#define CONFIG_SYS_FSL_CORES_PER_CLUSTER 4
 #define CONFIG_SYS_FSL_QMAN_V3		/* QMAN version 3 */
+#ifdef CONFIG_PPC_T4240
 #define CONFIG_MAX_CPUS			12
+#define CONFIG_SYS_NUM_FM1_DTSEC	8
+#define CONFIG_SYS_NUM_FM1_10GEC	2
+#define CONFIG_SYS_NUM_FM2_DTSEC	8
+#define CONFIG_SYS_NUM_FM2_10GEC	2
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
+#ifdef CONFIG_SYS_FSL_EMU_AP1
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#else
+#define CONFIG_NUM_DDR_CONTROLLERS	3
+#endif
+#else
+#define CONFIG_MAX_CPUS			8
+#define CONFIG_SYS_NUM_FM1_DTSEC	7
+#define CONFIG_SYS_NUM_FM1_10GEC	1
+#define CONFIG_SYS_NUM_FM2_DTSEC	7
+#define CONFIG_SYS_NUM_FM2_10GEC	1
+#define CONFIG_NUM_DDR_CONTROLLERS	2
+#endif
 #define CONFIG_SYS_FSL_NUM_CC_PLLS	5
 #define CONFIG_SYS_FSL_NUM_LAWS		32
 #define CONFIG_SYS_FSL_SRDS_3
 #define CONFIG_SYS_FSL_SRDS_4
 #define CONFIG_SYS_FSL_SEC_COMPAT	4
 #define CONFIG_SYS_NUM_FMAN		2
-#define CONFIG_SYS_NUM_FM1_DTSEC	8
-#define CONFIG_SYS_NUM_FM1_10GEC	2
-#define CONFIG_SYS_NUM_FM2_DTSEC	8
-#define CONFIG_SYS_NUM_FM2_10GEC	2
-#define CONFIG_NUM_DDR_CONTROLLERS	3
 #define CONFIG_SYS_FSL_DDR_VER		FSL_DDR_VER_4_7
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT	8
 #define CONFIG_SYS_FMAN_V3
 #define CONFIG_SYS_FM_MURAM_SIZE	0x60000
 #define CONFIG_SYS_FSL_TBCLK_DIV	16
@@ -518,37 +607,139 @@
 #define CONFIG_SYS_FSL_SRIO_MAX_PORTS	2
 #define CONFIG_SYS_FSL_SRIO_OB_WIN_NUM	9
 #define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
-#define CONFIG_SYS_FSL_USB1_PHY_ENABLE
-#define CONFIG_SYS_FSL_USB2_PHY_ENABLE
+#define CONFIG_SYS_FSL_SRIO_LIODN
+#define CONFIG_SYS_FSL_USB_DUAL_PHY_ENABLE
 #define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
 #define CONFIG_SYS_FSL_ERRATUM_A004468
+#define CONFIG_SYS_FSL_ERRATUM_A004511
+#define CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV	0x10
 #define CONFIG_SYS_FSL_ERRATUM_A_004934
+#define CONFIG_SYS_FSL_ERRATUM_A004779
+#define CONFIG_SYS_FSL_ERRATUM_A004786
+#define CONFIG_SYS_FSL_ERRATUM_A004792
+#define CONFIG_SYS_FSL_ERRATUM_A004806
+#define CONFIG_SYS_FSL_ERRATUM_A004809
+#define CONFIG_SYS_FSL_ERRATUM_A004857
+#define CONFIG_SYS_FSL_ERRATUM_A005475
+#define CONFIG_SYS_FSL_ERRATUM_A005553
+#define CONFIG_SYS_FSL_ERRATUM_A005977
+#define CONFIG_SYS_FSL_ERRATUM_A004390
+#define CONFIG_SYS_FSL_ERRATUM_A005871
+#define CONFIG_SYS_FSL_ERRATUM_A006208
+#define CONFIG_SYS_FSL_ERRATUM_A006593
+#define CONFIG_SYS_FSL_ERRATUM_A006918
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xfe000000
+#define CONFIG_SYS_FSL_PCI_VER_3_X
+#define CONFIG_SYS_FSL_SFP_VER_3_0
+#define CONFIG_SYS_FSL_ISBC_VER		2
 
-#elif defined(CONFIG_PPC_B4860)
+#elif defined(CONFIG_PPC_B4860) || defined(CONFIG_PPC_B4420)
+#define CONFIG_E6500
 #define CONFIG_SYS_PPC64		/* 64-bit core */
 #define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_SYS_FSL_QORIQ_CHASSIS2	/* Freescale Chassis generation 2 */
 #define CONFIG_SYS_FSL_QMAN_V3		/* QMAN version 3 */
-#define CONFIG_MAX_CPUS			4
-#define CONFIG_SYS_FSL_NUM_CC_PLLS	4
 #define CONFIG_SYS_FSL_NUM_LAWS		32
 #define CONFIG_SYS_FSL_SEC_COMPAT	4
 #define CONFIG_SYS_NUM_FMAN		1
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	1
+#define CONFIG_SYS_FSL_DDR_VER		FSL_DDR_VER_4_7
+#define CONFIG_SYS_FMAN_V3
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT	4
+#define CONFIG_SYS_FM_MURAM_SIZE	0x60000
+#define CONFIG_SYS_FSL_TBCLK_DIV	16
+#define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.4"
+#define CONFIG_SYS_FSL_USB1_PHY_ENABLE
+#define CONFIG_SYS_FSL_ERRATUM_A004511
+#define CONFIG_SYS_FSL_ERRATUM_A00451x_SVR_REV	0x10
+#define CONFIG_SYS_FSL_ERRATUM_A_004934
+#define CONFIG_SYS_FSL_ERRATUM_A004779
+#define CONFIG_SYS_FSL_ERRATUM_A004786
+#define CONFIG_SYS_FSL_ERRATUM_A004792
+#define CONFIG_SYS_FSL_ERRATUM_A004390
+#define CONFIG_SYS_FSL_ERRATUM_A004806
+#define CONFIG_SYS_FSL_ERRATUM_A004809
+#define CONFIG_SYS_FSL_ERRATUM_A004857
+#define CONFIG_SYS_FSL_ERRATUM_A005553
+#define CONFIG_SYS_FSL_ERRATUM_A005871
+#define CONFIG_SYS_FSL_ERRATUM_A006593
+#define CONFIG_SYS_FSL_ERRATUM_A005936
+#define CONFIG_SYS_CCSRBAR_DEFAULT	0xfe000000
+#define CONFIG_SYS_FSL_SFP_VER_3_0
+#define CONFIG_SYS_FSL_ISBC_VER		2
+
+#ifdef CONFIG_PPC_B4860
+#define CONFIG_SYS_FSL_CORES_PER_CLUSTER 4
+#define CONFIG_MAX_CPUS			4
+#define CONFIG_SYS_FSL_SRDS_NUM_PLLS	2
+#define CONFIG_SYS_FSL_NUM_CC_PLLS	4
 #define CONFIG_SYS_NUM_FM1_DTSEC	6
 #define CONFIG_SYS_NUM_FM1_10GEC	2
+#define CONFIG_NUM_DDR_CONTROLLERS	2
+#define CONFIG_SYS_FSL_SRIO_MAX_PORTS	2
+#define CONFIG_SYS_FSL_SRIO_OB_WIN_NUM	9
+#define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
+#define CONFIG_SYS_FSL_SRIO_LIODN
+#else
+#define CONFIG_MAX_CPUS			2
+#define CONFIG_SYS_FSL_SRDS_NUM_PLLS	1
+#define CONFIG_SYS_FSL_CORES_PER_CLUSTER 2
+#define CONFIG_SYS_FSL_NUM_CC_PLLS	4
+#define CONFIG_SYS_NUM_FM1_DTSEC	4
+#define CONFIG_SYS_NUM_FM1_10GEC	0
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#endif
+
+#elif defined(CONFIG_PPC_T1040)
+#define CONFIG_E5500
+#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
+#define CONFIG_SYS_FSL_QORIQ_CHASSIS2	/* Freescale Chassis generation 2 */
+#define CONFIG_SYS_FSL_CORES_PER_CLUSTER 1
+#define CONFIG_SYS_FSL_QMAN_V3		/* QMAN version 3 */
+#define CONFIG_MAX_CPUS			4
+#define CONFIG_SYS_FSL_NUM_CC_PLLS	5
+#define CONFIG_SYS_FSL_NUM_LAWS		16
+#define CONFIG_SYS_FSL_SEC_COMPAT	4
+#define CONFIG_SYS_NUM_FMAN		1
+#define CONFIG_SYS_NUM_FM1_DTSEC	5
+#define CONFIG_SYS_FSL_NUM_USB_CTRLS	2
 #define CONFIG_NUM_DDR_CONTROLLERS	1
 #define CONFIG_SYS_FSL_DDR_VER		FSL_DDR_VER_4_7
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT	4
 #define CONFIG_SYS_FMAN_V3
-#define CONFIG_SYS_FM_MURAM_SIZE	0x60000
-#define CONFIG_SYS_FSL_TBCLK_DIV	16
+#define CONFIG_SYS_FM_MURAM_SIZE	0x28000
+#define CONFIG_SYS_FSL_TBCLK_DIV	32
 #define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.4"
 #define CONFIG_SYS_FSL_SRIO_MAX_PORTS	2
 #define CONFIG_SYS_FSL_SRIO_OB_WIN_NUM	9
 #define CONFIG_SYS_FSL_SRIO_IB_WIN_NUM	5
 #define CONFIG_SYS_FSL_USB1_PHY_ENABLE
-#define CONFIG_SYS_FSL_ERRATUM_A_004934
+#define CONFIG_SYS_FSL_USB2_PHY_ENABLE
+#define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xfe000000
+#define CONFIG_SYS_FSL_SFP_VER_3_0
+#define CONFIG_SYS_FSL_ISBC_VER		2
+
+#elif defined(CONFIG_C29X)
+#define CONFIG_MAX_CPUS			1
+#define CONFIG_FSL_SDHC_V2_3
+#define CONFIG_SYS_FSL_NUM_LAWS		12
+#define CONFIG_SYS_PPC_E500_DEBUG_TLB	3
+#define CONFIG_TSECV2_1
+#define CONFIG_SYS_FSL_SEC_COMPAT	6
+#define CONFIG_SYS_FSL_ERRATUM_ESDHC111
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT	8
+#define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
+
+#if defined(CONFIG_C293)
+#define CONFIG_SYS_FSL_SEC_NUM		3
+#elif defined(CONFIG_C292)
+#define CONFIG_SYS_FSL_SEC_NUM		2
+#elif defined(CONFIG_C291)
+#define CONFIG_SYS_FSL_SEC_NUM		1
+#endif
 
 #else
 #error Processor type not defined for this platform
@@ -558,4 +749,10 @@
 #error "CONFIG_SYS_CCSRBAR_DEFAULT is not defined for this platform."
 #endif
 
+#ifdef CONFIG_E6500
+#define CONFIG_SYS_FSL_THREADS_PER_CORE 2
+#else
+#define CONFIG_SYS_FSL_THREADS_PER_CORE 1
+#endif
+
 #endif /* _ASM_MPC85xx_CONFIG_H_ */
diff --git a/arch/powerpc/include/asm/fsl_ddr_dimm_params.h b/arch/powerpc/include/asm/fsl_ddr_dimm_params.h
index ffe4db8..bd312ad 100644
--- a/arch/powerpc/include/asm/fsl_ddr_dimm_params.h
+++ b/arch/powerpc/include/asm/fsl_ddr_dimm_params.h
@@ -26,6 +26,7 @@ typedef struct dimm_params_s {
 	unsigned int primary_sdram_width;
 	unsigned int ec_sdram_width;
 	unsigned int registered_dimm;
+	unsigned int device_width;	/* x4, x8, x16 components */
 
 	/* SDRAM device parameters */
 	unsigned int n_row_addr;
diff --git a/arch/powerpc/include/asm/fsl_ddr_sdram.h b/arch/powerpc/include/asm/fsl_ddr_sdram.h
index bb5a670..e43720f 100644
--- a/arch/powerpc/include/asm/fsl_ddr_sdram.h
+++ b/arch/powerpc/include/asm/fsl_ddr_sdram.h
@@ -277,6 +277,7 @@ typedef struct memctl_options_s {
 	unsigned int mirrored_dimm;
 	unsigned int quad_rank_present;
 	unsigned int ap_en;	/* address parity enable for RDIMM */
+	unsigned int x4_en;	/* enable x4 devices */
 
 	/* Global Timing Parameters */
 	unsigned int cas_latency_override;
@@ -294,12 +295,12 @@ typedef struct memctl_options_s {
 	unsigned int wrlvl_start;
 	unsigned int wrlvl_ctl_2;
 	unsigned int wrlvl_ctl_3;
-	unsigned int wrlvl_odten_override;
-	unsigned int wrlvl_odten;
+    unsigned int wrlvl_odten_override;
+    unsigned int wrlvl_odten;
 
-	unsigned int act_pd_exit_mclk_override;
-	unsigned int dic_override;
-	unsigned int dic;
+    unsigned int act_pd_exit_mclk_override;
+    unsigned int dic_override;
+    unsigned int dic;
 
 	unsigned int half_strength_driver_enable;
 	unsigned int twoT_en;
@@ -336,9 +337,31 @@ extern phys_size_t fsl_ddr_sdram(void);
 extern phys_size_t fsl_ddr_sdram_size(void);
 extern int fsl_use_spd(void);
 extern void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
-					unsigned int ctrl_num);
+					unsigned int ctrl_num, int step);
 u32 fsl_ddr_get_intl3r(void);
 
+static void __board_assert_mem_reset(void)
+{
+}
+
+static void __board_deassert_mem_reset(void)
+{
+}
+
+void board_assert_mem_reset(void)
+	__attribute__((weak, alias("__board_assert_mem_reset")));
+
+void board_deassert_mem_reset(void)
+	__attribute__((weak, alias("__board_deassert_mem_reset")));
+
+static int __board_need_mem_reset(void)
+{
+	return 0;
+}
+
+int board_need_mem_reset(void)
+	__attribute__((weak, alias("__board_need_mem_reset")));
+
 /*
  * The 85xx boards have a common prototype for fixed_sdram so put the
  * declaration here.
diff --git a/arch/powerpc/include/asm/fsl_i2c.h b/arch/powerpc/include/asm/fsl_i2c.h
index 4f71341..0b54223 100644
--- a/arch/powerpc/include/asm/fsl_i2c.h
+++ b/arch/powerpc/include/asm/fsl_i2c.h
@@ -54,6 +54,7 @@ typedef struct fsl_i2c {
 #define I2C_CR_MTX	0x10
 #define I2C_CR_TXAK	0x08
 #define I2C_CR_RSTA	0x04
+#define I2C_CR_BIT6	0x02	/* required for workaround A00447 */
 #define I2C_CR_BCST	0x01
 
 	u8 sr;		/* I2C status register */
diff --git a/arch/powerpc/include/asm/fsl_ifc.h b/arch/powerpc/include/asm/fsl_ifc.h
index ba41b73..debcb6b 100644
--- a/arch/powerpc/include/asm/fsl_ifc.h
+++ b/arch/powerpc/include/asm/fsl_ifc.h
@@ -21,6 +21,7 @@
 #ifndef __ASM_PPC_FSL_IFC_H
 #define __ASM_PPC_FSL_IFC_H
 
+#ifdef CONFIG_FSL_IFC
 #include <config.h>
 #include <common.h>
 
@@ -798,13 +799,15 @@ extern void init_early_memctl_regs(void);
 #define set_ifc_ftim(i, j, v) \
 			(out_be32(&(IFC_BASE_ADDR)->ftim_cs[i].ftim[j], v))
 
-#define FSL_IFC_BANK_COUNT	4
-
 enum ifc_chip_sel {
 	IFC_CS0,
 	IFC_CS1,
 	IFC_CS2,
 	IFC_CS3,
+	IFC_CS4,
+	IFC_CS5,
+	IFC_CS6,
+	IFC_CS7,
 };
 
 enum ifc_ftims {
@@ -907,6 +910,22 @@ struct fsl_ifc_gpcm {
 	u32 res4[0x1F3];
 };
 
+#ifdef CONFIG_SYS_FSL_IFC_BANK_COUNT
+#if (CONFIG_SYS_FSL_IFC_BANK_COUNT <= 8)
+#define CONFIG_SYS_FSL_IFC_CSPR_RES \
+	(0x25 - CONFIG_SYS_FSL_IFC_BANK_COUNT *	3)
+#define CONFIG_SYS_FSL_IFC_AMASK_RES \
+	(0x24 - CONFIG_SYS_FSL_IFC_BANK_COUNT *	3)
+#define CONFIG_SYS_FSL_IFC_CSOR_RES \
+	(0x24 - CONFIG_SYS_FSL_IFC_BANK_COUNT *	3)
+#define CONFIG_SYS_FSL_IFC_FTIM_RES \
+	(0x90 - CONFIG_SYS_FSL_IFC_BANK_COUNT *	0xc)
+#else
+#error IFC BANK count not vaild
+#endif
+#else
+#error IFC BANK count not defined
+#endif
 
 /*
  * IFC Controller Registers
@@ -918,24 +937,24 @@ struct fsl_ifc {
 		u32 cspr_ext;
 		u32 cspr;
 		u32 res2;
-	} cspr_cs[FSL_IFC_BANK_COUNT];
-	u32 res3[0x19];
+	} cspr_cs[CONFIG_SYS_FSL_IFC_BANK_COUNT];
+	u32 res3[CONFIG_SYS_FSL_IFC_CSPR_RES];
 	struct {
 		u32 amask;
 		u32 res4[0x2];
-	} amask_cs[FSL_IFC_BANK_COUNT];
-	u32 res5[0x17];
+	} amask_cs[CONFIG_SYS_FSL_IFC_BANK_COUNT];
+	u32 res5[CONFIG_SYS_FSL_IFC_AMASK_RES];
 	struct {
-		u32 csor_ext;
 		u32 csor;
+		u32 csor_ext;
 		u32 res6;
-	} csor_cs[FSL_IFC_BANK_COUNT];
-	u32 res7[0x19];
+	} csor_cs[CONFIG_SYS_FSL_IFC_BANK_COUNT];
+	u32 res7[CONFIG_SYS_FSL_IFC_CSOR_RES];
 	struct {
 		u32 ftim[4];
 		u32 res8[0x8];
-	} ftim_cs[FSL_IFC_BANK_COUNT];
-	u32 res9[0x60];
+	} ftim_cs[CONFIG_SYS_FSL_IFC_BANK_COUNT];
+	u32 res9[CONFIG_SYS_FSL_IFC_FTIM_RES];
 	u32 rb_stat;
 	u32 res10[0x2];
 	u32 ifc_gcr;
@@ -961,6 +980,7 @@ struct fsl_ifc {
 #undef CSPR_MSEL_NOR
 #define CSPR_MSEL_NOR	CSPR_MSEL_GPCM
 #endif
+#endif /* CONFIG_FSL_IFC */
 
 #endif /* __ASSEMBLY__ */
 #endif /* __ASM_PPC_FSL_IFC_H */
diff --git a/arch/powerpc/include/asm/fsl_law.h b/arch/powerpc/include/asm/fsl_law.h
index f9cec8e..41e8291 100644
--- a/arch/powerpc/include/asm/fsl_law.h
+++ b/arch/powerpc/include/asm/fsl_law.h
@@ -70,6 +70,8 @@ enum law_trgt_if {
 	LAW_TRGT_IF_DCSR = 0x1d,
 	LAW_TRGT_IF_LBC = 0x1f,
 	LAW_TRGT_IF_QMAN = 0x3c,
+
+	LAW_TRGT_IF_MAPLE = 0x50,
 };
 #define LAW_TRGT_IF_DDR		LAW_TRGT_IF_DDR_1
 #define LAW_TRGT_IF_IFC		LAW_TRGT_IF_LBC
@@ -80,14 +82,22 @@ enum law_trgt_if {
 #ifndef CONFIG_MPC8641
 	LAW_TRGT_IF_PCIE_1 = 0x02,
 #endif
-#if !defined(CONFIG_MPC8572) && !defined(CONFIG_P2020)
+#if defined(CONFIG_BSC9131) || defined(CONFIG_BSC9132)
+	LAW_TRGT_IF_OCN_DSP = 0x03,
+#elif !defined(CONFIG_MPC8572) && !defined(CONFIG_P2020)
 	LAW_TRGT_IF_PCIE_3 = 0x03,
 #endif
 	LAW_TRGT_IF_LBC = 0x04,
 	LAW_TRGT_IF_CCSR = 0x08,
+	LAW_TRGT_IF_DSP_CCSR = 0x09,
+	LAW_TRGT_IF_PLATFORM_SRAM = 0x0a,
 	LAW_TRGT_IF_DDR_INTRLV = 0x0b,
 	LAW_TRGT_IF_RIO = 0x0c,
+#if defined(CONFIG_BSC9132)
+	LAW_TRGT_IF_CLASS_DSP = 0x0d,
+#else
 	LAW_TRGT_IF_RIO_2 = 0x0d,
+#endif
 	LAW_TRGT_IF_DPAA_SWP_SRAM = 0x0e,
 	LAW_TRGT_IF_DDR = 0x0f,
 	LAW_TRGT_IF_DDR_2 = 0x16,	/* 2nd controller */
diff --git a/arch/powerpc/include/asm/fsl_liodn.h b/arch/powerpc/include/asm/fsl_liodn.h
index d759de9..43ecd40 100644
--- a/arch/powerpc/include/asm/fsl_liodn.h
+++ b/arch/powerpc/include/asm/fsl_liodn.h
@@ -45,6 +45,13 @@ struct srio_liodn_id_table {
 		+ CONFIG_SYS_MPC85xx_GUTS_OFFSET + CONFIG_SYS_CCSRBAR, \
 	}
 
+#define SET_SRIO_LIODN_BASE(port, idA) \
+	{ .id = { idA }, .num_ids = 1, .portid = port, \
+	  .reg_offset[0] = offsetof(struct ccsr_rio, liodn) \
+		+ (port - 1) * 0x200 \
+		+ CONFIG_SYS_FSL_SRIO_ADDR, \
+	}
+
 struct liodn_id_table {
 	const char * compat;
 	u32 id[2];
diff --git a/arch/powerpc/include/asm/fsl_memac.h b/arch/powerpc/include/asm/fsl_memac.h
index d6b60e6..531d253 100644
--- a/arch/powerpc/include/asm/fsl_memac.h
+++ b/arch/powerpc/include/asm/fsl_memac.h
@@ -172,6 +172,7 @@ struct memac {
 #define MEMAC_CMD_CFG_RX_EN		0x00000002 /* MAC Rx path enable */
 #define MEMAC_CMD_CFG_TX_EN		0x00000001 /* MAC Tx path enable */
 #define MEMAC_CMD_CFG_RXTX_EN	(MEMAC_CMD_CFG_RX_EN | MEMAC_CMD_CFG_TX_EN)
+#define MEMAC_CMD_CFG_NO_LEN_CHK 0x20000 /* Payload length check disable */
 
 /* HASHTABLE_CTRL - Hashtable control register */
 #define HASHTABLE_CTRL_MCAST_EN	0x00000200 /* enable mulitcast Rx hash */
@@ -222,6 +223,10 @@ struct memac {
 
 /* IF_MODE - Interface Mode Register */
 #define IF_MODE_EN_AUTO	0x00008000 /* 1 - Enable automatic speed selection */
+#define IF_MODE_SETSP_100M	0x00000000 /* 00 - 100Mbps RGMII */
+#define IF_MODE_SETSP_10M	0x00002000 /* 01 - 10Mbps RGMII */
+#define IF_MODE_SETSP_1000M	0x00004000 /* 10 - 1000Mbps RGMII */
+#define IF_MODE_SETSP_MASK	0x00006000 /* setsp mask bits */
 #define IF_MODE_XGMII	0x00000000 /* 00- XGMII(10) interface mode */
 #define IF_MODE_GMII		0x00000002 /* 10- GMII interface mode */
 #define IF_MODE_MASK	0x00000003 /* mask for mode interface mode */
diff --git a/arch/powerpc/include/asm/fsl_pamu.h b/arch/powerpc/include/asm/fsl_pamu.h
new file mode 100644
index 0000000..9246310
--- /dev/null
+++ b/arch/powerpc/include/asm/fsl_pamu.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __PAMU_H
+#define __PAMU_H
+
+#define CONFIG_NUM_PAMU		16
+#define NUM_PPAACT_ENTRIES	512
+#define NUM_SPAACT_ENTRIES	256
+
+/* PAMU_OFFSET to the next pamu space in ccsr */
+#define PAMU_OFFSET 0x1000
+
+#define PAMU_TABLE_ALIGNMENT 0x00001000
+
+#define PAMU_PAGE_SHIFT 12
+#define PAMU_PAGE_SIZE  4096U
+
+#define PAACE_M_COHERENCE_REQ   0x01
+
+#define PAACE_DA_HOST_CR                0x80
+#define PAACE_DA_HOST_CR_SHIFT          7
+
+#define PAACE_AF_PT                     0x00000002
+#define PAACE_AF_PT_SHIFT               1
+
+#define PAACE_PT_PRIMARY       0x0
+#define PAACE_PT_SECONDARY     0x1
+
+#define PPAACE_AF_WBAL			0xfffff000
+#define PPAACE_AF_WBAL_SHIFT		12
+
+#define	OME_NUMBER_ENTRIES      16   /* based on P4080 2.0 silicon plan */
+
+#define PAACE_IA_CID			0x00FF0000
+#define PAACE_IA_CID_SHIFT		16
+#define PAACE_IA_WCE			0x000000F0
+#define PAACE_IA_WCE_SHIFT		4
+#define PAACE_IA_ATM			0x0000000C
+#define PAACE_IA_ATM_SHIFT		2
+#define PAACE_IA_OTM			0x00000003
+#define PAACE_IA_OTM_SHIFT		0
+
+#define PAACE_OTM_NO_XLATE      0x00
+#define PAACE_OTM_IMMEDIATE     0x01
+#define PAACE_OTM_INDEXED       0x02
+#define PAACE_OTM_RESERVED      0x03
+#define PAACE_ATM_NO_XLATE      0x00
+#define PAACE_ATM_WINDOW_XLATE  0x01
+#define PAACE_ATM_PAGE_XLATE    0x02
+#define PAACE_ATM_WIN_PG_XLATE  \
+	(PAACE_ATM_WINDOW_XLATE | PAACE_ATM_PAGE_XLATE)
+#define PAACE_WIN_TWBAL			0xfffff000
+#define PAACE_WIN_TWBAL_SHIFT		12
+#define PAACE_WIN_SWSE			0x00000fc0
+#define PAACE_WIN_SWSE_SHIFT		6
+
+#define PAACE_AF_AP			0x00000018
+#define PAACE_AF_AP_SHIFT		3
+#define PAACE_AF_DD			0x00000004
+#define PAACE_AF_DD_SHIFT		2
+#define PAACE_AF_PT			0x00000002
+#define PAACE_AF_PT_SHIFT		1
+#define PAACE_AF_V			0x00000001
+#define PAACE_AF_V_SHIFT		0
+#define PPAACE_AF_WSE			0x00000fc0
+#define PPAACE_AF_WSE_SHIFT		6
+#define PPAACE_AF_MW			0x00000020
+#define PPAACE_AF_MW_SHIFT		5
+
+#define PAACE_AP_PERMS_DENIED  0x0
+#define PAACE_AP_PERMS_QUERY   0x1
+#define PAACE_AP_PERMS_UPDATE  0x2
+#define PAACE_AP_PERMS_ALL     0x3
+
+#define SPAACE_AF_LIODN			0xffff0000
+#define SPAACE_AF_LIODN_SHIFT		16
+#define PAACE_V_VALID          0x1
+
+#define set_bf(v, m, x)             (v = ((v) & ~(m)) | (((x) << \
+					(m##_SHIFT)) & (m)))
+#define get_bf(v, m)            (((v) & (m)) >> (m##_SHIFT))
+
+#define DEFAULT_NUM_SUBWINDOWS		128
+#define PAMU_PCR_OFFSET 0xc10
+#define PAMU_PCR_PE	0x40000000
+
+struct pamu_addr_tbl {
+	phys_addr_t start_addr[10];
+	phys_addr_t end_addr[10];
+	phys_size_t size[10];
+};
+
+typedef struct paace_t {
+	/* PAACE Offset 0x00 */
+	uint32_t wbah;			/* only valid for Primary PAACE */
+	uint32_t addr_bitfields;	/* See P/S PAACE_AF_* */
+
+	/* PAACE Offset 0x08 */
+	/* Interpretation of first 32 bits dependent on DD above */
+	union {
+		struct {
+			/* Destination ID, see PAACE_DID_* defines */
+			uint8_t did;
+			/* Partition ID */
+			uint8_t pid;
+			/* Snoop ID */
+			uint8_t snpid;
+			/* coherency_required : 1 reserved : 7 */
+			uint8_t coherency_required; /* See PAACE_DA_* */
+		} to_host;
+		struct {
+			/* Destination ID, see PAACE_DID_* defines */
+			uint8_t  did;
+			uint8_t  reserved1;
+			uint16_t reserved2;
+		} to_io;
+	} domain_attr;
+
+	/* Implementation attributes + window count + address & operation
+	 * translation modes
+	 */
+	uint32_t impl_attr;			/* See PAACE_IA_* */
+
+	/* PAACE Offset 0x10 */
+	/* Translated window base address */
+	uint32_t twbah;
+	uint32_t win_bitfields;			/* See PAACE_WIN_* */
+
+	/* PAACE Offset 0x18 */
+	/* first secondary paace entry */
+	uint32_t fspi;			/* only valid for Primary PAACE */
+	union {
+		struct {
+			uint8_t ioea;
+			uint8_t moea;
+			uint8_t ioeb;
+			uint8_t moeb;
+		} immed_ot;
+		struct {
+			uint16_t reserved;
+			uint16_t omi;
+		} index_ot;
+	} op_encode;
+
+	/* PAACE Offset 0x20 */
+	uint32_t reserved1[2];			/* not currently implemented */
+
+	/* PAACE Offset 0x28 */
+	uint32_t reserved2[2];			/* not currently implemented */
+
+	/* PAACE Offset 0x30 */
+	uint32_t reserved3[2];			/* not currently implemented */
+
+	/* PAACE Offset 0x38 */
+	uint32_t reserved4[2];			/* not currently implemented */
+
+} paace_t;
+
+int pamu_init(void);
+void pamu_enable(void);
+void pamu_disable(void);
+int config_pamu(struct pamu_addr_tbl *tbl, int num_entries, uint32_t liodn);
+int sec_config_pamu_table(uint32_t liodn_ns, uint32_t liodn_s);
+
+#endif
diff --git a/arch/powerpc/include/asm/fsl_pci.h b/arch/powerpc/include/asm/fsl_pci.h
index 49bd2bf..90b0a2f 100644
--- a/arch/powerpc/include/asm/fsl_pci.h
+++ b/arch/powerpc/include/asm/fsl_pci.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007,2009-2011 Freescale Semiconductor, Inc.
+ * Copyright 2007,2009-2012 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -27,6 +27,34 @@
 
 #define PEX_IP_BLK_REV_2_2	0x02080202
 #define PEX_IP_BLK_REV_2_3	0x02080203
+#define PEX_IP_BLK_REV_3_0	0x02080300
+
+/* Freescale-specific PCI config registers */
+#define FSL_PCI_PBFR		0x44
+
+#ifdef CONFIG_SYS_FSL_PCI_VER_3_X
+/* Currently only the PCIe capability is used, so hardcode the offset.
+ * if more capabilities need to be justified, the capability link method
+ * should be applied here
+ */
+#define FSL_PCIE_CAP_ID		0x70
+#define PCI_DCR		0x78    /* PCIe Device Control Register */
+#define PCI_DSR		0x7a    /* PCIe Device Status Register */
+#define PCI_LSR		0x82    /* PCIe Link Status Register */
+#define PCI_LCR		0x80    /* PCIe Link Control Register */
+#else
+#define FSL_PCIE_CAP_ID		0x4c
+#define PCI_DCR		0x54    /* PCIe Device Control Register */
+#define PCI_DSR		0x56    /* PCIe Device Status Register */
+#define PCI_LSR		0x5e    /* PCIe Link Status Register */
+#define PCI_LCR		0x5c    /* PCIe Link Control Register */
+#define FSL_PCIE_CFG_RDY	0x4b0
+#endif
+#define FSL_PCI_CFG_READY	1 /* Endpoint: allow inbound configuration */
+#define FSL_PROG_IF_AGENT	0x1
+
+#define PCI_LTSSM	0x404   /* PCIe Link Training, Status State Machine */
+#define  PCI_LTSSM_L0	0x16    /* L0 state */
 
 int fsl_setup_hose(struct pci_controller *hose, unsigned long addr);
 int fsl_is_pci_agent(struct pci_controller *hose);
@@ -163,7 +191,10 @@ typedef struct ccsr_pci {
 	u32	perr_cap3;	/* 0xe34 - PCIE Error Capture Register 3 */
 	char	res23[200];
 	u32	pdb_stat;	/* 0xf00 - PCIE Debug Status */
-	char	res24[252];
+	char	res24[16];
+	u32	pex_csr0;	/* 0xf14 - PEX Control/Status register 0*/
+	u32	pex_csr1;	/* 0xf18 - PEX Control/Status register 1*/
+	char	res25[228];
 } ccsr_fsl_pci_t;
 #define PCIE_CONFIG_PC	0x00020000
 #define PCIE_CONFIG_OB_CK	0x00002000
diff --git a/arch/powerpc/include/asm/fsl_secure_boot.h b/arch/powerpc/include/asm/fsl_secure_boot.h
index d1c1967..4d6462a 100644
--- a/arch/powerpc/include/asm/fsl_secure_boot.h
+++ b/arch/powerpc/include/asm/fsl_secure_boot.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -22,22 +22,98 @@
 
 #ifndef __FSL_SECURE_BOOT_H
 #define __FSL_SECURE_BOOT_H
+#include <asm/config_mpc85xx.h>
 
-/* Starting TLB number for the TLB entried for 3.5 G space created by ISBC */
 #if defined(CONFIG_FSL_CORENET)
-#define CONFIG_SYS_ISBC_START_TLB		3
+#define CONFIG_SYS_PBI_FLASH_BASE		0xc0000000
+#elif defined(CONFIG_BSC9132QDS)
+#define CONFIG_SYS_PBI_FLASH_BASE		0xc8000000
 #else
-#define CONFIG_SYS_ISBC_START_TLB		0
+#define CONFIG_SYS_PBI_FLASH_BASE		0xce000000
 #endif
+#define CONFIG_SYS_PBI_FLASH_WINDOW		0xcff80000
 
-/* Number fo TLB's created by ISBC */
-#define CONFIG_SYS_ISBC_NUM_TLBS		5
+/*
+ * Define the key hash for boot script here if public/private key pair used to
+ * sign bootscript are different from the SRK hash put in the fuse
+ * Example of defining KEY_HASH is
+ * #define CONFIG_BOOTSCRIPT_KEY_HASH \
+ *	 "41066b564c6ffcef40ccbc1e0a5d0d519604000c785d97bbefd25e4d288d1c8b"
+ */
 
-#if defined(CONFIG_FSL_CORENET)
-#define CONFIG_SYS_PBI_FLASH_BASE		0xc0000000
+#define CONFIG_CMD_ESBC_VALIDATE
+
+#if CONFIG_SYS_FSL_ISBC_VER > 1
+#define CONFIG_SECURE_HKAREA_CPC
+#undef CONFIG_SYS_INIT_L3_ADDR
+#define CONFIG_SYS_INIT_L3_ADDR		0xbff00000
+#endif
+
+/* The bootscript header address is different for B4860 because the NOR
+ * mapping is different on B4 due to reduced NOR size.
+ */
+#if defined(CONFIG_B4860QDS)
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0xecc00000
+#elif defined(CONFIG_FSL_CORENET)
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0xe8e00000
+#elif defined(CONFIG_BSC9132QDS)
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0x88020000
 #else
-#define CONFIG_SYS_PBI_FLASH_BASE		0xce000000
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0xee020000
 #endif
-#define CONFIG_SYS_PBI_FLASH_WINDOW		0xcff80000
+
+/*
+ * Control should not reach back to uboot after validation of images
+ * for secure boot flow and therefore bootscript should have
+ * the bootm command. If control reaches back to uboot anyhow
+ * after validating images, core should just spin.
+ */
+#ifdef CONFIG_BOOTSCRIPT_KEY_HASH
+#define CONFIG_SECBOOT \
+	"setenv bs_hdraddr " __stringify(CONFIG_BOOTSCRIPT_HDR_ADDR)";"	   \
+	"setenv bootargs \"root=/dev/ram rw console=ttyS0,115200 ramdisk_size=600000\";"	\
+	"esbc_validate $bs_hdraddr "  __stringify(CONFIG_BOOTSCRIPT_KEY_HASH)";" \
+	"source $img_addr;"					\
+	"esbc_halt;"
+#else
+#define CONFIG_SECBOOT \
+	"setenv bs_hdraddr " __stringify(CONFIG_BOOTSCRIPT_HDR_ADDR)";"	 \
+	"setenv bootargs \"root=/dev/ram rw console=ttyS0,115200 ramdisk_size=600000\";"	\
+	"esbc_validate $bs_hdraddr;"			\
+	"source $img_addr;"				\
+	"esbc_halt;"
+#endif
+
+/* For secure boot flow, default environment used will be used */
+#if defined(CONFIG_SYS_RAMBOOT)
+#if defined(CONFIG_RAMBOOT_SPIFLASH)
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined(CONFIG_NAND)
+#undef CONFIG_ENV_IS_IN_NAND
+#elif defined(CONFIG_RAMBOOT_SDCARD)
+#undef CONFIG_ENV_IS_IN_MMC
+#endif
+#else /*CONFIG_SYS_RAMBOOT*/
+#undef CONFIG_ENV_IS_IN_FLASH
+#endif
+
+#define CONFIG_ENV_IS_NOWHERE
+
+/*
+ * We don't want boot delay for secure boot flow
+ * before autoboot starts
+ */
+#undef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY	0
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND		CONFIG_SECBOOT
+
+/*
+ * CONFIG_ZERO_BOOTDELAY_CHECK should not be defined for
+ * secure boot flow as defining this would enable a user to
+ * reach uboot prompt by pressing some key before start of
+ * autoboot
+ */
+#undef CONFIG_ZERO_BOOTDELAY_CHECK
 
 #endif
diff --git a/arch/powerpc/include/asm/fsl_serdes.h b/arch/powerpc/include/asm/fsl_serdes.h
index 6cd7379..d428e90 100644
--- a/arch/powerpc/include/asm/fsl_serdes.h
+++ b/arch/powerpc/include/asm/fsl_serdes.h
@@ -80,6 +80,14 @@ enum srds_prtcl {
 	XFI_FM2_MAC9,
 	XFI_FM2_MAC10,
 	INTERLAKEN,
+	SGMII_SW1_DTSEC1,	/* SW indicates on L2 switch */
+	SGMII_SW1_DTSEC2,
+	SGMII_SW1_DTSEC3,
+	SGMII_SW1_DTSEC4,
+	SGMII_SW1_DTSEC5,
+	SGMII_SW1_DTSEC6,
+	QSGMII_SW1_A,		/* SW indicates on L2 swtich */
+	QSGMII_SW1_B,
 };
 
 enum srds {
@@ -95,6 +103,7 @@ void fsl_serdes_init(void);
 #ifdef CONFIG_FSL_CORENET
 #ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
 int serdes_get_first_lane(u32 sd, enum srds_prtcl device);
+enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane);
 #else
 int serdes_get_first_lane(enum srds_prtcl device);
 #endif
diff --git a/arch/powerpc/include/asm/fsl_sfp_snvs.h b/arch/powerpc/include/asm/fsl_sfp_snvs.h
new file mode 100644
index 0000000..c215359
--- /dev/null
+++ b/arch/powerpc/include/asm/fsl_sfp_snvs.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _FSL_SFP_SNVS_
+#define _FSL_SFP_SNVS_
+
+#include <common.h>
+
+/* Number of SRKH registers */
+#define NUM_SRKH_REGS	8
+
+/*
+ * SNVS read. This specifies the possible reads
+ * from the SNVS
+ */
+enum {
+	SNVS_SSM_ST,
+	SNVS_SW_FSV,
+	SNVS_SW_SV,
+};
+
+void branch_to_self(void);
+int change_sec_mon_state(uint32_t initial_state, uint32_t final_state);
+void generate_reset_req(void);
+
+#endif
diff --git a/arch/powerpc/include/asm/fsl_usb.h b/arch/powerpc/include/asm/fsl_usb.h
new file mode 100644
index 0000000..ca1827e
--- /dev/null
+++ b/arch/powerpc/include/asm/fsl_usb.h
@@ -0,0 +1,88 @@
+/*
+ * Freescale USB Controller
+ *
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This software may be used and distributed according to the
+ * terms of the GNU Public License, Version 2, incorporated
+ * herein by reference.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ASM_FSL_USB_H_
+#define _ASM_FSL_USB_H_
+
+#include <stdbool.h>
+
+#ifdef CONFIG_SYS_FSL_USB_DUAL_PHY_ENABLE
+struct ccsr_usb_port_ctrl {
+	u32	ctrl;
+	u32	drvvbuscfg;
+	u32	pwrfltcfg;
+	u32	sts;
+	u8	res_14[0xc];
+	u32	bistcfg;
+	u32	biststs;
+	u32	abistcfg;
+	u32	abiststs;
+	u8	res_30[0x10];
+	u32	xcvrprg;
+	u32	anaprg;
+	u32	anadrv;
+	u32	anasts;
+};
+
+struct ccsr_usb_phy {
+	u32	id;
+	struct ccsr_usb_port_ctrl port1;
+	u8	res_50[0xc];
+	u32	tvr;
+	u32	pllprg[4];
+	u8	res_70[0x4];
+	u32	anaccfg;
+	u32	dbg;
+	u8	res_7c[0x4];
+	struct ccsr_usb_port_ctrl port2;
+	u8	res_dc[0x334];
+};
+
+#define CONFIG_SYS_FSL_USB_CTRL_PHY_EN (1 << 0)
+#define CONFIG_SYS_FSL_USB_DRVVBUS_CR_EN (1 << 1)
+#define CONFIG_SYS_FSL_USB_PWRFLT_CR_EN (1 << 1)
+#define CONFIG_SYS_FSL_USB_PLLPRG1_PHY_DIV (1 << 0)
+#define CONFIG_SYS_FSL_USB_PLLPRG2_PHY2_CLK_EN (1 << 0)
+#define CONFIG_SYS_FSL_USB_PLLPRG2_PHY1_CLK_EN (1 << 1)
+#define CONFIG_SYS_FSL_USB_PLLPRG2_FRAC_LPF_EN (1 << 13)
+#define CONFIG_SYS_FSL_USB_PLLPRG2_REF_DIV (1 << 4)
+#define CONFIG_SYS_FSL_USB_PLLPRG2_MFI (5 << 16)
+#define CONFIG_SYS_FSL_USB_PLLPRG2_PLL_EN (1 << 21)
+#define CONFIG_SYS_FSL_USB_SYS_CLK_VALID (1 << 0)
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A006918
+extern bool	has_fsl_erratum_a006918;
+#define FSL_MAX_USBPLL_RETRY_COUNT	7
+#endif
+
+#else
+struct ccsr_usb_phy {
+	u8	res0[0x18];
+	u32	usb_enable_override;
+	u8	res[0xe4];
+};
+#define CONFIG_SYS_FSL_USB_ENABLE_OVERRIDE 1
+#endif
+
+#endif /*_ASM_FSL_USB_H_ */
diff --git a/arch/powerpc/include/asm/immap_85xx.h b/arch/powerpc/include/asm/immap_85xx.h
index 1691c75..b3b389f 100644
--- a/arch/powerpc/include/asm/immap_85xx.h
+++ b/arch/powerpc/include/asm/immap_85xx.h
@@ -298,7 +298,9 @@ typedef struct ccsr_pcix {
 	u32	int_ack;	/* PCIX IRQ Acknowledge */
 	u8	res000c[52];
 	u32	liodn_base;	/* PCIX LIODN base register */
-	u8	res0044[3004];
+	u8	res0044[2996];
+	u32	ipver1;		/* PCIX IP block revision register 1 */
+	u32	ipver2;		/* PCIX IP block revision register 2 */
 	u32	potar0;		/* PCIX Outbound Transaction Addr 0 */
 	u32	potear0;	/* PCIX Outbound Translation Extended Addr 0 */
 	u32	powbar0;	/* PCIX Outbound Window Base Addr 0 */
@@ -1560,6 +1562,18 @@ struct rio_pw {
 };
 #endif
 
+#ifdef CONFIG_SYS_FSL_SRIO_LIODN
+struct rio_liodn {
+	u32	plbr;
+	u8	res0[28];
+	u32	plaor;
+	u8	res1[12];
+	u32	pludr;
+	u32	plldr;
+	u8	res2[456];
+};
+#endif
+
 /* RapidIO Registers */
 struct ccsr_rio {
 	struct rio_arch	arch;
@@ -1582,6 +1596,10 @@ struct ccsr_rio {
 	u8	res7[100];
 	struct rio_pw	pw;
 #endif
+#ifdef CONFIG_SYS_FSL_SRIO_LIODN
+	u8	res5[8192];
+	struct rio_liodn liodn[CONFIG_SYS_FSL_SRIO_MAX_PORTS];
+#endif
 };
 #endif
 
@@ -1676,18 +1694,17 @@ typedef struct cpc_corenet {
 /* Global Utilities Block */
 #ifdef CONFIG_FSL_CORENET
 typedef struct ccsr_gur {
-	u32	porsr1;		/* POR status */
-	u8	res1[28];
+	u32	porsr1;		/* POR status 1 */
+	u32	porsr2;		/* POR status 2 */
+	u8	res_008[0x20-0x8];
 	u32	gpporcr1;	/* General-purpose POR configuration */
-	u8	res2[12];
-	u32	gpiocr;		/* GPIO control */
-	u8	res3[12];
-	u32	gpoutdr;	/* General-purpose output data */
-	u8	res4[12];
-	u32	gpindr;		/* General-purpose input data */
-	u8	res5[12];
-	u32	alt_pmuxcr;	/* Alt function signal multiplex control */
-	u8	res6[12];
+	u32	gpporcr2;	/* General-purpose POR configuration 2 */
+	u32	dcfg_fusesr;	/* Fuse status register */
+#define FSL_CORENET_DCFG_FUSESR_VID_SHIFT	25
+#define FSL_CORENET_DCFG_FUSESR_VID_MASK	0x1F
+#define FSL_CORENET_DCFG_FUSESR_ALTVID_SHIFT	20
+#define FSL_CORENET_DCFG_FUSESR_ALTVID_MASK	0x1F
+	u8	res_02c[0x70-0x2c];
 	u32	devdisr;	/* Device disable control */
 	u32	devdisr2;	/* Device disable control 2 */
 	u32	devdisr3;	/* Device disable control 3 */
@@ -1816,6 +1833,9 @@ typedef struct ccsr_gur {
 	u32	rstrqpblsr;	/* Reset request preboot loader status */
 	u8	res11[8];
 	u32	rstrqmr1;	/* Reset request mask */
+#ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
+#define FSL_CORENET_RSTRQMR1_SRDS_RST_MSK      0x00000800
+#endif
 	u8	res12[4];
 	u32	rstrqsr1;	/* Reset request status */
 	u8	res13[4];
@@ -1831,7 +1851,7 @@ typedef struct ccsr_gur {
 #ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
 #define FSL_CORENET_RCWSR0_MEM_PLL_RAT_SHIFT	16
 #define FSL_CORENET_RCWSR0_MEM_PLL_RAT_MASK	0x3f
-#if defined(CONFIG_PPC_T4240)
+#if defined(CONFIG_PPC_T4240) || defined(CONFIG_PPC_T4160)
 #define FSL_CORENET2_RCWSR4_SRDS1_PRTCL		0xfc000000
 #define FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT	26
 #define FSL_CORENET2_RCWSR4_SRDS2_PRTCL		0x00fe0000
@@ -1840,11 +1860,18 @@ typedef struct ccsr_gur {
 #define FSL_CORENET2_RCWSR4_SRDS3_PRTCL_SHIFT	11
 #define FSL_CORENET2_RCWSR4_SRDS4_PRTCL		0x000000f8
 #define FSL_CORENET2_RCWSR4_SRDS4_PRTCL_SHIFT	3
-#elif defined(CONFIG_PPC_B4860)
+#define FSL_CORENET_RCWSR6_BOOT_LOC	0x0f800000
+#elif defined(CONFIG_PPC_B4860) || defined(CONFIG_PPC_B4420)
 #define FSL_CORENET2_RCWSR4_SRDS1_PRTCL	0xfe000000
 #define FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT	25
 #define FSL_CORENET2_RCWSR4_SRDS2_PRTCL	0x00ff0000
 #define FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT	16
+#define FSL_CORENET_RCWSR6_BOOT_LOC	0x0f800000
+#elif defined(CONFIG_PPC_T1040)
+#define FSL_CORENET2_RCWSR4_SRDS1_PRTCL	0xff000000
+#define FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT	24
+#define FSL_CORENET2_RCWSR4_SRDS2_PRTCL	0x00fe0000
+#define FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT	17
 #endif
 #define FSL_CORENET2_RCWSR5_SRDS_PLL_PD_S1_PLL1	0x00800000
 #define FSL_CORENET2_RCWSR5_SRDS_PLL_PD_S1_PLL2	0x00400000
@@ -1864,6 +1891,7 @@ typedef struct ccsr_gur {
 #define FSL_CORENET_RCWSR5_SRDS_EN		0x00002000
 #define FSL_CORENET_RCWSR5_SRDS2_EN		0x00001000
 #define FSL_CORENET_RCWSR6_BOOT_LOC	0x0f800000
+#define FSL_CORENET_RCWSR6_SB_EN		0x00200000
 #define FSL_CORENET_RCWSRn_SRDS_LPD_B2		0x3c000000 /* bits 162..165 */
 #define FSL_CORENET_RCWSRn_SRDS_LPD_B3		0x003c0000 /* bits 170..173 */
 #endif /* CONFIG_SYS_FSL_QORIQ_CHASSIS2 */
@@ -1899,7 +1927,7 @@ typedef struct ccsr_gur {
 #define FSL_CORENET_RCWSR11_EC2_FM2_DTSEC5_MII          0x00100000
 #define FSL_CORENET_RCWSR11_EC2_FM2_DTSEC5_NONE         0x00180000
 #endif
-#if defined(CONFIG_PPC_T4240)
+#if defined(CONFIG_PPC_T4240) || defined(CONFIG_PPC_T4160)
 #define FSL_CORENET_RCWSR13_EC1			0x60000000 /* bits 417..418 */
 #define FSL_CORENET_RCWSR13_EC1_FM2_DTSEC5_RGMII	0x00000000
 #define FSL_CORENET_RCWSR13_EC1_FM2_GPIO		0x40000000
@@ -1992,6 +2020,7 @@ typedef struct ccsr_gur {
 
 #define TP_CLUSTER_EOC		0x80000000	/* end of clusters */
 #define TP_CLUSTER_INIT_MASK	0x0000003f	/* initiator mask */
+#define TP_INIT_PER_CLUSTER	4
 
 #define FSL_CORENET_DCSR_SZ_MASK	0x00000003
 #define FSL_CORENET_DCSR_SZ_4M		0x0
@@ -2004,22 +2033,13 @@ typedef struct ccsr_gur {
 #define rmuliodnr rio1maintliodnr
 
 typedef struct ccsr_clk {
-	u32	clkc0csr;	/* 0x000 Core 0 Clock control/status */
-	u8	res1[0x1c];
-	u32	clkc1csr;	/* 0x020 Core 1 Clock control/status */
-	u8	res2[0x1c];
-	u32	clkc2csr;	/* 0x040 Core 2 Clock control/status */
-	u8	res3[0x1c];
-	u32	clkc3csr;	/* 0x060 Core 3 Clock control/status */
-	u8	res4[0x1c];
-	u32	clkc4csr;	/* 0x080 Core 4 Clock control/status */
-	u8	res5[0x1c];
-	u32	clkc5csr;	/* 0x0a0 Core 5 Clock control/status */
-	u8	res6[0x1c];
-	u32	clkc6csr;	/* 0x0c0 Core 6 Clock control/status */
-	u8	res7[0x1c];
-	u32	clkc7csr;	/* 0x0e0 Core 7 Clock control/status */
-	u8	res8[0x71c];
+	struct {
+		u32 clkcncsr;	/* core cluster n clock control status */
+		u8  res_004[0x0c];
+		u32 clkcgnhwacsr;/* clock generator n hardware accelerator */
+		u8  res_014[0x0c];
+	} clkcsr[8];
+	u8	res_100[0x700]; /* 0x100 */
 	u32	pllc1gsr;	/* 0x800 Cluster PLL 1 General Status */
 	u8	res10[0x1c];
 	u32	pllc2gsr;	/* 0x820 Cluster PLL 2 General Status */
@@ -2149,8 +2169,13 @@ typedef struct ccsr_gur {
 #ifdef CONFIG_MPC8536
 #define MPC85xx_PORPLLSR_DDR_RATIO	0x3e000000
 #define MPC85xx_PORPLLSR_DDR_RATIO_SHIFT	25
+#elif defined(CONFIG_C29X)
+#define MPC85xx_PORPLLSR_DDR_RATIO	0x00003f00
+#define MPC85xx_PORPLLSR_DDR_RATIO_SHIFT	(9 - ((gur->pordevsr2 \
+					& MPC85xx_PORDEVSR2_DDR_SPD_0) \
+					>> MPC85xx_PORDEVSR2_DDR_SPD_0_SHIFT))
 #else
-#ifdef CONFIG_BSC9131
+#if defined(CONFIG_BSC9131) || defined(CONFIG_BSC9132)
 #define MPC85xx_PORPLLSR_DDR_RATIO	0x00003f00
 #else
 #define MPC85xx_PORPLLSR_DDR_RATIO	0x00003e00
@@ -2164,6 +2189,11 @@ typedef struct ccsr_gur {
 	u32	porbmsr;	/* POR boot mode status */
 #define MPC85xx_PORBMSR_HA		0x00070000
 #define MPC85xx_PORBMSR_HA_SHIFT	16
+#define MPC85XX_PORBMSR_ROMLOC_SHIFT	24
+#define PORBMSR_ROMLOC_SPI	0x6
+#define PORBMSR_ROMLOC_SDHC	0x7
+#define PORBMSR_ROMLOC_NAND_2K	0x9
+#define PORBMSR_ROMLOC_NOR	0xf
 	u32	porimpscr;	/* POR I/O impedance status & control */
 	u32	pordevsr;	/* POR I/O device status regsiter */
 #if defined(CONFIG_P1017) || defined(CONFIG_P1023)
@@ -2188,6 +2218,12 @@ typedef struct ccsr_gur {
 #if defined(CONFIG_P1010)
 #define MPC85xx_PORDEVSR_IO_SEL		0x00600000
 #define MPC85xx_PORDEVSR_IO_SEL_SHIFT	21
+#elif defined(CONFIG_BSC9132)
+#define MPC85xx_PORDEVSR_IO_SEL		0x00FE0000
+#define MPC85xx_PORDEVSR_IO_SEL_SHIFT	17
+#elif defined(CONFIG_C29X)
+#define MPC85xx_PORDEVSR_IO_SEL		0x00e00000
+#define MPC85xx_PORDEVSR_IO_SEL_SHIFT	21
 #else
 #define MPC85xx_PORDEVSR_IO_SEL		0x00780000
 #define MPC85xx_PORDEVSR_IO_SEL_SHIFT	19
@@ -2204,6 +2240,10 @@ typedef struct ccsr_gur {
 	u32	pordbgmsr;	/* POR debug mode status */
 	u32	pordevsr2;	/* POR I/O device status 2 */
 #define MPC85xx_PORDEVSR2_SDHC_CD_POL  0x00000100
+#if defined(CONFIG_C29X)
+#define MPC85xx_PORDEVSR2_DDR_SPD_0	0x00000008
+#define MPC85xx_PORDEVSR2_DDR_SPD_0_SHIFT	3
+#endif
 /* The 8544 RM says this is bit 26, but it's really bit 24 */
 #define MPC85xx_PORDEVSR2_SEC_CFG	0x00000080
 	u8	res1[8];
@@ -2346,6 +2386,15 @@ typedef struct ccsr_gur {
 #define MPC85xx_PMUXCR_SPI1_CS3_dbg_adi2_rxen	0x00000002
 #define MPC85xx_PMUXCR_SPI1_CS3_GPO76		0x00000003
 #endif
+#ifdef CONFIG_BSC9132
+#define MPC85xx_PMUXCR0_SIM_SEL_MASK	0x0003b000
+#define MPC85xx_PMUXCR0_SIM_SEL		0x00014000
+#endif
+#if defined(CONFIG_C29X)
+#define MPC85xx_PMUXCR_SPI_MASK			0x00000300
+#define MPC85xx_PMUXCR_SPI			0x00000000
+#define MPC85xx_PMUXCR_SPI_GPIO			0x00000100
+#endif
 	u32	pmuxcr2;	/* Alt. function signal multiplex control 2 */
 #if defined(CONFIG_P1010) || defined(CONFIG_P1014)
 #define MPC85xx_PMUXCR2_UART_GPIO		0x40000000
@@ -2376,6 +2425,7 @@ typedef struct ccsr_gur {
 #define MPC85xx_PMUXCR2_ETSECUSB_MASK	0x001f8000
 #define MPC85xx_PMUXCR2_USB		0x00150000
 #endif
+#if defined(CONFIG_BSC9131) || defined(CONFIG_BSC9132)
 #if defined(CONFIG_BSC9131)
 #define MPC85xx_PMUXCR2_UART_CTS_B0_SIM_PD		0X40000000
 #define MPC85xx_PMUXCR2_UART_CTS_B0_DSP_TMS		0X80000000
@@ -2419,8 +2469,9 @@ typedef struct ccsr_gur {
 #define MPC85xx_PMUXCR2_ANT3_AGC_GPO53			0x00000004
 #define MPC85xx_PMUXCR2_ANT3_DO_TDM			0x00000001
 #define MPC85xx_PMUXCR2_ANT3_DO_GPIO46_49		0x00000002
+#endif
 	u32	pmuxcr3;
-
+#if defined(CONFIG_BSC9131)
 #define MPC85xx_PMUXCR3_ANT3_DO4_5_TDM			0x40000000
 #define MPC85xx_PMUXCR3_ANT3_DO4_5_GPIO_50_51		0x80000000
 #define MPC85xx_PMUXCR3_ANT3_DO6_7_TRIG_IN_SRESET_B	0x10000000
@@ -2435,6 +2486,13 @@ typedef struct ccsr_gur {
 #define MPC85xx_PMUXCR3_SPI2_CS3_GPO94			0x00040000
 #define MPC85xx_PMUXCR3_ANT2_AGC_RSVD			0x00010000
 #define MPC85xx_PMUXCR3_ANT2_GPO89			0x00030000
+#endif
+#ifdef CONFIG_BSC9132
+#define MPC85xx_PMUXCR3_USB_SEL_MASK	0x0000ff00
+#define MPC85xx_PMUXCR3_UART2_SEL	0x00005000
+#define MPC85xx_PMUXCR3_UART3_SEL_MASK	0xc0000000
+#define MPC85xx_PMUXCR3_UART3_SEL	0x40000000
+#endif
 	u32 pmuxcr4;
 #else
 	u8	res6[8];
@@ -2524,7 +2582,9 @@ typedef struct serdes_corenet {
 #define SRDS_RSTCTL_RSTDONE	0x40000000
 #define SRDS_RSTCTL_RSTERR	0x20000000
 #define SRDS_RSTCTL_SWRST	0x10000000
-#define SRDS_RSTCTL_SDPD	0x00000020
+#define SRDS_RSTCTL_SDEN	0x00000020
+#define SRDS_RSTCTL_SDRST_B	0x00000040
+#define SRDS_RSTCTL_PLLRST_B	0x00000080
 		u32	pllcr0; /* PLL Control Register 0 */
 #define SRDS_PLLCR0_POFF		0x80000000
 #define SRDS_PLLCR0_RFCK_SEL_MASK	0x70000000
@@ -2534,6 +2594,7 @@ typedef struct serdes_corenet {
 #define SRDS_PLLCR0_RFCK_SEL_150	0x30000000
 #define SRDS_PLLCR0_RFCK_SEL_161_13	0x40000000
 #define SRDS_PLLCR0_RFCK_SEL_122_88	0x50000000
+#define SRDS_PLLCR0_PLL_LCK		0x00800000
 #define SRDS_PLLCR0_FRATE_SEL_MASK	0x000f0000
 #define SRDS_PLLCR0_FRATE_SEL_5		0x00000000
 #define SRDS_PLLCR0_FRATE_SEL_3_75	0x00050000
@@ -2649,6 +2710,32 @@ typedef struct serdes_corenet {
 } serdes_corenet_t;
 #endif /* CONFIG_SYS_FSL_QORIQ_CHASSIS2 */
 
+typedef struct serdes2_corenet {
+	u32	rstctl;	/* Reset Control Register */
+	u32	pllcr0; /* PLL Control Register 0 */
+	u32	pllcr1; /* PLL Control Register 1 */
+	u32	res1[25];
+	u32	srdstcalcr;	/* TX Calibration Control */
+	u32	res2[3];
+	u32	srdsrcalcr;	/* RX Calibration Control */
+	u32	res3[3];
+	u32	srdsgr0;	/* General Register 0 */
+	u32	res4[11];
+	u32	srdspccr0;	/* Protocol Converter Config 0 */
+	u32	res5[79];
+	struct {
+		u32	gcr0;	/* General Control Register 0 */
+		u32	gcr1;	/* General Control Register 1 */
+		u32	res1[2];
+		u32	recr0;	/* Receive Equalization Control Reg 0 */
+		u32	res2;
+		u32	tecr0;	/* TX Equalization Control Reg 0 */
+		u32	res3;
+		u32	ttlcr0;	/* Transition Tracking Loop Ctrl 0 */
+		u32	res4[7];
+	} lane[2];
+} serdes2_corenet_t;
+
 enum {
 	FSL_SRDS_B1_LANE_A = 0,
 	FSL_SRDS_B1_LANE_B = 1,
@@ -2672,10 +2759,39 @@ enum {
 
 /* Security Engine Block (MS = Most Sig., LS = Least Sig.) */
 #if CONFIG_SYS_FSL_SEC_COMPAT >= 4
+/* RNG4 TRNG test registers */
+struct rng4tst {
+#define RTMCTL_PRGM 0x00010000	/* 1 -> program mode, 0 -> run mode */
+	u32 rtmctl;		/* misc. control register */
+	u32 rtscmisc;		/* statistical check misc. register */
+	u32 rtpkrrng;		/* poker range register */
+	union {
+		u32 rtpkrmax;	/* PRGM=1: poker max. limit register */
+		u32 rtpkrsq;	/* PRGM=0: poker square calc. result register */
+	};
+#define RTSDCTL_ENT_DLY_SHIFT 16
+#define RTSDCTL_ENT_DLY_MASK (0xffff << RTSDCTL_ENT_DLY_SHIFT)
+	u32 rtsdctl;		/* seed control register */
+	union {
+		u32 rtsblim;	/* PRGM=1: sparse bit limit register */
+		u32 rttotsam;	/* PRGM=0: total samples register */
+	};
+	u32 rtfreqmin;		/* frequency count min. limit register */
+	union {
+		u32 rtfreqmax;	/* PRGM=1: freq. count max. limit register */
+		u32 rtfreqcnt;	/* PRGM=0: freq. count register */
+	};
+	u32 rsvd1[40];
+#define RNG_STATE0_HANDLE_INSTANTIATED	0x00000001
+	u32 rdsta;		/*RNG DRNG Status Register*/
+	u32 rsvd2[15];
+};
+
 typedef struct ccsr_sec {
 	u32	res0;
 	u32	mcfgr;		/* Master CFG Register */
-	u8	res1[0x8];
+	u8	res1[0x4];
+	u32	scfgr;
 	struct {
 		u32	ms;	/* Job Ring LIODN Register, MS */
 		u32	ls;	/* Job Ring LIODN Register, LS */
@@ -2694,19 +2810,21 @@ typedef struct ccsr_sec {
 	u8	res4[0x40];
 	u32	dar;		/* DECO Avail Register */
 	u32	drr;		/* DECO Reset Register */
-	u8	res5[0xe78];
+	u8	res5[0x4d8];
+	struct rng4tst rng;	/* RNG Registers */
+	u8	res6[0x8a0];
 	u32	crnr_ms;	/* CHA Revision Number Register, MS */
 	u32	crnr_ls;	/* CHA Revision Number Register, LS */
 	u32	ctpr_ms;	/* Compile Time Parameters Register, MS */
 	u32	ctpr_ls;	/* Compile Time Parameters Register, LS */
-	u8	res6[0x10];
+	u8	res7[0x10];
 	u32	far_ms;		/* Fault Address Register, MS */
 	u32	far_ls;		/* Fault Address Register, LS */
 	u32	falr;		/* Fault Address LIODN Register */
 	u32	fadr;		/* Fault Address Detail Register */
-	u8	res7[0x4];
+	u8	res8[0x4];
 	u32	csta;		/* CAAM Status Register */
-	u8	res8[0x8];
+	u8	res9[0x8];
 	u32	rvid;		/* Run Time Integrity Checking Version ID Reg.*/
 	u32	ccbvid;		/* CHA Cluster Block Version ID Register */
 	u32	chavid_ms;	/* CHA Version ID Register, MS */
@@ -2715,10 +2833,10 @@ typedef struct ccsr_sec {
 	u32	chanum_ls;	/* CHA Number Register, LS */
 	u32	secvid_ms;	/* SEC Version ID Register, MS */
 	u32	secvid_ls;	/* SEC Version ID Register, LS */
-	u8	res9[0x6020];
+	u8	res10[0x6020];
 	u32	qilcr_ms;	/* Queue Interface LIODN CFG Register, MS */
 	u32	qilcr_ls;	/* Queue Interface LIODN CFG Register, LS */
-	u8	res10[0x8fd8];
+	u8	res11[0x8fd8];
 } ccsr_sec_t;
 
 #define SEC_CTPR_MS_AXI_LIODN		0x08000000
@@ -2728,6 +2846,15 @@ typedef struct ccsr_sec {
 #define SEC_CHANUM_MS_JRNUM_SHIFT	28
 #define SEC_CHANUM_MS_DECONUM_MASK	0x0f000000
 #define SEC_CHANUM_MS_DECONUM_SHIFT	24
+#define SEC_SECVID_MS_IPID_MASK		0xffff0000
+#define SEC_SECVID_MS_IPID_SHIFT	16
+#define SEC_SECVID_MS_MAJ_REV_MASK	0x0000ff00
+#define SEC_SECVID_MS_MAJ_REV_SHIFT	8
+#define SEC_CCBVID_ERA_MASK		0xff000000
+#define SEC_CCBVID_ERA_SHIFT		24
+#define SEC_SCFGR_RDBENABLE		0x00000400
+#define SEC_CHAVID_LS_RNG_SHIFT		16
+#define SEC_CHAVID_RNG_LS_MASK		0x000f0000
 #endif
 
 typedef struct ccsr_qman {
@@ -2803,12 +2930,61 @@ typedef struct ccsr_pme {
 	u8	res4[0x400];
 } ccsr_pme_t;
 
-typedef struct ccsr_usb_phy {
-	u8	res0[0x18];
-	u32	usb_enable_override;
-	u8	res[0xe4];
-} ccsr_usb_phy_t;
-#define CONFIG_SYS_FSL_USB_ENABLE_OVERRIDE 1
+typedef struct ccsr_dce {
+	u8      res0[0x100];
+	u32     liodnbr;        /* LIODN Base Register */
+	u32     srcidr;         /* Source ID Register */
+	u8      res1[0x2f0];
+	u32     dce_ip_rev_1;   /* DCE IP Block Revision Reg 1*/
+	u32     dce_ip_rev_2;   /* DCE IP Block Revision Reg 2*/
+	u8      res4[0xc00];
+} ccsr_dce_t;
+
+typedef struct ccsr_pamu {
+	u32 ppbah;
+	u32 ppbal;
+	u32 pplah;
+	u32 pplal;
+	u32 spbah;
+	u32 spbal;
+	u32 splah;
+	u32 splal;
+	u32 obah;
+	u32 obal;
+	u32 olah;
+	u32 olal;
+} ccsr_pamu_t;
+
+typedef struct jr_regs {
+	u32 irba_h;
+	u32 irba_l;
+	u32 rsvd1;
+	u32 irs;
+	u32 rsvd2;
+	u32 irsa;
+	u32 rsvd3;
+	u32 irja;
+	u32 orba_h;
+	u32 orba_l;
+	u32 rsvd4;
+	u32 ors;
+	u32 rsvd5;
+	u32 orjr;
+	u32 rsvd6;
+	u32 orsf;
+	u32 rsvd7;
+	u32 jrsta;
+	u32 rsvd8;
+	u32 jrint;
+	u32 jrcfg0;
+	u32 jrcfg1;
+	u32 rsvd9;
+	u32 irri;
+	u32 rsvd10;
+	u32 orwi;
+	u32 rsvd11;
+	u32 jrcr;
+} jr_regs_t;
 
 #ifdef CONFIG_SYS_FSL_RAID_ENGINE
 struct ccsr_raide {
@@ -2863,6 +3039,48 @@ struct ccsr_pman {
 	u8	res_f4[0xf0c];
 };
 #endif
+#ifdef CONFIG_SYS_FSL_SFP_VER_3_0
+typedef struct ccsr_sfp_regs {
+	u32 ospr;		/* 0x200 */
+	u32 reserved0[14];
+	u32 srk_hash[8];	/* 0x23c Super Root Key Hash */
+	u32 oem_uid;		/* 0x9c OEM Unique ID */
+	u8 reserved2[0x04];
+	u32 ovpr;			/* 0xA4  Intent To Secure */
+	u8 reserved4[0x08];
+	u32 fsl_uid;		/* 0xB0  FSL Unique ID */
+} ccsr_sfp_regs_t;
+#else
+typedef struct ccsr_sfp_regs {
+	u8 reserved0[0x40];
+	u32 ospr;	/* 0x40  OEM Security Policy Register */
+	u8 reserved2[0x38];
+	u32 srk_hash[8];	/* 0x7c  Super Root Key Hash */
+	u32 oem_uid;	/* 0x9c  OEM Unique ID */
+	u8 reserved4[0x4];
+	u32 ovpr;	/* 0xA4  OEM Validation Policy Register */
+	u8 reserved8[0x8];
+	u32 fsl_uid;	/* 0xB0  FSL Unique ID */
+} ccsr_sfp_regs_t;
+#endif
+#define ITS_MASK	0x00000004
+#define ITS_BIT		2
+
+typedef struct ccsr_snvs_regs {
+	u8 reserved0[0x04];
+	u32 hp_com;	/* 0x04 SNVS_HP Command Register */
+	u8 reserved2[0x0c];
+	u32 hp_stat;	/* 0x08 SNVS_HP Status Register */
+} ccsr_snvs_regs_t;
+
+#define HPCOMR_SW_SV 0x100		/* Security Violation bit */
+#define HPCOMR_SW_FSV 0x200		/* Fatal Security Violation bit */
+#define HPCOMR_SSM_ST 0x1		/* SSM_ST field in SNVS command reg */
+#define HPSR_SSM_ST_CHECK	0x900	/* SNVS is in check state */
+#define HPSR_SSM_ST_NON_SECURE	0xb00	/* SNVS is in non secure state */
+#define HPSR_SSM_ST_TRUST	0xd00	/* SNVS is in trusted state */
+#define HPSR_SSM_ST_SOFT_FAIL	0x300	/* SNVS is in soft fail state */
+#define HPSR_SSM_ST_MASK	0xf00	/* Mask for SSM_ST field */
 
 #ifdef CONFIG_FSL_CORENET
 #define CONFIG_SYS_FSL_CORENET_CCM_OFFSET	0x0000
@@ -2876,9 +3094,18 @@ struct ccsr_pman {
 #define CONFIG_SYS_MPC8xxx_DDR3_OFFSET		0xA000
 #define CONFIG_SYS_FSL_CORENET_CLK_OFFSET	0xE1000
 #define CONFIG_SYS_FSL_CORENET_RCPM_OFFSET	0xE2000
+#ifdef CONFIG_SYS_FSL_SFP_VER_3_0
+/* In SFPv3, OSPR register is now at offset 0x200.
+ * So directly mapping sfp register map to this address */
+#define CONFIG_SYS_OSPR_OFFSET			0x200
+#define CONFIG_SYS_SFP_OFFSET		 (0xE8000 + CONFIG_SYS_OSPR_OFFSET)
+#else
+#define CONFIG_SYS_SFP_OFFSET			0xE8000
+#endif
 #define CONFIG_SYS_FSL_CORENET_SERDES_OFFSET	0xEA000
 #define CONFIG_SYS_FSL_CORENET_SERDES2_OFFSET	0xEB000
 #define CONFIG_SYS_FSL_CPC_OFFSET		0x10000
+#define CONFIG_SYS_FSL_PAMU_OFFSET		0x20000
 #define CONFIG_SYS_MPC85xx_DMA1_OFFSET		0x100000
 #define CONFIG_SYS_MPC85xx_DMA2_OFFSET		0x101000
 #define CONFIG_SYS_MPC85xx_DMA_OFFSET		CONFIG_SYS_MPC85xx_DMA1_OFFSET
@@ -2888,7 +3115,8 @@ struct ccsr_pman {
 #define CONFIG_SYS_MPC85xx_IFC_OFFSET		0x124000
 #define CONFIG_SYS_MPC85xx_GPIO_OFFSET		0x130000
 #define CONFIG_SYS_FSL_CORENET_RMAN_OFFSET	0x1e0000
-#ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
+#if defined(CONFIG_SYS_FSL_QORIQ_CHASSIS2) && !defined(CONFIG_PPC_B4860)\
+	&& !defined(CONFIG_PPC_B4420)
 #define CONFIG_SYS_MPC85xx_PCIE1_OFFSET		0x240000
 #define CONFIG_SYS_MPC85xx_PCIE2_OFFSET		0x250000
 #define CONFIG_SYS_MPC85xx_PCIE3_OFFSET		0x260000
@@ -2906,7 +3134,15 @@ struct ccsr_pman {
 #define CONFIG_SYS_MPC85xx_USB2_PHY_OFFSET 0x214100
 #define CONFIG_SYS_MPC85xx_SATA1_OFFSET		0x220000
 #define CONFIG_SYS_MPC85xx_SATA2_OFFSET		0x221000
+#if defined(CONFIG_C29X)
+#define CONFIG_SYS_FSL_SEC_OFFSET		0x80000
+#define CONFIG_SYS_FSL_JR0_OFFSET		0x81000
+#else
 #define CONFIG_SYS_FSL_SEC_OFFSET		0x300000
+#define CONFIG_SYS_FSL_JR0_OFFSET		0x301000
+#endif
+#define CONFIG_SYS_FSL_CORENET_DCE_OFFSET	0x312000
+#define CONFIG_SYS_SNVS_OFFSET			0x314000
 #define CONFIG_SYS_FSL_CORENET_PME_OFFSET	0x316000
 #define CONFIG_SYS_FSL_QMAN_OFFSET		0x318000
 #define CONFIG_SYS_FSL_BMAN_OFFSET		0x31a000
@@ -2958,11 +3194,15 @@ struct ccsr_pman {
 #define CONFIG_SYS_MPC85xx_USB2_OFFSET		0x23000
 #ifdef CONFIG_TSECV2
 #define CONFIG_SYS_TSEC1_OFFSET			0xB0000
+#elif defined(CONFIG_TSECV2_1)
+#define CONFIG_SYS_TSEC1_OFFSET			0x10000
 #else
 #define CONFIG_SYS_TSEC1_OFFSET			0x24000
 #endif
 #define CONFIG_SYS_MDIO1_OFFSET			0x24000
 #define CONFIG_SYS_MPC85xx_ESDHC_OFFSET		0x2e000
+#define CONFIG_SYS_FSL_SEC_OFFSET		0x30000
+#define CONFIG_SYS_FSL_JR0_OFFSET		0x31000
 #define CONFIG_SYS_MPC85xx_SERDES2_OFFSET	0xE3100
 #define CONFIG_SYS_MPC85xx_SERDES1_OFFSET	0xE3000
 #define CONFIG_SYS_SNVS_OFFSET			0xE6000
@@ -2980,6 +3220,12 @@ struct ccsr_pman {
 #define CONFIG_SYS_MPC85xx_GUTS_OFFSET		0xE0000
 #define CONFIG_SYS_FSL_SRIO_OFFSET		0xC0000
 
+#if defined(CONFIG_BSC9132)
+#define CONFIG_SYS_FSL_DSP_CCSR_DDR_OFFSET	0x10000
+#define CONFIG_SYS_FSL_DSP_CCSR_DDR_ADDR \
+	(CONFIG_SYS_FSL_DSP_CCSRBAR + CONFIG_SYS_FSL_DSP_CCSR_DDR_OFFSET)
+#endif
+
 #define CONFIG_SYS_FSL_CPC_ADDR	\
 	(CONFIG_SYS_CCSRBAR + CONFIG_SYS_FSL_CPC_OFFSET)
 #define CONFIG_SYS_FSL_QMAN_ADDR \
@@ -2988,6 +3234,8 @@ struct ccsr_pman {
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_BMAN_OFFSET)
 #define CONFIG_SYS_FSL_CORENET_PME_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_CORENET_PME_OFFSET)
+#define CONFIG_SYS_FSL_CORENET_DCE_ADDR \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_CORENET_DCE_OFFSET)
 #define CONFIG_SYS_FSL_RAID_ENGINE_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_RAID_ENGINE_OFFSET)
 #define CONFIG_SYS_FSL_CORENET_RMAN_ADDR \
@@ -3050,6 +3298,8 @@ struct ccsr_pman {
 	(CONFIG_SYS_IMMR + CONFIG_SYS_MPC85xx_USB2_PHY_OFFSET)
 #define CONFIG_SYS_FSL_SEC_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_SEC_OFFSET)
+#define CONFIG_SYS_FSL_JR0_ADDR \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_JR0_OFFSET)
 #define CONFIG_SYS_FSL_FM1_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_FM1_OFFSET)
 #define CONFIG_SYS_FSL_FM1_DTSEC1_ADDR \
@@ -3058,6 +3308,8 @@ struct ccsr_pman {
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_FM2_OFFSET)
 #define CONFIG_SYS_FSL_SRIO_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_SRIO_OFFSET)
+#define CONFIG_SYS_PAMU_ADDR \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_PAMU_OFFSET)
 
 #define CONFIG_SYS_PCI1_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_MPC85xx_PCI1_OFFSET)
@@ -3072,6 +3324,11 @@ struct ccsr_pman {
 #define CONFIG_SYS_PCIE4_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_MPC85xx_PCIE4_OFFSET)
 
+#define CONFIG_SYS_SFP_ADDR  \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_SFP_OFFSET)
+#define CONFIG_SYS_SNVS_ADDR  \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_SNVS_OFFSET)
+
 #define TSEC_BASE_ADDR		(CONFIG_SYS_IMMR + CONFIG_SYS_TSEC1_OFFSET)
 #define MDIO_BASE_ADDR		(CONFIG_SYS_IMMR + CONFIG_SYS_MDIO1_OFFSET)
 
@@ -3129,6 +3386,9 @@ struct ccsr_cluster_l2 {
 	u32 l2erreaddr;	/* 0xe50 L2 cache error extended address */
 	u32 l2erraddr;	/* 0xe54 L2 cache error address */
 	u32 l2errctl;	/* 0xe58 L2 cache error control */
+	u8  res_e5c[0xa4];	/* 0xe5c - 0xf00 */
+	u32 magic_f00;	/* Magic registers referred to by errata */
+	u32 magic_f04;
 };
 #define CONFIG_SYS_FSL_CLUSTER_1_L2 \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_CLUSTER_1_L2_OFFSET)
diff --git a/arch/powerpc/include/asm/mmu.h b/arch/powerpc/include/asm/mmu.h
index 2e0e292..b700a3a 100644
--- a/arch/powerpc/include/asm/mmu.h
+++ b/arch/powerpc/include/asm/mmu.h
@@ -401,8 +401,8 @@ extern void print_bats(void);
 #define MAS1_IPROT	0x40000000
 #define MAS1_TID(x)	(((x) << 16) & 0x3FFF0000)
 #define MAS1_TS		0x00001000
-#define MAS1_TSIZE(x)	(((x) << 8) & 0x00000F00)
-#define TSIZE_TO_BYTES(x) (1ULL << (((x) * 2) + 10))
+#define MAS1_TSIZE(x)	(((x) << 7) & 0x00000F80)
+#define TSIZE_TO_BYTES(x) (1ULL << ((x) + 10))
 
 #define MAS2_EPN	0xFFFFF000
 #define MAS2_X0		0x00000040
@@ -458,22 +458,38 @@ extern void print_bats(void);
 #define FSL_BOOKE_MAS7(rpn) \
 		(((u64)(rpn)) >> 32)
 
-#define BOOKE_PAGESZ_1K         0
-#define BOOKE_PAGESZ_4K         1
-#define BOOKE_PAGESZ_16K        2
-#define BOOKE_PAGESZ_64K        3
-#define BOOKE_PAGESZ_256K       4
-#define BOOKE_PAGESZ_1M         5
-#define BOOKE_PAGESZ_4M         6
-#define BOOKE_PAGESZ_16M        7
-#define BOOKE_PAGESZ_64M        8
-#define BOOKE_PAGESZ_256M       9
-#define BOOKE_PAGESZ_1G		10
-#define BOOKE_PAGESZ_4G		11
-#define BOOKE_PAGESZ_16GB	12
-#define BOOKE_PAGESZ_64GB	13
-#define BOOKE_PAGESZ_256GB	14
-#define BOOKE_PAGESZ_1TB	15
+#define BOOKE_PAGESZ_1K		0
+#define BOOKE_PAGESZ_2K		1
+#define BOOKE_PAGESZ_4K		2
+#define BOOKE_PAGESZ_8K		3
+#define BOOKE_PAGESZ_16K	4
+#define BOOKE_PAGESZ_32K	5
+#define BOOKE_PAGESZ_64K	6
+#define BOOKE_PAGESZ_128K	7
+#define BOOKE_PAGESZ_256K	8
+#define BOOKE_PAGESZ_512K	9
+#define BOOKE_PAGESZ_1M		10
+#define BOOKE_PAGESZ_2M		11
+#define BOOKE_PAGESZ_4M		12
+#define BOOKE_PAGESZ_8M		13
+#define BOOKE_PAGESZ_16M	14
+#define BOOKE_PAGESZ_32M	15
+#define BOOKE_PAGESZ_64M	16
+#define BOOKE_PAGESZ_128M	17
+#define BOOKE_PAGESZ_256M	18
+#define BOOKE_PAGESZ_512M	19
+#define BOOKE_PAGESZ_1G		20
+#define BOOKE_PAGESZ_2G		21
+#define BOOKE_PAGESZ_4G		22
+#define BOOKE_PAGESZ_8G		23
+#define BOOKE_PAGESZ_16GB	24
+#define BOOKE_PAGESZ_32GB	25
+#define BOOKE_PAGESZ_64GB	26
+#define BOOKE_PAGESZ_128GB	27
+#define BOOKE_PAGESZ_256GB	28
+#define BOOKE_PAGESZ_512GB	29
+#define BOOKE_PAGESZ_1TB	30
+#define BOOKE_PAGESZ_2TB	31
 
 #define TLBIVAX_ALL		4
 #define TLBIVAX_TLB0		0
diff --git a/arch/powerpc/include/asm/processor.h b/arch/powerpc/include/asm/processor.h
index 19fe250..64a6f9c 100644
--- a/arch/powerpc/include/asm/processor.h
+++ b/arch/powerpc/include/asm/processor.h
@@ -507,6 +507,15 @@
 #define   L2CSR0_L2IO		0x00100000	/* L2 Cache Instruction Only */
 #define   L2CSR0_L2DO		0x00010000	/* L2 Cache Data Only */
 #define   L2CSR0_L2REP		0x00003000	/* L2 Line Replacement Algo */
+
+/* e6500 */
+#define   L2CSR0_L2REP_SPLRUAGE	0x00000000	/* L2REP Streaming PLRU with Aging */
+#define   L2CSR0_L2REP_FIFO	0x00001000	/* L2REP FIFO */
+#define   L2CSR0_L2REP_SPLRU	0x00002000	/* L2REP Streaming PLRU */
+#define   L2CSR0_L2REP_PLRU	0x00003000	/* L2REP PLRU */
+
+#define   L2CSR0_L2REP_MODE	L2CSR0_L2REP_SPLRUAGE
+
 #define   L2CSR0_L2FL		0x00000800	/* L2 Cache Flush */
 #define   L2CSR0_L2LFC		0x00000400	/* L2 Cache Lock Flash Clear */
 #define   L2CSR0_L2LOA		0x00000080	/* L2 Cache Lock Overflow Allocate */
@@ -575,6 +584,16 @@
 #define SPRN_MSSSR0	0x3f7
 #endif
 
+#define SPRN_HDBCR0	0x3d0
+#define SPRN_HDBCR1	0x3d1
+#define SPRN_HDBCR2	0x3d2
+#define SPRN_HDBCR3	0x3d3
+#define SPRN_HDBCR4	0x3d4
+#define SPRN_HDBCR5	0x3d5
+#define SPRN_HDBCR6	0x3d6
+#define SPRN_HDBCR7	0x277
+#define SPRN_HDBCR8	0x278
+
 /* Short-hand versions for a number of the above SPRNs */
 
 #define CTR	SPRN_CTR	/* Counter Register */
@@ -1099,6 +1118,10 @@
 #define SVR_P5040	0x820400
 #define SVR_T4240	0x824000
 #define SVR_T4120	0x824001
+#define SVR_T4160	0x824100
+#define SVR_C291	0x850000
+#define SVR_C292	0x850020
+#define SVR_C293	0x850030
 #define SVR_B4860	0X868000
 #define SVR_G4860	0x868001
 #define SVR_G4060	0x868003
@@ -1106,6 +1129,12 @@
 #define SVR_G4440	0x868101
 #define SVR_B4420	0x868102
 #define SVR_B4220	0x868103
+#define SVR_T1040	0x852000
+#define SVR_T1041	0x852001
+#define SVR_T1042	0x852002
+#define SVR_T1020	0x852100
+#define SVR_T1021	0x852101
+#define SVR_T1022	0x852102
 
 #define SVR_8610	0x80A000
 #define SVR_8641	0x809000
@@ -1113,6 +1142,8 @@
 
 #define SVR_9130	0x860001
 #define SVR_9131	0x860000
+#define SVR_9132	0x861000
+#define SVR_9232	0x861400
 
 #define SVR_Unknown	0xFFFFFF
 
@@ -1172,6 +1203,8 @@ struct cpu_type {
 struct cpu_type *identify_cpu(u32 ver);
 int fixup_cpu(void);
 
+int fsl_qoriq_core_to_cluster(unsigned int core);
+
 #if defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx)
 #define CPU_TYPE_ENTRY(n, v, nc) \
 	{ .name = #n, .soc_ver = SVR_##v, .num_cores = (nc), \
diff --git a/arch/powerpc/include/asm/types.h b/arch/powerpc/include/asm/types.h
index b27a6b7..ec9a4c3 100644
--- a/arch/powerpc/include/asm/types.h
+++ b/arch/powerpc/include/asm/types.h
@@ -41,8 +41,11 @@ typedef unsigned long long u64;
 
 #define BITS_PER_LONG 32
 
-/* DMA addresses are 32-bits wide */
+#ifdef CONFIG_PHYS_64BIT
+typedef unsigned long long dma_addr_t;
+#else
 typedef u32 dma_addr_t;
+#endif
 
 #ifdef CONFIG_PHYS_64BIT
 typedef unsigned long long phys_addr_t;
diff --git a/arch/powerpc/lib/board.c b/arch/powerpc/lib/board.c
index 5595329..779f5a4 100644
--- a/arch/powerpc/lib/board.c
+++ b/arch/powerpc/lib/board.c
@@ -130,6 +130,11 @@ ulong monitor_flash_len;
 #include <bedbug/type.h>
 #endif
 
+/*onie*/
+#include <sys_eeprom.h>
+extern int populate_env(char *env_name,  u8 type_code);
+extern int mac_read_from_eeprom(void);
+
 /*
  * Utilities
  */
@@ -624,6 +629,7 @@ void board_init_f(ulong bootflag)
 	/* NOTREACHED - relocate_code() does not return */
 }
 
+
 /*
  * This is the next part if the initialization sequence: we are now
  * running from RAM and have a "normal" C environment, i. e. global
@@ -857,7 +863,15 @@ void board_init_r(gd_t *id, ulong dest_addr)
 #endif
 
 #ifdef CONFIG_POPULATE_SERIAL_NUMBER
-	populate_serial_number();
+    /* serial# */
+    /*populate_serial_number();*/
+    populate_env("serial#", TLV_CODE_SERIAL_NUMBER);
+
+    /* onie_platform */
+    populate_env("onie_platform", TLV_CODE_PLATFORM_NAME);
+
+    /* onie_version */
+    populate_env("onie_version", TLV_CODE_ONIE_VERSION);
 #endif
 
 #ifdef	CONFIG_HERMES
diff --git a/arch/powerpc/lib/bootm.c b/arch/powerpc/lib/bootm.c
index 78ac9e7..7088293 100644
--- a/arch/powerpc/lib/bootm.c
+++ b/arch/powerpc/lib/bootm.c
@@ -293,11 +293,6 @@ static int boot_body_linux(bootm_headers_t *images)
 		ft_board_setup(*of_flat_tree, gd->bd);
 #endif
 
-#if defined(CONFIG_FDT_ENV_SIZE) && defined(CONFIG_ENV_SIZE)
-		do_fixup_by_prop_u32(*of_flat_tree, "label", "uboot-env", 10,
-				     "env_size", CONFIG_ENV_SIZE, 1);
-#endif
-
 		/* Delete the old LMB reservation */
 		lmb_free(lmb, (phys_addr_t)(u32)*of_flat_tree,
 				(phys_size_t)fdt_totalsize(*of_flat_tree));
diff --git a/board/freescale/as6700_32x/Makefile b/board/freescale/as6700_32x/Makefile
new file mode 100644
index 0000000..f040270
--- /dev/null
+++ b/board/freescale/as6700_32x/Makefile
@@ -0,0 +1,49 @@
+#
+# Copyright 2011 Freescale Semiconductor, Inc.
+# (C) Copyright 2001-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y += cpld.o
+COBJS-y	+= ddr.o
+COBJS-y	+= eth.o
+COBJS-$(CONFIG_FASTPATH) += bootf.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/as6700_32x/README b/board/freescale/as6700_32x/README
new file mode 100644
index 0000000..292d0d3
--- /dev/null
+++ b/board/freescale/as6700_32x/README
@@ -0,0 +1,123 @@
+Overview
+=========
+The P2041 Processor combines four Power Architecture processor cores
+with high-performance datapath acceleration architecture(DPAA), CoreNet
+fabric infrastructure, as well as network and peripheral bus interfaces
+required for networking, telecom/datacom, wireless infrastructure, and
+military/aerospace applications.
+
+P2041RDB board is a quad core platform supporting the P2041 processor
+of QorIQ DPAA series.
+
+Boot from NOR flash
+===================
+1. Build image
+	make P2041RDB_config
+	make all
+
+2. Program image
+	=> tftp 1000000 u-boot.bin
+	=> protect off all
+	=> erase eff80000 efffffff
+	=> cp.b 1000000 eff80000 80000
+
+3. Program RCW
+	=> tftp 1000000 rcw.bin
+	=> protect off all
+	=> erase e8000000 e801ffff
+	=> cp.b 1000000 e8000000 50
+
+4. Program FMAN Firmware ucode
+	=> tftp 1000000 ucode.bin
+	=> protect off all
+	=> erase ef000000 ef0fffff
+	=> cp.b 1000000 ef000000 2000
+
+5. Change DIP-switch
+	SW1[1-5] = 10110
+	Note: 1 stands for 'on', 0 stands for 'off'
+
+Boot from SDCard
+===================
+1. Build image
+	make P2041RDB_SDCARD_config
+	make all
+
+2. Generate PBL imge
+   Use PE tool to produce a image used to be programed to
+   SDCard which contains RCW and U-Boot image.
+
+3. Program the PBL image to SDCard
+	=> tftp 1000000 pbl_sd.bin
+	=> mmcinfo
+	=> mmc write 1000000 8 441
+
+4. Program FMAN Firmware ucode
+	=> tftp 1000000 ucode.bin
+	=> mmc write 1000000 46a 10
+
+5. Change DIP-switch
+	SW1[1-5] = 01100
+	Note: 1 stands for 'on', 0 stands for 'off'
+
+Boot from SPI flash
+===================
+1. Build image
+	make P2041RDB_SPIFLASH_config
+	make all
+
+2. Generate PBL imge
+   Use PE tool to produce a image used to be programed to
+   SPI flash which contains RCW and U-Boot image.
+
+3. Program the PBL image to SPI flash
+	=> tftp 1000000 pbl_spi.bin
+	=> spi probe 0
+	=> sf erase 0 100000
+	=> sf write 1000000 0 $filesize
+
+4. Program FMAN Firmware ucode
+	=> tftp 1000000 ucode.bin
+	=> sf erase 110000 10000
+	=> sf write 1000000 110000 $filesize
+
+5. Change DIP-switch
+	SW1[1-5] = 10100
+	Note: 1 stands for 'on', 0 stands for 'off'
+
+CPLD command
+============
+The CPLD is used to control the power sequence and some serdes lane
+mux function.
+
+cpld reset			 - hard reset to default bank
+cpld reset altbank		 - reset to alternate bank
+cpld lane_mux <lane> <mux_value> - set multiplexed lane pin
+		lane 6: 0 -> slot1 (Default)
+			1 -> SGMII
+		lane a: 0 -> slot2 (Default)
+			1 -> AURORA
+		lane c: 0 -> slot2 (Default)
+			1 -> SATA0
+		lane d: 0 -> slot2 (Default)
+			1 -> SATA1
+
+Using the Device Tree Source File
+=================================
+To create the DTB (Device Tree Binary) image file, use a command
+similar to this:
+	dtc -O dtb -b 0 -p 1024 p2041rdb.dts > p2041rdb.dtb
+
+Or use the following command:
+	{linux-2.6}/make p2041rdb.dtb ARCH=powerpc
+
+then the dtb file will be generated under the following directory:
+	{linux-2.6}/arch/powerpc/boot/p2041rdb.dtb
+
+Booting Linux
+=============
+Place a linux uImage in the TFTP disk area.
+	tftp 1000000 uImage
+	tftp 2000000 rootfs.ext2.gz.uboot
+	tftp 3000000 p2041rdb.dtb
+	bootm 1000000 2000000 3000000
diff --git a/board/freescale/as6700_32x/as6700_32x.c b/board/freescale/as6700_32x/as6700_32x.c
new file mode 100644
index 0000000..42041cb
--- /dev/null
+++ b/board/freescale/as6700_32x/as6700_32x.c
@@ -0,0 +1,843 @@
+/*
+ * Copyright 2011,2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <fm_eth.h>
+#include <i2c.h>
+
+extern void pci_of_setup(void *blob, bd_t *bd);
+
+#include "cpld.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+/*
+	u8 sw;
+	struct cpu_type *cpu = gd->cpu;
+	unsigned int i;
+*/
+
+	printf("Board: %s\n", CONFIG_BOARDNAME);
+/*
+	printf("CPLD version: %d.%d ", CPLD_READ(cpld_ver),
+			CPLD_READ(cpld_ver_sub));
+
+	sw = CPLD_READ(fbank_sel);
+	printf("vBank: %d\n", sw & 0x1);
+*/
+
+	/*
+	 * Display the actual SERDES reference clocks as configured by the
+	 * dip switches on the board.  Note that the SWx registers could
+	 * technically be set to force the reference clocks to match the
+	 * values that the SERDES expects (or vice versa).  For now, however,
+	 * we just display both values and hope the user notices when they
+	 * don't match.
+	 */
+/*
+	puts("SERDES Reference Clocks: ");
+	sw = in_8(&CPLD_SW(2)) >> 2;
+	for (i = 0; i < 2; i++) {
+		static const char * const freq[][3] = {{"0", "100", "125"},
+						{"100", "156.25", "125"}
+		};
+		unsigned int clock = (sw >> (2 * i)) & 3;
+
+		if ((i == 1) && (CPLD_READ(pcba_ver) >= 5))
+			printf("Bank%u=%sMhz ", i+1, freq[i-1][clock]);
+		else
+			printf("Bank%u=%sMhz ", i+1, freq[i][clock]);
+	}
+
+	puts("\n");
+*/
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	/* board only uses the DDR_MCK0/1, so disable the DDR_MCK2/3 */
+	setbits_be32(&gur->ddrclkdr, 0x000f000f);
+
+	return 0;
+}
+
+#define CPLD_LANE_A_SEL	0x1
+#define CPLD_LANE_G_SEL	0x2
+#define CPLD_LANE_C_SEL	0x4
+#define CPLD_LANE_D_SEL	0x8
+
+void board_config_lanes_mux(void)
+{
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+	int srds_prtcl = (in_be32(&gur->rcwsr[4]) &
+				FSL_CORENET_RCWSR4_SRDS_PRTCL) >> 26;
+
+	u8 mux = 0;
+	switch (srds_prtcl) {
+	case 0x2:
+	case 0x5:
+	case 0x9:
+	case 0xa:
+	case 0xf:
+		break;
+	case 0x8:
+		mux |= CPLD_LANE_C_SEL | CPLD_LANE_D_SEL;
+		break;
+	case 0x14:
+		mux |= CPLD_LANE_A_SEL;
+		break;
+	case 0x17:
+		mux |= CPLD_LANE_G_SEL;
+		break;
+	case 0x16:
+	case 0x19:
+	case 0x1a:
+		mux |= CPLD_LANE_G_SEL | CPLD_LANE_C_SEL | CPLD_LANE_D_SEL;
+		break;
+	case 0x1c:
+		mux |= CPLD_LANE_G_SEL | CPLD_LANE_A_SEL;
+		break;
+	default:
+		printf("Fman:Unsupported SerDes Protocol 0x%02x\n", srds_prtcl);
+		break;
+	}
+	/*CPLD_WRITE(serdes_mux, mux);*/
+}
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash + promjet */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_256M, 1);
+
+	set_liodns();
+	setup_portals();
+	board_config_lanes_mux();
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(unsigned long dummy)
+{
+#if 0
+	u8 sysclk_conf = CPLD_READ(sysclk_sw1);
+
+	switch (sysclk_conf & 0x7) {
+	case CPLD_SYSCLK_83:
+		return 83333333;
+	case CPLD_SYSCLK_100:
+		return 100000000;
+	default:
+		return 66666666;
+	}
+#endif
+    return 83333333;
+}
+/*
+static const char *serdes_clock_to_string(u32 clock)
+{
+	switch (clock) {
+	case SRDS_PLLCR0_RFCK_SEL_100:
+		return "100";
+	case SRDS_PLLCR0_RFCK_SEL_125:
+		return "125";
+	case SRDS_PLLCR0_RFCK_SEL_156_25:
+		return "156.25";
+	default:
+		return "150";
+	}
+}
+*/
+#define NUM_SRDS_BANKS	2
+
+int misc_init_r(void)
+{
+#if 0
+	serdes_corenet_t *regs = (void *)CONFIG_SYS_FSL_CORENET_SERDES_ADDR;
+	u32 actual[NUM_SRDS_BANKS];
+	unsigned int i;
+	u8 sw;
+	static const int freq[][3] = {
+		{0, SRDS_PLLCR0_RFCK_SEL_100, SRDS_PLLCR0_RFCK_SEL_125},
+		{SRDS_PLLCR0_RFCK_SEL_100, SRDS_PLLCR0_RFCK_SEL_156_25,
+			SRDS_PLLCR0_RFCK_SEL_125}
+	};
+
+	sw = in_8(&CPLD_SW(2)) >> 2;
+	for (i = 0; i < NUM_SRDS_BANKS; i++) {
+		unsigned int clock = (sw >> (2 * i)) & 3;
+		if (clock == 0x3) {
+			printf("Warning: SDREFCLK%u switch setting of '11' is "
+			       "unsupported\n", i + 1);
+			break;
+		}
+		if (i == 0 && clock == 0)
+			puts("Warning: SDREFCLK1 switch setting of"
+				"'00' is unsupported\n");
+		else
+			actual[i] = freq[i][clock];
+
+		/*
+		 * RevD(x) board has a different clock setting with RevC(x)
+		 * board, CPLD on RevD(x) board has pcba_ver = 5. RevC(x)
+		 * board has pcba_ver = 4, it can be used to distinguish
+		 * the two boards.
+		 */
+		if ((i == 1) && (CPLD_READ(pcba_ver) >= 5))
+			/* RevD(x) board bank2 frequency */
+			actual[i] = freq[i-1][clock];
+	}
+
+	for (i = 0; i < NUM_SRDS_BANKS; i++) {
+		u32 expected = in_be32(&regs->bank[i].pllcr0);
+		expected &= SRDS_PLLCR0_RFCK_SEL_MASK;
+		if (expected != actual[i]) {
+			printf("Warning: SERDES bank %u expects reference clock"
+			       " %sMHz, but actual is %sMHz\n", i + 1,
+			       serdes_clock_to_string(expected),
+			       serdes_clock_to_string(actual[i]));
+		}
+	}
+#endif
+	return 0;
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB)
+	fdt_fixup_dr_usb(blob, bd);
+#endif
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+#endif
+}
+
+static int do_usbiddev(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int devno;
+    int target = -1;
+    block_dev_desc_t *blk_dev;
+    char val[2];
+
+    /*
+     * The internal USB NAND flash drive is connected to the
+     * internal hub such that the NAND device always appears as
+     * the *last* mass storage device.
+     *
+     * Sure this is dependent on the depth-first USB topology
+     * enumeration strategy, but that is not going to change.
+     */
+    for (devno = 0; ; ++devno) {
+        blk_dev = usb_stor_get_dev(devno);
+        if (blk_dev == NULL)
+            break;
+        if ( (blk_dev->if_type == IF_TYPE_USB) &&
+             !blk_dev->removable &&
+             ((blk_dev->type & 0x1F) == DEV_TYPE_HARDDISK) ) {
+            target = devno;
+        }
+    }
+
+    if (target == -1) {
+        printf("Error: Unable to detect internal USB flash device.\n");
+        printf("Perhaps you forgot to run 'usb start' ?\n");
+        return 1;
+    }
+
+    if (target > 9) {
+        printf("Error: Unexpectedly large device number: %d.\n", target);
+        return 1;
+    }
+
+    val[0] = '0' + target;
+    val[1] = 0;
+
+    setenv("usbdev", val);
+
+    return 0;
+}
+
+U_BOOT_CMD(
+    usbiddev,   3,  1,  do_usbiddev,
+    "Identify internal USB NAND flash device number and set\n"
+    "environment variable 'usbdev' to that number.",
+    ""
+);
+
+/*
+ * set USB1 0x214010: 0x0 (eUSB)
+ * set USB2 0x214110: 0x0 (front panel)
+ *
+ * for eye diagram adjustment
+ *
+ *  To increase the TX voltage on USB port 2:
+ *  0xFE00_0000 is CCSR BAR
+ *  USB1 PHY offset is 0x214000
+ *  USB2 PHY offset is 0x214100
+ *
+ *  increase the TX voltage of 40 mV by setting:
+ *      mw fe214110 0000000e
+ *
+ *    The value for the last 4 digits:
+ *    00000008;  ( HSTX – 3 )   -60 mV
+ *    00000009;  ( HSTX – 2 )   -40 mV
+ *    0000000a;  ( HSTX – 1 )   -0 mV
+ *    0000000b;  ( default untrimmed )  0
+ *    0000000c;  ( default untrimmed )  0
+ *    0000000d;  ( HSTX + 1 )  +0 mV
+ *    0000000e;  ( HSTX + 2 )   +40 mV
+ *    0000000f;  ( HSTX + 3 )   +60 mV
+ */
+void set_USB_TX_voltage(void)
+{
+    ulong *usb1_tx_voltage_reg = (ulong *)0xfe214010;
+    ulong *usb2_tx_voltage_reg = (ulong *)0xfe214110;
+    ulong val;
+
+    val = 0x0;
+    *usb1_tx_voltage_reg = val;
+
+    udelay(1000);
+
+    val = 0x0;
+    *usb2_tx_voltage_reg = val;
+}
+
+extern const char *miiphy_get_current_dev(void);
+extern int miiphy_read(const char *devname, unsigned char addr, unsigned char reg, unsigned short *value);
+extern int miiphy_write(const char *devname, unsigned char addr, unsigned char reg, unsigned short value);
+
+/*
+ * exchange two led function of mgmt port on mainboard
+ * left side is link LED
+ * right side is active LED
+ */
+void exchange_mgmt_led_func(void)
+{
+    const char *curr_devname;
+    unsigned char addr, reg;
+    unsigned short data;
+
+    curr_devname = miiphy_get_current_dev();
+    if(NULL==curr_devname)
+    {
+        printf("miiphy_get_current_dev() return NULL\n");
+        return;
+    }
+
+    addr = 0x1;
+    reg = 0x1c;
+    data = 0xb801;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    addr = 0x1;
+    reg = 0x1c;
+    data = 0xb430;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+}
+
+/*
+mii write 0x1e 0x9 0x300
+mii write 0x1e 0x4 0x1e1
+mii write 0x1e 0x0 0x0
+mii write 0x1e 0x0 0x1040
+
+mii write 0x1 0x9 0x300
+mii write 0x1 0x4 0x1e1
+mii write 0x1 0x0 0x0
+mii write 0x1 0x0 0x1040
+ */
+void set_mgmt_port_link_capability(unsigned char addr)
+{
+    const char *curr_devname;
+    unsigned char reg;
+    unsigned short data;
+
+    curr_devname = miiphy_get_current_dev();
+    if(NULL==curr_devname)
+    {
+        printf("miiphy_get_current_dev() return NULL\n");
+        return;
+    }
+
+    /* 1G F/H capability */
+    reg = 0x9;
+    data = 0x300;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    /* 100M/10M F/H capability */
+    reg = 0x4;
+    data = 0x1e1;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    /*disable auto-nego*/
+    reg = 0x0;
+    data = 0x0;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    /*enable auto-nego*/
+    reg = 0x0;
+    data = 0x1040;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    return;
+}
+
+/*
+ * (front mgmt) phy output amplitude 0xa => 0xf
+ * mii write 0x01 0x17 0x0f52
+ * mii write 0x01 0x15 0x00f0
+ * (cpu mgmt) phy output amplitude 0xa => 0xf
+ * mii write 0x1e 0x17 0x0f52
+ * mii write 0x1e 0x15 0x00f0
+ */
+void set_SGMII_amplitude(void)
+{
+    const char *curr_devname;
+    unsigned char addr, reg;
+    unsigned short data;
+
+    curr_devname = miiphy_get_current_dev();
+    if(NULL==curr_devname)
+    {
+        printf("miiphy_get_current_dev() return NULL\n");
+        return;
+    }
+
+    addr = 0x1;
+    reg = 0x17;
+    data = 0x0f52;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    addr = 0x1;
+    reg = 0x15;
+    data = 0x00f0;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    addr = 0x1e;
+    reg = 0x17;
+    data = 0x0f52;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    addr = 0x1e;
+    reg = 0x15;
+    data = 0x00f0;
+    if(0 != miiphy_write(curr_devname, addr, reg, data))
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n", addr, reg);
+        return;
+    }
+
+    return;
+}
+
+
+#define MAX_NUM_OF_MODULE 2
+#define M1_PRESENT_L 0x1
+#define M2_PRESENT_L 0x2
+
+void reset_QSFP_module(int module_id, u8 module_sel)
+{
+    u8 data;
+    int rc = 0;
+    int module_not_present;
+    u8 module_present[MAX_NUM_OF_MODULE] = {M1_PRESENT_L, M2_PRESENT_L};
+
+    if(module_id>MAX_NUM_OF_MODULE)
+    {
+        printf("Bad parameter: module_id.\n");
+        return;
+    }
+
+    /* Is module present or not */
+    rc = i2c_read(0x31, 0x03, 1, &data, 1);
+    if(rc==0)
+    {
+        module_not_present = module_present[module_id-1] & data;
+
+        printf("QSFP module %d is %spresent.\n",
+            module_id, (module_not_present ? "not " : ""));
+
+        if(module_not_present)
+            return;
+    }
+    else
+    {
+        printf("error: i2c_read()\n");
+        return;
+    }
+
+    /* reset mode */
+    rc=i2c_write(0x31, 0x60, 1, &module_sel, 1);  /* select Module 1 or 2 */
+    data=0x00; rc+=i2c_write(0x20, 0x18, 1, &data, 1);  /* config to output */
+    data=0x00; rc+=i2c_write(0x20, 0x08, 1, &data, 1);  /* reset port 0~5 */
+    if(0 != rc) {
+        printf("error: QSFP Module %d reset mode\n", module_id);
+        return;
+    }
+
+    /* interval 1000 us, spec>2us */
+	udelay(1000);
+
+    /* normal mode */
+    rc=i2c_write(0x31, 0x60, 1, &module_sel, 1);
+    data=0x00; rc+=i2c_write(0x20, 0x18, 1, &data, 1);
+    data=0x3f; rc+=i2c_write(0x20, 0x08, 1, &data, 1);
+    if(0 != rc) {
+        printf("error: QSFP Module %d normal mode\n", module_id);
+        return;
+    }
+
+	/* Configure IO expander */
+    /* Disable LPmode, Clear MODSEL bit, 2-wire serial, Configure interrupt */
+    rc=i2c_write(0x31, 0x60, 1, &module_sel, 1);
+    data=0x00; rc+=i2c_write(0x20, 0x19, 1, &data, 1);
+    data=0x00; rc+=i2c_write(0x20, 0x09, 1, &data, 1);
+    data=0xfc; rc+=i2c_write(0x20, 0x1a, 1, &data, 1);
+    data=0x00; rc+=i2c_write(0x20, 0x0a, 1, &data, 1);
+    data=0xc0; rc+=i2c_write(0x20, 0x23, 1, &data, 1);
+    if(0 != rc) {
+        printf("error: Configure IO expander of module %d\n", module_id);
+        return;
+    }
+
+    return;
+}
+
+void reset_QSFP(void)
+{
+    u8 data, rov;
+    uchar dev;
+    int rc = 0;
+
+    rc=i2c_set_bus_num(1);
+    if(0 != rc)
+    {
+        printf("i2c set bus error!\n");
+        return;
+    }
+
+    dev = 0x31;
+    rc=i2c_probe(dev);
+    if(0 != rc)
+    {
+        printf("i2c probe 0x%02x error\n", dev);
+        return;
+    }
+
+    /* read ROV */
+    i2c_read(0x31, 0xa, 1, &data, 1);
+
+    /* set VID based on ROV(recommended operation voltage) */
+    if(0x2==data)
+    {
+        rov=0x90; /* 0.95v */
+    }
+    else
+    {
+        rov=0x60; /* 1.025v */
+    }
+
+    /* QSFP reset mode */
+    data=0x0;       rc+=i2c_write(0x31, 0x24, 1, &data, 1); /*reset port 0~7*/
+    data=0x0;       rc+=i2c_write(0x31, 0x25, 1, &data, 1); /*reset port 8~15*/
+    data=rov|0x0;   rc+=i2c_write(0x31, 0x26, 1, &data, 1); /*reset port 16~19*/
+    if(0 != rc)
+    {
+        printf("error: QSFP reset mode\n");
+        return;
+    }
+
+    udelay(1000); /* interval 1000 us, spec>2us */
+
+    /* QSFP normal mode */
+    data=0xff;    rc+=i2c_write(0x31, 0x24, 1, &data, 1);
+    data=0xff;    rc+=i2c_write(0x31, 0x25, 1, &data, 1);
+    data=rov|0xf; rc+=i2c_write(0x31, 0x26, 1, &data, 1);
+    if(0 != rc)
+    {
+        printf("error: QSFP normal mode\n");
+        return;
+    }
+
+	/* waiting for the module 1&2 power-up */
+    udelay(10000);
+
+    reset_QSFP_module(1, 0x21); /* module 1, set value = 0x21 */
+    reset_QSFP_module(2, 0x22); /* module 2, set value = 0x22 */
+
+    return;
+}
+
+void mgmtPhyReset(void)
+{
+    ulong* addr;
+    ulong val;
+
+    addr = (ulong*)0xfe110028;
+    val = 0x8;
+    *addr = val;
+
+    udelay(10000);
+
+    val = 0x100008;
+    *addr = val;
+}
+
+void module_2_led_gpio(void)
+{
+    ulong* addr;
+    ulong val;
+    u8 data;
+    int rc=0;
+
+    rc=i2c_set_bus_num(1);
+    if(0 != rc)
+    {
+        printf("i2c set bus error!\n");
+        return;
+    }
+
+    /* i2c mw 0x31 0x21 0x10 */
+    data=0x10; rc+=i2c_write(0x31, 0x21, 1, &data, 1);
+    /* i2c mw 0x31 0x22 0x10 */
+    data=0x10; rc+=i2c_write(0x31, 0x22, 1, &data, 1);
+
+    if(rc!=0)
+        printf("line: %d,error: Enable Module power , rc=%d\n", __LINE__, rc);
+
+    udelay(5000);
+
+    /* set GPIO 0,1,2,3,23,24,29,30,31 pin as output; GPIO 21,22,25,26,27,28(and else(not GPIO)) as input*/
+    addr = (ulong*) 0xfe130000;
+    val = 0xf0000187;
+    *addr = val;
+
+    udelay(5000);
+
+	/*reset GPIO*/
+    addr = (ulong*)0xfe130008;
+    val = 0x80;
+    *addr = val;
+
+    udelay(10000);
+	udelay(10000);
+
+	/*release reset GPIO*/
+    addr = (ulong*)0xfe130008;
+    val = 0x70000187;
+    *addr = val;
+
+    return;
+}
+
+static void set_sys_led(void)
+{
+    u8 data;
+    uchar cpld_slave_addr = 0x31;
+    int rc=0;
+
+    rc=i2c_set_bus_num(1);
+    if(0 != rc) {
+        printf("i2c set bus error!\n");
+        return;
+    }
+
+    rc=i2c_probe(cpld_slave_addr);
+    if(0 != rc) {
+        printf("i2c probe 0x%02x error\n", cpld_slave_addr);
+        return;
+    }
+
+    /* force sys led and alarm led to green */
+    data=0x0a; rc+=i2c_write(cpld_slave_addr, 0x2d, 1, &data, 1);
+    if(0 != rc) {
+        printf("i2c_write() fail\n");
+        return;
+    }
+
+    return;
+}
+
+static void set_fan_speed_low_boundary(void)
+{
+    u8 data;
+    uchar cpld_slave_addr = 0x35;
+    int rc=0;
+
+    rc=i2c_set_bus_num(1);
+    if(0 != rc) {
+        printf("i2c set bus error!\n");
+        return;
+    }
+
+    rc=i2c_probe(cpld_slave_addr);
+    if(0 != rc) {
+        printf("i2c probe 0x%02x error\n", cpld_slave_addr);
+        return;
+    }
+
+    /* reg offset = 0x21, low boundary 0xc3 */
+    data=0xc3; rc+=i2c_write(cpld_slave_addr, 0x21, 1, &data, 1);
+    if(0 != rc) {
+        printf("i2c_write() fail\n");
+        return;
+    }
+
+    return;
+}
+
+int last_stage_init(void)
+{
+    unsigned char addr;
+
+ /*added for mainboard mgmt phy reset*/
+    mgmtPhyReset();
+    /* 0xfe110028 0x00000008*/
+    /* 0xfe110028 0x00100008*/
+
+/*added for mainboard module 2 led display */
+    module_2_led_gpio();
+    /* mw fe130000 03 */
+    /* mw fe130008 107 */
+    /* i2c dev 1 */
+    /* i2c mw 0x31 0x21 0x10 */
+    /* i2c mw 0x31 0x22 0x10 */
+
+    udelay(5000);
+
+/*added for exchange two led of mgmt port on mainboard*/
+    exchange_mgmt_led_func();
+
+/*added for reset whole QSFPs setting in CPLD */
+    reset_QSFP();
+
+/*added for USB eye diagram adjustment*/
+    set_USB_TX_voltage();
+
+/*added for SGMII(PHY->CPU) amplitude 0xa -> 0xf */
+    set_SGMII_amplitude();
+/*
+ * (front mgmt) phy output amplitude 0xa => 0xf
+ * mii write 0x01 0x17 0x0f52
+ * mii write 0x01 0x15 0x00f0
+ * (cpu mgmt) phy output amplitude 0xa => 0xf
+ * mii write 0x1e 0x17 0x0f52
+ * mii write 0x1e 0x15 0x00f0
+ */
+
+    addr = (unsigned char)0x1e;
+    set_mgmt_port_link_capability(addr);
+
+    addr = (unsigned char)0x1;
+    set_mgmt_port_link_capability(addr);
+
+    set_sys_led();
+
+    set_fan_speed_low_boundary();
+
+    return 0;
+}
diff --git a/board/freescale/as6700_32x/bootf.c b/board/freescale/as6700_32x/bootf.c
new file mode 100644
index 0000000..72b40b1
--- /dev/null
+++ b/board/freescale/as6700_32x/bootf.c
@@ -0,0 +1,54 @@
+/*
+* File:        bootf.c
+* Purpose:     To boot the fastpath application image.
+*
+* Notes:
+* History:
+*  2012/03/08    -- Aaron Lien, Initial version
+*
+* Copyright (C) 2012  Accton Corporation & authors.
+*/
+#include <common.h>
+#include "fastpath.h"
+
+
+/* STK image = {STK header + uImage}*/
+static int do_bootf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    char * local_argv[3];
+    ulong	addr;
+    char str_addr[30], tmp[30];
+    stkFileHeader_t *header;
+
+    /* <addr> */
+    addr = CONFIG_SYS_LOAD_ADDR;		/* Default Load Address */
+    if(argc >= 2)
+        addr = simple_strtoul(argv[1], NULL, 16);
+
+    header = (stkFileHeader_t *)addr;
+
+    addr += header->stk_header_size;    /* uImage start address */
+    sprintf(str_addr, "0x%08lX", addr);
+
+    /* <fdt#> */
+    if(argc >=3)
+        sprintf(tmp, "-f%s", argv[2]);
+    else
+        sprintf(tmp, "-f%d", CONFIG_FDT_INDEX);
+
+    /* <ex.> bootm 0x1000074 -f<fdt#> */
+    local_argv[0] = "bootm";
+    local_argv[1] = str_addr;
+    local_argv[2] = tmp;
+
+    return do_bootm(NULL, 0, 3, local_argv);
+}
+
+U_BOOT_CMD(
+    bootf, CONFIG_SYS_MAXARGS, 1,	do_bootf,
+    "bootf\t- boot FASTPATH application image from memory.",
+    "[<addr> [<fdt#>]] - boot FASTPATH application image stored in memory.\n"
+    "\taddr: image address in memory.\n"
+    "\tfdt#: image# of flat device tree in FASTPATH image.\n"
+    "\n\tThe default fdt# is 4 which indicates the fdt is at image#4."
+);
diff --git a/board/freescale/as6700_32x/cpld.c b/board/freescale/as6700_32x/cpld.c
new file mode 100644
index 0000000..fd2c7b4
--- /dev/null
+++ b/board/freescale/as6700_32x/cpld.c
@@ -0,0 +1,168 @@
+/**
+ * Copyright 2011 Freescale Semiconductor
+ * Author: Mingkai Hu <Mingkai.hu@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This file provides support for the board-specific CPLD used on some Freescale
+ * reference boards.
+ *
+ * The following macros need to be defined:
+ *
+ * CPLD_BASE - The virtual address of the base of the CPLD register map
+ *
+ */
+
+
+#if defined(CPLD_BASE)
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+
+#include "cpld.h"
+
+static u8 __cpld_read(unsigned int reg)
+{
+	void *p = (void *)CPLD_BASE;
+
+	return in_8(p + reg);
+}
+u8 cpld_read(unsigned int reg) __attribute__((weak, alias("__cpld_read")));
+
+static void __cpld_write(unsigned int reg, u8 value)
+{
+	void *p = (void *)CPLD_BASE;
+
+	out_8(p + reg, value);
+}
+void cpld_write(unsigned int reg, u8 value)
+	__attribute__((weak, alias("__cpld_write")));
+
+/*
+ * Reset the board. This honors the por_cfg registers.
+ */
+void __cpld_reset(void)
+{
+	CPLD_WRITE(system_rst, 1);
+}
+void cpld_reset(void) __attribute__((weak, alias("__cpld_reset")));
+
+/**
+ * Set the boot bank to the alternate bank
+ */
+void __cpld_set_altbank(void)
+{
+	u8 reg5 = CPLD_READ(sw_ctl_on);
+
+	CPLD_WRITE(sw_ctl_on, reg5 | CPLD_SWITCH_BANK_ENABLE);
+	CPLD_WRITE(fbank_sel, 1);
+	CPLD_WRITE(system_rst, 1);
+}
+void cpld_set_altbank(void)
+	__attribute__((weak, alias("__cpld_set_altbank")));
+
+/**
+ * Set the boot bank to the default bank
+ */
+void __cpld_set_defbank(void)
+{
+	CPLD_WRITE(system_rst_default, 1);
+}
+void cpld_set_defbank(void)
+	__attribute__((weak, alias("__cpld_set_defbank")));
+
+#ifdef DEBUG
+static void cpld_dump_regs(void)
+{
+	printf("cpld_ver	= 0x%02x\n", CPLD_READ(cpld_ver));
+	printf("cpld_ver_sub	= 0x%02x\n", CPLD_READ(cpld_ver_sub));
+	printf("pcba_ver	= 0x%02x\n", CPLD_READ(pcba_ver));
+	printf("system_rst	= 0x%02x\n", CPLD_READ(system_rst));
+	printf("sw_ctl_on	= 0x%02x\n", CPLD_READ(sw_ctl_on));
+	printf("por_cfg		= 0x%02x\n", CPLD_READ(por_cfg));
+	printf("switch_strobe	= 0x%02x\n", CPLD_READ(switch_strobe));
+	printf("jtag_sel	= 0x%02x\n", CPLD_READ(jtag_sel));
+	printf("sdbank1_clk	= 0x%02x\n", CPLD_READ(sdbank1_clk));
+	printf("sdbank2_clk	= 0x%02x\n", CPLD_READ(sdbank2_clk));
+	printf("fbank_sel	= 0x%02x\n", CPLD_READ(fbank_sel));
+	printf("serdes_mux	= 0x%02x\n", CPLD_READ(serdes_mux));
+	printf("SW[2]		= 0x%02x\n", in_8(&CPLD_SW(2)));
+	putc('\n');
+}
+#endif
+
+int cpld_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rc = 0;
+
+	if (argc <= 1)
+		return cmd_usage(cmdtp);
+
+	if (strcmp(argv[1], "reset") == 0) {
+		if (strcmp(argv[2], "altbank") == 0)
+			cpld_set_altbank();
+		else
+			cpld_set_defbank();
+	} else if (strcmp(argv[1], "lane_mux") == 0) {
+		u32 lane = simple_strtoul(argv[2], NULL, 16);
+		u8 val = (u8)simple_strtoul(argv[3], NULL, 16);
+		u8 reg = CPLD_READ(serdes_mux);
+
+		switch (lane) {
+		case 0x6:
+			reg &= ~SERDES_MUX_LANE_6_MASK;
+			reg |= val << SERDES_MUX_LANE_6_SHIFT;
+			break;
+		case 0xa:
+			reg &= ~SERDES_MUX_LANE_A_MASK;
+			reg |= val << SERDES_MUX_LANE_A_SHIFT;
+			break;
+		case 0xc:
+			reg &= ~SERDES_MUX_LANE_C_MASK;
+			reg |= val << SERDES_MUX_LANE_C_SHIFT;
+			break;
+		case 0xd:
+			reg &= ~SERDES_MUX_LANE_D_MASK;
+			reg |= val << SERDES_MUX_LANE_D_SHIFT;
+			break;
+		default:
+			printf("Invalid value\n");
+			break;
+		}
+
+		CPLD_WRITE(serdes_mux, reg);
+#ifdef DEBUG
+	} else if (strcmp(argv[1], "dump") == 0) {
+		cpld_dump_regs();
+#endif
+	} else
+		rc = cmd_usage(cmdtp);
+
+	return rc;
+}
+
+U_BOOT_CMD(
+	cpld_cmd, CONFIG_SYS_MAXARGS, 1, cpld_cmd,
+	"Reset the board or pin mulexing selection using the CPLD sequencer",
+	"reset - hard reset to default bank\n"
+	"cpld_cmd reset altbank - reset to alternate bank\n"
+	"cpld_cmd lane_mux <lane> <mux_value> - set multiplexed lane pin\n"
+	"	lane 6: 0 -> slot1\n"
+	"		1 -> SGMII (Default)\n"
+	"	lane a: 0 -> slot2\n"
+	"		1 -> AURORA (Default)\n"
+	"	lane c: 0 -> slot2\n"
+	"		1 -> SATA0 (Default)\n"
+	"	lane d: 0 -> slot2\n"
+	"		1 -> SATA1 (Default)\n"
+#ifdef DEBUG
+	"cpld_cmd dump - display the CPLD registers\n"
+#endif
+	);
+
+
+#endif
diff --git a/board/freescale/as6700_32x/cpld.h b/board/freescale/as6700_32x/cpld.h
new file mode 100644
index 0000000..2e3e7b1
--- /dev/null
+++ b/board/freescale/as6700_32x/cpld.h
@@ -0,0 +1,58 @@
+/**
+ * Copyright 2011 Freescale Semiconductor
+ * Author: Mingkai Hu <Mingkai.hu@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This file provides support for the ngPIXIS, a board-specific FPGA used on
+ * some Freescale reference boards.
+ */
+
+/*
+ * CPLD register set. Feel free to add board-specific #ifdefs where necessary.
+ */
+typedef struct cpld_data {
+	u8 cpld_ver;		/* 0x0 - CPLD Major Revision Register */
+	u8 cpld_ver_sub;	/* 0x1 - CPLD Minor Revision Register */
+	u8 pcba_ver;		/* 0x2 - PCBA Revision Register */
+	u8 system_rst;		/* 0x3 - system reset register */
+	u8 res0;		/* 0x4 - not used */
+	u8 sw_ctl_on;		/* 0x5 - Switch Control Enable Register */
+	u8 por_cfg;		/* 0x6 - POR Control Register */
+	u8 switch_strobe;	/* 0x7 - Multiplexed pin Select Register */
+	u8 jtag_sel;		/* 0x8 - JTAG or AURORA Selection */
+	u8 sdbank1_clk;		/* 0x9 - SerDes Bank1 Reference clock */
+	u8 sdbank2_clk;		/* 0xa - SerDes Bank2 Reference clock */
+	u8 fbank_sel;		/* 0xb - Flash bank selection */
+	u8 serdes_mux;		/* 0xc - Multiplexed pin Select Register */
+	u8 sw[1];		/* 0xd - SW2 Status */
+	u8 system_rst_default;	/* 0xe - system reset to default register */
+	u8 sysclk_sw1;		/* 0xf - sysclk configuration register */
+} __attribute__ ((packed)) cpld_data_t;
+
+#define SERDES_MUX_LANE_6_MASK	0x2
+#define SERDES_MUX_LANE_6_SHIFT	1
+#define SERDES_MUX_LANE_A_MASK	0x1
+#define SERDES_MUX_LANE_A_SHIFT	0
+#define SERDES_MUX_LANE_C_MASK	0x4
+#define SERDES_MUX_LANE_C_SHIFT	2
+#define SERDES_MUX_LANE_D_MASK	0x8
+#define SERDES_MUX_LANE_D_SHIFT	3
+#define CPLD_SWITCH_BANK_ENABLE	0x40
+#define CPLD_SYSCLK_83		0x1	/* system clock 83.3MHz */
+#define CPLD_SYSCLK_100		0x2	/* system clock 100MHz */
+
+/* Pointer to the CPLD register set */
+#define cpld ((cpld_data_t *)CPLD_BASE)
+
+/* The CPLD SW register that corresponds to board switch X, where x >= 1 */
+#define CPLD_SW(x)		(cpld->sw[(x) - 2])
+
+u8 cpld_read(unsigned int reg);
+void cpld_write(unsigned int reg, u8 value);
+
+#define CPLD_READ(reg) cpld_read(offsetof(cpld_data_t, reg))
+#define CPLD_WRITE(reg, value) cpld_write(offsetof(cpld_data_t, reg), value)
diff --git a/board/freescale/as6700_32x/ddr.c b/board/freescale/as6700_32x/ddr.c
new file mode 100644
index 0000000..61648d9
--- /dev/null
+++ b/board/freescale/as6700_32x/ddr.c
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 as published by the Free Software Foundation.
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <hwconfig.h>
+#include <asm/mmu.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+#include <asm/fsl_law.h>
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 cpo;
+	u32 write_data_delay;
+	u32 force_2T;
+};
+
+/*
+ * This table contains all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ *
+ * ranges for parameters:
+ *  wr_data_delay = 0-6
+ *  clk adjust = 0-8
+ *  cpo 2-0x1E (30)
+ */
+static const struct board_specific_parameters dimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi|  clk| wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz|adjst| start | delay|
+	 */
+    {1,  1350,    5,     7,   0xff,    2,  0}, /* added this entry, num_ranks=1 is known for sure,
+                                                  but the others fileds are uncertain, need to check */
+	{2,   750,    3,     5,   0xff,    2,  0},
+	{2,  1250,    4,     6,   0xff,    2,  0},
+	{2,  1350,    5,     7,   0xff,    2,  0},
+	{2,  1666,    5,     8,   0xff,    2,  0},
+	{}
+};
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num) {
+		printf("Wrong parameter for controller number %d", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = dimm0;
+
+	/*
+	 * Get clk_adjust, cpo, write_data_delay,2T, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->cpo_override = pbsp->cpo;
+				popts->write_data_delay =
+					pbsp->write_data_delay;
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->twoT_en = pbsp->force_2T;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found "
+			"for data rate %lu MT/s!\n"
+			"Trying to use the highest speed (%u) parameters\n",
+			ddr_freq, pbsp_highest->datarate_mhz_high);
+		popts->cpo_override = pbsp_highest->cpo;
+		popts->write_data_delay = pbsp_highest->write_data_delay;
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->twoT_en = pbsp_highest->force_2T;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+
+found:
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+	/* Write leveling override */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/* Rtt and Rtt_WR override */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 60 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN;
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size = 0;
+
+	puts("Initializing....");
+
+	if (fsl_use_spd()) {
+		puts("using SPD\n");
+		dram_size = fsl_ddr_sdram();
+	} else {
+		puts("no SPD and fixed parameters\n");
+		return dram_size;
+	}
+
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+
+	debug("    DDR: ");
+	return dram_size;
+}
diff --git a/board/freescale/as6700_32x/eth.c b/board/freescale/as6700_32x/eth.c
new file mode 100644
index 0000000..b0fa932
--- /dev/null
+++ b/board/freescale/as6700_32x/eth.c
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ * Author: Mingkai Hu <Mingkai.hu@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * The RGMII PHYs are provided by the two on-board PHY. The SGMII PHYs
+ * are provided by the three on-board PHY or by the standard Freescale
+ * four-port SGMII riser card. We need to change the phy-handle in the
+ * kernel dts file to point to the correct PHY according to serdes mux
+ * and serdes protocol selection.
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/fsl_serdes.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+#include <asm/fsl_dtsec.h>
+
+#include "cpld.h"
+#include "../common/fman.h"
+
+#ifdef CONFIG_FMAN_ENET
+/*
+ * Mapping of all 18 SERDES lanes to board slots. A value of '0' here means
+ * that the mapping must be determined dynamically, or that the lane maps to
+ * something other than a board slot
+ */
+static u8 lane_to_slot[] = {
+	0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0
+};
+
+static int riser_phy_addr[] = {
+	CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR,
+	CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR,
+	CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR,
+	CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR,
+};
+
+/*
+ * Initialize the lane_to_slot[] array.
+ *
+ * On the P2040RDB board the mapping is controlled by CPLD register.
+ */
+static void initialize_lane_to_slot(void)
+{
+/*
+	u8 mux = CPLD_READ(serdes_mux);
+
+	lane_to_slot[6] = (mux & SERDES_MUX_LANE_6_MASK) ? 0 : 1;
+	lane_to_slot[10] = (mux & SERDES_MUX_LANE_A_MASK) ? 0 : 2;
+	lane_to_slot[12] = (mux & SERDES_MUX_LANE_C_MASK) ? 0 : 2;
+	lane_to_slot[13] = (mux & SERDES_MUX_LANE_D_MASK) ? 0 : 2;
+*/
+}
+
+/*
+ * Given the following ...
+ *
+ * 1) A pointer to an Fman Ethernet node (as identified by the 'compat'
+ * compatible string and 'addr' physical address)
+ *
+ * 2) An Fman port
+ *
+ * ... update the phy-handle property of the Ethernet node to point to the
+ * right PHY.  This assumes that we already know the PHY for each port.
+ *
+ * The offset of the Fman Ethernet node is also passed in for convenience, but
+ * it is not used, and we recalculate the offset anyway.
+ *
+ * Note that what we call "Fman ports" (enum fm_port) is really an Fman MAC.
+ * Inside the Fman, "ports" are things that connect to MACs.  We only call them
+ * ports in U-Boot because on previous Ethernet devices (e.g. Gianfar), MACs
+ * and ports are the same thing.
+ *
+ */
+void board_ft_fman_fixup_port(void *fdt, char *compat, phys_addr_t addr,
+			      enum fm_port port, int offset)
+{
+	phy_interface_t intf = fm_info_get_enet_if(port);
+	char phy[16];
+
+	/* The RGMII PHY is identified by the MAC connected to it */
+	if (intf == PHY_INTERFACE_MODE_RGMII) {
+		sprintf(phy, "phy_rgmii_%u", port == FM1_DTSEC5 ? 0 : 1);
+		fdt_set_phy_handle(fdt, compat, addr, phy);
+	}
+
+	/* The SGMII PHY is identified by the MAC connected to it */
+	if (intf == PHY_INTERFACE_MODE_SGMII) {
+		int lane = serdes_get_first_lane(SGMII_FM1_DTSEC1 + port);
+		u8 slot;
+		if (lane < 0)
+			return;
+		slot = lane_to_slot[lane];
+		if (slot) {
+			sprintf(phy, "phy_sgmii_%x",
+					CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR
+					+ (port - FM1_DTSEC1));
+			fdt_set_phy_handle(fdt, compat, addr, phy);
+		} else {
+			sprintf(phy, "phy_sgmii_%x",
+					CONFIG_SYS_FM1_DTSEC1_PHY_ADDR
+					+ (port - FM1_DTSEC1));
+			fdt_set_phy_handle(fdt, compat, addr, phy);
+		}
+	}
+
+	if (intf == PHY_INTERFACE_MODE_XGMII) {
+		/* XAUI */
+		int lane = serdes_get_first_lane(XAUI_FM1);
+		if (lane >= 0) {
+			/* The XAUI PHY is identified by the slot */
+			sprintf(phy, "phy_xgmii_%u", lane_to_slot[lane]);
+			fdt_set_phy_handle(fdt, compat, addr, phy);
+		}
+	}
+}
+#endif /* #ifdef CONFIG_FMAN_ENET */
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FMAN_ENET
+	struct fsl_pq_mdio_info dtsec_mdio_info;
+	struct tgec_mdio_info tgec_mdio_info;
+	unsigned int i, slot;
+	int lane;
+
+	printf("Initializing Fman\n");
+
+	initialize_lane_to_slot();
+
+	dtsec_mdio_info.regs =
+		(struct tsec_mii_mng *)CONFIG_SYS_FM1_DTSEC1_MDIO_ADDR;
+	dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the real 1G MDIO bus */
+	fsl_pq_mdio_init(bis, &dtsec_mdio_info);
+
+	tgec_mdio_info.regs =
+		(struct tgec_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the real 10G MDIO bus */
+	fm_tgec_mdio_init(bis, &tgec_mdio_info);
+
+	/*
+	 * Program the three on-board SGMII PHY addresses. If the SGMII Riser
+	 * card used, we'll override the PHY address later. For any DTSEC that
+	 * is RGMII, we'll also override its PHY address later. We assume that
+	 * DTSEC4 and DTSEC5 are used for RGMII.
+	 */
+	fm_info_set_phy_address(FM1_DTSEC1, CONFIG_SYS_FM1_DTSEC1_PHY_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC2, CONFIG_SYS_FM1_DTSEC2_PHY_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC3, CONFIG_SYS_FM1_DTSEC3_PHY_ADDR);
+
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+		int idx = i - FM1_DTSEC1;
+
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_SGMII:
+			lane = serdes_get_first_lane(SGMII_FM1_DTSEC1 + idx);
+			if (lane < 0)
+				break;
+			slot = lane_to_slot[lane];
+			if (slot)
+				fm_info_set_phy_address(i, riser_phy_addr[i]);
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			/* Only DTSEC4 and DTSEC5 can be routed to RGMII */
+			fm_info_set_phy_address(i, i == FM1_DTSEC5 ?
+					CONFIG_SYS_FM1_DTSEC5_PHY_ADDR :
+					CONFIG_SYS_FM1_DTSEC4_PHY_ADDR);
+			break;
+		default:
+			printf("Fman1: DTSEC%u set to unknown interface %i\n",
+			       idx + 1, fm_info_get_enet_if(i));
+			break;
+		}
+
+		fm_info_set_mdio(i,
+			miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+	}
+
+	lane = serdes_get_first_lane(XAUI_FM1);
+	if (lane >= 0) {
+		slot = lane_to_slot[lane];
+		if (slot)
+			fm_info_set_phy_address(FM1_10GEC1,
+					CONFIG_SYS_FM1_10GEC1_PHY_ADDR);
+	}
+
+	fm_info_set_mdio(FM1_10GEC1,
+			miiphy_get_dev_by_name(DEFAULT_FM_TGEC_MDIO_NAME));
+	cpu_eth_init(bis);
+#endif
+
+	return pci_eth_init(bis);
+}
diff --git a/board/freescale/as6700_32x/fastpath.h b/board/freescale/as6700_32x/fastpath.h
new file mode 100644
index 0000000..9fcfa95
--- /dev/null
+++ b/board/freescale/as6700_32x/fastpath.h
@@ -0,0 +1,54 @@
+/*
+* File:        fastpath.h
+* Purpose:     Fastpath boot image data structure.
+*
+* Notes:
+* History:
+*  2013/08/23    -- Aaron Lien, Initial version
+*
+* Copyright (C) 2013  Accton Corporation & authors.
+*/
+
+#ifndef __FASTPATH_
+#define __FASTPATH_
+
+#define DIM_MAX_BOOTCFG_LINE_SIZE       128
+#define DIM_MAX_FILENAME_SIZE           40
+
+/* boot Image descriptor. Each Image is described as below */
+typedef struct _dim_image
+{
+    /* Mandatory information */
+    char    currentState[15];                   /* active / backup */
+    char    nextState[15];                      /* active / backup */
+    char    fileName[DIM_MAX_FILENAME_SIZE];    /* on the fs */
+    char    numErrors[5];           /* Num of tries w/ errors    */
+    char    descr[DIM_MAX_BOOTCFG_LINE_SIZE]; /* text description */
+} dimImageInfo_t;
+
+
+/* STK image header */
+typedef struct stkFileHeader_s{
+ unsigned short crc;
+ unsigned short tag1;
+ unsigned long tag2;
+
+ unsigned long num_components; /* Number of OPR and tgz files in the STK image (may be 0) */
+
+ unsigned long file_size; /* Total number of bytes in the STK file */
+
+ unsigned char rel;
+ unsigned char ver;
+ unsigned char maint_level;
+ unsigned char build_num;
+
+ unsigned long stk_header_size; /* Number of bytes in the STk header */
+
+ unsigned char reserved[64];    /* Reserved for future use */
+
+}stkFileHeader_t;
+
+#define STK_TAG1    0xAA55
+#define STK_TAG2    0x2288BB66
+
+#endif  /* __FASTPATH_ */
diff --git a/board/freescale/as6700_32x/pbi.cfg b/board/freescale/as6700_32x/pbi.cfg
new file mode 100644
index 0000000..8941bf6
--- /dev/null
+++ b/board/freescale/as6700_32x/pbi.cfg
@@ -0,0 +1,95 @@
+#
+# Default PBI for Accton AS6700_32X
+#
+
+#PBI commands
+091380C0 000009C4
+09000010 00000000
+091380C0 000009C4
+09000014 00000000
+091380C0 000009C4
+09000018 81D00000
+091380C0 000009C4
+890B0050 00000002
+091380C0 000009C4
+890B0054 00000002
+091380C0 000009C4
+890B0058 00000002
+091380C0 000009C4
+890B005C 00000002
+091380C0 000009C4
+890B0090 00000002
+091380C0 000009C4
+890B0094 00000002
+091380C0 000009C4
+890B0098 00000002
+091380C0 000009C4
+890B009C 00000002
+091380C0 000009C4
+890B0108 00000012
+091380C0 000009C4
+89021008 0000F000
+091380C0 000009C4
+89021028 0000F000
+091380C0 000009C4
+89021048 0000F000
+091380C0 000009C4
+89021068 0000F000
+091380C0 000009C4
+09138000 00000000
+090ea4a0 1b000001
+090ea4a8 00880000
+090ea4b0 40000000
+090ea4e0 1b000001
+090ea4e8 00880000
+090ea4f0 40000000
+090ea520 1b000001
+090ea528 00880000
+090ea530 40000000
+090ea560 1b000001
+090ea568 00880000
+090ea570 40000000
+090ea5a0 1b000001
+090ea5a8 00880000
+090ea5b0 40000000
+090ea5e0 1b000001
+090ea5e8 00880000
+090ea5f0 40000000
+090ea620 1b000001
+090ea628 00880000
+090ea630 40000000
+090ea660 1b000001
+090ea668 00880000
+090ea670 40000000
+090ea820 1b000001
+090ea828 00880000
+090ea830 40000000
+090ea860 1b000001
+090ea868 00880000
+090ea870 40000000
+090ea8a0 1b000001
+090ea8a8 00880000
+090ea8b0 40000000
+090ea8e0 1b000001
+090ea8e8 00880000
+090ea8f0 40000000
+09010000 00200400
+09138000 00000000
+091380c0 00000100
+09010100 00000000
+09010104 fff0000b
+09010f00 08000000
+09010000 80000000
+09000d00 00000000
+09000d04 fff00000
+09000d08 81000013
+09000010 00000000
+09000014 ff000000
+09000018 81000000
+09110000 80000403
+09110020 2d170008
+09110024 00100008
+09110028 00100008
+0911002c 00100008
+09138000 00000000
+091380c0 00000000
diff --git a/board/freescale/as6700_32x/rcw.cfg b/board/freescale/as6700_32x/rcw.cfg
new file mode 100644
index 0000000..d5983f9
--- /dev/null
+++ b/board/freescale/as6700_32x/rcw.cfg
@@ -0,0 +1,11 @@
+#
+# Default RCW for Accton AS6700_32X
+#
+
+#PBL preamble and RCW header
+aa55aa55 010e0100
+#64 bytes RCW data
+12600000 00000000 24240000 00000000
+5860a0c0 f3c02000 58000000 01000000
+00000000 00000000 00000000 d05b0302
+00000000 00000000 00000000 00000000
diff --git a/board/freescale/b4860qds/Makefile b/board/freescale/b4860qds/Makefile
new file mode 100644
index 0000000..06018f4
--- /dev/null
+++ b/board/freescale/b4860qds/Makefile
@@ -0,0 +1,54 @@
+#
+# Copyright 2012 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-$(CONFIG_B4860QDS)+= eth_b4860qds.o
+COBJS-$(CONFIG_PCI)	+= pci.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/b4860qds/b4860qds.c b/board/freescale/b4860qds/b4860qds.c
new file mode 100644
index 0000000..b1b012c
--- /dev/null
+++ b/board/freescale/b4860qds/b4860qds.c
@@ -0,0 +1,843 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/errno.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <fm_eth.h>
+#include <hwconfig.h>
+
+#include "../common/qixis.h"
+#include "../common/vsc3316_3308.h"
+#include "../common/idt8t49n222a_serdes_clk.h"
+#include "b4860qds.h"
+#include "b4860qds_qixis.h"
+#include "b4860qds_crossbar_con.h"
+
+#define CLK_MUX_SEL_MASK	0x4
+#define ETH_PHY_CLK_OUT		0x4
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	char buf[64];
+	u8 sw;
+	struct cpu_type *cpu = gd->cpu;
+	static const char *const freq[] = {"100", "125", "156.25", "161.13",
+						"122.88", "122.88", "122.88"};
+	int clock;
+
+	printf("Board: %sQDS, ", cpu->name);
+	printf("Sys ID: 0x%02x, Sys Ver: 0x%02x, ",
+		QIXIS_READ(id), QIXIS_READ(arch));
+
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	if (sw < 0x8)
+		printf("vBank: %d\n", sw);
+	else if (sw >= 0x8 && sw <= 0xE)
+		puts("NAND\n");
+	else
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+
+	printf("FPGA: v%d (%s), build %d",
+		(int)QIXIS_READ(scver), qixis_read_tag(buf),
+		(int)qixis_read_minor());
+	/* the timestamp string contains "\n" at the end */
+	printf(" on %s", qixis_read_time(buf));
+
+	/*
+	 * Display the actual SERDES reference clocks as configured by the
+	 * dip switches on the board.  Note that the SWx registers could
+	 * technically be set to force the reference clocks to match the
+	 * values that the SERDES expects (or vice versa).  For now, however,
+	 * we just display both values and hope the user notices when they
+	 * don't match.
+	 */
+	puts("SERDES Reference Clocks: ");
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = (sw >> 5) & 7;
+	printf("Bank1=%sMHz ", freq[clock]);
+	sw = QIXIS_READ(brdcfg[4]);
+	clock = (sw >> 6) & 3;
+	printf("Bank2=%sMHz\n", freq[clock]);
+
+	return 0;
+}
+
+int select_i2c_ch_pca(u8 ch)
+{
+	int ret;
+
+	/* Selecting proper channel via PCA*/
+	ret = i2c_write(I2C_MUX_PCA_ADDR, 0x0, 1, &ch, 1);
+	if (ret) {
+		printf("PCA: failed to select proper channel.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int configure_vsc3316_3308(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	unsigned int num_vsc16_con, num_vsc08_con;
+	u32 serdes1_prtcl, serdes2_prtcl;
+	int ret;
+	char buffer[HWCONFIG_BUFFER_SIZE];
+	char *buf = NULL;
+
+	serdes1_prtcl = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+	if (!serdes1_prtcl) {
+		printf("SERDES1 is not enabled\n");
+		return 0;
+	}
+	serdes1_prtcl >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+	debug("Using SERDES1 Protocol: 0x%x:\n", serdes1_prtcl);
+
+	serdes2_prtcl = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+	if (!serdes2_prtcl) {
+		printf("SERDES2 is not enabled\n");
+		return 0;
+	}
+	serdes2_prtcl >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+	debug("Using SERDES2 Protocol: 0x%x:\n", serdes2_prtcl);
+
+	switch (serdes1_prtcl) {
+	case 0x2a:
+	case 0x2C:
+	case 0x2D:
+	case 0x2E:
+			/*
+			 * Configuration:
+			 * SERDES: 1
+			 * Lanes: A,B: SGMII
+			 * Lanes: C,D,E,F,G,H: CPRI
+			 */
+		debug("Configuring crossbar to use onboard SGMII PHYs:"
+				"srds_prctl:%x\n", serdes1_prtcl);
+		num_vsc16_con = NUM_CON_VSC3316;
+		/* Configure VSC3316 crossbar switch */
+		ret = select_i2c_ch_pca(I2C_CH_VSC3316);
+		if (!ret) {
+			ret = vsc3316_config(VSC3316_TX_ADDRESS,
+					vsc16_tx_4sfp_sgmii_12_56,
+					num_vsc16_con);
+			if (ret)
+				return ret;
+			ret = vsc3316_config(VSC3316_RX_ADDRESS,
+					vsc16_rx_4sfp_sgmii_12_56,
+					num_vsc16_con);
+			if (ret)
+				return ret;
+		} else {
+			return ret;
+		}
+		break;
+
+	case 0x02:
+	case 0x04:
+	case 0x05:
+	case 0x06:
+	case 0x08:
+	case 0x09:
+	case 0x0A:
+	case 0x0B:
+	case 0x0C:
+	case 0x30:
+	case 0x32:
+	case 0x33:
+	case 0x34:
+	case 0x39:
+	case 0x3A:
+	case 0x3C:
+	case 0x3D:
+	case 0x5C:
+	case 0x5D:
+			/*
+			 * Configuration:
+			 * SERDES: 1
+			 * Lanes: A,B: AURORA
+			 * Lanes: C,d: SGMII
+			 * Lanes: E,F,G,H: CPRI
+			 */
+		debug("Configuring crossbar for Aurora, SGMII 3 and 4,"
+				" and CPRI. srds_prctl:%x\n", serdes1_prtcl);
+		num_vsc16_con = NUM_CON_VSC3316;
+		/* Configure VSC3316 crossbar switch */
+		ret = select_i2c_ch_pca(I2C_CH_VSC3316);
+		if (!ret) {
+			ret = vsc3316_config(VSC3316_TX_ADDRESS,
+					vsc16_tx_sfp_sgmii_aurora,
+					num_vsc16_con);
+			if (ret)
+				return ret;
+			ret = vsc3316_config(VSC3316_RX_ADDRESS,
+					vsc16_rx_sfp_sgmii_aurora,
+					num_vsc16_con);
+			if (ret)
+				return ret;
+		} else {
+			return ret;
+		}
+		break;
+
+#ifdef CONFIG_PPC_B4420
+	case 0x18:
+			/*
+			 * Configuration:
+			 * SERDES: 1
+			 * Lanes: A,B,C,D: SGMII
+			 * Lanes: E,F,G,H: CPRI
+			 */
+		debug("Configuring crossbar to use onboard SGMII PHYs:"
+				"srds_prctl:%x\n", serdes1_prtcl);
+		num_vsc16_con = NUM_CON_VSC3316;
+		/* Configure VSC3316 crossbar switch */
+		ret = select_i2c_ch_pca(I2C_CH_VSC3316);
+		if (!ret) {
+			ret = vsc3316_config(VSC3316_TX_ADDRESS,
+					vsc16_tx_sgmii_lane_cd, num_vsc16_con);
+			if (ret)
+				return ret;
+			ret = vsc3316_config(VSC3316_RX_ADDRESS,
+					vsc16_rx_sgmii_lane_cd, num_vsc16_con);
+			if (ret)
+				return ret;
+		} else {
+			return ret;
+		}
+		break;
+#endif
+
+	case 0x3E:
+	case 0x0D:
+	case 0x0E:
+	case 0x12:
+		num_vsc16_con = NUM_CON_VSC3316;
+		/* Configure VSC3316 crossbar switch */
+		ret = select_i2c_ch_pca(I2C_CH_VSC3316);
+		if (!ret) {
+			ret = vsc3316_config(VSC3316_TX_ADDRESS,
+					vsc16_tx_sfp, num_vsc16_con);
+			if (ret)
+				return ret;
+			ret = vsc3316_config(VSC3316_RX_ADDRESS,
+					vsc16_rx_sfp, num_vsc16_con);
+			if (ret)
+				return ret;
+		} else {
+			return ret;
+		}
+		break;
+	default:
+		printf("WARNING:VSC crossbars programming not supported for:%x"
+					" SerDes1 Protocol.\n", serdes1_prtcl);
+		return -1;
+	}
+
+	num_vsc08_con = NUM_CON_VSC3308;
+	/* Configure VSC3308 crossbar switch */
+	ret = select_i2c_ch_pca(I2C_CH_VSC3308);
+	switch (serdes2_prtcl) {
+	case 0x9E:
+	case 0x9A:
+	case 0x98:
+	case 0x49:
+	case 0x4E:
+	case 0x7A:
+		if (!ret) {
+			ret = vsc3308_config(VSC3308_TX_ADDRESS,
+					vsc08_tx_amc, num_vsc08_con);
+			if (ret)
+				return ret;
+			ret = vsc3308_config(VSC3308_RX_ADDRESS,
+					vsc08_rx_amc, num_vsc08_con);
+			if (ret)
+				return ret;
+		} else {
+			return ret;
+		}
+		break;
+	case 0x81:
+	case 0x82:
+	case 0x84:
+	case 0x85:
+	case 0x87:
+	case 0x88:
+	case 0x8a:
+	case 0x8b:
+	case 0x8d:
+	case 0x8e:
+	case 0xb2:
+		if (!ret) {
+			/*
+			 * Extract hwconfig from environment since environment
+			 * is not setup properly yet
+			 */
+			getenv_f("hwconfig", buffer, sizeof(buffer));
+			buf = buffer;
+
+			if (hwconfig_subarg_cmp_f("fsl_b4860_serdes2",
+						"sfp_amc", "sfp", buf)) {
+#ifdef CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+				/* change default VSC3308 for XFI erratum */
+				ret = vsc3308_config_adjust(VSC3308_TX_ADDRESS,
+						vsc08_tx_sfp, num_vsc08_con);
+				if (ret)
+					return ret;
+
+				ret = vsc3308_config_adjust(VSC3308_RX_ADDRESS,
+						vsc08_rx_sfp, num_vsc08_con);
+				if (ret)
+					return ret;
+#else
+				ret = vsc3308_config(VSC3308_TX_ADDRESS,
+						vsc08_tx_sfp, num_vsc08_con);
+				if (ret)
+					return ret;
+
+				ret = vsc3308_config(VSC3308_RX_ADDRESS,
+						vsc08_rx_sfp, num_vsc08_con);
+				if (ret)
+					return ret;
+#endif
+			} else {
+				ret = vsc3308_config(VSC3308_TX_ADDRESS,
+						vsc08_tx_amc, num_vsc08_con);
+				if (ret)
+					return ret;
+
+				ret = vsc3308_config(VSC3308_RX_ADDRESS,
+						vsc08_rx_amc, num_vsc08_con);
+				if (ret)
+					return ret;
+			}
+
+		} else {
+			return ret;
+		}
+		break;
+
+	default:
+		printf("WARNING:VSC crossbars programming not supported for: %x"
+					" SerDes2 Protocol.\n", serdes2_prtcl);
+		return -1;
+	}
+
+	return 0;
+}
+
+int config_serdes1_refclks(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	serdes_corenet_t *srds_regs =
+		(void *)CONFIG_SYS_FSL_CORENET_SERDES_ADDR;
+	u32 serdes1_prtcl, lane;
+	unsigned int flag_sgmii_aurora_prtcl = 0;
+	int i;
+	int ret = 0;
+
+	serdes1_prtcl = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+	if (!serdes1_prtcl) {
+		printf("SERDES1 is not enabled\n");
+		return -1;
+	}
+	serdes1_prtcl >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+	debug("Using SERDES1 Protocol: 0x%x:\n", serdes1_prtcl);
+
+	/* To prevent generation of reset request from SerDes
+	 * while changing the refclks, By setting SRDS_RST_MSK bit,
+	 * SerDes reset event cannot cause a reset request
+	 */
+	setbits_be32(&gur->rstrqmr1, FSL_CORENET_RSTRQMR1_SRDS_RST_MSK);
+
+	/* Reconfigure IDT idt8t49n222a device for CPRI to work
+	 * For this SerDes1's Refclk1 and refclk2 need to be set
+	 * to 122.88MHz
+	 */
+	switch (serdes1_prtcl) {
+	case 0x2A:
+	case 0x2C:
+	case 0x2D:
+	case 0x2E:
+	case 0x02:
+	case 0x04:
+	case 0x05:
+	case 0x06:
+	case 0x08:
+	case 0x09:
+	case 0x0A:
+	case 0x0B:
+	case 0x0C:
+	case 0x30:
+	case 0x32:
+	case 0x33:
+	case 0x34:
+	case 0x39:
+	case 0x3A:
+	case 0x3C:
+	case 0x3D:
+	case 0x5C:
+	case 0x5D:
+		debug("Configuring idt8t49n222a for CPRI SerDes clks:"
+			" for srds_prctl:%x\n", serdes1_prtcl);
+		ret = select_i2c_ch_pca(I2C_CH_IDT);
+		if (!ret) {
+			ret = set_serdes_refclk(IDT_SERDES1_ADDRESS, 1,
+					SERDES_REFCLK_122_88,
+					SERDES_REFCLK_122_88, 0);
+			if (ret) {
+				printf("IDT8T49N222A configuration failed.\n");
+				goto out;
+			} else
+				debug("IDT8T49N222A configured.\n");
+		} else {
+			goto out;
+		}
+		select_i2c_ch_pca(I2C_CH_DEFAULT);
+
+		/* Change SerDes1's Refclk1 to 125MHz for on board
+		 * SGMIIs or Aurora to work
+		 */
+		for (lane = 0; lane < SRDS_MAX_LANES; lane++) {
+			enum srds_prtcl lane_prtcl = serdes_get_prtcl
+						(0, serdes1_prtcl, lane);
+			switch (lane_prtcl) {
+			case SGMII_FM1_DTSEC1:
+			case SGMII_FM1_DTSEC2:
+			case SGMII_FM1_DTSEC3:
+			case SGMII_FM1_DTSEC4:
+			case SGMII_FM1_DTSEC5:
+			case SGMII_FM1_DTSEC6:
+			case AURORA:
+				flag_sgmii_aurora_prtcl++;
+				break;
+			default:
+				break;
+			}
+		}
+
+		if (flag_sgmii_aurora_prtcl)
+			QIXIS_WRITE(brdcfg[4], QIXIS_SRDS1CLK_125);
+
+		/* Steps For SerDes PLLs reset and reconfiguration after
+		 * changing SerDes's refclks
+		 */
+		for (i = 0; i < CONFIG_SYS_FSL_SRDS_NUM_PLLS; i++) {
+			debug("For PLL%d reset and reconfiguration after"
+			       " changing refclks\n", i+1);
+			clrbits_be32(&srds_regs->bank[i].rstctl,
+					SRDS_RSTCTL_SDRST_B);
+			udelay(10);
+			clrbits_be32(&srds_regs->bank[i].rstctl,
+				(SRDS_RSTCTL_SDEN | SRDS_RSTCTL_PLLRST_B));
+			udelay(10);
+			setbits_be32(&srds_regs->bank[i].rstctl,
+					SRDS_RSTCTL_RST);
+			setbits_be32(&srds_regs->bank[i].rstctl,
+				(SRDS_RSTCTL_SDEN | SRDS_RSTCTL_PLLRST_B
+				| SRDS_RSTCTL_SDRST_B));
+		}
+		break;
+	default:
+		printf("WARNING:IDT8T49N222A configuration not"
+			" supported for:%x SerDes1 Protocol.\n",
+			serdes1_prtcl);
+	}
+
+out:
+	/* Clearing SRDS_RST_MSK bit as now
+	 * SerDes reset event can cause a reset request
+	 */
+	clrbits_be32(&gur->rstrqmr1, FSL_CORENET_RSTRQMR1_SRDS_RST_MSK);
+	return ret;
+}
+
+int config_serdes2_refclks(void)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	serdes_corenet_t *srds2_regs =
+		(void *)CONFIG_SYS_FSL_CORENET_SERDES2_ADDR;
+	u32 serdes2_prtcl;
+	int ret = 0;
+	int i;
+
+	serdes2_prtcl = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+	if (!serdes2_prtcl) {
+		debug("SERDES2 is not enabled\n");
+		return -ENODEV;
+	}
+	serdes2_prtcl >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+	debug("Using SERDES2 Protocol: 0x%x:\n", serdes2_prtcl);
+
+	/* To prevent generation of reset request from SerDes
+	 * while changing the refclks, By setting SRDS_RST_MSK bit,
+	 * SerDes reset event cannot cause a reset request
+	 */
+	setbits_be32(&gur->rstrqmr1, FSL_CORENET_RSTRQMR1_SRDS_RST_MSK);
+
+	/* Reconfigure IDT idt8t49n222a device for PCIe SATA to work
+	 * For this SerDes2's Refclk1 need to be set to 100MHz
+	 */
+	switch (serdes2_prtcl) {
+	case 0x9E:
+	case 0x9A:
+	case 0xb2:
+		debug("Configuring IDT for PCIe SATA for srds_prctl:%x\n",
+			serdes2_prtcl);
+		ret = select_i2c_ch_pca(I2C_CH_IDT);
+		if (!ret) {
+			ret = set_serdes_refclk(IDT_SERDES2_ADDRESS, 2,
+					SERDES_REFCLK_100,
+					SERDES_REFCLK_156_25, 0);
+			if (ret) {
+				printf("IDT8T49N222A configuration failed.\n");
+				goto out;
+			} else
+				debug("IDT8T49N222A configured.\n");
+		} else {
+			goto out;
+		}
+		select_i2c_ch_pca(I2C_CH_DEFAULT);
+
+		/* Steps For SerDes PLLs reset and reconfiguration after
+		 * changing SerDes's refclks
+		 */
+		for (i = 0; i < CONFIG_SYS_FSL_SRDS_NUM_PLLS; i++) {
+			clrbits_be32(&srds2_regs->bank[i].rstctl,
+					SRDS_RSTCTL_SDRST_B);
+			udelay(10);
+			clrbits_be32(&srds2_regs->bank[i].rstctl,
+				(SRDS_RSTCTL_SDEN | SRDS_RSTCTL_PLLRST_B));
+			udelay(10);
+			setbits_be32(&srds2_regs->bank[i].rstctl,
+					SRDS_RSTCTL_RST);
+			setbits_be32(&srds2_regs->bank[i].rstctl,
+				(SRDS_RSTCTL_SDEN | SRDS_RSTCTL_PLLRST_B
+				| SRDS_RSTCTL_SDRST_B));
+		}
+		break;
+	default:
+		printf("IDT configuration not supported for:%x S2 Protocol.\n",
+			serdes2_prtcl);
+	}
+
+out:
+	/* Clearing SRDS_RST_MSK bit as now
+	 * SerDes reset event can cause a reset request
+	 */
+	clrbits_be32(&gur->rstrqmr1, FSL_CORENET_RSTRQMR1_SRDS_RST_MSK);
+	return ret;
+}
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+	int ret;
+	u32 svr = SVR_SOC_VER(get_svr());
+
+	/* Create law for MAPLE only for personalities having MAPLE */
+	if ((svr == SVR_B4860) || (svr == SVR_B4440) ||
+			(svr == SVR_B4420) || (svr == SVR_B4220)) {
+		set_next_law(CONFIG_SYS_MAPLE_MEM_PHYS, LAW_SIZE_16M,
+				LAW_TRGT_IF_MAPLE);
+	}
+
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash + promjet */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_256M, 1);
+
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+	/* SerDes1 refclks need to be set again, as default clks
+	 * are not suitable for CPRI and onboard SGMIIs to work
+	 * simultaneously.
+	 * This function will set SerDes1's Refclk1 and refclk2
+	 * as per SerDes1 protocols
+	 */
+	if (config_serdes1_refclks())
+		printf("SerDes1 Refclks couldn't set properly.\n");
+	else
+		printf("SerDes1 Refclks have been set.\n");
+
+	/* SerDes2 refclks need to be set again, as default clks
+	 * are not suitable for PCIe SATA to work
+	 * This function will set SerDes2's Refclk1 and refclk2
+	 * for SerDes2 protocols having PCIe in them
+	 * for PCIe SATA to work
+	 */
+	ret = config_serdes2_refclks();
+	if (!ret)
+		printf("SerDes2 Refclks have been set.\n");
+	else if (ret == -ENODEV)
+		printf("SerDes disable, Refclks couldn't change.\n");
+	else
+		printf("SerDes2 Refclk reconfiguring failed.\n");
+
+	/* Configure VSC3316 and VSC3308 crossbar switches */
+	if (configure_vsc3316_3308())
+		printf("VSC:failed to configure VSC3316/3308.\n");
+	else
+		printf("VSC:VSC3316/3308 successfully configured.\n");
+
+	select_i2c_ch_pca(I2C_CH_DEFAULT);
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch ((sysclk_conf & 0x0C) >> 2) {
+	case QIXIS_CLK_100:
+		return 100000000;
+	case QIXIS_CLK_125:
+		return 125000000;
+	case QIXIS_CLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (ddrclk_conf & 0x03) {
+	case QIXIS_CLK_100:
+		return 100000000;
+	case QIXIS_CLK_125:
+		return 125000000;
+	case QIXIS_CLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+static int serdes_refclock(u8 sw, u8 sdclk)
+{
+	unsigned int clock;
+	int ret = -1;
+	u8 brdcfg4;
+
+	if (sdclk == 1) {
+		brdcfg4 = QIXIS_READ(brdcfg[4]);
+		if ((brdcfg4 & CLK_MUX_SEL_MASK) == ETH_PHY_CLK_OUT)
+			return SRDS_PLLCR0_RFCK_SEL_125;
+		else
+			clock = (sw >> 5) & 7;
+	} else
+		clock = (sw >> 6) & 3;
+
+	switch (clock) {
+	case 0:
+		ret = SRDS_PLLCR0_RFCK_SEL_100;
+		break;
+	case 1:
+		ret = SRDS_PLLCR0_RFCK_SEL_125;
+		break;
+	case 2:
+		ret = SRDS_PLLCR0_RFCK_SEL_156_25;
+		break;
+	case 3:
+		ret = SRDS_PLLCR0_RFCK_SEL_161_13;
+		break;
+	case 4:
+	case 5:
+	case 6:
+		ret = SRDS_PLLCR0_RFCK_SEL_122_88;
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+static const char *serdes_clock_to_string(u32 clock)
+{
+	switch (clock) {
+	case SRDS_PLLCR0_RFCK_SEL_100:
+		return "100";
+	case SRDS_PLLCR0_RFCK_SEL_125:
+		return "125";
+	case SRDS_PLLCR0_RFCK_SEL_156_25:
+		return "156.25";
+	case SRDS_PLLCR0_RFCK_SEL_161_13:
+		return "161.13";
+	default:
+		return "122.88";
+	}
+}
+
+#define NUM_SRDS_BANKS	2
+
+int misc_init_r(void)
+{
+	u8 sw;
+	serdes_corenet_t *srds_regs =
+		(void *)CONFIG_SYS_FSL_CORENET_SERDES_ADDR;
+	u32 actual[NUM_SRDS_BANKS];
+	unsigned int i;
+	int clock;
+
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = serdes_refclock(sw, 1);
+	if (clock >= 0)
+		actual[0] = clock;
+	else
+		printf("Warning: SDREFCLK1 switch setting is unsupported\n");
+
+	sw = QIXIS_READ(brdcfg[4]);
+	clock = serdes_refclock(sw, 2);
+	if (clock >= 0)
+		actual[1] = clock;
+	else
+		printf("Warning: SDREFCLK2 switch setting unsupported\n");
+
+	for (i = 0; i < NUM_SRDS_BANKS; i++) {
+		u32 pllcr0 = srds_regs->bank[i].pllcr0;
+		u32 expected = pllcr0 & SRDS_PLLCR0_RFCK_SEL_MASK;
+		if (expected != actual[i]) {
+			printf("Warning: SERDES bank %u expects reference clock"
+			       " %sMHz, but actual is %sMHz\n", i + 1,
+			       serdes_clock_to_string(expected),
+			       serdes_clock_to_string(actual[i]));
+		}
+	}
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005936
+	QIXIS_WRITE(rst_ctl, 0x30);
+#endif
+	return 0;
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+	fdt_fixup_dr_usb(blob, bd);
+#endif
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+	fdt_fixup_board_enet(blob);
+#endif
+}
+
+/*
+ * Dump board switch settings.
+ * The bits that cannot be read/sampled via some FPGA or some
+ * registers, they will be displayed as
+ * underscore in binary format. mask[] has those bits.
+ * Some bits are calculated differently than the actual switches
+ * if booting with overriding by FPGA.
+ */
+void qixis_dump_switch(void)
+{
+	int i;
+	u8 sw[5];
+
+	/*
+	 * Any bit with 1 means that bit cannot be reverse engineered.
+	 * It will be displayed as _ in binary format.
+	 */
+	static const u8 mask[] = {0x07, 0, 0, 0xff, 0};
+	char buf[10];
+	u8 brdcfg[16], dutcfg[16];
+
+	for (i = 0; i < 16; i++) {
+		brdcfg[i] = qixis_read(offsetof(struct qixis, brdcfg[0]) + i);
+		dutcfg[i] = qixis_read(offsetof(struct qixis, dutcfg[0]) + i);
+	}
+
+	sw[0] = ((brdcfg[0] & 0x0f) << 4)	| \
+		(brdcfg[9] & 0x08);
+	sw[1] = ((dutcfg[1] & 0x01) << 7)	| \
+		((dutcfg[2] & 0x07) << 4)       | \
+		((dutcfg[6] & 0x10) >> 1)       | \
+		((dutcfg[6] & 0x80) >> 5)       | \
+		((dutcfg[1] & 0x40) >> 5)       | \
+		(dutcfg[6] & 0x01);
+	sw[2] = dutcfg[0];
+	sw[3] = 0;
+	sw[4] = ((brdcfg[1] & 0x30) << 2)	| \
+		((brdcfg[1] & 0xc0) >> 2)	| \
+		(brdcfg[1] & 0x0f);
+
+	puts("DIP switch settings:\n");
+	for (i = 0; i < 5; i++) {
+		printf("SW%d         = 0b%s (0x%02x)\n",
+			i + 1, byte_to_binary_mask(sw[i], mask[i], buf), sw[i]);
+	}
+}
diff --git a/board/freescale/b4860qds/b4860qds.h b/board/freescale/b4860qds/b4860qds.h
new file mode 100644
index 0000000..f290f3c
--- /dev/null
+++ b/board/freescale/b4860qds/b4860qds.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CORENET_DS_H__
+#define __CORENET_DS_H__
+
+void fdt_fixup_board_enet(void *blob);
+void pci_of_setup(void *blob, bd_t *bd);
+
+#endif
diff --git a/board/freescale/b4860qds/b4860qds_crossbar_con.h b/board/freescale/b4860qds/b4860qds_crossbar_con.h
new file mode 100644
index 0000000..21246aa
--- /dev/null
+++ b/board/freescale/b4860qds/b4860qds_crossbar_con.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CROSSBAR_CONNECTIONS_H__
+#define __CROSSBAR_CONNECTIONS_H__
+
+#define NUM_CON_VSC3316	8
+#define NUM_CON_VSC3308	4
+
+static const int8_t vsc16_tx_amc[8][2] = { {15, 3}, {0, 2}, {7, 4}, {9, 10},
+				{5, 11}, {4, 5}, {2, 6}, {12, 9} };
+
+static const int8_t vsc16_tx_sfp[8][2] = { {15, 7}, {0, 1}, {7, 8}, {9, 0},
+				{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1} };
+
+static const int8_t vsc16_tx_4sfp_sgmii_12_56[8][2] = { {15, 7}, {0, 1},
+				{7, 8}, {9, 0}, {2, 14}, {12, 15},
+				{-1, -1}, {-1, -1} };
+
+static const int8_t vsc16_tx_4sfp_sgmii_34[8][2] = { {15, 7}, {0, 1},
+				{7, 8}, {9, 0}, {5, 14}, {4, 15},
+				{-1, -1}, {-1, -1} };
+
+static const int8_t vsc16_tx_sfp_sgmii_aurora[8][2] = { {15, 7}, {0, 1},
+					{7, 8}, {9, 0}, {5, 14},
+					{4, 15}, {2, 12}, {12, 13} };
+
+#ifdef CONFIG_PPC_B4420
+static const int8_t vsc16_tx_sgmii_lane_cd[8][2] = { {5, 14}, {4, 15},
+		{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1} };
+#endif
+
+static const int8_t vsc16_tx_aurora[8][2] = { {2, 13}, {12, 12}, {-1, -1},
+			{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1} };
+
+static const int8_t vsc16_rx_amc[8][2] = { {3, 15}, {2, 1}, {4, 8}, {10, 9},
+				{11, 11}, {5, 10}, {6, 3}, {9, 12} };
+
+static const int8_t vsc16_rx_sfp[8][2] = { {8, 15}, {0, 1}, {7, 8}, {1, 9},
+				{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1} };
+
+static const int8_t vsc16_rx_4sfp_sgmii_12_56[8][2] = { {8, 15}, {0, 1},
+				{7, 8}, {1, 9}, {14, 3}, {15, 12},
+				{-1, -1}, {-1, -1} };
+
+static const int8_t vsc16_rx_4sfp_sgmii_34[8][2] = { {8, 15}, {0, 1},
+				{7, 8}, {1, 9}, {14, 11}, {15, 10},
+				{-1, -1}, {-1, -1} };
+
+static const int8_t vsc16_rx_sfp_sgmii_aurora[8][2] = { {8, 15}, {0, 1},
+					{7, 8}, {1, 9}, {14, 11},
+					{15, 10}, {13, 3}, {12, 12} };
+
+#ifdef CONFIG_PPC_B4420
+static const int8_t vsc16_rx_sgmii_lane_cd[8][2] = { {14, 11}, {15, 10},
+		{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1} };
+#endif
+
+static const int8_t vsc16_rx_aurora[8][2] = { {13, 3}, {12, 12}, {-1, -1},
+			{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1} };
+
+static const int8_t vsc08_tx_amc[4][2] = { {2, 2}, {3, 3}, {7, 4}, {1, 5} };
+
+static const int8_t vsc08_tx_sfp[4][2] = { {2, 1}, {3, 0}, {7, 6}, {1, 7} };
+
+static const int8_t vsc08_rx_amc[4][2] = { {2, 3}, {3, 4}, {4, 7}, {5, 1} };
+
+static const int8_t vsc08_rx_sfp[4][2] = { {1, 3}, {0, 4}, {6, 7}, {7, 1} };
+
+#endif
diff --git a/board/freescale/b4860qds/b4860qds_qixis.h b/board/freescale/b4860qds/b4860qds_qixis.h
new file mode 100644
index 0000000..575b2ae
--- /dev/null
+++ b/board/freescale/b4860qds/b4860qds_qixis.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __B4860QDS_QIXIS_H__
+#define __B4860QDS_QIXIS_H__
+
+/* Definitions of QIXIS Registers for B4860QDS */
+
+/* BRDCFG4[4:7]] select EC1 and EC2 as a pair */
+#define BRDCFG4_EMISEL_MASK		0xE0
+#define BRDCFG4_EMISEL_SHIFT		5
+
+/* CLK */
+#define QIXIS_CLK_66		0x0
+#define QIXIS_CLK_100		0x1
+#define QIXIS_CLK_125		0x2
+#define QIXIS_CLK_133		0x3
+
+#define QIXIS_SRDS1CLK_122		0x5a
+#define QIXIS_SRDS1CLK_125		0x5e
+#endif
diff --git a/board/freescale/b4860qds/b4_pbi.cfg b/board/freescale/b4860qds/b4_pbi.cfg
new file mode 100644
index 0000000..57b726e
--- /dev/null
+++ b/board/freescale/b4860qds/b4_pbi.cfg
@@ -0,0 +1,27 @@
+#PBI commands
+#Initialize CPC1
+09010000 00200400
+09138000 00000000
+091380c0 00000100
+#Configure CPC1 as 512KB SRAM
+09010100 00000000
+09010104 fff80009
+09010f00 08000000
+09010000 80000000
+#Configure LAW for CPC1
+09000d00 00000000
+09000d04 fff80000
+09000d08 81000012
+#Configure alternate space
+09000010 00000000
+09000014 ff000000
+09000018 81000000
+#Configure SPI controller
+09110000 80000403
+09110020 2d170008
+09110024 00100008
+09110028 00100008
+0911002c 00100008
+#Flush PBL data
+09138000 00000000
+091380c0 00000000
diff --git a/board/freescale/b4860qds/b4_rcw.cfg b/board/freescale/b4860qds/b4_rcw.cfg
new file mode 100644
index 0000000..7bf0066
--- /dev/null
+++ b/board/freescale/b4860qds/b4_rcw.cfg
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 010e0100
+# serdes protocol 0x2A_0x98
+140e0018 0f001218 00000000 00000000
+54980000 9000a000 e8904000 a9000000
+01000000 00000000 00000000 0001f1f8
+00000000 14000020 00000000 00000011
diff --git a/board/freescale/b4860qds/ddr.c b/board/freescale/b4860qds/ddr.c
new file mode 100644
index 0000000..f19f338
--- /dev/null
+++ b/board/freescale/b4860qds/ddr.c
@@ -0,0 +1,262 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 or later as published by the Free Software Foundation.
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <hwconfig.h>
+#include <asm/mmu.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+#include <asm/fsl_law.h>
+#include <../arch/powerpc/cpu/mpc8xxx/ddr/ddr.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 2,
+	.rank_density = 2147483648u,
+	.capacity = 4294967296u,
+	.primary_sdram_width = 64,
+	.ec_sdram_width = 8,
+	.registered_dimm = 0,
+	.mirrored_dimm = 1,
+	.n_row_addr = 15,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 2,	/* ECC */
+	.burst_lengths_bitmask = 0x0c,
+
+	.tCKmin_X_ps = 1071,
+	.caslat_X = 0x2fe << 4,	/* 5,6,7,8,9,10,11,13 */
+	.tAA_ps = 13910,
+	.tWR_ps = 15000,
+	.tRCD_ps = 13910,
+	.tRRD_ps = 6000,
+	.tRP_ps = 13910,
+	.tRAS_ps = 34000,
+	.tRC_ps = 48910,
+	.tRFC_ps = 260000,
+	.tWTR_ps = 7500,
+	.tRTP_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tFAW_ps = 35000,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "RAW timing DDR";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+	u32 cpo;
+	u32 write_data_delay;
+	u32 force_2T;
+};
+
+/*
+ * This table contains all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz|adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+	{2,  1350,    4,     7, 0x09080807, 0x07060607,   0xff,    2,  0},
+	{2,  1666,    4,     7, 0x09080806, 0x06050607,   0xff,    2,  0},
+	{2,  1900,    3,     7, 0x08070706, 0x06040507,   0xff,    2,  0},
+	{1,  1350,    4,     7, 0x09080807, 0x07060607,   0xff,    2,  0},
+	{1,  1700,    4,     7, 0x09080806, 0x06050607,   0xff,    2,  0},
+	{1,  1900,    3,     7, 0x08070706, 0x06040507,   0xff,    2,  0},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 2) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = udimms[0];
+
+
+	/* Get clk_adjust, cpo, write_data_delay,2T, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->cpo_override = pbsp->cpo;
+				popts->write_data_delay =
+					pbsp->write_data_delay;
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				popts->twoT_en = pbsp->force_2T;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found "
+			"for data rate %lu MT/s\n"
+			"Trying to use the highest speed (%u) parameters\n",
+			ddr_freq, pbsp_highest->datarate_mhz_high);
+		popts->cpo_override = pbsp_highest->cpo;
+		popts->write_data_delay = pbsp_highest->write_data_delay;
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->twoT_en = pbsp_highest->force_2T;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+	puts("Initializing....using SPD\n");
+
+	dram_size = fsl_ddr_sdram();
+
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+
+	puts("    DDR: ");
+	return dram_size;
+}
+
+unsigned long long step_assign_addresses(fsl_ddr_info_t *pinfo,
+			  unsigned int dbw_cap_adj[])
+{
+	int i, j;
+	unsigned long long total_mem, current_mem_base, total_ctlr_mem;
+	unsigned long long rank_density, ctlr_density = 0;
+
+	current_mem_base = 0ull;
+	total_mem = 0;
+	/*
+	 * This board has soldered DDR chips. DDRC1 has two rank.
+	 * DDRC2 has only one rank.
+	 * Assigning DDRC2 to lower address and DDRC1 to higher address.
+	 */
+	if (pinfo->memctl_opts[0].memctl_interleaving) {
+		rank_density = pinfo->dimm_params[0][0].rank_density >>
+					dbw_cap_adj[0];
+		ctlr_density = rank_density;
+
+		debug("rank density is 0x%llx, ctlr density is 0x%llx\n",
+			rank_density, ctlr_density);
+		for (i = CONFIG_NUM_DDR_CONTROLLERS - 1; i >= 0; i--) {
+			switch (pinfo->memctl_opts[i].memctl_interleaving_mode) {
+			case FSL_DDR_CACHE_LINE_INTERLEAVING:
+			case FSL_DDR_PAGE_INTERLEAVING:
+			case FSL_DDR_BANK_INTERLEAVING:
+			case FSL_DDR_SUPERBANK_INTERLEAVING:
+				total_ctlr_mem = 2 * ctlr_density;
+				break;
+			default:
+				panic("Unknown interleaving mode");
+			}
+			pinfo->common_timing_params[i].base_address =
+						current_mem_base;
+			pinfo->common_timing_params[i].total_mem =
+						total_ctlr_mem;
+			total_mem = current_mem_base + total_ctlr_mem;
+			debug("ctrl %d base 0x%llx\n", i, current_mem_base);
+			debug("ctrl %d total 0x%llx\n", i, total_ctlr_mem);
+		}
+	} else {
+		/*
+		 * Simple linear assignment if memory
+		 * controllers are not interleaved.
+		 */
+		for (i = CONFIG_NUM_DDR_CONTROLLERS - 1; i >= 0; i--) {
+			total_ctlr_mem = 0;
+			pinfo->common_timing_params[i].base_address =
+						current_mem_base;
+			for (j = 0; j < CONFIG_DIMM_SLOTS_PER_CTLR; j++) {
+				/* Compute DIMM base addresses. */
+				unsigned long long cap =
+					pinfo->dimm_params[i][j].capacity;
+				pinfo->dimm_params[i][j].base_address =
+					current_mem_base;
+				debug("ctrl %d dimm %d base 0x%llx\n",
+					i, j, current_mem_base);
+				current_mem_base += cap;
+				total_ctlr_mem += cap;
+			}
+			debug("ctrl %d total 0x%llx\n", i, total_ctlr_mem);
+			pinfo->common_timing_params[i].total_mem =
+							total_ctlr_mem;
+			total_mem += total_ctlr_mem;
+		}
+	}
+	debug("Total mem by %s is 0x%llx\n", __func__, total_mem);
+
+	return total_mem;
+}
diff --git a/board/freescale/b4860qds/eth_b4860qds.c b/board/freescale/b4860qds/eth_b4860qds.c
new file mode 100644
index 0000000..476d048
--- /dev/null
+++ b/board/freescale/b4860qds/eth_b4860qds.c
@@ -0,0 +1,467 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Author: Sandeep Kumar Singh <sandeep@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* This file is based on board/freescale/corenet_ds/eth_superhydra.c */
+
+/*
+ * This file handles the board muxing between the Fman Ethernet MACs and
+ * the RGMII/SGMII/XGMII PHYs on a Freescale B4860 "Centaur". The SGMII
+ * PHYs are the two on-board 1Gb ports. There are no RGMII PHY on board.
+ * The 10Gb XGMII PHY is provided via the XAUI riser card. There is only
+ * one Fman device on B4860. The SERDES configuration is used to determine
+ * where the SGMII and XAUI cards exist, and also which Fman MACs are routed
+ * to which PHYs. So for a given Fman MAC, there is one and only PHY it
+ * connects to. MACs cannot be routed to PHYs dynamically. This configuration
+ * is done at boot time by reading SERDES protocol from RCW.
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/fsl_serdes.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+#include <fdt_support.h>
+#include <asm/fsl_dtsec.h>
+
+#include "../common/ngpixis.h"
+#include "../common/fman.h"
+#include "../common/qixis.h"
+#include "b4860qds_qixis.h"
+
+#define EMI_NONE       0xFFFFFFFF
+
+#ifdef CONFIG_FMAN_ENET
+
+/*
+ * Mapping of all 16 SERDES lanes to board slots. A value n(>0) will mean that
+ * lane at index is mapped to slot number n. A value of '0' will mean
+ * that the mapping must be determined dynamically, or that the lane maps to
+ * something other than a board slot
+ */
+static u8 lane_to_slot[] = {
+	0, 0, 0, 0,
+	0, 0, 0, 0,
+	1, 1, 1, 1,
+	0, 0, 0, 0
+};
+
+/*
+ * This function initializes the lane_to_slot[] array. It reads RCW to check
+ * if Serdes2{E,F,G,H} is configured as slot 2 or as SFP and initializes
+ * lane_to_slot[] accordingly
+ */
+static void initialize_lane_to_slot(void)
+{
+	unsigned int  serdes2_prtcl;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	serdes2_prtcl = in_be32(&gur->rcwsr[4]) &
+		FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+	serdes2_prtcl >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+	debug("Initializing lane to slot: Serdes2 protocol: %x\n",
+			serdes2_prtcl);
+
+	switch (serdes2_prtcl) {
+	case 0x18:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: SGMII
+		 * Lanes: E,F: Aur
+		 * Lanes: G,H: SRIO
+		 */
+	case 0x91:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B: SGMII
+		 * Lanes: C,D: SRIO2
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0x93:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: SGMII
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0x98:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: XAUI2
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0x9a:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B: PCI
+		 * Lanes: C,D: SGMII
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0x9e:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: PCI
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0xb2:
+	case 0x8d:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: PCI
+		 * Lanes: E,F: SGMII 3&4
+		 * Lanes: G,H: XFI
+		 */
+	case 0xc2:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B: SGMII
+		 * Lanes: C,D: SRIO2
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+		lane_to_slot[12] = 2;
+		lane_to_slot[13] = lane_to_slot[12];
+		lane_to_slot[14] = lane_to_slot[12];
+		lane_to_slot[15] = lane_to_slot[12];
+		break;
+
+	default:
+		printf("Fman: Unsupported SerDes2 Protocol 0x%02x\n",
+				serdes2_prtcl);
+			break;
+	}
+	return;
+}
+
+#endif /* #ifdef CONFIG_FMAN_ENET */
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FMAN_ENET
+	struct memac_mdio_info memac_mdio_info;
+	struct memac_mdio_info tg_memac_mdio_info;
+	unsigned int i;
+	unsigned int  serdes1_prtcl, serdes2_prtcl;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	serdes1_prtcl = in_be32(&gur->rcwsr[4]) &
+		FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+	if (!serdes1_prtcl) {
+		printf("SERDES1 is not enabled\n");
+		return 0;
+	}
+	serdes1_prtcl >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+	debug("Using SERDES1 Protocol: 0x%x:\n", serdes1_prtcl);
+
+	serdes2_prtcl = in_be32(&gur->rcwsr[4]) &
+		FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+	if (!serdes2_prtcl) {
+		printf("SERDES2 is not enabled\n");
+		return 0;
+	}
+	serdes2_prtcl >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+	debug("Using SERDES2 Protocol: 0x%x:\n", serdes2_prtcl);
+
+	printf("Initializing Fman\n");
+
+	initialize_lane_to_slot();
+
+	memac_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+	memac_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the real 1G MDIO bus */
+	fm_memac_mdio_init(bis, &memac_mdio_info);
+
+	tg_memac_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tg_memac_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the real 10G MDIO bus */
+	fm_memac_mdio_init(bis, &tg_memac_mdio_info);
+
+	/*
+	 * Program the two on board DTSEC PHY addresses assuming that they are
+	 * all SGMII. RGMII is not supported on this board. Setting SGMII 5 and
+	 * 6 to on board SGMII phys
+	 */
+	fm_info_set_phy_address(FM1_DTSEC5, CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC6, CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
+
+	switch (serdes1_prtcl) {
+	case 0x2a:
+		/* Serdes 1: A-B SGMII, Configuring DTSEC 5 and 6 */
+		debug("Setting phy addresses for FM1_DTSEC5: %x and"
+			"FM1_DTSEC6: %x\n", CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR,
+			CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC5,
+				CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC6,
+				CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
+		break;
+#ifdef CONFIG_PPC_B4420
+	case 0x18:
+		/* Serdes 1: A-D SGMII, Configuring on board dual SGMII Phy */
+		debug("Setting phy addresses for FM1_DTSEC3: %x and"
+			"FM1_DTSEC4: %x\n", CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR,
+			CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
+		/* Fixing Serdes clock by programming FPGA register */
+		QIXIS_WRITE(brdcfg[4], QIXIS_SRDS1CLK_125);
+		fm_info_set_phy_address(FM1_DTSEC3,
+				CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC4,
+				CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
+		break;
+#endif
+	default:
+		printf("Fman:  Unsupported SerDes1 Protocol 0x%02x\n",
+				serdes1_prtcl);
+		break;
+	}
+	switch (serdes2_prtcl) {
+	case 0x18:
+		debug("Setting phy addresses on SGMII Riser card for"
+				"FM1_DTSEC1: %x\n",
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC1,
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC2,
+				CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3,
+				CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC4,
+				CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR);
+		break;
+	case 0x49:
+		debug("Setting phy addresses on SGMII Riser card for"
+				"FM1_DTSEC1: %x\n",
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC1,
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC2,
+				CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3,
+				CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR);
+		break;
+	case 0xb2:
+	case 0x8d:
+		debug("Setting phy addresses on SGMII Riser card for"
+				"FM1_DTSEC1: %x\n",
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3,
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		/*
+		 * XFI does not need a PHY to work, but to avoid U-boot use
+		 * default PHY address which is zero to a MAC when it found
+		 * a MAC has no PHY address, we give a PHY address to XFI
+		 * MAC, and should not use a real XAUI PHY address, since
+		 * MDIO can access it successfully, and then MDIO thinks
+		 * the XAUI card is used for the XFI MAC, which will cause
+		 * error.
+		 */
+		fm_info_set_phy_address(FM1_DTSEC4,
+				CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_10GEC1,
+				0);
+		fm_info_set_phy_address(FM1_10GEC2,
+				1);
+		break;
+	case 0x98:
+		/* XAUI in Slot1 and Slot2 */
+		debug("Setting phy addresses on B4860 QDS AMC2PEX-2S"
+				"for FM1_10GEC1: %x\n",
+				CONFIG_SYS_FM1_10GEC1_PHY_ADDR);
+		fm_info_set_phy_address(FM1_10GEC1,
+				CONFIG_SYS_FM1_10GEC1_PHY_ADDR);
+		debug("Setting phy addresses on B4860 QDS AMC2PEX-2S"
+				"for FM1_10GEC2: %x\n",
+				CONFIG_SYS_FM1_10GEC2_PHY_ADDR);
+		fm_info_set_phy_address(FM1_10GEC2,
+				CONFIG_SYS_FM1_10GEC2_PHY_ADDR);
+		break;
+	case 0x9E:
+		/* XAUI in Slot2 */
+		debug("Setting phy addresses on B4860 QDS AMC2PEX-2S"
+				"for FM1_10GEC2: %x\n",
+				CONFIG_SYS_FM1_10GEC2_PHY_ADDR);
+		fm_info_set_phy_address(FM1_10GEC2,
+				CONFIG_SYS_FM1_10GEC2_PHY_ADDR);
+		break;
+	default:
+		printf("Fman:  Unsupported SerDes2 Protocol 0x%02x\n",
+				serdes2_prtcl);
+		break;
+	}
+
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+		int idx = i - FM1_DTSEC1;
+
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_SGMII:
+			fm_info_set_mdio(i,
+				miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+			break;
+		case PHY_INTERFACE_MODE_NONE:
+			fm_info_set_phy_address(i, 0);
+			break;
+		default:
+			printf("Fman1: DTSEC%u set to unknown interface %i\n",
+					idx + 1, fm_info_get_enet_if(i));
+			fm_info_set_phy_address(i, 0);
+			break;
+		}
+	}
+
+	for (i = FM1_10GEC1; i < FM1_10GEC1 + CONFIG_SYS_NUM_FM1_10GEC; i++) {
+		int idx = i - FM1_10GEC1;
+
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_XGMII:
+			fm_info_set_mdio(i,
+			     miiphy_get_dev_by_name(DEFAULT_FM_TGEC_MDIO_NAME));
+			break;
+		case PHY_INTERFACE_MODE_NONE:
+			fm_info_set_phy_address(i, 0);
+			break;
+		default:
+			printf("Fman1: TGEC%u set to unknown interface %i\n",
+					idx + 1, fm_info_get_enet_if(i));
+			fm_info_set_phy_address(i, 0);
+			break;
+		}
+	}
+
+	cpu_eth_init(bis);
+#endif
+
+	return pci_eth_init(bis);
+}
+
+/*
+ * Set status to disabled for unused ethernet node
+ */
+
+void fdt_fixup_board_enet(void *fdt)
+{
+	int i;
+	char alias[32];
+
+	for (i = FM1_DTSEC1; i <= FM1_10GEC2; i++) {
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_NONE:
+			sprintf(alias, "ethernet%u", i);
+			fdt_status_disabled_by_alias(fdt, alias);
+			break;
+		default:
+			break;
+		}
+	}
+}
+/*
+ * Given the following ...
+ *
+ * 1) A pointer to an Fman Ethernet node (as identified by the 'compat'
+ * compatible string and 'addr' physical address)
+ *
+ * 2) An Fman port
+ *
+ * ... update the phy-handle property of the Ethernet node to point to the
+ * right PHY.  This assumes that we already know the PHY for each port.  That
+ * information is stored in fm_info[i].phy_addr.
+ *
+ * The offset of the Fman Ethernet node is also passed in for convenience, but
+ * it is not used.
+ *
+ * Note that what we call "Fman ports" (enum fm_port) is really an Fman MAC.
+ * Inside the Fman, "ports" are things that connect to MACs.  We only call them
+ * ports in U-Boot because on previous Ethernet devices (e.g. Gianfar), MACs
+ * and ports are the same thing.
+ */
+void board_ft_fman_fixup_port(void *fdt, char *compat, phys_addr_t addr,
+			      enum fm_port port, int offset)
+{
+	int phy;
+	char alias[16];
+	struct fixed_link f_link;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 prtcl2 = in_be32(&gur->rcwsr[4]) & FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+
+	prtcl2 >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+
+	if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_SGMII) {
+		phy = fm_info_get_phy_address(port);
+		sprintf(alias, "phy_sgmii_%x", phy);
+		fdt_set_phy_handle(fdt, compat, addr, alias);
+		fdt_status_okay_by_alias(fdt, alias);
+	} else if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_XGMII) {
+		/* check if it's XFI interface for 10g */
+		switch (prtcl2) {
+		case 0x81:
+		case 0x82:
+		case 0x84:
+		case 0x85:
+		case 0x87:
+		case 0x88:
+		case 0x8a:
+		case 0x8b:
+		case 0x8d:
+		case 0x8e:
+		case 0xb2:
+			f_link.phy_id = port;
+			f_link.duplex = 1;
+			f_link.link_speed = 10000;
+			f_link.pause = 0;
+			f_link.asym_pause = 0;
+
+			fdt_delprop(fdt, offset, "phy-handle");
+			fdt_setprop(fdt, offset, "fixed-link", &f_link,
+					sizeof(f_link));
+			break;
+		case 0x98: /* XAUI interface */
+			sprintf(alias, "phy_xaui_slot1");
+			fdt_status_okay_by_alias(fdt, alias);
+
+			sprintf(alias, "phy_xaui_slot2");
+			fdt_status_okay_by_alias(fdt, alias);
+			break;
+		case 0x9e: /* XAUI interface */
+		case 0x9a:
+		case 0x93:
+		case 0x91:
+			sprintf(alias, "phy_xaui_slot1");
+			fdt_status_okay_by_alias(fdt, alias);
+			break;
+		case 0x97: /* XAUI interface */
+		case 0xc3:
+			sprintf(alias, "phy_xaui_slot2");
+			fdt_status_okay_by_alias(fdt, alias);
+			break;
+		default:
+			break;
+		}
+	}
+}
diff --git a/board/freescale/b4860qds/law.c b/board/freescale/b4860qds/law.c
new file mode 100644
index 0000000..abaad7a
--- /dev/null
+++ b/board/freescale/b4860qds/law.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_IFC),
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_BMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_BMAN),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
+#endif
+	SET_LAW(QIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	/* Limit DCSR to 32M to access NPC Trace Buffer */
+	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_DCSR),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/freescale/b4860qds/pci.c b/board/freescale/b4860qds/pci.c
new file mode 100644
index 0000000..b130d13
--- /dev/null
+++ b/board/freescale/b4860qds/pci.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <asm/fsl_serdes.h>
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void pci_of_setup(void *blob, bd_t *bd)
+{
+	FT_FSL_PCI_SETUP;
+}
diff --git a/board/freescale/b4860qds/tlb.c b/board/freescale/b4860qds/tlb.c
new file mode 100644
index 0000000..3572b44
--- /dev/null
+++ b/board/freescale/b4860qds/tlb.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L3_ADDR)
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 1M SRAM, the address of the
+	 * SRAM is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L3_ADDR, CONFIG_SYS_INIT_L3_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_1M, 1),
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. When slave boot, the address of the
+	 * space is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR,
+			CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_W|MAS2_G,
+			0, 0, BOOKE_PAGESZ_1M, 1),
+#else
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_16M, 1),
+
+	/* *I*G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_256M, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT + 0x10000000,
+                      CONFIG_SYS_PCIE1_MEM_PHYS + 0x10000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 5, BOOKE_PAGESZ_64K, 1),
+
+	/* Bman/Qman */
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE, CONFIG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 6, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_BMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 7, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE, CONFIG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 8, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_QMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 9, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_DCSRBAR, CONFIG_SYS_DCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_32M, 1),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE
+	/*
+	 * *I*G - NAND
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 11, BOOKE_PAGESZ_64K, 1),
+#endif
+	SET_TLB_ENTRY(1, QIXIS_BASE, QIXIS_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 12, BOOKE_PAGESZ_4K, 1),
+
+	/*
+	 * *I*G - SRIO
+	 * entry 14 and 15 has been used hard coded, they will be disabled
+	 * in cpu_init_f, so we use entry 16 for SRIO2.
+	 */
+#ifdef CONFIG_SYS_SRIO1_MEM_PHYS
+	/* *I*G* - SRIO1 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO1_MEM_VIRT, CONFIG_SYS_SRIO1_MEM_PHYS,
+		MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 13, BOOKE_PAGESZ_256M, 1),
+#endif
+#ifdef CONFIG_SYS_SRIO2_MEM_PHYS
+	/* *I*G* - SRIO2 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO2_MEM_VIRT, CONFIG_SYS_SRIO2_MEM_PHYS,
+		MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 16, BOOKE_PAGESZ_256M, 1),
+#endif
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. 1M space from 0xffe00000 for
+	 * fetching ucode and ENV from master
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR,
+		CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS,
+		MAS3_SX|MAS3_SW|MAS3_SR, MAS2_G,
+		0, 17, BOOKE_PAGESZ_1M, 1),
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/freescale/bsc9131rdb/Makefile b/board/freescale/bsc9131rdb/Makefile
index 6f4cb26..2e829ad 100644
--- a/board/freescale/bsc9131rdb/Makefile
+++ b/board/freescale/bsc9131rdb/Makefile
@@ -24,12 +24,28 @@ include $(TOPDIR)/config.mk
 
 LIB    = $(obj)lib$(BOARD).o
 
+MINIMAL=
+
+ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_SPL_INIT_MINIMAL
+MINIMAL=y
+endif
+endif
+
+ifdef MINIMAL
+
+COBJS-y	+= spl_minimal.o tlb.o law.o
+
+else
+
 COBJS-y        += $(BOARD).o
 COBJS-y        += ddr.o
 COBJS-y        += law.o
 COBJS-y        += tlb.o
 #COBJS-y		+= bsc9131rdb_mux.o
 
+endif
+
 SRCS   := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS   := $(addprefix $(obj),$(COBJS-y))
 SOBJS  := $(addprefix $(obj),$(SOBJS))
diff --git a/board/freescale/bsc9131rdb/README b/board/freescale/bsc9131rdb/README
index 065faa3..4902b98 100644
--- a/board/freescale/bsc9131rdb/README
+++ b/board/freescale/bsc9131rdb/README
@@ -89,10 +89,14 @@ NAND boot
 Building U-boot
 --------------
 To build the u-boot for BSC9131RDB:
-1. NAND Flash
+1. NAND Flash with sysclk 66MHz(J16 on RDB closed, default)
 	make BSC9131RDB_NAND
-2. SPI Flash
+2. NAND Flash with sysclk 100MHz(J16 on RDB open)
+	make BSC9131RDB_NAND_SYSCLK100
+3. SPI Flash with sysclk 66MHz(J16 on RDB closed, default)
 	make BSC9131RDB_SPIFLASH
+4. SPI Flash with sysclk 100MHz(J16 on RDB open)
+	make BSC9131RDB_SPIFLASH_SYSCLK100
 
 Memory map
 -----------
@@ -107,6 +111,16 @@ Memory map
  0xFF70_0000	0xFF7F_FFFF	PA CCSR			1M
  0xFF80_0000	0xFFFF_FFFF	Boot Page & NAND Buffer 8M
 
+DDR Memory map
+---------------
+ 0x0000_0000	0x36FF_FFFF	Memory passed onto Linux
+ 0x3700_0000	0x37FF_FFFF	PowerPC-DSP shared control area
+ 0x3800_0000	0x4FFF_FFFF	DSP Private area
+
+ Out of 880M, passed onto Linux, 1hugetlb page of 256M is reserved for
+ data communcation between PowerPC and DSP core.
+ Rest is PowerPC private area.
+
 Flashing Images
 ---------------
 To place a new u-boot image in the NAND flash and then boot
diff --git a/board/freescale/bsc9131rdb/ddr.c b/board/freescale/bsc9131rdb/ddr.c
index c753edf..5296986 100644
--- a/board/freescale/bsc9131rdb/ddr.c
+++ b/board/freescale/bsc9131rdb/ddr.c
@@ -103,7 +103,7 @@ phys_size_t fixed_sdram(void)
 	}
 
 	ddr_size = (phys_size_t) CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
-	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
 
 	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE, ddr_size,
 					LAW_TRGT_IF_DDR_1) < 0) {
diff --git a/board/freescale/bsc9131rdb/law.c b/board/freescale/bsc9131rdb/law.c
index 201c147..0432780 100644
--- a/board/freescale/bsc9131rdb/law.c
+++ b/board/freescale/bsc9131rdb/law.c
@@ -26,6 +26,10 @@
 
 struct law_entry law_table[] = {
 	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_FSL_DSP_CCSRBAR_PHYS, LAW_SIZE_1M,
+		LAW_TRGT_IF_DSP_CCSR),
+	SET_LAW(CONFIG_SYS_FSL_DSP_M2_RAM_ADDR, LAW_SIZE_16M,
+		LAW_TRGT_IF_OCN_DSP),
 };
 
 int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/freescale/bsc9131rdb/spl_minimal.c b/board/freescale/bsc9131rdb/spl_minimal.c
new file mode 100644
index 0000000..b5b29e0
--- /dev/null
+++ b/board/freescale/bsc9131rdb/spl_minimal.c
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <common.h>
+#include <ns16550.h>
+#include <asm/io.h>
+#include <nand.h>
+#include <linux/compiler.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+static void sdram_init(void)
+{
+	ccsr_ddr_t *ddr = (ccsr_ddr_t *)CONFIG_SYS_MPC8xxx_DDR_ADDR;
+
+	__raw_writel(CONFIG_SYS_DDR_CS0_BNDS, &ddr->cs0_bnds);
+	__raw_writel(CONFIG_SYS_DDR_CS0_CONFIG, &ddr->cs0_config);
+#if CONFIG_CHIP_SELECTS_PER_CTRL > 1
+	__raw_writel(CONFIG_SYS_DDR_CS1_BNDS, &ddr->cs1_bnds);
+	__raw_writel(CONFIG_SYS_DDR_CS1_CONFIG, &ddr->cs1_config);
+#endif
+	__raw_writel(CONFIG_SYS_DDR_TIMING_3_800, &ddr->timing_cfg_3);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_0_800, &ddr->timing_cfg_0);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_1_800, &ddr->timing_cfg_1);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_2_800, &ddr->timing_cfg_2);
+
+	__raw_writel(CONFIG_SYS_DDR_CONTROL_2, &ddr->sdram_cfg_2);
+	__raw_writel(CONFIG_SYS_DDR_MODE_1_800, &ddr->sdram_mode);
+	__raw_writel(CONFIG_SYS_DDR_MODE_2_800, &ddr->sdram_mode_2);
+
+	__raw_writel(CONFIG_SYS_DDR_INTERVAL_800, &ddr->sdram_interval);
+	__raw_writel(CONFIG_SYS_DDR_DATA_INIT, &ddr->sdram_data_init);
+	__raw_writel(CONFIG_SYS_DDR_CLK_CTRL_800, &ddr->sdram_clk_cntl);
+
+	__raw_writel(CONFIG_SYS_DDR_WRLVL_CONTROL_800, &ddr->ddr_wrlvl_cntl);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_4, &ddr->timing_cfg_4);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_5, &ddr->timing_cfg_5);
+	__raw_writel(CONFIG_SYS_DDR_ZQ_CONTROL, &ddr->ddr_zq_cntl);
+
+	/* Set, but do not enable the memory */
+	__raw_writel(CONFIG_SYS_DDR_CONTROL & ~SDRAM_CFG_MEM_EN, &ddr->sdram_cfg);
+
+	asm volatile("sync;isync");
+	udelay(500);
+
+	/* Let the controller go */
+	out_be32(&ddr->sdram_cfg, in_be32(&ddr->sdram_cfg) | SDRAM_CFG_MEM_EN);
+
+	set_next_law(CONFIG_SYS_NAND_DDR_LAW, LAW_SIZE_1G, LAW_TRGT_IF_DDR_1);
+}
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	/* initialize selected port with appropriate baud rate */
+	plat_ratio = in_be32(&gur->porpllsr) & MPC85xx_PORPLLSR_PLAT_RATIO;
+	plat_ratio >>= 1;
+	gd->bus_clk = CONFIG_SYS_CLK_FREQ * plat_ratio;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+			gd->bus_clk / 16 / CONFIG_BAUDRATE);
+
+	puts("\nNAND boot... ");
+
+	/* Initialize the DDR3 */
+	sdram_init();
+
+	/* copy code to RAM and jump to it - this should not return */
+	/* NOTE - code has to be copied out of NAND buffer before
+	 * other blocks can be read.
+	 */
+	relocate_code(CONFIG_SPL_RELOC_STACK, 0, CONFIG_SPL_RELOC_TEXT_BASE);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	nand_boot();
+}
+
+void putc(char c)
+{
+	if (c == '\n')
+		NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, '\r');
+
+	NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, c);
+}
+
+void puts(const char *str)
+{
+	while (*str)
+		putc(*str++);
+}
diff --git a/board/freescale/bsc9131rdb/tlb.c b/board/freescale/bsc9131rdb/tlb.c
index 5b68f4a..87451c3 100644
--- a/board/freescale/bsc9131rdb/tlb.c
+++ b/board/freescale/bsc9131rdb/tlb.c
@@ -44,15 +44,25 @@ struct fsl_e_tlb_entry tlb_table[] = {
 	/* TLB 1 */
 	/* *I*** - Covers boot page */
 	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
-			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
-			0, 0, BOOKE_PAGESZ_4K, 1),
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#ifdef CONFIG_SPL_NAND_MINIMAL
+	SET_TLB_ENTRY(1, 0xffffe000, 0xffffe000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_4K, 1),
+#endif
 
 	/* *I*G* - CCSRBAR (PA) */
 	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
 			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 			0, 1, BOOKE_PAGESZ_1M, 1),
 
-#if defined(CONFIG_SYS_RAMBOOT)
+	/* CCSRBAR (DSP) */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FSL_DSP_CCSRBAR,
+		      CONFIG_SYS_FSL_DSP_CCSRBAR_PHYS, MAS3_SW|MAS3_SR,
+		      MAS2_I|MAS2_G, 0, 2, BOOKE_PAGESZ_1M, 1),
+
+#if  defined(CONFIG_SYS_RAMBOOT) || defined(CONFIG_SPL)
 	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
 			MAS3_SX|MAS3_SW|MAS3_SR, 0,
 			0, 8, BOOKE_PAGESZ_1G, 1),
diff --git a/board/freescale/bsc9132qds/Makefile b/board/freescale/bsc9132qds/Makefile
new file mode 100644
index 0000000..72b1917
--- /dev/null
+++ b/board/freescale/bsc9132qds/Makefile
@@ -0,0 +1,69 @@
+#
+# Copyright 2013 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+MINIMAL=
+
+ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_SPL_INIT_MINIMAL
+MINIMAL=y
+endif
+endif
+
+ifdef MINIMAL
+
+COBJS-y	+= spl_minimal.o tlb.o law.o
+
+else
+
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+
+endif
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/bsc9132qds/README b/board/freescale/bsc9132qds/README
new file mode 100644
index 0000000..4a3dbfe
--- /dev/null
+++ b/board/freescale/bsc9132qds/README
@@ -0,0 +1,150 @@
+Overview
+--------
+ The BSC9132 is a highly integrated device that targets the evolving
+ Microcell, Picocell, and Enterprise-Femto base station market subsegments.
+
+ The BSC9132 device combines Power Architecture e500 and DSP StarCore SC3850
+ core technologies with MAPLE-B2P baseband acceleration processing elements
+ to address the need for a high performance, low cost, integrated solution
+ that handles all required processing layers without the need for an
+ external device except for an RF transceiver or, in a Micro base station
+ configuration, a host device that handles the L3/L4 and handover between
+ sectors.
+
+ The BSC9132 SoC includes the following function and features:
+    - Power Architecture subsystem including two e500 processors with
+	512-Kbyte shared L2 cache
+    - Two StarCore SC3850 DSP subsystems, each with a 512-Kbyte private L2
+	cache
+    - 32 Kbyte of shared M3 memory
+    - The Multi Accelerator Platform Engine for Pico BaseStation Baseband
+      Processing (MAPLE-B2P)
+    - Two DDR3/3L memory interfaces with 32-bit data width (40 bits including
+      ECC), up to 1333 MHz data rate
+    - Dedicated security engine featuring trusted boot
+    - Two DMA controllers
+         - OCNDMA with four bidirectional channels
+         - SysDMA with sixteen bidirectional channels
+    - Interfaces
+        - Four-lane SerDes PHY
+	    - PCI Express controller complies with the PEX Specification-Rev 2.0
+        - Two Common Public Radio Interface (CPRI) controller lanes
+	    - High-speed USB 2.0 host and device controller with ULPI interface
+        - Enhanced secure digital (SD/MMC) host controller (eSDHC)
+	    - Antenna interface controller (AIC), supporting four industry
+		standard JESD207/four custom ADI RF interfaces
+       - ADI lanes support both full duplex FDD support & half duplex TDD
+       - Universal Subscriber Identity Module (USIM) interface that
+	   facilitates communication to SIM cards or Eurochip pre-paid phone
+	   cards
+       - Two DUART, two eSPI, and two I2C controllers
+       - Integrated Flash memory controller (IFC)
+       - GPIO
+     - Sixteen 32-bit timers
+
+The SC3850 core subsystem consists of the following:
+ - 32 KB, 8-way, level 1 instruction cache (L1 ICache)
+ - 32 KB, 8-way, level 1 data cache (L1 DCache)
+ - 512 KB, 8-way, level 2 unified instruction/data cache (L2 cache/M2 memory)
+ - Memory management unit (MMU)
+ - Global interrupt controller ( GIC)
+ - Debug and profiling unit (DPU)
+ - Two 32-bit quad timers
+
+BSC9132QDS board Overview
+-------------------------
+ 2Gbyte DDR3 (on board DDR), Dual Ranki
+ 32Mbyte 16bit NOR flash
+ 128Mbyte 2K page size NAND Flash
+ 256 Kbit M24256 I2C EEPROM
+ 128 Mbit SPI Flash memory
+ SD slot
+ USB-ULPI
+ eTSEC1: Connected to SGMII PHY
+ eTSEC2: Connected to SGMII PHY
+ PCIe
+ CPRI
+ SerDes
+ I2C RTC
+ DUART interface: supports one UARTs up to 115200 bps for console display
+
+Frequency Combinations Supported
+--------------------------------
+Core MHz/CCB MHz/DDR(MT/s)
+1. CPU0/CPU1/CCB/DDR: 1000MHz/1000MHz/500MHz/800MHz
+     (SYSCLK = 100MHz, DDRCLK = 100MHz)
+2. CPU0/CPU1/CCB/DDR: 1200MHz/1200MHz/600MHz/1330MHz
+     (SYSCLK = 100MHz, DDRCLK = 133MHz)
+
+Boot Methods Supported
+-----------------------
+1. NOR Flash
+2. NAND Flash
+3. SD Card
+4. SPI flash
+
+Default Boot Method
+--------------------
+NOR boot
+
+Building U-boot
+--------------
+To build the u-boot for BSC9132QDS:
+1. NOR Flash
+	make BSC9132QDS_NOR_DDRCLK100 : For 100MHZ DDR CLK
+	make BSC9132QDS_NOR_DDRCLK133 : For 133MHZ DDR CLK
+2. NAND Flash : It is currently not supported
+3. SPI Flash
+	make BSC9132QDS_SPIFLASH_DDRCLK100 : For 100MHZ DDR CLK
+	make BSC9132QDS_SPIFLASH_DDRCLK133 : For 133MHZ DDR CLK
+4. SD Card
+	make BSC9132QDS_SDCARD_DDRCLK100 : For 100MHZ DDR CLK
+	make BSC9132QDS_SDCARD_DDRCLK133 : For 133MHZ DDR CLK
+
+Memory map
+-----------
+ 0x0000_0000	0x7FFF_FFFF	DDR			2G cacheable
+ 0x8000_0000	0x8FFF_FFFF	NOR Flash		256M
+ 0x9000_0000	0x9FFF_FFFF	PCIe Memory 		256M
+ 0xA000_0000	0xA7FF_FFFF	DSP core1 L2 space	128M
+ 0xB000_0000	0xB0FF_FFFF	DSP core0 M2 space	16M
+ 0xB100_0000	0xB1FF_FFFF	DSP core1 M2 space	16M
+ 0xC000_0000	0xC000_7FFF	M3 Memory		32K
+ 0xC001_0000	0xC001_FFFF	PCI Express I/O		64K
+ 0xC100_0000	0xC13F_FFFF	MAPLE-2F		4M
+ 0xC1F0_0000	0xC1F7_FFFF	PA SRAM Region 0	512K
+ 0xC1F8_0000	0xC1FB_FFFF	PA SRAM Region 1	512K
+ 0xFED0_0000	0xFED0_3FFF	SEC Secured RAM		16K
+ 0xFEE0_0000	0xFEE0_0FFF	DSP Boot ROM		4K
+ 0xFF60_0000	0xFF6F_FFFF 	DSP CCSR		1M
+ 0xFF70_0000	0xFF7F_FFFF	PA CCSR			1M
+ 0xFF80_0000	0xFFFF_FFFF	Boot Page & NAND Buffer 8M
+
+Flashing Images
+---------------
+To place a new u-boot image in the NAND flash and then boot
+with that new image temporarily, use this:
+	tftp 1000000 u-boot-nand.bin
+	nand erase 0 100000
+	nand write 1000000 0 100000
+	reset
+
+Using the Device Tree Source File
+---------------------------------
+To create the DTB (Device Tree Binary) image file,
+use a command similar to this:
+
+	dtc -b 0 -f -I dts -O dtb bsc9132qds.dts > bsc9132qds.dtb
+
+Likely, that .dts file will come from here;
+
+	linux-2.6/arch/powerpc/boot/dts/bsc9132qds.dts
+
+Booting Linux
+-------------
+Place a linux uImage in the TFTP disk area.
+
+	tftp 1000000 uImage
+	tftp 2000000 rootfs.ext2.gz.uboot
+	tftp c00000 bsc9132qds.dtb
+	bootm 1000000 2000000 c00000
diff --git a/board/freescale/bsc9132qds/bsc9132qds.c b/board/freescale/bsc9132qds/bsc9132qds.c
new file mode 100644
index 0000000..3ec5911
--- /dev/null
+++ b/board/freescale/bsc9132qds/bsc9132qds.c
@@ -0,0 +1,425 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <fsl_mdio.h>
+#include <tsec.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <asm/fsl_ifc.h>
+#include <hwconfig.h>
+#include <i2c.h>
+#include <asm/fsl_ddr_sdram.h>
+
+#ifdef CONFIG_PCI
+#include <pci.h>
+#include <asm/fsl_pci.h>
+#endif
+
+#include "../common/qixis.h"
+DECLARE_GLOBAL_DATA_PTR;
+
+
+int board_early_init_f(void)
+{
+	struct fsl_ifc *ifc = (void *)CONFIG_SYS_IFC_ADDR;
+
+	setbits_be32(&ifc->ifc_gcr, 1 << IFC_GCR_TBCTL_TRN_TIME_SHIFT);
+
+	return 0;
+}
+
+void board_config_serdes_mux(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 pordevsr = in_be32(&gur->pordevsr);
+	u32 srds_cfg = (pordevsr & MPC85xx_PORDEVSR_IO_SEL) >>
+				MPC85xx_PORDEVSR_IO_SEL_SHIFT;
+
+	switch (srds_cfg) {
+	/* PEX(1) PEX(2) CPRI 2 CPRI 1 */
+	case  1:
+	case  2:
+	case  3:
+	case  4:
+	case  5:
+	case 22:
+	case 23:
+	case 24:
+	case 25:
+	case 26:
+		QIXIS_WRITE_I2C(brdcfg[4], 0x03);
+		break;
+
+	/* PEX(1) PEX(2) SGMII1 CPRI 1 */
+	case  6:
+	case  7:
+	case  8:
+	case  9:
+	case 10:
+	case 27:
+	case 28:
+	case 29:
+	case 30:
+	case 31:
+		QIXIS_WRITE_I2C(brdcfg[4], 0x01);
+		break;
+
+	/* PEX(1) PEX(2) SGMII1 SGMII2 */
+	case 11:
+	case 32:
+		QIXIS_WRITE_I2C(brdcfg[4], 0x00);
+		break;
+
+	/* PEX(1) SGMII2 CPRI 2 CPRI 1 */
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+	case 16:
+	case 33:
+	case 34:
+	case 35:
+	case 36:
+	case 37:
+		QIXIS_WRITE_I2C(brdcfg[4], 0x07);
+		break;
+
+	/* PEX(1) SGMII2 SGMII1 CPRI 1 */
+	case 17:
+	case 18:
+	case 19:
+	case 20:
+	case 21:
+	case 38:
+	case 39:
+	case 40:
+	case 41:
+	case 42:
+		QIXIS_WRITE_I2C(brdcfg[4], 0x05);
+		break;
+
+	/* SGMII1 SGMII2 CPRI 2 CPRI 1 */
+	case 43:
+	case 44:
+	case 45:
+	case 46:
+	case 47:
+		QIXIS_WRITE_I2C(brdcfg[4], 0x0F);
+		break;
+
+
+	default:
+		break;
+	}
+}
+
+/* Configure DSP DDR controller */
+void dsp_ddr_configure(void)
+{
+	/*
+	 *There are separate DDR-controllers for DSP and PowerPC side DDR.
+	 *copy the ddr controller settings from PowerPC side DDR controller
+	 *to the DSP DDR controller as connected DDR memories are similar.
+	 */
+	ccsr_ddr_t __iomem *pa_ddr =
+			(ccsr_ddr_t __iomem *)CONFIG_SYS_MPC8xxx_DDR_ADDR;
+	ccsr_ddr_t temp_ddr;
+	ccsr_ddr_t __iomem *dsp_ddr =
+			(ccsr_ddr_t __iomem *)CONFIG_SYS_FSL_DSP_CCSR_DDR_ADDR;
+
+	memcpy(&temp_ddr, pa_ddr, sizeof(ccsr_ddr_t));
+	temp_ddr.cs0_bnds = CONFIG_SYS_DDR1_CS0_BNDS;
+	temp_ddr.sdram_cfg &= ~SDRAM_CFG_MEM_EN;
+	memcpy(dsp_ddr, &temp_ddr, sizeof(ccsr_ddr_t));
+	dsp_ddr->sdram_cfg |= SDRAM_CFG_MEM_EN;
+}
+
+int board_early_init_r(void)
+{
+#ifndef CONFIG_SYS_NO_FLASH
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_64M, 1);
+
+	set_tlb(1, flashbase + 0x4000000,
+			CONFIG_SYS_FLASH_BASE_PHYS + 0x4000000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel+1, BOOKE_PAGESZ_64M, 1);
+#endif
+	board_config_serdes_mux();
+	dsp_ddr_configure();
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+#endif /* ifdef CONFIG_PCI */
+
+int checkboard(void)
+{
+	struct cpu_type *cpu;
+	u8 sw;
+
+	cpu = gd->cpu;
+	printf("Board: %sQDS\n", cpu->name);
+
+	printf("Sys ID: 0x%02x, Sys Ver: 0x%02x, FPGA Ver: 0x%02x,\n",
+	QIXIS_READ(id), QIXIS_READ(arch), QIXIS_READ(scver));
+
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	printf("IFC chip select:");
+	switch (sw) {
+	case 0:
+		printf("NOR\n");
+		break;
+	case 2:
+		printf("Promjet\n");
+		break;
+	case 4:
+		printf("NAND\n");
+		break;
+	default:
+		printf("Invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+		break;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct fsl_pq_mdio_info mdio_info;
+	struct tsec_info_struct tsec_info[4];
+	int num = 0;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+
+#endif
+
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	num++;
+#endif
+
+	mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
+	mdio_info.name = DEFAULT_MII_NAME;
+
+	fsl_pq_mdio_init(bis, &mdio_info);
+	tsec_eth_init(bis, tsec_info, num);
+
+	#ifdef CONFIG_PCI
+	pci_eth_init(bis);
+	#endif
+
+	return 0;
+}
+#endif
+
+#define USBMUX_SEL_MASK		0xc0
+#define USBMUX_SEL_UART2	0xc0
+#define USBMUX_SEL_USB		0x40
+#define SPIMUX_SEL_UART3	0x80
+#define GPS_MUX_SEL_GPS		0x40
+
+#define TSEC_1588_CLKIN_MASK	0x03
+#define CON_XCVR_REF_CLK	0x00
+
+int misc_init_r(void)
+{
+	u8 val;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 porbmsr = in_be32(&gur->porbmsr);
+	u32 romloc = (porbmsr >> MPC85XX_PORBMSR_ROMLOC_SHIFT) & 0xf;
+
+	/*Configure 1588 clock-in source from RF Card*/
+	val = QIXIS_READ_I2C(brdcfg[5]);
+	QIXIS_WRITE_I2C(brdcfg[5],
+		(val & ~(TSEC_1588_CLKIN_MASK)) | CON_XCVR_REF_CLK);
+
+	if (hwconfig("uart2") && hwconfig("usb1")) {
+		printf("UART2 and USB cannot work together on the board\n");
+		printf("Remove one from hwconfig and reset\n");
+	} else {
+		if (hwconfig("uart2")) {
+			val = QIXIS_READ_I2C(brdcfg[5]);
+			QIXIS_WRITE_I2C(brdcfg[5],
+				(val & ~(USBMUX_SEL_MASK)) | USBMUX_SEL_UART2);
+			clrbits_be32(&gur->pmuxcr3,
+						MPC85xx_PMUXCR3_USB_SEL_MASK);
+			setbits_be32(&gur->pmuxcr3, MPC85xx_PMUXCR3_UART2_SEL);
+		} else {
+			/* By default USB should be selected.
+			* Programming FPGA to select USB. */
+			val = QIXIS_READ_I2C(brdcfg[5]);
+			QIXIS_WRITE_I2C(brdcfg[5],
+				(val & ~(USBMUX_SEL_MASK)) | USBMUX_SEL_USB);
+		}
+
+	}
+
+	if (hwconfig("sim")) {
+		if (romloc == PORBMSR_ROMLOC_NAND_2K ||
+			romloc == PORBMSR_ROMLOC_NOR ||
+			romloc == PORBMSR_ROMLOC_SPI) {
+
+			val = QIXIS_READ_I2C(brdcfg[3]);
+			QIXIS_WRITE_I2C(brdcfg[3], val|0x10);
+			clrbits_be32(&gur->pmuxcr,
+				MPC85xx_PMUXCR0_SIM_SEL_MASK);
+			setbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR0_SIM_SEL);
+		}
+	}
+
+	if (hwconfig("uart3")) {
+		if (romloc == PORBMSR_ROMLOC_NAND_2K ||
+			romloc == PORBMSR_ROMLOC_NOR ||
+			romloc == PORBMSR_ROMLOC_SDHC) {
+
+			/* UART3 and SPI1 (Flashes) are muxed together */
+			val = QIXIS_READ_I2C(brdcfg[3]);
+			QIXIS_WRITE_I2C(brdcfg[3], (val | SPIMUX_SEL_UART3));
+			clrbits_be32(&gur->pmuxcr3,
+						MPC85xx_PMUXCR3_UART3_SEL_MASK);
+			setbits_be32(&gur->pmuxcr3, MPC85xx_PMUXCR3_UART3_SEL);
+
+			/* MUX to select UART3 connection to J24 header
+			 * or to GPS */
+			val = QIXIS_READ_I2C(brdcfg[6]);
+			if (hwconfig("gps"))
+				QIXIS_WRITE_I2C(brdcfg[6],
+						(val | GPS_MUX_SEL_GPS));
+			else
+				QIXIS_WRITE_I2C(brdcfg[6],
+						(val & ~(GPS_MUX_SEL_GPS)));
+		}
+	}
+	return 0;
+}
+
+void fdt_del_node_compat(void *blob, const char *compatible)
+{
+	int err;
+	int off = fdt_node_offset_by_compatible(blob, -1, compatible);
+	if (off < 0) {
+		printf("WARNING: could not find compatible node %s: %s.\n",
+			compatible, fdt_strerror(off));
+		return;
+	}
+	err = fdt_del_node(blob, off);
+	if (err < 0) {
+		printf("WARNING: could not remove %s: %s.\n",
+			compatible, fdt_strerror(err));
+	}
+}
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	#if defined(CONFIG_PCI)
+	FT_FSL_PCI_SETUP;
+	#endif
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 porbmsr = in_be32(&gur->porbmsr);
+	u32 romloc = (porbmsr >> MPC85XX_PORBMSR_ROMLOC_SHIFT) & 0xf;
+
+	if (!(hwconfig("uart2") && hwconfig("usb1"))) {
+		/* If uart2 is there in hwconfig remove usb node from
+		 *  device tree */
+
+		if (hwconfig("uart2")) {
+			/* remove dts usb node */
+			fdt_del_node_compat(blob, "fsl-usb2-dr");
+		} else {
+			fdt_fixup_dr_usb(blob, bd);
+			fdt_del_node_and_alias(blob, "serial2");
+		}
+	}
+
+	if (hwconfig("uart3")) {
+		if (romloc == PORBMSR_ROMLOC_NAND_2K ||
+			romloc == PORBMSR_ROMLOC_NOR ||
+			romloc == PORBMSR_ROMLOC_SDHC)
+			/* Delete SPI node from the device tree */
+				fdt_del_node_and_alias(blob, "spi1");
+	} else
+		fdt_del_node_and_alias(blob, "serial3");
+
+	if (hwconfig("sim")) {
+		if (romloc == PORBMSR_ROMLOC_NAND_2K ||
+			romloc == PORBMSR_ROMLOC_NOR ||
+			romloc == PORBMSR_ROMLOC_SPI) {
+
+			/* remove dts sdhc node */
+			fdt_del_node_compat(blob, "fsl,esdhc");
+		} else if (romloc == PORBMSR_ROMLOC_SDHC) {
+
+			/* remove dts sim node */
+			fdt_del_node_compat(blob, "fsl,sim-v1.0");
+			printf("SIM & SDHC can't work together on the board");
+			printf("\nRemove sim from hwconfig and reset\n");
+		}
+	}
+}
+#endif
diff --git a/board/freescale/bsc9132qds/ddr.c b/board/freescale/bsc9132qds/ddr.c
new file mode 100644
index 0000000..60abaa6
--- /dev/null
+++ b/board/freescale/bsc9132qds/ddr.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_SYS_DDR_RAW_TIMING
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_800 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_800,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_800,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_800,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_800,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_800,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_800,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_800,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_800,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL_800,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_1333 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_1333,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_1333,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_1333,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_1333,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_1333,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_1333,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_1333,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_1333,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL_1333,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+
+fixed_ddr_parm_t fixed_ddr_parm_0[] = {
+	{750, 850, &ddr_cfg_regs_800},
+	{1060, 1333, &ddr_cfg_regs_1333},
+	{0, 0, NULL}
+};
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+phys_size_t fixed_sdram(void)
+{
+	int i;
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	phys_size_t ddr_size;
+	ulong ddr_freq, ddr_freq_mhz;
+
+	ddr_freq = get_ddr_freq(0);
+	ddr_freq_mhz = ddr_freq / 1000000;
+
+	printf("Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, ddr_freq));
+
+	for (i = 0; fixed_ddr_parm_0[i].max_freq > 0; i++) {
+		if ((ddr_freq_mhz > fixed_ddr_parm_0[i].min_freq) &&
+		   (ddr_freq_mhz <= fixed_ddr_parm_0[i].max_freq)) {
+			memcpy(&ddr_cfg_regs, fixed_ddr_parm_0[i].ddr_settings,
+							sizeof(ddr_cfg_regs));
+			break;
+		}
+	}
+
+	if (fixed_ddr_parm_0[i].max_freq == 0)
+		panic("Unsupported DDR data rate %s MT/s data rate\n",
+					strmhz(buf, ddr_freq));
+
+	ddr_size = (phys_size_t) CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
+
+	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE, ddr_size,
+					LAW_TRGT_IF_DDR_1) < 0) {
+		printf("ERROR setting Local Access Windows for DDR\n");
+		return 0;
+	}
+
+	return ddr_size;
+}
+
+#else /* CONFIG_SYS_DDR_RAW_TIMING */
+/* Micron MT41J512M8_187E */
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 1073741824u,
+	.capacity = 1073741824u,
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 15,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tCKmin_X_ps = 1870,
+	.caslat_X = 0x1e << 4,	/* 5,6,7,8 */
+	.tAA_ps = 13125,
+	.tWR_ps = 15000,
+	.tRCD_ps = 13125,
+	.tRRD_ps = 7500,
+	.tRP_ps = 13125,
+	.tRAS_ps = 37500,
+	.tRC_ps = 50625,
+	.tRFC_ps = 160000,
+	.tWTR_ps = 7500,
+	.tRTP_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tFAW_ps = 37500,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR on board";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	int i;
+	popts->clk_adjust = 6;
+	popts->cpo_override = 0x1f;
+	popts->write_data_delay = 2;
+	popts->half_strength_driver_enable = 1;
+	/* Write leveling override */
+	popts->wrlvl_en = 1;
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+	popts->wrlvl_start = 0x8;
+	popts->trwt_override = 1;
+	popts->trwt = 0;
+
+	for (i = 0; i < CONFIG_CHIP_SELECTS_PER_CTRL; i++) {
+		popts->cs_local_opts[i].odt_rd_cfg = FSL_DDR_ODT_NEVER;
+		popts->cs_local_opts[i].odt_wr_cfg = FSL_DDR_ODT_CS;
+	}
+}
+
+#endif /* CONFIG_SYS_DDR_RAW_TIMING */
diff --git a/board/freescale/bsc9132qds/law.c b/board/freescale/bsc9132qds/law.c
new file mode 100644
index 0000000..99ea56b
--- /dev/null
+++ b/board/freescale/bsc9132qds/law.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_128M, LAW_TRGT_IF_IFC),
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+#endif
+#ifdef CONFIG_SYS_FPGA_BASE_PHYS
+	SET_LAW(CONFIG_SYS_FPGA_BASE_PHYS, LAW_SIZE_128K, LAW_TRGT_IF_IFC),
+#endif
+	SET_LAW(CONFIG_SYS_FSL_DSP_CCSRBAR_PHYS, LAW_SIZE_1M,
+		LAW_TRGT_IF_DSP_CCSR),
+	SET_LAW(CONFIG_SYS_FSL_DSP_M2_RAM_ADDR, LAW_SIZE_32M,
+		LAW_TRGT_IF_OCN_DSP),
+	SET_LAW(CONFIG_SYS_FSL_DSP_M3_RAM_ADDR, LAW_SIZE_32K,
+		LAW_TRGT_IF_CLASS_DSP),
+	SET_LAW(CONFIG_SYS_FSL_DSP_DDR_ADDR, LAW_SIZE_1G,
+		LAW_TRGT_IF_CLASS_DSP)
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/freescale/bsc9132qds/spl_minimal.c b/board/freescale/bsc9132qds/spl_minimal.c
new file mode 100644
index 0000000..d408518
--- /dev/null
+++ b/board/freescale/bsc9132qds/spl_minimal.c
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <common.h>
+#include <ns16550.h>
+#include <asm/io.h>
+#include <nand.h>
+#include <linux/compiler.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static void sdram_init(void)
+{
+	ccsr_ddr_t __iomem *ddr = (ccsr_ddr_t __iomem *)CONFIG_SYS_MPC8xxx_DDR_ADDR;
+#if CONFIG_DDR_CLK_FREQ == 100000000
+	__raw_writel(CONFIG_SYS_DDR_CS0_BNDS, &ddr->cs0_bnds);
+	__raw_writel(CONFIG_SYS_DDR_CS0_CONFIG, &ddr->cs0_config);
+	__raw_writel(CONFIG_SYS_DDR_CONTROL_800 | SDRAM_CFG_32_BE, &ddr->sdram_cfg);
+	__raw_writel(CONFIG_SYS_DDR_CONTROL_2_800, &ddr->sdram_cfg_2);
+	__raw_writel(CONFIG_SYS_DDR_DATA_INIT, &ddr->sdram_data_init);
+
+	__raw_writel(CONFIG_SYS_DDR_TIMING_3_800, &ddr->timing_cfg_3);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_0_800, &ddr->timing_cfg_0);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_1_800, &ddr->timing_cfg_1);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_2_800, &ddr->timing_cfg_2);
+	__raw_writel(CONFIG_SYS_DDR_MODE_1_800, &ddr->sdram_mode);
+	__raw_writel(CONFIG_SYS_DDR_MODE_2_800, &ddr->sdram_mode_2);
+	__raw_writel(CONFIG_SYS_DDR_INTERVAL_800, &ddr->sdram_interval);
+	__raw_writel(CONFIG_SYS_DDR_CLK_CTRL_800, &ddr->sdram_clk_cntl);
+	__raw_writel(CONFIG_SYS_DDR_WRLVL_CONTROL_800, &ddr->ddr_wrlvl_cntl);
+
+	__raw_writel(CONFIG_SYS_DDR_TIMING_4_800, &ddr->timing_cfg_4);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_5_800, &ddr->timing_cfg_5);
+	__raw_writel(CONFIG_SYS_DDR_ZQ_CONTROL, &ddr->ddr_zq_cntl);
+#elif CONFIG_DDR_CLK_FREQ == 133000000
+	__raw_writel(CONFIG_SYS_DDR_CS0_BNDS, &ddr->cs0_bnds);
+	__raw_writel(CONFIG_SYS_DDR_CS0_CONFIG, &ddr->cs0_config);
+	__raw_writel(CONFIG_SYS_DDR_CONTROL_1333 | SDRAM_CFG_32_BE, &ddr->sdram_cfg);
+	__raw_writel(CONFIG_SYS_DDR_CONTROL_2_1333, &ddr->sdram_cfg_2);
+	__raw_writel(CONFIG_SYS_DDR_DATA_INIT, &ddr->sdram_data_init);
+
+	__raw_writel(CONFIG_SYS_DDR_TIMING_3_1333, &ddr->timing_cfg_3);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_0_1333, &ddr->timing_cfg_0);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_1_1333, &ddr->timing_cfg_1);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_2_1333, &ddr->timing_cfg_2);
+	__raw_writel(CONFIG_SYS_DDR_MODE_1_1333, &ddr->sdram_mode);
+	__raw_writel(CONFIG_SYS_DDR_MODE_2_1333, &ddr->sdram_mode_2);
+	__raw_writel(CONFIG_SYS_DDR_INTERVAL_1333, &ddr->sdram_interval);
+	__raw_writel(CONFIG_SYS_DDR_CLK_CTRL_1333, &ddr->sdram_clk_cntl);
+	__raw_writel(CONFIG_SYS_DDR_WRLVL_CONTROL_1333, &ddr->ddr_wrlvl_cntl);
+
+	__raw_writel(CONFIG_SYS_DDR_TIMING_4_1333, &ddr->timing_cfg_4);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_5_1333, &ddr->timing_cfg_5);
+	__raw_writel(CONFIG_SYS_DDR_ZQ_CONTROL, &ddr->ddr_zq_cntl);
+#else
+	puts("Not a valid DDR Freq Found! Please Reset\n");
+#endif
+	asm volatile("sync;isync");
+	udelay(500);
+
+	/* Let the controller go */
+	out_be32(&ddr->sdram_cfg, in_be32(&ddr->sdram_cfg) | SDRAM_CFG_MEM_EN);
+
+	set_next_law(CONFIG_SYS_NAND_DDR_LAW, LAW_SIZE_1G, LAW_TRGT_IF_DDR_1);
+}
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio;
+	ccsr_gur_t __iomem *gur = (void __iomem *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	/* initialize selected port with appropriate baud rate */
+	plat_ratio = in_be32(&gur->porpllsr) & MPC85xx_PORPLLSR_PLAT_RATIO;
+	plat_ratio >>= 1;
+	gd->bus_clk = CONFIG_SYS_CLK_FREQ * plat_ratio;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+			gd->bus_clk / 16 / CONFIG_BAUDRATE);
+
+	puts("\nNAND boot... ");
+
+	/* Initialize the DDR3 */
+	sdram_init();
+
+	/* copy code to RAM and jump to it - this should not return */
+	/* NOTE - code has to be copied out of NAND buffer before
+	 * other blocks can be read.
+	 */
+	relocate_code(CONFIG_SPL_RELOC_STACK, 0, CONFIG_SPL_RELOC_TEXT_BASE);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	nand_boot();
+}
+
+void putc(char c)
+{
+	if (c == '\n')
+		NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, '\r');
+
+	NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, c);
+}
+
+void puts(const char *str)
+{
+	while (*str)
+		putc(*str++);
+}
diff --git a/board/freescale/bsc9132qds/tlb.c b/board/freescale/bsc9132qds/tlb.c
new file mode 100644
index 0000000..5c920de
--- /dev/null
+++ b/board/freescale/bsc9132qds/tlb.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR, CONFIG_SYS_INIT_RAM_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#ifdef CONFIG_SPL_NAND_MINIMAL
+	SET_TLB_ENTRY(1, 0xffffe000, 0xffffe000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR (PA) */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 1, BOOKE_PAGESZ_1M, 1),
+
+	/* CCSRBAR (DSP) */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FSL_DSP_CCSRBAR,
+		      CONFIG_SYS_FSL_DSP_CCSRBAR_PHYS, MAS3_SW|MAS3_SR,
+		      MAS2_I|MAS2_G, 0, 2, BOOKE_PAGESZ_1M, 1),
+
+#ifndef CONFIG_SPL_BUILD
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 3, BOOKE_PAGESZ_64M, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE + 0x4000000,
+			CONFIG_SYS_FLASH_BASE_PHYS + 0x4000000,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 4, BOOKE_PAGESZ_64M, 1),
+
+#ifdef CONFIG_PCI
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 6, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 7, BOOKE_PAGESZ_64K, 1),
+#endif
+#endif
+
+#if defined(CONFIG_SYS_RAMBOOT) || defined(CONFIG_SPL)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 8, BOOKE_PAGESZ_1G, 1),
+#endif
+
+#ifdef CONFIG_SYS_FPGA_BASE
+		/* *I*G - Board FPGA  */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FPGA_BASE, CONFIG_SYS_FPGA_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 9, BOOKE_PAGESZ_256K, 1),
+#endif
+
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 5, BOOKE_PAGESZ_1M, 1),
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/freescale/c29xpcie/Makefile b/board/freescale/c29xpcie/Makefile
new file mode 100644
index 0000000..15bef9a
--- /dev/null
+++ b/board/freescale/c29xpcie/Makefile
@@ -0,0 +1,34 @@
+#
+# Copyright 2013 Freescale Semiconductor, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= cpld.o
+COBJS-y	+= ddr.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/c29xpcie/README b/board/freescale/c29xpcie/README
new file mode 100644
index 0000000..430f082
--- /dev/null
+++ b/board/freescale/c29xpcie/README
@@ -0,0 +1,100 @@
+Overview
+=========
+C29XPCIE board is a series of Freescale PCIe add-in cards to perform
+as public key crypto accelerator or secure key management module.
+It includes C293PCIE board, C293PCIE board and C291PCIE board.
+The Freescale C29x family is a high performance crypto co-processor.
+It combines a single e500v2 core with necessary SEC engines.
+(maximum core frequency 1000/1200 MHz).
+
+The C29xPCIE board features are as follows:
+Memory subsystem:
+	- 512Mbyte unbuffered DDR3 SDRAM discrete devices (32-bit bus)
+	- 64 Mbyte NOR flash single-chip memory
+	- 4 Gbyte NAND flash memory
+	- 1 Mbit AT24C1024 I2C EEPROM
+	- 16 Mbyte SPI memory
+
+Interfaces:
+	- 10/100/1000 BaseT Ethernet ports:
+		- eTSEC1, RGMII: one 10/100/1000 port
+		- eTSEC2, RGMII: one 10/100/1000 port
+	- DUART interface:
+		- DUART interface: supports two UARTs up to 115200 bps for
+		   console display
+
+Board connectors:
+	- Mini-ITX power supply connector
+	- JTAG/COP for debugging
+
+Physical Memory Map on C29xPCIE
+===============================
+Address Start   Address End   Memory type
+0x0_0000_0000 - 0x0_1fff_ffff   512MB DDR
+0xc_0000_0000 - 0xc_8fff_ffff   256MB PCIE memory
+0xf_ec00_0000 - 0xf_efff_ffff   64MB NOR flash
+0xf_ffb0_0000 - 0xf_ffb7_ffff   512KB SRAM
+0xf_ffc0_0000 - 0xf_ffc0_ffff   64KB PCIE IO
+0xf_ffdf_0000 - 0xf_ffdf_0fff   4KB CPLD
+0xf_ffe0_0000 - 0xf_ffef_ffff   1MB CCSR
+
+Serial Port Configuration on C29xPCIE
+=====================================
+Configure the serial port of the attached computer with the following values:
+	-Data rate: 115200 bps
+	-Number of data bits: 8
+	-Parity: None
+	-Number of Stop bits: 1
+	-Flow Control: Hardware/None
+
+Settings of DIP-switch
+======================
+  SW5[1:4]= 1111 and SW5[6]=0 for boot from 16bit NOR flash
+  SW5[1:4]= 0110 and SW5[6]=0 for boot from SPI flash
+Note: 1 stands for 'off', 0 stands for 'on'
+
+Build and program u-boot to NOR flash
+==================================
+1. Build u-boot.bin image example:
+	export ARCH=powerpc
+	export CROSS_COMPILE=/your_path/powerpc-linux-gnu-
+	make C293PCIE
+
+2. Program u-boot.bin into NOR flash
+	=> tftp $loadaddr $uboot
+	=> protect off eff80000 +$filesize
+	=> erase eff80000 +$filesize
+	=> cp.b $loadaddr eff80000 $filesize
+
+3. Check SW5[1:4]= 1111 and SW5[6]=0, then power on.
+
+Alternate NOR bank
+==================
+There are four banks in C29XPCIE board, example to change bank booting:
+1. Program u-boot.bin into alternate NOR bank
+	=> tftp $loadaddr $uboot
+	=> protect off e9f80000 +$filesize
+	=> erase e9f80000 +$filesize
+	=> cp.b $loadaddr e9f80000 $filesize
+
+2. Switch to alternate NOR bank
+	=> cpld_cmd reset altbank [bank]
+	- [bank] bank value select 1-4
+	- bank 1 on the flash 0x0000000~0x0ffffff
+	- bank 2 on the flash 0x1000000~0x1ffffff
+	- bank 3 on the flash 0x2000000~0x2ffffff
+	- bank 4 on the flash 0x3000000~0x3ffffff
+	or set SW5[7]= ON/OFF and SW5[7]= ON/OFF, then power on again.
+
+Build and program u-boot to SPI flash
+==================================
+1. Build u-boot-spi.bin image
+	make C29xPCIE_SPIFLASH_config; make
+	Need the boot_format tool to generate u-boot-spi.bin from the u-boot.bin.
+
+2. Program u-boot-spi.bin into SPI flash
+	=> tftp $loadaddr $uboot-spi
+	=> sf erase 0 100000
+	=> sf write $loadaddr 0 $filesize
+
+3. Check SW5[1:4]= 0110 and SW5[6]=0, then power on.
diff --git a/board/freescale/c29xpcie/c29xpcie.c b/board/freescale/c29xpcie/c29xpcie.c
new file mode 100644
index 0000000..ac1056f
--- /dev/null
+++ b/board/freescale/c29xpcie/c29xpcie.c
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <fsl_mdio.h>
+#include <tsec.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <pci.h>
+#include <asm/fsl_ifc.h>
+#include <asm/fsl_pci.h>
+
+#include "cpld.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	struct cpu_type *cpu = gd->cpu;
+
+	printf("Board: %sPCIe, ", cpu->name);
+	printf("CPLD Ver: 0x%02x\n", CPLD_READ(cpldver));
+
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	struct fsl_ifc *ifc = (void *)CONFIG_SYS_IFC_ADDR;
+
+	/* Clock configuration to access CPLD using IFC(GPCM) */
+	setbits_be32(&ifc->ifc_gcr, 1 << IFC_GCR_TBCTL_TRN_TIME_SHIFT);
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	const unsigned long flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_64M, 1);
+
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+#endif /* ifdef CONFIG_PCI */
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct fsl_pq_mdio_info mdio_info;
+	struct tsec_info_struct tsec_info[2];
+	int num = 0;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	num++;
+#endif
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+
+	/* Register 1G MDIO bus */
+	mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
+	mdio_info.name = DEFAULT_MII_NAME;
+
+	fsl_pq_mdio_init(bis, &mdio_info);
+
+	tsec_eth_init(bis, tsec_info, num);
+
+	return pci_eth_init(bis);
+}
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+#if defined(CONFIG_PCI)
+	FT_FSL_PCI_SETUP;
+#endif
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+}
+#endif
diff --git a/board/freescale/c29xpcie/cpld.c b/board/freescale/c29xpcie/cpld.c
new file mode 100644
index 0000000..54a8820
--- /dev/null
+++ b/board/freescale/c29xpcie/cpld.c
@@ -0,0 +1,155 @@
+/**
+ * Copyright 2013 Freescale Semiconductor
+ * Author: Mingkai Hu <Mingkai.hu@freescale.com>
+ *         Po Liu <Po.Liu@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This file provides support for the board-specific CPLD used on some Freescale
+ * reference boards.
+ *
+ * The following macros need to be defined:
+ *
+ * CONFIG_SYS_CPLD_BASE - The virtual address of the base of the
+ * CPLD register map
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+
+#include "cpld.h"
+
+static u8 __cpld_read(unsigned int reg)
+{
+	void *p = (void *)CONFIG_SYS_CPLD_BASE;
+
+	return in_8(p + reg);
+}
+
+u8 cpld_read(unsigned int reg) __attribute__((weak, alias("__cpld_read")));
+
+static void __cpld_write(unsigned int reg, u8 value)
+{
+	void *p = (void *)CONFIG_SYS_CPLD_BASE;
+
+	out_8(p + reg, value);
+}
+
+void cpld_write(unsigned int reg, u8 value)
+	__attribute__((weak, alias("__cpld_write")));
+
+/**
+ * Set the boot bank to the alternate bank
+ */
+void __cpld_set_altbank(u8 banksel)
+{
+	u8 reg11 = CPLD_READ(flhcsr);
+
+	switch (banksel) {
+	case 1:
+		CPLD_WRITE(flhcsr, (reg11 & CPLD_BANKSEL_MASK)
+			| CPLD_BANKSEL_EN | CPLD_SELECT_BANK1);
+		break;
+	case 2:
+		CPLD_WRITE(flhcsr, (reg11 & CPLD_BANKSEL_MASK)
+			| CPLD_BANKSEL_EN | CPLD_SELECT_BANK2);
+		break;
+	case 3:
+		CPLD_WRITE(flhcsr, (reg11 & CPLD_BANKSEL_MASK)
+			| CPLD_BANKSEL_EN | CPLD_SELECT_BANK3);
+		break;
+	case 4:
+		CPLD_WRITE(flhcsr, (reg11 & CPLD_BANKSEL_MASK)
+			| CPLD_BANKSEL_EN | CPLD_SELECT_BANK4);
+		break;
+	default:
+		printf("Invalid value! [1-4]\n");
+		return;
+	}
+
+	udelay(100);
+	do_reset(NULL, 0, 0, NULL);
+}
+
+void cpld_set_altbank(u8 banksel)
+	__attribute__((weak, alias("__cpld_set_altbank")));
+
+/**
+ * Set the boot bank to the default bank
+ */
+void __cpld_set_defbank(void)
+{
+	__cpld_set_altbank(4);
+}
+
+void cpld_set_defbank(void)
+	__attribute__((weak, alias("__cpld_set_defbank")));
+
+#ifdef DEBUG
+static void cpld_dump_regs(void)
+{
+	printf("chipid1		= 0x%02x\n", CPLD_READ(chipid1));
+	printf("chipid2		= 0x%02x\n", CPLD_READ(chipid2));
+	printf("hwver		= 0x%02x\n", CPLD_READ(hwver));
+	printf("cpldver		= 0x%02x\n", CPLD_READ(cpldver));
+	printf("rstcon		= 0x%02x\n", CPLD_READ(rstcon));
+	printf("flhcsr		= 0x%02x\n", CPLD_READ(flhcsr));
+	printf("wdcsr		= 0x%02x\n", CPLD_READ(wdcsr));
+	printf("wdkick		= 0x%02x\n", CPLD_READ(wdkick));
+	printf("fancsr		= 0x%02x\n", CPLD_READ(fancsr));
+	printf("ledcsr		= 0x%02x\n", CPLD_READ(ledcsr));
+	printf("misc		= 0x%02x\n", CPLD_READ(misccsr));
+	printf("bootor		= 0x%02x\n", CPLD_READ(bootor));
+	printf("bootcfg1	= 0x%02x\n", CPLD_READ(bootcfg1));
+	printf("bootcfg2	= 0x%02x\n", CPLD_READ(bootcfg2));
+	printf("bootcfg3	= 0x%02x\n", CPLD_READ(bootcfg3));
+	printf("bootcfg4	= 0x%02x\n", CPLD_READ(bootcfg4));
+	putc('\n');
+}
+#endif
+
+int cpld_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rc = 0;
+	unsigned char value;
+
+	if (argc <= 1)
+		return cmd_usage(cmdtp);
+
+	if (strcmp(argv[1], "reset") == 0) {
+		if (!strcmp(argv[2], "altbank") && argv[3]) {
+			value = (u8)simple_strtoul(argv[3], NULL, 16);
+			cpld_set_altbank(value);
+		} else if (!argv[2])
+			cpld_set_defbank();
+		else
+			cmd_usage(cmdtp);
+#ifdef DEBUG
+	} else if (strcmp(argv[1], "dump") == 0) {
+		cpld_dump_regs();
+#endif
+	} else
+		rc = cmd_usage(cmdtp);
+
+	return rc;
+}
+
+U_BOOT_CMD(
+	cpld_cmd, CONFIG_SYS_MAXARGS, 1, cpld_cmd,
+	"Reset the board using the CPLD sequencer",
+	"reset - hard reset to default bank 4\n"
+	"cpld_cmd reset altbank [bank]- reset to alternate bank\n"
+	"	- [bank] bank value select 1-4\n"
+	"	- bank 1 on the flash 0x0000000~0x0ffffff\n"
+	"	- bank 2 on the flash 0x1000000~0x1ffffff\n"
+	"	- bank 3 on the flash 0x2000000~0x2ffffff\n"
+	"	- bank 4 on the flash 0x3000000~0x3ffffff\n"
+#ifdef DEBUG
+	"cpld_cmd dump - display the CPLD registers\n"
+#endif
+	);
diff --git a/board/freescale/c29xpcie/cpld.h b/board/freescale/c29xpcie/cpld.h
new file mode 100644
index 0000000..15d33cd
--- /dev/null
+++ b/board/freescale/c29xpcie/cpld.h
@@ -0,0 +1,53 @@
+/**
+ * Copyright 2013 Freescale Semiconductor
+ * Author: Mingkai Hu <Mingkai.Hu@freescale.com>
+ *         Po Liu <Po.Liu@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This file provides support for the ngPIXIS, a board-specific FPGA used on
+ * some Freescale reference boards.
+ */
+
+/*
+ * CPLD register set. Feel free to add board-specific #ifdefs where necessary.
+ */
+struct cpld_data {
+	u8 chipid1;	/* 0x0 - CPLD Chip ID1 Register */
+	u8 chipid2;	/* 0x1 - CPLD Chip ID2 Register */
+	u8 hwver;	/* 0x2 - Hardware Version Register */
+	u8 cpldver;	/* 0x3 - Software Version Register */
+	u8 res[12];
+	u8 rstcon;	/* 0x10 - Reset control register */
+	u8 flhcsr;	/* 0x11 - Flash control and status Register */
+	u8 wdcsr;	/* 0x12 - Watchdog control and status Register */
+	u8 wdkick;	/* 0x13 - Watchdog kick Register */
+	u8 fancsr;	/* 0x14 - Fan control and status Register */
+	u8 ledcsr;	/* 0x15 - LED control and status Register */
+	u8 misccsr;	/* 0x16 - Misc control and status Register */
+	u8 bootor;	/* 0x17 - Boot configure override Register */
+	u8 bootcfg1;	/* 0x18 - Boot configure 1 Register */
+	u8 bootcfg2;	/* 0x19 - Boot configure 2 Register */
+	u8 bootcfg3;	/* 0x1a - Boot configure 3 Register */
+	u8 bootcfg4;	/* 0x1b - Boot configure 4 Register */
+};
+
+/* Pointer to the CPLD register set */
+#define cpld ((struct cpld_data *)CONFIG_SYS_CPLD_BASE)
+
+u8 cpld_read(unsigned int reg);
+void cpld_write(unsigned int reg, u8 value);
+
+#define CPLD_BANKSEL_EN		0x02
+#define CPLD_BANKSEL_MASK	0x3f
+#define CPLD_SELECT_BANK1	0xc0
+#define CPLD_SELECT_BANK2	0x80
+#define CPLD_SELECT_BANK3	0x40
+#define CPLD_SELECT_BANK4	0x00
+
+#define CPLD_READ(reg) cpld_read(offsetof(struct cpld_data, reg))
+#define CPLD_WRITE(reg, value) cpld_write(offsetof(struct cpld_data, reg), \
+						value)
diff --git a/board/freescale/c29xpcie/ddr.c b/board/freescale/c29xpcie/ddr.c
new file mode 100644
index 0000000..6ffd996
--- /dev/null
+++ b/board/freescale/c29xpcie/ddr.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+
+/*
+ * Micron MT41J128M16HA-15E
+ * */
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 536870912u,
+	.capacity = 536870912u,
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 8,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 14,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 2,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tCKmin_X_ps = 1650,
+	.caslat_X = 0x7e << 4,	/* 5,6,7,8,9,10 */
+	.tAA_ps = 14050,
+	.tWR_ps = 15000,
+	.tRCD_ps = 13500,
+	.tRRD_ps = 75000,
+	.tRP_ps = 13500,
+	.tRAS_ps = 40000,
+	.tRC_ps = 49500,
+	.tRFC_ps = 160000,
+	.tWTR_ps = 75000,
+	.tRTP_ps = 75000,
+	.refresh_rate_ps = 7800000,
+	.tFAW_ps = 30000,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR on board";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	int i;
+	popts->clk_adjust = 5;
+	popts->cpo_override = 0x1f;
+	popts->write_data_delay = 4;
+	popts->half_strength_driver_enable = 1;
+	popts->bstopre = 0x3cf;
+	popts->quad_rank_present = 1;
+	popts->rtt_override = 1;
+	popts->rtt_override_value = 1;
+	popts->dynamic_power = 1;
+	/* Write leveling override */
+	popts->wrlvl_en = 1;
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+	popts->wrlvl_start = 0x7;
+	popts->trwt_override = 1;
+	popts->trwt = 0;
+
+	for (i = 0; i < CONFIG_CHIP_SELECTS_PER_CTRL; i++) {
+		popts->cs_local_opts[i].odt_rd_cfg = FSL_DDR_ODT_NEVER;
+		popts->cs_local_opts[i].odt_wr_cfg = FSL_DDR_ODT_CS;
+	}
+}
diff --git a/board/freescale/c29xpcie/law.c b/board/freescale/c29xpcie/law.c
new file mode 100644
index 0000000..064fa71
--- /dev/null
+++ b/board/freescale/c29xpcie/law.c
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_64M, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_CPLD_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_PLATFORM_SRAM_BASE_PHYS, LAW_SIZE_512K,
+					LAW_TRGT_IF_PLATFORM_SRAM),
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/freescale/c29xpcie/tlb.c b/board/freescale/c29xpcie/tlb.c
new file mode 100644
index 0000000..b793c2c
--- /dev/null
+++ b/board/freescale/c29xpcie/tlb.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR, CONFIG_SYS_INIT_RAM_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+			MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 1, BOOKE_PAGESZ_1M, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 2, BOOKE_PAGESZ_64M, 1),
+
+#ifdef CONFIG_PCI
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+			MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 3, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+			MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 4, BOOKE_PAGESZ_256K, 1),
+#endif
+
+	/* *I*G - Board CPLD */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CPLD_BASE, CONFIG_SYS_CPLD_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 5, BOOKE_PAGESZ_4K, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 6, BOOKE_PAGESZ_1M, 1),
+
+	/* *I*G - platform SRAM */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PLATFORM_SRAM_BASE,
+			CONFIG_SYS_PLATFORM_SRAM_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 7, BOOKE_PAGESZ_256K, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_PLATFORM_SRAM_BASE + 0x40000,
+			CONFIG_SYS_PLATFORM_SRAM_BASE_PHYS + 0x40000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 8, BOOKE_PAGESZ_256K, 1),
+
+#ifdef CONFIG_SYS_RAMBOOT
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE,
+			CONFIG_SYS_DDR_SDRAM_BASE,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 9, BOOKE_PAGESZ_256M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE + 0x10000000,
+			CONFIG_SYS_DDR_SDRAM_BASE + 0x10000000,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 10, BOOKE_PAGESZ_256M, 1),
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/freescale/common/Makefile b/board/freescale/common/Makefile
index 75725b4..a550e5a 100644
--- a/board/freescale/common/Makefile
+++ b/board/freescale/common/Makefile
@@ -29,14 +29,27 @@ endif
 
 LIB	= $(obj)libfreescale.o
 
+MINIMAL=
+
+ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_SPL_INIT_MINIMAL
+MINIMAL=y
+endif
+endif
+
+ifndef MINIMAL
 COBJS-$(CONFIG_FSL_CADMUS)	+= cadmus.o
 COBJS-$(CONFIG_FSL_VIA)		+= cds_via.o
 COBJS-$(CONFIG_FMAN_ENET)	+= fman.o
 COBJS-$(CONFIG_FSL_PIXIS)	+= pixis.o
+ifndef CONFIG_SPL_BUILD
 COBJS-$(CONFIG_FSL_NGPIXIS)	+= ngpixis.o
+endif
 COBJS-$(CONFIG_FSL_QIXIS)	+= qixis.o
 COBJS-$(CONFIG_PQ_MDS_PIB)	+= pq-mds-pib.o
+ifndef CONFIG_SPL_BUILD
 COBJS-$(CONFIG_ID_EEPROM)	+= sys_eeprom.o
+endif
 COBJS-$(CONFIG_FSL_SGMII_RISER)	+= sgmii_riser.o
 ifndef CONFIG_RAMBOOT_PBL
 COBJS-$(CONFIG_FSL_FIXED_MMC_LOCATION)	+= sdhc_boot.o
@@ -48,13 +61,16 @@ COBJS-$(CONFIG_MPC8555CDS)	+= cds_pci_ft.o
 
 COBJS-$(CONFIG_MPC8536DS)	+= ics307_clk.o
 COBJS-$(CONFIG_MPC8572DS)	+= ics307_clk.o
+ifndef CONFIG_SPL_BUILD
 COBJS-$(CONFIG_P1022DS)		+= ics307_clk.o
+endif
 COBJS-$(CONFIG_P2020DS)		+= ics307_clk.o
 COBJS-$(CONFIG_P3041DS)		+= ics307_clk.o
 COBJS-$(CONFIG_P4080DS)		+= ics307_clk.o
 COBJS-$(CONFIG_P5020DS)		+= ics307_clk.o
 COBJS-$(CONFIG_P5040DS)		+= ics307_clk.o
 COBJS-$(CONFIG_VSC_CROSSBAR)    += vsc3316_3308.o
+COBJS-$(CONFIG_IDT8T49N222A)	+= idt8t49n222a_serdes_clk.o
 
 # deal with common files for P-series corenet based devices
 SUBLIB-$(CONFIG_P2041RDB)	+= p_corenet/libp_corenet.o
@@ -62,6 +78,7 @@ SUBLIB-$(CONFIG_P3041DS)	+= p_corenet/libp_corenet.o
 SUBLIB-$(CONFIG_P4080DS)	+= p_corenet/libp_corenet.o
 SUBLIB-$(CONFIG_P5020DS)	+= p_corenet/libp_corenet.o
 SUBLIB-$(CONFIG_P5040DS)	+= p_corenet/libp_corenet.o
+endif
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS-y))
diff --git a/board/freescale/common/idt8t49n222a_serdes_clk.c b/board/freescale/common/idt8t49n222a_serdes_clk.c
new file mode 100644
index 0000000..8798c87
--- /dev/null
+++ b/board/freescale/common/idt8t49n222a_serdes_clk.c
@@ -0,0 +1,220 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ * Author: Shaveta Leekha <shaveta@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "idt8t49n222a_serdes_clk.h"
+
+#define DEVICE_ID_REG		0x00
+
+static int check_pll_status(u8 idt_addr)
+{
+	u8 val = 0;
+	int ret;
+
+	ret = i2c_read(idt_addr, 0x17, 1, &val, 1);
+	if (ret < 0) {
+		printf("IDT:0x%x could not read status register from device.\n",
+			idt_addr);
+		return ret;
+	}
+
+	if (val & 0x04) {
+		debug("idt8t49n222a PLL is LOCKED: %x\n", val);
+	} else {
+		printf("idt8t49n222a PLL is not LOCKED: %x\n", val);
+		return -1;
+	}
+
+	return 0;
+}
+
+int set_serdes_refclk(u8 idt_addr, u8 serdes_num,
+			enum serdes_refclk refclk1,
+			enum serdes_refclk refclk2, u8 feedback)
+{
+	u8 dev_id = 0;
+	int i, ret;
+
+	debug("IDT:Configuring idt8t49n222a device at I2C address: 0x%2x\n",
+		idt_addr);
+
+	ret = i2c_read(idt_addr, DEVICE_ID_REG, 1, &dev_id, 1);
+	if (ret < 0) {
+		debug("IDT:0x%x could not read DEV_ID from device.\n",
+			idt_addr);
+		return ret;
+	}
+
+	if ((dev_id != 0x00) && (dev_id != 0x24) && (dev_id != 0x2a)) {
+		debug("IDT: device at address 0x%x is not idt8t49n222a.\n",
+			idt_addr);
+	}
+
+	if (serdes_num != 1 && serdes_num != 2) {
+		debug("serdes_num should be 1 for SerDes1 and"
+			" 2 for SerDes2.\n");
+		return -1;
+	}
+
+	if ((refclk1 == SERDES_REFCLK_122_88 && refclk2 != SERDES_REFCLK_122_88)
+		|| (refclk1 != SERDES_REFCLK_122_88
+			&& refclk2 == SERDES_REFCLK_122_88)) {
+		debug("Only one refclk at 122.88MHz is not supported."
+			" Please set both refclk1 & refclk2 to 122.88MHz"
+			" or both not to 122.88MHz.\n");
+		return -1;
+	}
+
+	if (refclk1 != SERDES_REFCLK_100 && refclk1 != SERDES_REFCLK_122_88
+					&& refclk1 != SERDES_REFCLK_125
+					&& refclk1 != SERDES_REFCLK_156_25) {
+		debug("refclk1 should be 100MHZ, 122.88MHz, 125MHz"
+			" or 156.25MHz.\n");
+		return -1;
+	}
+
+	if (refclk2 != SERDES_REFCLK_100 && refclk2 != SERDES_REFCLK_122_88
+					&& refclk2 != SERDES_REFCLK_125
+					&& refclk2 != SERDES_REFCLK_156_25) {
+		debug("refclk2 should be 100MHZ, 122.88MHz, 125MHz"
+			" or 156.25MHz.\n");
+		return -1;
+	}
+
+	if (feedback != 0 && feedback != 1) {
+		debug("valid values for feedback are 0(default) or 1.\n");
+		return -1;
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 122.88MHz  Refclk2 = 122.88MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_122_88 &&
+			refclk2 == SERDES_REFCLK_122_88) {
+		printf("Setting refclk1:122.88 and refclk2:122.88\n");
+		for (i = 0; i < NUM_IDT_REGS; i++)
+			i2c_reg_write(idt_addr, idt_conf_122_88[i][0],
+						idt_conf_122_88[i][1]);
+
+		if (feedback) {
+			for (i = 0; i < NUM_IDT_REGS_FEEDBACK; i++)
+				i2c_reg_write(idt_addr,
+					idt_conf_122_88_feedback[i][0],
+					idt_conf_122_88_feedback[i][1]);
+		}
+	}
+
+	if (refclk1 != SERDES_REFCLK_122_88 &&
+			refclk2 != SERDES_REFCLK_122_88) {
+		for (i = 0; i < NUM_IDT_REGS; i++)
+			i2c_reg_write(idt_addr, idt_conf_not_122_88[i][0],
+						idt_conf_not_122_88[i][1]);
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 100MHz  Refclk2 = 125MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_100 && refclk2 == SERDES_REFCLK_125) {
+		printf("Setting refclk1:100 and refclk2:125\n");
+		i2c_reg_write(idt_addr, 0x11, 0x10);
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 125MHz  Refclk2 = 125MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_125 && refclk2 == SERDES_REFCLK_125) {
+		printf("Setting refclk1:125 and refclk2:125\n");
+		i2c_reg_write(idt_addr, 0x10, 0x10);
+		i2c_reg_write(idt_addr, 0x11, 0x10);
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 125MHz  Refclk2 = 100MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_125 && refclk2 == SERDES_REFCLK_100) {
+		printf("Setting refclk1:125 and refclk2:100\n");
+		i2c_reg_write(idt_addr, 0x10, 0x10);
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 156.25MHz  Refclk2 = 156.25MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_156_25 &&
+			refclk2 == SERDES_REFCLK_156_25) {
+		printf("Setting refclk1:156.25 and refclk2:156.25\n");
+		for (i = 0; i < NUM_IDT_REGS_156_25; i++)
+			i2c_reg_write(idt_addr, idt_conf_156_25[i][0],
+						idt_conf_156_25[i][1]);
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 100MHz  Refclk2 = 156.25MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_100 &&
+			refclk2 == SERDES_REFCLK_156_25) {
+		printf("Setting refclk1:100 and refclk2:156.25\n");
+		for (i = 0; i < NUM_IDT_REGS_156_25; i++)
+			i2c_reg_write(idt_addr, idt_conf_100_156_25[i][0],
+						idt_conf_100_156_25[i][1]);
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 125MHz  Refclk2 = 156.25MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_125 &&
+			refclk2 == SERDES_REFCLK_156_25) {
+		printf("Setting refclk1:125 and refclk2:156.25\n");
+		for (i = 0; i < NUM_IDT_REGS_156_25; i++)
+			i2c_reg_write(idt_addr, idt_conf_125_156_25[i][0],
+						idt_conf_125_156_25[i][1]);
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 156.25MHz  Refclk2 = 100MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_156_25 &&
+			refclk2 == SERDES_REFCLK_100) {
+		printf("Setting refclk1:156.25 and refclk2:100\n");
+		for (i = 0; i < NUM_IDT_REGS_156_25; i++)
+			i2c_reg_write(idt_addr, idt_conf_156_25_100[i][0],
+						idt_conf_156_25_100[i][1]);
+	}
+
+	/* Configuring IDT for output refclks as
+	 * Refclk1 = 156.25MHz  Refclk2 = 125MHz
+	 */
+	if (refclk1 == SERDES_REFCLK_156_25 &&
+			refclk2 == SERDES_REFCLK_125) {
+		printf("Setting refclk1:156.25 and refclk2:125\n");
+		for (i = 0; i < NUM_IDT_REGS_156_25; i++)
+			i2c_reg_write(idt_addr, idt_conf_156_25_125[i][0],
+						idt_conf_156_25_125[i][1]);
+	}
+
+	/* waiting for maximum of 1 second if PLL doesn'r get locked
+	 * initially. then check the status again.
+	 */
+	if (check_pll_status(idt_addr)) {
+		mdelay(1000);
+		if (check_pll_status(idt_addr))
+			return -1;
+	}
+
+	return 0;
+}
diff --git a/board/freescale/common/idt8t49n222a_serdes_clk.h b/board/freescale/common/idt8t49n222a_serdes_clk.h
new file mode 100644
index 0000000..d7d64e7
--- /dev/null
+++ b/board/freescale/common/idt8t49n222a_serdes_clk.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ * Author: Shaveta Leekha <shaveta@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __IDT8T49N222A_SERDES_CLK_H_
+#define __IDT8T49N222A_SERDES_CLK_H_	1
+
+#include <common.h>
+#include <i2c.h>
+#include "qixis.h"
+#include "../b4860qds/b4860qds_qixis.h"
+#include <errno.h>
+
+#define NUM_IDT_REGS		23
+#define NUM_IDT_REGS_FEEDBACK	12
+#define NUM_IDT_REGS_156_25	11
+
+/* CLK */
+enum serdes_refclk {
+	SERDES_REFCLK_100,	/* refclk 100Mhz */
+	SERDES_REFCLK_122_88,	/* refclk 122.88Mhz */
+	SERDES_REFCLK_125,	/* refclk 125Mhz */
+	SERDES_REFCLK_156_25,	/* refclk 156.25Mhz */
+	SERDES_REFCLK_NONE = -1,
+};
+
+/* configuration values for IDT registers for Output Refclks:
+ * Refclk1 = 122.88MHz Refclk2 = 122.88MHz
+ */
+static const u8 idt_conf_122_88[23][2] = { {0x00, 0x3C}, {0x01, 0x00},
+		{0x02, 0x9F}, {0x03, 0x00}, {0x04, 0x0B}, {0x05, 0x00},
+		{0x06, 0x00}, {0x07, 0x00}, {0x08, 0x7D}, {0x09, 0x00},
+		{0x0A, 0x08}, {0x0B, 0x00}, {0x0C, 0xDC}, {0x0D, 0x00},
+		{0x0E, 0x00}, {0x0F, 0x00}, {0x10, 0x12}, {0x11, 0x12},
+		{0x12, 0xB9}, {0x13, 0xBC}, {0x14, 0x40}, {0x15, 0x08},
+		{0x16, 0xA0} };
+
+
+/* configuration values for IDT registers for Output Refclks:
+ * Refclk1 not equal to 122.88MHz Refclk2 not equal to 122.88MHz
+ */
+static const u8 idt_conf_not_122_88[23][2] = { {0x00, 0x00}, {0x01, 0x00},
+		{0x02, 0x00}, {0x03, 0x00}, {0x04, 0x0A}, {0x05, 0x00},
+		{0x06, 0x00}, {0x07, 0x00}, {0x08, 0x7D}, {0x09, 0x00},
+		{0x0A, 0x08}, {0x0B, 0x00}, {0x0C, 0xDC}, {0x0D, 0x00},
+		{0x0E, 0x00}, {0x0F, 0x00}, {0x10, 0x14}, {0x11, 0x14},
+		{0x12, 0x35}, {0x13, 0xBC}, {0x14, 0x40}, {0x15, 0x08},
+		{0x16, 0xA0} };
+
+/* Reconfiguration values for some of IDT registers for
+ * Output Refclks:
+ * Refclk1 = 122.88MHz Refclk2 = 122.88MHz
+ * and with feedback as 1
+ */
+static const u8 idt_conf_122_88_feedback[12][2] = { {0x00, 0x50}, {0x02, 0xD7},
+		{0x04, 0x89}, {0x06, 0xC3}, {0x08, 0xC0}, {0x0A, 0x07},
+		{0x0C, 0x80}, {0x10, 0x10}, {0x11, 0x10}, {0x12, 0x1B},
+		{0x14, 0x00}, {0x15, 0xE8} };
+
+/* configuration values for IDT registers for Output Refclks:
+ * Refclk1 : 156.25MHz Refclk2 : 156.25MHz
+ */
+static const u8 idt_conf_156_25[11][2] = { {0x04, 0x19}, {0x06, 0x03},
+		{0x08, 0xC0}, {0x0A, 0x07}, {0x0C, 0xA1}, {0x0E, 0x20},
+		{0x10, 0x10}, {0x11, 0x10}, {0x12, 0xB5}, {0x13, 0x3C},
+		{0x15, 0xE8} };
+
+/* configuration values for IDT registers for Output Refclks:
+ * Refclk1 : 100MHz Refclk2 : 156.25MHz
+ */
+static const u8 idt_conf_100_156_25[11][2] = { {0x04, 0x19}, {0x06, 0x03},
+		{0x08, 0xC0}, {0x0A, 0x07}, {0x0C, 0xA1}, {0x0E, 0x20},
+		{0x10, 0x19}, {0x11, 0x10}, {0x12, 0xB5}, {0x13, 0x3C},
+		{0x15, 0xE8} };
+
+/* configuration values for IDT registers for Output Refclks:
+ * Refclk1 : 125MHz Refclk2 : 156.25MHz
+ */
+static const u8 idt_conf_125_156_25[11][2] = { {0x04, 0x19}, {0x06, 0x03},
+		{0x08, 0xC0}, {0x0A, 0x07}, {0x0C, 0xA1}, {0x0E, 0x20},
+		{0x10, 0x14}, {0x11, 0x10}, {0x12, 0xB5}, {0x13, 0x3C},
+		{0x15, 0xE8} };
+
+/* configuration values for IDT registers for Output Refclks:
+ * Refclk1 : 156.25MHz Refclk2 : 100MHz
+ */
+static const u8 idt_conf_156_25_100[11][2] = { {0x04, 0x19}, {0x06, 0x03},
+		{0x08, 0xC0}, {0x0A, 0x07}, {0x0C, 0xA1}, {0x0E, 0x20},
+		{0x10, 0x10}, {0x11, 0x19}, {0x12, 0xB5}, {0x13, 0x3C},
+		{0x15, 0xE8} };
+
+/* configuration values for IDT registers for Output Refclks:
+ * Refclk1 : 156.25MHz Refclk2 : 125MHz
+ */
+static const u8 idt_conf_156_25_125[11][2] = { {0x04, 0x19}, {0x06, 0x03},
+		{0x08, 0xC0}, {0x0A, 0x07}, {0x0C, 0xA1}, {0x0E, 0x20},
+		{0x10, 0x10}, {0x11, 0x14}, {0x12, 0xB5}, {0x13, 0x3C},
+		{0x15, 0xE8} };
+
+int set_serdes_refclk(u8 idt_addr, u8 serdes_num,
+			enum serdes_refclk refclk1,
+			enum serdes_refclk refclk2, u8 feedback);
+
+#endif	/*__IDT8T49N222A_SERDES_CLK_H_ */
diff --git a/board/freescale/common/p_corenet/law.c b/board/freescale/common/p_corenet/law.c
index 09ef561..2d5cbec 100644
--- a/board/freescale/common/p_corenet/law.c
+++ b/board/freescale/common/p_corenet/law.c
@@ -28,7 +28,8 @@
 #include <asm/mmu.h>
 
 struct law_entry law_table[] = {
-	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_64M, LAW_TRGT_IF_LBC),
+
 #ifdef CONFIG_SYS_BMAN_MEM_PHYS
 	SET_LAW(CONFIG_SYS_BMAN_MEM_PHYS, LAW_SIZE_2M, LAW_TRGT_IF_BMAN),
 #endif
diff --git a/board/freescale/common/p_corenet/tlb.c b/board/freescale/common/p_corenet/tlb.c
index e5cf208..7f84de6 100644
--- a/board/freescale/common/p_corenet/tlb.c
+++ b/board/freescale/common/p_corenet/tlb.c
@@ -92,6 +92,8 @@ struct fsl_e_tlb_entry tlb_table[] = {
 		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_256M, 1),
 
+#if 0 /* susan  */
+
 	/* *I*G* - PCI */
 	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
 		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
@@ -112,6 +114,33 @@ struct fsl_e_tlb_entry tlb_table[] = {
 	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
 		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 6, BOOKE_PAGESZ_256K, 1),
+#else
+
+	#ifdef CONFIG_PCIE1
+    /* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G, 0, 3, BOOKE_PAGESZ_128M, 1),
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G, 0, 4, BOOKE_PAGESZ_64K, 1),
+    #endif
+	#ifdef CONFIG_PCIE2
+    /* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE2_MEM_VIRT, CONFIG_SYS_PCIE2_MEM_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G, 0, 3, BOOKE_PAGESZ_128M, 1),
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE2_IO_VIRT, CONFIG_SYS_PCIE2_IO_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G, 0, 4, BOOKE_PAGESZ_64K, 1),
+    #endif
+	#ifdef CONFIG_PCIE3
+    /* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT, CONFIG_SYS_PCIE3_MEM_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G, 0, 3, BOOKE_PAGESZ_128M, 1),
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_IO_VIRT, CONFIG_SYS_PCIE3_IO_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G, 0, 4, BOOKE_PAGESZ_64K, 1),
+    #endif
+#endif
 
 	/* Bman/Qman */
 #ifdef CONFIG_SYS_BMAN_MEM_PHYS
diff --git a/board/freescale/common/qixis.c b/board/freescale/common/qixis.c
index c92902a..0dea660 100644
--- a/board/freescale/common/qixis.c
+++ b/board/freescale/common/qixis.c
@@ -14,8 +14,23 @@
 #include <common.h>
 #include <command.h>
 #include <asm/io.h>
+#include <linux/time.h>
+#include <i2c.h>
 #include "qixis.h"
 
+#ifdef CONFIG_SYS_I2C_FPGA_ADDR
+u8 qixis_read_i2c(unsigned int reg)
+{
+	return i2c_reg_read(CONFIG_SYS_I2C_FPGA_ADDR, reg);
+}
+
+void qixis_write_i2c(unsigned int reg, u8 value)
+{
+	u8 val = value;
+	i2c_reg_write(CONFIG_SYS_I2C_FPGA_ADDR, reg, val);
+}
+#endif
+
 u8 qixis_read(unsigned int reg)
 {
 	void *p = (void *)QIXIS_BASE;
@@ -30,6 +45,92 @@ void qixis_write(unsigned int reg, u8 value)
 	out_8(p + reg, value);
 }
 
+u16 qixis_read_minor(void)
+{
+	u16 minor;
+
+	/* this data is in little endian */
+	QIXIS_WRITE(tagdata, 5);
+	minor = QIXIS_READ(tagdata);
+	QIXIS_WRITE(tagdata, 6);
+	minor += QIXIS_READ(tagdata) << 8;
+
+	return minor;
+}
+
+char *qixis_read_time(char *result)
+{
+	time_t time = 0;
+	int i;
+
+	/* timestamp is in 32-bit big endian */
+	for (i = 8; i <= 11; i++) {
+		QIXIS_WRITE(tagdata, i);
+		time =  (time << 8) + QIXIS_READ(tagdata);
+	}
+
+	return ctime_r(&time, result);
+}
+
+char *qixis_read_tag(char *buf)
+{
+	int i;
+	char tag, *ptr = buf;
+
+	for (i = 16; i <= 63; i++) {
+		QIXIS_WRITE(tagdata, i);
+		tag = QIXIS_READ(tagdata);
+		*(ptr++) = tag;
+		if (!tag)
+			break;
+	}
+	if (i > 63)
+		*ptr = '\0';
+
+	return buf;
+}
+
+/*
+ * return the string of binary of u8 in the format of
+ * 1010 10_0. The masked bit is filled as underscore.
+ */
+const char *byte_to_binary_mask(u8 val, u8 mask, char *buf)
+{
+	char *ptr;
+	int i;
+
+	ptr = buf;
+	for (i = 0x80; i > 0x08 ; i >>= 1, ptr++)
+		*ptr = (val & i) ? '1' : ((mask & i) ? '_' : '0');
+	*(ptr++) = ' ';
+	for (i = 0x08; i > 0 ; i >>= 1, ptr++)
+		*ptr = (val & i) ? '1' : ((mask & i) ? '_' : '0');
+
+	*ptr = '\0';
+
+	return buf;
+}
+
+#ifdef QIXIS_RST_FORCE_MEM
+void board_assert_mem_reset(void)
+{
+	u8 rst;
+
+	rst = QIXIS_READ(rst_frc[0]);
+	if (!(rst & QIXIS_RST_FORCE_MEM))
+		QIXIS_WRITE(rst_frc[0], rst | QIXIS_RST_FORCE_MEM);
+}
+
+void board_deassert_mem_reset(void)
+{
+	u8 rst;
+
+	rst = QIXIS_READ(rst_frc[0]);
+	if (rst & QIXIS_RST_FORCE_MEM)
+		QIXIS_WRITE(rst_frc[0], rst & ~QIXIS_RST_FORCE_MEM);
+}
+#endif
+
 void qixis_reset(void)
 {
 	QIXIS_WRITE(rst_ctl, QIXIS_RST_CTL_RESET);
@@ -61,7 +162,6 @@ void set_altbank(void)
 	QIXIS_WRITE(brdcfg[0], reg);
 }
 
-#ifdef DEBUG
 static void qixis_dump_regs(void)
 {
 	int i;
@@ -91,7 +191,14 @@ static void qixis_dump_regs(void)
 	printf("stat_sys = %02x\n", QIXIS_READ(stat_sys));
 	printf("stat_alrm = %02x\n", QIXIS_READ(stat_alrm));
 }
-#endif
+
+static void __qixis_dump_switch(void)
+{
+	puts("Reverse engineering switch is not implemented for this board\n");
+}
+
+void qixis_dump_switch(void)
+	__attribute__((weak, alias("__qixis_dump_switch")));
 
 int qixis_reset_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -122,16 +229,13 @@ int qixis_reset_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 				return 0;
 			}
 		}
-	}
-
-#ifdef DEBUG
-	else if (strcmp(argv[1], "dump") == 0) {
+	} else if (strcmp(argv[1], "dump") == 0) {
 		qixis_dump_regs();
 		return 0;
-	}
-#endif
-
-	else {
+	} else if (strcmp(argv[1], "switch") == 0) {
+		qixis_dump_switch();
+		return 0;
+	} else {
 		printf("Invalid option: %s\n", argv[1]);
 		return 1;
 	}
@@ -146,7 +250,6 @@ U_BOOT_CMD(
 	"qixis_reset altbank - reset to alternate bank\n"
 	"qixis watchdog <watchdog_period> - set the watchdog period\n"
 	"	period: 1s 2s 4s 8s 16s 32s 1min 2min 4min 8min\n"
-#ifdef DEBUG
 	"qixis_reset dump - display the QIXIS registers\n"
-#endif
+	"qixis_reset switch - display switch\n"
 	);
diff --git a/board/freescale/common/qixis.h b/board/freescale/common/qixis.h
index b98b180..2cf8738 100644
--- a/board/freescale/common/qixis.h
+++ b/board/freescale/common/qixis.h
@@ -78,7 +78,11 @@ struct qixis {
 	u8 trig_stat;
 	u8 res12[3];
 	u8 trig_ctr[4];
-	u8 res13[48];
+	u8 res13[16];
+	u8 clk_freq[6];	/* Clock Measurement Registers */
+	u8 res_c6[8];
+	u8 clk_base[2];	/* Clock Frequency Base Reg */
+	u8 res_d0[16];
 	u8 aux2[4];	/* Auxiliary Registers,0xE0 */
 	u8 res14[10];
 	u8 aux_ad;
@@ -88,8 +92,21 @@ struct qixis {
 
 u8 qixis_read(unsigned int reg);
 void qixis_write(unsigned int reg, u8 value);
+u16 qixis_read_minor(void);
+char *qixis_read_time(char *result);
+char *qixis_read_tag(char *buf);
+const char *byte_to_binary_mask(u8 val, u8 mask, char *buf);
+#ifdef CONFIG_SYS_I2C_FPGA_ADDR
+u8 qixis_read_i2c(unsigned int reg);
+void qixis_write_i2c(unsigned int reg, u8 value);
+#endif
 
 #define QIXIS_READ(reg) qixis_read(offsetof(struct qixis, reg))
 #define QIXIS_WRITE(reg, value) qixis_write(offsetof(struct qixis, reg), value)
+#ifdef CONFIG_SYS_I2C_FPGA_ADDR
+#define QIXIS_READ_I2C(reg) qixis_read_i2c(offsetof(struct qixis, reg))
+#define QIXIS_WRITE_I2C(reg, value) \
+			qixis_write_i2c(offsetof(struct qixis, reg), value)
+#endif
 
 #endif
diff --git a/board/freescale/common/sys_eeprom.c b/board/freescale/common/sys_eeprom.c
index d2ed036..e64503b 100644
--- a/board/freescale/common/sys_eeprom.c
+++ b/board/freescale/common/sys_eeprom.c
@@ -412,6 +412,7 @@ int do_mac(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return 0;
 }
 
+#if 0 /* ONIE has its own function */
 /**
  * mac_read_from_eeprom - read the MAC addresses from EEPROM
  *
@@ -514,6 +515,7 @@ int mac_read_from_eeprom(void)
 
 	return 0;
 }
+#endif
 
 #ifdef CONFIG_SYS_I2C_EEPROM_CCID
 
diff --git a/board/freescale/common/vsc3316_3308.c b/board/freescale/common/vsc3316_3308.c
index 7868565..b87b65c 100644
--- a/board/freescale/common/vsc3316_3308.c
+++ b/board/freescale/common/vsc3316_3308.c
@@ -29,7 +29,12 @@
 #define INPUT_STATE_REG		0x13
 #define GLOBAL_INPUT_ISE1		0x51
 #define GLOBAL_INPUT_ISE2		0x52
+#define GLOBAL_INPUT_GAIN		0x53
 #define GLOBAL_INPUT_LOS		0x55
+#define GLOBAL_OUTPUT_PE1		0x56
+#define GLOBAL_OUTPUT_PE2		0x57
+#define GLOBAL_OUTPUT_LEVEL		0x58
+#define GLOBAL_OUTPUT_TERMINATION	0x5A
 #define GLOBAL_CORE_CNTRL		0x5D
 #define OUTPUT_MODE_PAGE		0x23
 #define CORE_CONTROL_PAGE		0x25
@@ -108,6 +113,110 @@ int vsc3316_config(unsigned int vsc_addr, const int8_t con_arr[][2],
 	return 0;
 }
 
+#ifdef CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+int vsc3308_config_adjust(unsigned int vsc_addr, const int8_t con_arr[][2],
+		unsigned int num_con)
+{
+	unsigned int i;
+	u8 rev_id = 0;
+	int ret;
+
+	debug("VSC:Initializing VSC3308 at I2C address 0x%x"
+		" for Tx\n", vsc_addr);
+
+	ret = i2c_read(vsc_addr, REVISION_ID_REG, 1, &rev_id, 1);
+	if (ret < 0) {
+		printf("VSC:0x%x could not read REV_ID from device.\n",
+			vsc_addr);
+		return ret;
+	}
+
+	if (rev_id != 0xab) {
+		printf("VSC: device at address 0x%x is not VSC3316/3308.\n",
+			vsc_addr);
+		return -ENODEV;
+	}
+
+	ret = vsc_if_enable(vsc_addr);
+	if (ret) {
+		printf("VSC:0x%x could not configured for 2-wire I/F.\n",
+			vsc_addr);
+		return ret;
+	}
+
+	/* config connections - page 0x00 */
+	i2c_reg_write(vsc_addr, CURRENT_PAGE_REGISTER, CONNECTION_CONFIG_PAGE);
+
+	/* Configure Global Input ISE */
+	i2c_reg_write(vsc_addr, GLOBAL_INPUT_ISE1, 0);
+	i2c_reg_write(vsc_addr, GLOBAL_INPUT_ISE2, 0);
+
+	/* Configure Tx/Rx Global Output PE1 */
+	i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_PE1, 0);
+
+	/* Configure Tx/Rx Global Output PE2 */
+	i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_PE2, 0);
+
+	/* Configure Tx/Rx Global Input GAIN */
+	i2c_reg_write(vsc_addr, GLOBAL_INPUT_GAIN, 0x3F);
+
+	/* Setting Global Input LOS threshold value */
+	i2c_reg_write(vsc_addr, GLOBAL_INPUT_LOS, 0xE0);
+
+	/* Setting Global output termination */
+	i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_TERMINATION, 0);
+
+	/* Configure Tx/Rx Global Output level */
+	if (vsc_addr == VSC3308_TX_ADDRESS)
+		i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_LEVEL, 4);
+	else
+		i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_LEVEL, 2);
+
+	/* Making crosspoint connections, by connecting required
+	 * input to output */
+	for (i = 0; i < num_con ; i++)
+		i2c_reg_write(vsc_addr, con_arr[i][1], con_arr[i][0]);
+
+	/* input state - page 0x13 */
+	i2c_reg_write(vsc_addr, CURRENT_PAGE_REGISTER, INPUT_STATE_REG);
+	/* Turning off all the required input of the switch */
+	for (i = 0; i < num_con; i++)
+		i2c_reg_write(vsc_addr, con_arr[i][0], 1);
+
+	/* only turn on specific Tx/Rx requested by the XFI erratum */
+	if (vsc_addr == VSC3308_TX_ADDRESS) {
+		i2c_reg_write(vsc_addr, 2, 0);
+		i2c_reg_write(vsc_addr, 3, 0);
+	} else {
+		i2c_reg_write(vsc_addr, 0, 0);
+		i2c_reg_write(vsc_addr, 1, 0);
+	}
+
+	/* config output mode - page 0x23 */
+	i2c_reg_write(vsc_addr, CURRENT_PAGE_REGISTER, OUTPUT_MODE_PAGE);
+	/* Turn off the Output driver correspond to required output*/
+	for (i = 0; i < num_con ; i++)
+		i2c_reg_write(vsc_addr,  con_arr[i][1], 1);
+
+	/* only turn on specific Tx/Rx requested by the XFI erratum */
+	if (vsc_addr == VSC3308_TX_ADDRESS) {
+		i2c_reg_write(vsc_addr, 0, 0);
+		i2c_reg_write(vsc_addr, 1, 0);
+	} else {
+		i2c_reg_write(vsc_addr, 3, 0);
+		i2c_reg_write(vsc_addr, 4, 0);
+	}
+
+	/* configure global core control register, Turn on Global core power */
+	i2c_reg_write(vsc_addr, GLOBAL_CORE_CNTRL, 0);
+
+	vsc_wp_config(vsc_addr);
+
+	return 0;
+
+}
+#endif
+
 int vsc3308_config(unsigned int vsc_addr, const int8_t con_arr[][2],
 		unsigned int num_con)
 {
diff --git a/board/freescale/common/vsc3316_3308.h b/board/freescale/common/vsc3316_3308.h
index effd66d..55f4508 100644
--- a/board/freescale/common/vsc3316_3308.h
+++ b/board/freescale/common/vsc3316_3308.h
@@ -27,6 +27,10 @@
 int vsc_if_enable(unsigned int vsc_addr);
 int vsc3316_config(unsigned int vsc_addr, const int8_t con_arr[][2],
 		unsigned int num_con);
+#ifdef CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+int vsc3308_config_adjust(unsigned int vsc_addr, const int8_t con_arr[][2],
+		unsigned int num_con);
+#endif
 int vsc3308_config(unsigned int vsc_addr, const int8_t con_arr[][2],
 		unsigned int num_con);
 void vsc_wp_config(unsigned int vsc_addr);
diff --git a/board/freescale/corenet_ds/corenet_ds.c b/board/freescale/corenet_ds/corenet_ds.c
index 21428e3..ccefe30 100644
--- a/board/freescale/corenet_ds/corenet_ds.c
+++ b/board/freescale/corenet_ds/corenet_ds.c
@@ -43,8 +43,10 @@ int checkboard (void)
 {
 	u8 sw;
 	struct cpu_type *cpu = gd->cpu;
-	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+#if defined(CONFIG_P3041DS) || defined(CONFIG_P5020DS) \
+	|| defined(CONFIG_P5040DS)
 	unsigned int i;
+#endif
 	static const char * const freq[] = {"100", "125", "156.25", "212.5" };
 
 	printf("Board: %sDS, ", cpu->name);
@@ -63,19 +65,6 @@ int checkboard (void)
 	else
 		printf("invalid setting of SW%u\n", PIXIS_LBMAP_SWITCH);
 
-	/* Display the RCW, so that no one gets confused as to what RCW
-	 * we're actually using for this boot.
-	 */
-	puts("Reset Configuration Word (RCW):");
-	for (i = 0; i < ARRAY_SIZE(gur->rcwsr); i++) {
-		u32 rcw = in_be32(&gur->rcwsr[i]);
-
-		if ((i % 4) == 0)
-			printf("\n       %08x:", i * 4);
-		printf(" %08x", rcw);
-	}
-	puts("\n");
-
 	/* Display the actual SERDES reference clocks as configured by the
 	 * dip switches on the board.  Note that the SWx registers could
 	 * technically be set to force the reference clocks to match the
diff --git a/board/freescale/corenet_ds/ddr.c b/board/freescale/corenet_ds/ddr.c
index da284cd..517e87f 100644
--- a/board/freescale/corenet_ds/ddr.c
+++ b/board/freescale/corenet_ds/ddr.c
@@ -56,14 +56,14 @@ phys_size_t fixed_sdram(void)
 
 	ddr_size = (phys_size_t) CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
 	ddr_cfg_regs.ddr_cdr1 = DDR_CDR1_DHC_EN;
-	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
 
 #if (CONFIG_NUM_DDR_CONTROLLERS == 2)
 	memcpy(&ddr_cfg_regs,
 		fixed_ddr_parm_1[i].ddr_settings,
 		sizeof(ddr_cfg_regs));
 	ddr_cfg_regs.ddr_cdr1 = DDR_CDR1_DHC_EN;
-	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 1);
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 1, 0);
 #endif
 
 	/*
diff --git a/board/freescale/corenet_ds/eth_hydra.c b/board/freescale/corenet_ds/eth_hydra.c
index 962f380..3a42db8 100644
--- a/board/freescale/corenet_ds/eth_hydra.c
+++ b/board/freescale/corenet_ds/eth_hydra.c
@@ -78,7 +78,7 @@
 
 #ifdef CONFIG_FMAN_ENET
 
-#define BRDCFG1_EMI1_SEL_MASK	0x70
+#define BRDCFG1_EMI1_SEL_MASK	0x78
 #define BRDCFG1_EMI1_SEL_SLOT1	0x10
 #define BRDCFG1_EMI1_SEL_SLOT2	0x20
 #define BRDCFG1_EMI1_SEL_SLOT5	0x30
@@ -216,6 +216,8 @@ static void fdt_set_mdio_mux(void *fdt, const char *alias, u32 mux)
 	if (!path)
 		path = alias;
 
+	do_fixup_by_path(fdt, path, "reg",
+			 &mux, sizeof(mux), 1);
 	do_fixup_by_path(fdt, path, "fsl,hydra-mdio-muxval",
 			 &mux, sizeof(mux), 1);
 }
@@ -264,11 +266,12 @@ void board_ft_fman_fixup_port(void *fdt, char *compat, phys_addr_t addr,
 		return;
 	}
 
-	if (mux == BRDCFG1_EMI1_SEL_RGMII) {
+	if (mux == (BRDCFG1_EMI1_SEL_RGMII | BRDCFG1_EMI1_EN)) {
 		/* RGMII */
 		/* The RGMII PHY is identified by the MAC connected to it */
 		sprintf(phy, "phy_rgmii_%u", port == FM1_DTSEC4 ? 0 : 1);
 		fdt_set_phy_handle(fdt, compat, addr, phy);
+		return;
 	}
 
 	/* If it's not RGMII or XGMII, it must be SGMII */
diff --git a/board/freescale/corenet_ds/eth_superhydra.c b/board/freescale/corenet_ds/eth_superhydra.c
index ef9de25..ae07073 100644
--- a/board/freescale/corenet_ds/eth_superhydra.c
+++ b/board/freescale/corenet_ds/eth_superhydra.c
@@ -605,8 +605,8 @@ int board_eth_init(bd_t *bis)
 	lane = serdes_get_first_lane(XAUI_FM1);
 	if (lane >= 0) {
 		debug("FM1@TGEC1 expects XAUI in slot %u\n", lane_to_slot[lane]);
-		mdio_mux[FM1_10GEC1].mask = BRDCFG1_EMI2_SEL_MASK;
-		mdio_mux[FM1_10GEC1].val = BRDCFG1_EMI2_SEL_SLOT2;
+		mdio_mux[i].mask = BRDCFG1_EMI2_SEL_MASK;
+		mdio_mux[i].val = BRDCFG1_EMI2_SEL_SLOT2;
 		super_hydra_mdio_set_mux("SUPER_HYDRA_FM1_TGEC_MDIO",
 					mdio_mux[i].mask, mdio_mux[i].val);
 	}
@@ -704,8 +704,8 @@ int board_eth_init(bd_t *bis)
 	lane = serdes_get_first_lane(XAUI_FM2);
 	if (lane >= 0) {
 		debug("FM2@TGEC1 expects XAUI in slot %u\n", lane_to_slot[lane]);
-		mdio_mux[FM2_10GEC1].mask = BRDCFG1_EMI2_SEL_MASK;
-		mdio_mux[FM2_10GEC1].val = BRDCFG1_EMI2_SEL_SLOT1;
+		mdio_mux[i].mask = BRDCFG1_EMI2_SEL_MASK;
+		mdio_mux[i].val = BRDCFG1_EMI2_SEL_SLOT1;
 		super_hydra_mdio_set_mux("SUPER_HYDRA_FM2_TGEC_MDIO",
 					mdio_mux[i].mask, mdio_mux[i].val);
 	}
diff --git a/board/freescale/corenet_ds/rcw_p2041rdb.cfg b/board/freescale/corenet_ds/rcw_p2041rdb.cfg
new file mode 100644
index 0000000..8df19dd
--- /dev/null
+++ b/board/freescale/corenet_ds/rcw_p2041rdb.cfg
@@ -0,0 +1,11 @@
+#
+# Default RCW for P2041RDB.
+#
+
+#PBL preamble and RCW header
+aa55aa55 010e0100
+#64 bytes RCW data
+12600000 00000000 241C0000 00000000
+649FA0C1 C3C02000 58000000 40000000
+00000000 00000000 00000000 D0030F07
+00000000 00000000 00000000 00000000
diff --git a/board/freescale/corenet_ds/rcw_p5040ds.cfg b/board/freescale/corenet_ds/rcw_p5040ds.cfg
new file mode 100644
index 0000000..82fa741
--- /dev/null
+++ b/board/freescale/corenet_ds/rcw_p5040ds.cfg
@@ -0,0 +1,11 @@
+#
+# Default RCW for P5040DS.
+#
+
+#PBL preamble and RCW header
+aa55aa55 010e0100
+#64 bytes RCW data
+0c580000 00000000 22121200 00000000
+089c4400 00283000 58000000 61000000
+00000000 00000000 00000000 10070000
+00000000 00000000 00000000 00000000
diff --git a/board/freescale/p1010rdb/Makefile b/board/freescale/p1010rdb/Makefile
index 4c705b6..e6563be 100644
--- a/board/freescale/p1010rdb/Makefile
+++ b/board/freescale/p1010rdb/Makefile
@@ -24,11 +24,27 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(BOARD).o
 
+MINIMAL=
+
+ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_SPL_INIT_MINIMAL
+MINIMAL=y
+endif
+endif
+
+ifdef MINIMAL
+
+COBJS-y	+= spl_minimal.o tlb.o law.o
+
+else
+
 COBJS-y	+= $(BOARD).o
 COBJS-y	+= ddr.o
 COBJS-y	+= law.o
 COBJS-y	+= tlb.o
 
+endif
+
 SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS-y))
 SOBJS	:= $(addprefix $(obj),$(SOBJS))
diff --git a/board/freescale/p1010rdb/ddr.c b/board/freescale/p1010rdb/ddr.c
index 6d00caf..722a89f 100644
--- a/board/freescale/p1010rdb/ddr.c
+++ b/board/freescale/p1010rdb/ddr.c
@@ -155,7 +155,7 @@ phys_size_t fixed_sdram(void)
 	}
 
 	ddr_size = (phys_size_t) CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
-	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
 
 	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE, ddr_size,
 					LAW_TRGT_IF_DDR_1) < 0) {
diff --git a/board/freescale/p1010rdb/p1010rdb.c b/board/freescale/p1010rdb/p1010rdb.c
index dfeb86f..2e52a9e 100644
--- a/board/freescale/p1010rdb/p1010rdb.c
+++ b/board/freescale/p1010rdb/p1010rdb.c
@@ -37,10 +37,8 @@
 #include <asm/fsl_serdes.h>
 #include <asm/fsl_ifc.h>
 #include <asm/fsl_pci.h>
-
-#ifndef CONFIG_SDCARD
 #include <hwconfig.h>
-#endif
+#include <i2c.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -49,6 +47,19 @@ DECLARE_GLOBAL_DATA_PTR;
 #define MUX_CPLD_TDM			0x01
 #define MUX_CPLD_SPICS0_FLASH		0x00
 #define MUX_CPLD_SPICS0_SLIC		0x02
+#define PMUXCR1_IFC_MASK	0x00ffff00
+#define PMUXCR1_SDHC_MASK	0x00fff000
+#define PMUXCR1_SDHC_ENABLE	0x00555000
+#define PMUXCR1_ULPI_MASK	0x00ffffc0
+#define PMUXCR1_ULPI_ENABLE	0x00aaaa80
+
+enum {
+	MUX_TYPE_IFC,
+	MUX_TYPE_SDHC,
+	MUX_TYPE_ULPI,
+};
+
+uint pin_mux;
 
 #ifndef CONFIG_SDCARD
 struct cpld_data {
@@ -217,7 +228,7 @@ void fdt_del_flexcan(void *blob)
 	int nodeoff = 0;
 
 	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
-				"fsl,flexcan-v1.0")) >= 0) {
+				"fsl,p1010-flexcan")) >= 0) {
 		fdt_del_node(blob, nodeoff);
 	}
 }
@@ -262,6 +273,16 @@ void fdt_del_sdhc(void *blob)
 	}
 }
 
+void fdt_del_ifc(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+			"fsl,ifc")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
 void fdt_disable_uart1(void *blob)
 {
 	int nodeoff;
@@ -305,9 +326,13 @@ void ft_board_setup(void *blob, bd_t *bd)
 		fdt_del_flexcan(blob);
 		fdt_del_node_and_alias(blob, "ethernet2");
 	}
-#ifndef CONFIG_SDCARD
-	/* disable sdhc due to sdhc bug */
-	fdt_del_sdhc(blob);
+
+	/* Delete IFC node as IFC pins are multiplexing with SDHC */
+	if (pin_mux != MUX_TYPE_IFC)
+		fdt_del_ifc(blob);
+	else
+		fdt_del_sdhc(blob);
+
 	if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "can")) {
 		fdt_del_tdm(blob);
 		fdt_del_spi_slic(blob);
@@ -325,13 +350,70 @@ void ft_board_setup(void *blob, bd_t *bd)
 		fdt_del_flexcan(blob);
 		fdt_disable_uart1(blob);
 	}
-#endif
 }
 #endif
 
-#ifndef CONFIG_SDCARD
+int config_pin_mux(int if_type)
+{
+	ccsr_gur_t __iomem *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u8 tmp;
+	uint orig_bus = i2c_get_bus_num();
+
+	i2c_set_bus_num(CONFIG_SYS_PCA9557_BUS_NUM);
+	tmp = 0xf0;
+	if (i2c_write(CONFIG_SYS_I2C_PCA9557_ADDR, 3, 1, &tmp, 1) < 0)
+		goto wr_err;
+
+	switch (if_type) {
+	case MUX_TYPE_IFC:
+		tmp = 0x01;
+		if (i2c_write(CONFIG_SYS_I2C_PCA9557_ADDR, 1, 1, &tmp, 1) < 0)
+			goto wr_err;
+		pin_mux = MUX_TYPE_IFC;
+		clrbits_be32(&gur->pmuxcr, PMUXCR1_IFC_MASK);
+		debug("pin mux is configured for IFC, SDHC disabled\n");
+		break;
+	case MUX_TYPE_SDHC:
+		tmp = 0x05;
+		if (i2c_write(CONFIG_SYS_I2C_PCA9557_ADDR, 1, 1, &tmp, 1) < 0)
+			goto wr_err;
+		pin_mux = MUX_TYPE_SDHC;
+		clrsetbits_be32(&gur->pmuxcr, PMUXCR1_SDHC_MASK,
+							PMUXCR1_SDHC_ENABLE);
+		debug("pin mux is configured for SDHC, IFC disabled\n");
+		break;
+	case MUX_TYPE_ULPI:
+		tmp = 0x06;
+		if (i2c_write(CONFIG_SYS_I2C_PCA9557_ADDR, 1, 1, &tmp, 1) < 0)
+			goto wr_err;
+		pin_mux = MUX_TYPE_ULPI;
+		clrsetbits_be32(&gur->pmuxcr, PMUXCR1_ULPI_MASK,
+							PMUXCR1_ULPI_ENABLE);
+		debug("pin mux is configured for ULPI, IFC & SDHC disabled\n");
+		break;
+	default:
+		printf("wrong mux interface type\n");
+		i2c_set_bus_num(orig_bus);
+		return -1;
+	}
+	i2c_set_bus_num(orig_bus);
+	return 0;
+wr_err:
+	printf("pca9557: i2c write failed\n");
+	i2c_set_bus_num(orig_bus);
+	return -1;
+}
+
+void board_reset(void)
+{
+	/* mux to IFC to enable CPLD for reset */
+	if (pin_mux != MUX_TYPE_IFC)
+		config_pin_mux(MUX_TYPE_IFC);
+}
+
 int misc_init_r(void)
 {
+#ifndef CONFIG_SDCARD
 	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
 	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 
@@ -355,6 +437,34 @@ int misc_init_r(void)
 		out_8(&cpld_data->spi_cs0_sel, MUX_CPLD_SPICS0_FLASH);
 	}
 
+	if (hwconfig("esdhc")) {
+		pin_mux = MUX_TYPE_SDHC;
+		config_pin_mux(MUX_TYPE_SDHC);
+	}
+#else
+	pin_mux = MUX_TYPE_SDHC;
+#endif
 	return 0;
 }
-#endif
+
+static int pin_mux_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+					char * const argv[])
+{
+	if (argc < 2)
+		return CMD_RET_USAGE;
+	if (strcmp(argv[1], "ifc") == 0)
+		config_pin_mux(MUX_TYPE_IFC);
+	else if (strcmp(argv[1], "sdhc") == 0)
+		config_pin_mux(MUX_TYPE_SDHC);
+	else if (strcmp(argv[1], "ulpi") == 0)
+		config_pin_mux(MUX_TYPE_ULPI);
+	else
+		return CMD_RET_USAGE;
+	return 0;
+}
+
+U_BOOT_CMD(
+	mux, 2, 0, pin_mux_cmd,
+	"configure multiplexing pin for IFC/SDHC/ULPI buses",
+	"bus_type[ifc/sdhc/ulpi] (e.g. mux sdhc)"
+);
diff --git a/board/freescale/p1010rdb/spl_minimal.c b/board/freescale/p1010rdb/spl_minimal.c
new file mode 100644
index 0000000..c909e0e
--- /dev/null
+++ b/board/freescale/p1010rdb/spl_minimal.c
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#include <common.h>
+#include <mpc85xx.h>
+#include <asm/io.h>
+#include <ns16550.h>
+#include <nand.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_law.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+
+void sdram_init(void)
+{
+	ccsr_ddr_t *ddr = (ccsr_ddr_t *)CONFIG_SYS_MPC8xxx_DDR_ADDR;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+	u32 ddr_ratio;
+	unsigned long ddr_freq_mhz;
+
+	ddr_ratio = in_be32(&gur->porpllsr) & MPC85xx_PORPLLSR_DDR_RATIO;
+	ddr_ratio = ddr_ratio >> MPC85xx_PORPLLSR_DDR_RATIO_SHIFT;
+	ddr_freq_mhz = (CONFIG_SYS_CLK_FREQ * ddr_ratio) / 0x1000000;
+
+	/* mask off E bit */
+	u32 svr = SVR_SOC_VER(mfspr(SPRN_SVR));
+
+	__raw_writel(CONFIG_SYS_DDR_CONTROL | SDRAM_CFG_32_BE, &ddr->sdram_cfg);
+	__raw_writel(CONFIG_SYS_DDR_CS0_BNDS, &ddr->cs0_bnds);
+	__raw_writel(CONFIG_SYS_DDR_CS0_CONFIG, &ddr->cs0_config);
+	__raw_writel(CONFIG_SYS_DDR_CONTROL_2, &ddr->sdram_cfg_2);
+	__raw_writel(CONFIG_SYS_DDR_DATA_INIT, &ddr->sdram_data_init);
+
+	if (ddr_freq_mhz < 700) {
+		__raw_writel(CONFIG_SYS_DDR_TIMING_3_667, &ddr->timing_cfg_3);
+		__raw_writel(CONFIG_SYS_DDR_TIMING_0_667, &ddr->timing_cfg_0);
+		__raw_writel(CONFIG_SYS_DDR_TIMING_1_667, &ddr->timing_cfg_1);
+		__raw_writel(CONFIG_SYS_DDR_TIMING_2_667, &ddr->timing_cfg_2);
+		__raw_writel(CONFIG_SYS_DDR_MODE_1_667, &ddr->sdram_mode);
+		__raw_writel(CONFIG_SYS_DDR_MODE_2_667, &ddr->sdram_mode_2);
+		__raw_writel(CONFIG_SYS_DDR_INTERVAL_667, &ddr->sdram_interval);
+		__raw_writel(CONFIG_SYS_DDR_CLK_CTRL_667, &ddr->sdram_clk_cntl);
+		__raw_writel(CONFIG_SYS_DDR_WRLVL_CONTROL_667, &ddr->ddr_wrlvl_cntl);
+	} else {
+		__raw_writel(CONFIG_SYS_DDR_TIMING_3_800, &ddr->timing_cfg_3);
+		__raw_writel(CONFIG_SYS_DDR_TIMING_0_800, &ddr->timing_cfg_0);
+		__raw_writel(CONFIG_SYS_DDR_TIMING_1_800, &ddr->timing_cfg_1);
+		__raw_writel(CONFIG_SYS_DDR_TIMING_2_800, &ddr->timing_cfg_2);
+		__raw_writel(CONFIG_SYS_DDR_MODE_1_800, &ddr->sdram_mode);
+		__raw_writel(CONFIG_SYS_DDR_MODE_2_800, &ddr->sdram_mode_2);
+		__raw_writel(CONFIG_SYS_DDR_INTERVAL_800, &ddr->sdram_interval);
+		__raw_writel(CONFIG_SYS_DDR_CLK_CTRL_800, &ddr->sdram_clk_cntl);
+		__raw_writel(CONFIG_SYS_DDR_WRLVL_CONTROL_800, &ddr->ddr_wrlvl_cntl);
+	}
+
+	__raw_writel(CONFIG_SYS_DDR_TIMING_4, &ddr->timing_cfg_4);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_5, &ddr->timing_cfg_5);
+	__raw_writel(CONFIG_SYS_DDR_ZQ_CONTROL, &ddr->ddr_zq_cntl);
+
+	/* P1014 and it's derivatives support max 16bit DDR width */
+	if (svr == SVR_P1014) {
+		__raw_writel(ddr->sdram_cfg & ~SDRAM_CFG_DBW_MASK, &ddr->sdram_cfg);
+		__raw_writel(ddr->sdram_cfg | SDRAM_CFG_16_BE, &ddr->sdram_cfg);
+		/* For CS0_BNDS we divide the start and end address by 2, so we can just
+		 * shift the entire register to achieve the desired result and the mask
+		 * the value so we don't write reserved fields */
+		__raw_writel((CONFIG_SYS_DDR_CS0_BNDS >> 1) & 0x0fff0fff, &ddr->cs0_bnds);
+	}
+
+	asm volatile("sync;isync");
+	udelay(500);
+
+	/* Let the controller go */
+	out_be32(&ddr->sdram_cfg, in_be32(&ddr->sdram_cfg) | SDRAM_CFG_MEM_EN);
+
+	set_next_law(CONFIG_SYS_NAND_DDR_LAW, LAW_SIZE_1G, LAW_TRGT_IF_DDR_1);
+}
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	/* initialize selected port with appropriate baud rate */
+	plat_ratio = in_be32(&gur->porpllsr) & MPC85xx_PORPLLSR_PLAT_RATIO;
+	plat_ratio >>= 1;
+	gd->bus_clk = CONFIG_SYS_CLK_FREQ * plat_ratio;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+			gd->bus_clk / 16 / CONFIG_BAUDRATE);
+
+	puts("\nNAND boot... ");
+
+	/* Initialize the DDR3 */
+	sdram_init();
+
+	/* copy code to RAM and jump to it - this should not return */
+	/* NOTE - code has to be copied out of NAND buffer before
+	 * other blocks can be read.
+	 */
+
+	relocate_code(CONFIG_SPL_RELOC_STACK, 0, CONFIG_SPL_RELOC_TEXT_BASE);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	nand_boot();
+}
+
+void putc(char c)
+{
+	if (c == '\n')
+		NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, '\r');
+
+	NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, c);
+}
+
+void puts(const char *str)
+{
+	while (*str)
+		putc(*str++);
+}
diff --git a/board/freescale/p1010rdb/tlb.c b/board/freescale/p1010rdb/tlb.c
index 4256bf4..078717a 100644
--- a/board/freescale/p1010rdb/tlb.c
+++ b/board/freescale/p1010rdb/tlb.c
@@ -44,15 +44,20 @@ struct fsl_e_tlb_entry tlb_table[] = {
 	/* TLB 1 */
 	/* *I*** - Covers boot page */
 	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
-			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
-			0, 0, BOOKE_PAGESZ_4K, 1),
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#ifdef CONFIG_SPL_NAND_MINIMAL
+	SET_TLB_ENTRY(1, 0xffffe000, 0xffffe000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_4K, 1),
+#endif
 
 	/* *I*G* - CCSRBAR */
 	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
 			MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 			0, 1, BOOKE_PAGESZ_1M, 1),
 
-#ifndef CONFIG_NAND_SPL
+#ifndef CONFIG_SPL_BUILD
 #ifndef CONFIG_SDCARD
 	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
 			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
@@ -88,7 +93,7 @@ struct fsl_e_tlb_entry tlb_table[] = {
 			0, 7, BOOKE_PAGESZ_1M, 1),
 #endif
 
-#if defined(CONFIG_SYS_RAMBOOT)
+#if defined(CONFIG_SYS_RAMBOOT) || defined(CONFIG_SPL)
 	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
 			MAS3_SX|MAS3_SW|MAS3_SR, 0,
 			0, 8, BOOKE_PAGESZ_1G, 1)
diff --git a/board/freescale/p1022ds/Makefile b/board/freescale/p1022ds/Makefile
index c6d3418..0eeef05 100644
--- a/board/freescale/p1022ds/Makefile
+++ b/board/freescale/p1022ds/Makefile
@@ -11,12 +11,26 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(BOARD).o
 
+MINIMAL=
+
+ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_SPL_INIT_MINIMAL
+MINIMAL=y
+endif
+endif
+
+ifdef MINIMAL
+
+COBJS-y        += spl_minimal.o tlb.o law.o
+
+else
 COBJS-y	+= $(BOARD).o
 COBJS-y	+= ddr.o
 COBJS-y	+= law.o
 COBJS-y	+= tlb.o
 
 COBJS-$(CONFIG_FSL_DIU_FB) += diu.o
+endif
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS-y))
diff --git a/board/freescale/p1022ds/law.c b/board/freescale/p1022ds/law.c
index b23b8f9..c4398dd 100644
--- a/board/freescale/p1022ds/law.c
+++ b/board/freescale/p1022ds/law.c
@@ -16,6 +16,7 @@
 struct law_entry law_table[] = {
 	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
 	SET_LAW(PIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_32K, LAW_TRGT_IF_LBC),
 };
 
 int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/freescale/p1022ds/spl_minimal.c b/board/freescale/p1022ds/spl_minimal.c
new file mode 100644
index 0000000..8d12fa6
--- /dev/null
+++ b/board/freescale/p1022ds/spl_minimal.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <common.h>
+#include <ns16550.h>
+#include <asm/io.h>
+#include <nand.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_ddr_sdram.h>
+
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+void sdram_init(void)
+{
+	volatile ccsr_ddr_t *ddr = (ccsr_ddr_t *)CONFIG_SYS_MPC8xxx_DDR_ADDR;
+
+	__raw_writel(CONFIG_SYS_DDR_CS0_BNDS, &ddr->cs0_bnds);
+	__raw_writel(CONFIG_SYS_DDR_CS0_CONFIG, &ddr->cs0_config);
+#if CONFIG_CHIP_SELECTS_PER_CTRL > 1
+	__raw_writel(CONFIG_SYS_DDR_CS1_BNDS, &ddr->cs1_bnds);
+	__raw_writel(CONFIG_SYS_DDR_CS1_CONFIG, &ddr->cs1_config);
+#endif
+	__raw_writel(CONFIG_SYS_DDR_TIMING_3, &ddr->timing_cfg_3);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_0, &ddr->timing_cfg_0);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_1, &ddr->timing_cfg_1);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_2, &ddr->timing_cfg_2);
+
+	__raw_writel(CONFIG_SYS_DDR_CONTROL_2, &ddr->sdram_cfg_2);
+	__raw_writel(CONFIG_SYS_DDR_MODE_1, &ddr->sdram_mode);
+	__raw_writel(CONFIG_SYS_DDR_MODE_2, &ddr->sdram_mode_2);
+
+	__raw_writel(CONFIG_SYS_DDR_INTERVAL, &ddr->sdram_interval);
+	__raw_writel(CONFIG_SYS_DDR_DATA_INIT, &ddr->sdram_data_init);
+	__raw_writel(CONFIG_SYS_DDR_CLK_CTRL, &ddr->sdram_clk_cntl);
+
+	__raw_writel(CONFIG_SYS_DDR_TIMING_4, &ddr->timing_cfg_4);
+	__raw_writel(CONFIG_SYS_DDR_TIMING_5, &ddr->timing_cfg_5);
+	__raw_writel(CONFIG_SYS_DDR_ZQ_CONTROL, &ddr->ddr_zq_cntl);
+	__raw_writel(CONFIG_SYS_DDR_WRLVL_CONTROL, &ddr->ddr_wrlvl_cntl);
+
+	/* Set, but do not enable the memory */
+	__raw_writel(CONFIG_SYS_DDR_CONTROL & ~SDRAM_CFG_MEM_EN,
+			&ddr->sdram_cfg);
+
+	in_be32(&ddr->sdram_cfg);
+	udelay(500);
+
+	/* Let the controller go */
+	out_be32(&ddr->sdram_cfg, in_be32(&ddr->sdram_cfg) | SDRAM_CFG_MEM_EN);
+	in_be32(&ddr->sdram_cfg);
+
+	set_next_law(0, CONFIG_SYS_SDRAM_SIZE_LAW, LAW_TRGT_IF_DDR_1);
+}
+
+const static u32 sysclk_tbl[] = {
+	66666000, 7499900, 83332500, 8999900,
+	99999000, 11111000, 12499800, 13333200
+};
+
+void board_init_f(ulong bootflag)
+{
+	int px_spd;
+	u32 plat_ratio, sys_clk, bus_clk;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	/* for FPGA */
+	set_lbc_br(2, CONFIG_SYS_BR2_PRELIM);
+	set_lbc_or(2, CONFIG_SYS_OR2_PRELIM);
+
+	/* initialize selected port with appropriate baud rate */
+	px_spd = in_8((unsigned char *)(PIXIS_BASE + PIXIS_SPD));
+	sys_clk = sysclk_tbl[px_spd & PIXIS_SPD_SYSCLK_MASK];
+	plat_ratio = in_be32(&gur->porpllsr) & MPC85xx_PORPLLSR_PLAT_RATIO;
+	bus_clk = sys_clk * plat_ratio / 2;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+			bus_clk / 16 / CONFIG_BAUDRATE);
+
+	puts("\nNAND boot... ");
+
+	/* Initialize the DDR3 */
+	sdram_init();
+
+	/* copy code to RAM and jump to it - this should not return */
+	/* NOTE - code has to be copied out of NAND buffer before
+	 * other blocks can be read.
+	 */
+	relocate_code(CONFIG_SPL_RELOC_STACK, 0,
+			CONFIG_SPL_RELOC_TEXT_BASE);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	nand_boot();
+}
+
+void putc(char c)
+{
+	if (c == '\n')
+		NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, '\r');
+
+	NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, c);
+}
+
+void puts(const char *str)
+{
+	while (*str)
+		putc(*str++);
+}
diff --git a/board/freescale/p1022ds/tlb.c b/board/freescale/p1022ds/tlb.c
index 71e71f7..3acc449 100644
--- a/board/freescale/p1022ds/tlb.c
+++ b/board/freescale/p1022ds/tlb.c
@@ -41,6 +41,7 @@ struct fsl_e_tlb_entry tlb_table[] = {
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 1, BOOKE_PAGESZ_1M, 1),
 
+#ifndef CONFIG_SPL_BUILD
 	/* W**G* - Flash/promjet, localbus */
 	/* This will be changed to *I*G* after relocation to RAM. */
 	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
@@ -67,24 +68,31 @@ struct fsl_e_tlb_entry tlb_table[] = {
 	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_IO_VIRT, CONFIG_SYS_PCIE3_IO_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 6, BOOKE_PAGESZ_256K, 1),
+#endif
 
 	SET_TLB_ENTRY(1, PIXIS_BASE, PIXIS_BASE_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 7, BOOKE_PAGESZ_4K, 1),
 
-#ifdef CONFIG_SYS_RAMBOOT
-	/* *I*G - eSDHC/eSPI/NAND boot */
+#if defined(CONFIG_SYS_RAMBOOT) || defined(CONFIG_SPL)
+	/* **** - eSDHC/eSPI/NAND boot */
 	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
 			MAS3_SX|MAS3_SW|MAS3_SR, 0,
 			0, 8, BOOKE_PAGESZ_1G, 1),
-
-	/* map the second 1G */
+	/* **** - eSDHC/eSPI/NAND boot - second 1GB of memory */
 	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
 			CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
-			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
 			0, 9, BOOKE_PAGESZ_1G, 1),
 #endif
-#
+
+#ifdef CONFIG_SYS_NAND_BASE
+	/* *I*G - NAND */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 10, BOOKE_PAGESZ_16K, 1),
+#endif
+
 };
 
 int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/freescale/p1023rdb/Makefile b/board/freescale/p1023rdb/Makefile
new file mode 100644
index 0000000..45c4f8b
--- /dev/null
+++ b/board/freescale/p1023rdb/Makefile
@@ -0,0 +1,33 @@
+#
+# Copyright 2013 Freescale Semiconductor, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/p1023rdb/ddr.c b/board/freescale/p1023rdb/ddr.c
new file mode 100644
index 0000000..8b535e7
--- /dev/null
+++ b/board/freescale/p1023rdb/ddr.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* CONFIG_SYS_DDR_RAW_TIMING */
+/*
+ * Hynix H5TQ1G83TFR-H9C
+ */
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 536870912u,
+	.capacity = 536870912u,
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 14,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tCKmin_X_ps = 1875,
+	.caslat_X = 0x1e << 4,	/* 5,6,7,8 */
+	.tAA_ps = 13125,
+	.tWR_ps = 18000,
+	.tRCD_ps = 13125,
+	.tRRD_ps = 7500,
+	.tRP_ps = 13125,
+	.tRAS_ps = 37500,
+	.tRC_ps = 50625,
+	.tRFC_ps = 160000,
+	.tWTR_ps = 7500,
+	.tRTP_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tFAW_ps = 37500,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR on board";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	struct cpu_type *cpu;
+	int i;
+	popts->clk_adjust = 6;
+	popts->cpo_override = 0x1f;
+	popts->write_data_delay = 2;
+	popts->half_strength_driver_enable = 1;
+	/* Write leveling override */
+	popts->wrlvl_en = 1;
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+	popts->wrlvl_start = 0x8;
+	popts->trwt_override = 1;
+	popts->trwt = 0;
+
+	cpu = gd->cpu;
+	/* P1014 and it's derivatives support max 16it DDR width */
+	if (cpu->soc_ver == SVR_P1014)
+		popts->data_bus_width = DDR_DATA_BUS_WIDTH_16;
+
+	for (i = 0; i < CONFIG_CHIP_SELECTS_PER_CTRL; i++) {
+		popts->cs_local_opts[i].odt_rd_cfg = FSL_DDR_ODT_NEVER;
+		popts->cs_local_opts[i].odt_wr_cfg = FSL_DDR_ODT_CS;
+	}
+}
diff --git a/board/freescale/p1023rdb/law.c b/board/freescale/p1023rdb/law.c
new file mode 100644
index 0000000..b041d1f
--- /dev/null
+++ b/board/freescale/p1023rdb/law.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_4M,
+					LAW_TRGT_IF_DPAA_SWP_SRAM),
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/freescale/p1023rdb/p1023rdb.c b/board/freescale/p1023rdb/p1023rdb.c
new file mode 100644
index 0000000..b83cd3e
--- /dev/null
+++ b/board/freescale/p1023rdb/p1023rdb.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Authors:  Roy Zang <tie-fei.zang@freescale.com>
+ *           Chunhe Lan <Chunhe.Lan@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/io.h>
+#include <asm/cache.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_pci.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_portals.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <asm/fsl_dtsec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_early_init_f(void)
+{
+	fsl_lbc_t *lbc = LBC_BASE_ADDR;
+
+	/* Set ABSWP to implement conversion of addresses in the LBC */
+	setbits_be32(&lbc->lbcr, CONFIG_SYS_LBC_LBCR);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	printf("Board: P1023 RDB\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+#endif
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash + promjet */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_256M, 1);
+
+	setup_portals();
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(ulong dummy)
+{
+	return gd->bus_clk;
+}
+
+unsigned long get_board_ddr_clk(ulong dummy)
+{
+	return gd->mem_clk;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	ccsr_gur_t *gur = (ccsr_gur_t *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+	struct fsl_pq_mdio_info dtsec_mdio_info;
+
+	/*
+	 * Need to set dTSEC 1 pin multiplexing to TSEC. The default setting
+	 * is not correct.
+	 */
+	setbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_TSEC1_1);
+
+	dtsec_mdio_info.regs =
+		(struct tsec_mii_mng *)CONFIG_SYS_FM1_DTSEC1_MDIO_ADDR;
+	dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the 1G MDIO bus */
+	fsl_pq_mdio_init(bis, &dtsec_mdio_info);
+
+	fm_info_set_phy_address(FM1_DTSEC1, CONFIG_SYS_FM1_DTSEC1_PHY_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC2, CONFIG_SYS_FM1_DTSEC2_PHY_ADDR);
+
+	fm_info_set_mdio(FM1_DTSEC1,
+		miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+	fm_info_set_mdio(FM1_DTSEC2,
+		miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+
+#ifdef CONFIG_FMAN_ENET
+	cpu_eth_init(bis);
+#endif
+
+	return pci_eth_init(bis);
+}
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+	fdt_fixup_dr_usb(blob, bd);
+#endif
+
+	fdt_fixup_fman_ethernet(blob);
+}
+#endif
diff --git a/board/freescale/p1023rdb/tlb.c b/board/freescale/p1023rdb/tlb.c
new file mode 100644
index 0000000..a6c38a5
--- /dev/null
+++ b/board/freescale/p1023rdb/tlb.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR, CONFIG_SYS_INIT_RAM_ADDR,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_4M, 1),
+
+	/* W**G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT, CONFIG_SYS_PCIE3_MEM_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT + 0x40000000,
+		      CONFIG_SYS_PCIE3_MEM_PHYS + 0x40000000,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256M, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT + 0x50000000,
+		      CONFIG_SYS_PCIE3_MEM_PHYS + 0x50000000,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 5, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_IO_VIRT, CONFIG_SYS_PCIE3_IO_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_256K, 1),
+
+	/* Bman/Qman */
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE, CONFIG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 7, BOOKE_PAGESZ_1M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE + 0x00100000,
+		      CONFIG_SYS_BMAN_MEM_PHYS + 0x00100000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 8, BOOKE_PAGESZ_1M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE, CONFIG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_M,
+		      0, 9, BOOKE_PAGESZ_1M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE + 0x00100000,
+		      CONFIG_SYS_QMAN_MEM_PHYS + 0x00100000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_1M, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 11, BOOKE_PAGESZ_16K, 1),
+
+#ifdef CONFIG_SYS_RAMBOOT
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE,
+		      CONFIG_SYS_DDR_SDRAM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 12, BOOKE_PAGESZ_256M, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE + 0x10000000,
+		      CONFIG_SYS_DDR_SDRAM_BASE + 0x10000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 13, BOOKE_PAGESZ_256M, 1),
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/freescale/p1_p2_rdb/ddr.c b/board/freescale/p1_p2_rdb/ddr.c
index 916439c..f1b64a3 100644
--- a/board/freescale/p1_p2_rdb/ddr.c
+++ b/board/freescale/p1_p2_rdb/ddr.c
@@ -236,7 +236,7 @@ phys_size_t fixed_sdram (void)
 		ddr_cfg_regs.cs[0].bnds = 0x0000001F;
 	}
 
-	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
 
 	set_ddr_laws(0, ddr_size, LAW_TRGT_IF_DDR_1);
 	return ddr_size;
diff --git a/board/freescale/p1_p2_rdb_pc/ddr.c b/board/freescale/p1_p2_rdb_pc/ddr.c
index 9355536..0c41b22 100644
--- a/board/freescale/p1_p2_rdb_pc/ddr.c
+++ b/board/freescale/p1_p2_rdb_pc/ddr.c
@@ -80,7 +80,7 @@ dimm_params_t ddr_raw_timing = {
 	.refresh_rate_ps = 7800000,
 	.tFAW_ps = 30000,
 };
-#elif defined(CONFIG_P1020MBG)
+#elif (defined(CONFIG_P1020MBG) || defined(CONFIG_P1020RDB_PD))
 /* Micron MT41J512M8_187E */
 dimm_params_t ddr_raw_timing = {
 	.n_ranks = 2,
@@ -251,7 +251,7 @@ phys_size_t fixed_sdram(void)
 
 	ddr_size = CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
 
-	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
 
 	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE,
 				ddr_size, LAW_TRGT_IF_DDR_1) < 0) {
diff --git a/board/freescale/p1_p2_rdb_pc/p1_p2_rdb_pc.c b/board/freescale/p1_p2_rdb_pc/p1_p2_rdb_pc.c
index 5b5b86c..7c309c8 100644
--- a/board/freescale/p1_p2_rdb_pc/p1_p2_rdb_pc.c
+++ b/board/freescale/p1_p2_rdb_pc/p1_p2_rdb_pc.c
@@ -55,6 +55,13 @@
 #define GPIO_SLIC_PIN		30
 #define GPIO_SLIC_DATA		(1 << (31 - GPIO_SLIC_PIN))
 
+#if defined(CONFIG_P1021RDB) && !defined(CONFIG_SYS_RAMBOOT)
+#define GPIO_DDR_RST_PORT	1
+#define GPIO_DDR_RST_PIN	8
+#define GPIO_DDR_RST_DATA	(1 << (31 - GPIO_DDR_RST_PIN))
+
+#define GPIO_2BIT_MASK		(0x3 << (32 - (GPIO_DDR_RST_PIN + 1) * 2))
+#endif
 
 #if defined(CONFIG_P1025RDB) || defined(CONFIG_P1021RDB)
 #define PCA_IOPORT_I2C_ADDR		0x23
@@ -67,7 +74,7 @@
 const qe_iop_conf_t qe_iop_conf_tab[] = {
 	/* GPIO */
 	{1,   1, 2, 0, 0}, /* GPIO7/PB1   - LOAD_DEFAULT_N */
-#if 0
+#if defined(CONFIG_P1021RDB) && !defined(CONFIG_SYS_RAMBOOT)
 	{1,   8, 1, 1, 0}, /* GPIO10/PB8  - DDR_RST */
 #endif
 	{0,  15, 1, 0, 0}, /* GPIO11/A15  - WDI */
@@ -159,6 +166,16 @@ void board_gpio_init(void)
 	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 	par_io_t *par_io = (par_io_t *) &(gur->qe_par_io);
 
+#if defined(CONFIG_P1021RDB) && !defined(CONFIG_SYS_RAMBOOT)
+	/* reset DDR3 */
+	setbits_be32(&par_io[GPIO_DDR_RST_PORT].cpdat, GPIO_DDR_RST_DATA);
+	udelay(1000);
+	clrbits_be32(&par_io[GPIO_DDR_RST_PORT].cpdat, GPIO_DDR_RST_DATA);
+	udelay(1000);
+	setbits_be32(&par_io[GPIO_DDR_RST_PORT].cpdat, GPIO_DDR_RST_DATA);
+	/* disable CE_PB8 */
+	clrbits_be32(&par_io[GPIO_DDR_RST_PORT].cpdir1, GPIO_2BIT_MASK);
+#endif
 	/* Enable VSC7385 switch */
 	setbits_be32(&par_io[GPIO_GETH_SW_PORT].cpdat, GPIO_GETH_SW_DATA);
 
@@ -373,6 +390,102 @@ int board_eth_init(bd_t *bis)
 
 #if defined(CONFIG_QE) && \
 	(defined(CONFIG_P1025RDB) || defined(CONFIG_P1021RDB))
+#ifdef CONFIG_P1021RDB
+static void fdt_board_fixup_lbc_cs(void *blob)
+{
+	int offset, len;
+	const u32 pmc_range[] = {
+		CONFIG_SYS_PMC_BASE, 0x00010000
+	};
+
+	if (hwconfig("qe") && hwconfig("tdm")) {
+		/*
+		 * PMC has a shared CS pin with vitesse-7385, and
+		 * TDM has some pin muxed with lbc, so we modefy
+		 * the range and size of vitesse-7385 to the PMC,
+		 * then disable these both nor and l2switch nodes.
+		 */
+		int i;
+		const u32 *size_cell, *range;
+
+		offset = fdt_node_offset_by_compatible(blob, -1, "fsl,elbc");
+		range = fdt_getprop(blob, offset, "ranges", &len);
+		size_cell = fdt_getprop(blob, offset, "#size-cells", NULL);
+
+		/*
+		 * Scan the value from DTS, modify the address and size
+		 * of l2switch to the PMC if it was there.
+		 */
+		for (i = 0; i < len; i++)
+			if (range[i] == CONFIG_SYS_VSC7385_BASE)
+				break;
+
+		if (i < len) {
+			u32 *index = (u32 *)range;
+
+			index[i] = pmc_range[0];
+			index[i + *size_cell] = pmc_range[1];
+		} else
+			printf("WARNING: no range for PMC\n");
+
+		do_fixup_by_compat(blob, "cfi-flash", "status",
+			"disabled", sizeof("disabled"), 1);
+		do_fixup_by_compat(blob, "vitesse-7385", "status",
+			"disabled", sizeof("disabled"), 1);
+	} else {
+		/*
+		 * Disable the TDM tdmphy node, if there is no
+		 * "qe;tdm" string in hwconfig.
+		 */
+		do_fixup_by_compat(blob, "fsl,pq-mds-t1", "status",
+			"disabled", sizeof("disabled"), 1);
+	}
+}
+#endif
+
+#ifdef CONFIG_P1025RDB
+static void fdt_board_fixup_ucc_node(void *blob)
+{
+	int offset, ucc_sum;
+
+	if (hwconfig("qe") && hwconfig("tdm")) {
+		/* delete ucc geth and serial node, use tdm node */
+		for (ucc_sum = 4; ucc_sum > 0; ucc_sum--) {
+			offset = fdt_node_offset_by_compatible(blob,
+					-1, "ucc_geth");
+			if (offset >= 0)
+				fdt_del_node(blob, offset);
+			offset = fdt_node_offset_by_compatible(blob,
+					-1, "ucc_uart");
+			if (offset >= 0)
+				fdt_del_node(blob, offset);
+		}
+
+		do_fixup_by_compat(blob, "cfi-flash", "status",
+			"disabled", sizeof("disabled"), 1);
+	} else {
+		/*
+		 * Disable the TDM tdmphy node if don't use the mode
+		 * remove tdm node
+		 */
+		for (ucc_sum = 4; ucc_sum > 0; ucc_sum--) {
+			offset = fdt_node_offset_by_compatible(blob,
+					-1, "fsl,ucc-tdm");
+			if (offset >= 0)
+				fdt_del_node(blob, offset);
+		}
+
+		do_fixup_by_compat(blob, "fsl,pq-mds-t1", "status",
+			"disabled", sizeof("disabled"), 1);
+
+		offset = fdt_node_offset_by_compatible(blob,
+				-1, "fsl,mpc8569-qe-spi");
+		if (offset >= 0)
+			fdt_del_node(blob, offset);
+	}
+}
+#endif
+
 static void fdt_board_fixup_qe_pins(void *blob)
 {
 	unsigned int oldbus;
@@ -421,6 +534,8 @@ void ft_board_setup(void *blob, bd_t *bd)
 {
 	phys_addr_t base;
 	phys_size_t size;
+	const char *soc_usb_compat = "fsl-usb2-dr";
+	int err, usb1_off, usb2_off;
 
 	ft_cpu_setup(blob, bd);
 
@@ -435,6 +550,12 @@ void ft_board_setup(void *blob, bd_t *bd)
 	do_fixup_by_compat(blob, "fsl,qe", "status", "okay",
 			sizeof("okay"), 0);
 #if defined(CONFIG_P1025RDB) || defined(CONFIG_P1021RDB)
+#ifdef CONFIG_P1021RDB
+	fdt_board_fixup_lbc_cs(blob);
+#endif
+#ifdef CONFIG_P1025RDB
+	fdt_board_fixup_ucc_node(blob);
+#endif
 	fdt_board_fixup_qe_pins(blob);
 #endif
 #endif
@@ -442,5 +563,50 @@ void ft_board_setup(void *blob, bd_t *bd)
 #if defined(CONFIG_HAS_FSL_DR_USB)
 	fdt_fixup_dr_usb(blob, bd);
 #endif
+
+#if defined(CONFIG_SDCARD) || defined(CONFIG_SPIFLASH)
+	/* Delete eLBC node as it is muxed with USB2 controller */
+	if (hwconfig("usb2")) {
+		const char *soc_elbc_compat = "fsl,p1020-elbc";
+		int off = fdt_node_offset_by_compatible(blob, -1,
+				soc_elbc_compat);
+		if (off < 0) {
+			printf("WARNING: could not find compatible node"
+				" %s: %s.\n", soc_elbc_compat,
+				fdt_strerror(off));
+				return;
+		}
+		err = fdt_del_node(blob, off);
+		if (err < 0) {
+			printf("WARNING: could not remove %s: %s.\n",
+				soc_elbc_compat, fdt_strerror(err));
+		}
+		return;
+	}
+#endif
+
+/* Delete USB2 node as it is muxed with eLBC */
+	usb1_off = fdt_node_offset_by_compatible(blob, -1,
+		soc_usb_compat);
+	if (usb1_off < 0) {
+		printf("WARNING: could not find compatible node"
+			"%s: %s.\n", soc_usb_compat,
+			fdt_strerror(usb1_off));
+		return;
+	}
+	usb2_off = fdt_node_offset_by_compatible(blob, usb1_off,
+			soc_usb_compat);
+	if (usb2_off < 0) {
+		printf("WARNING: could not find compatible node"
+			" %s: %s.\n", soc_usb_compat,
+			fdt_strerror(usb2_off));
+		return;
+	}
+	err = fdt_del_node(blob, usb2_off);
+	if (err < 0) {
+		printf("WARNING: could not remove %s: %s.\n",
+			soc_usb_compat, fdt_strerror(err));
+	}
+
 }
 #endif
diff --git a/board/freescale/p1_p2_rdb_pc/spl_minimal.c b/board/freescale/p1_p2_rdb_pc/spl_minimal.c
index 09019e9..0f6f81a 100644
--- a/board/freescale/p1_p2_rdb_pc/spl_minimal.c
+++ b/board/freescale/p1_p2_rdb_pc/spl_minimal.c
@@ -81,6 +81,8 @@ void board_init_f(ulong bootflag)
 	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
 #ifndef CONFIG_QE
 	ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+#elif defined(CONFIG_P1021RDB)
+	par_io_t *par_io = (par_io_t *) &(gur->qe_par_io);
 #endif
 
 	/* initialize selected port with appropriate baud rate */
@@ -102,6 +104,19 @@ void board_init_f(ulong bootflag)
 	__raw_writel(0x00200000, &pgpio->gpdat);
 	udelay(1000);
 	__raw_writel(0x00000000, &pgpio->gpdir);
+#elif defined(CONFIG_P1021RDB)
+	/* init DDR3 reset signal CE_PB8 */
+	out_be32(&par_io[1].cpdir1, 0x00004000);
+	out_be32(&par_io[1].cpodr, 0x00800000);
+	out_be32(&par_io[1].cppar1, 0x00000000);
+	/* reset DDR3 */
+	out_be32(&par_io[1].cpdat, 0x00800000);
+	udelay(1000);
+	out_be32(&par_io[1].cpdat, 0x00000000);
+	udelay(1000);
+	out_be32(&par_io[1].cpdat, 0x00800000);
+	/* disable the CE_PB8 */
+	out_be32(&par_io[1].cpdir1, 0x00000000);
 #endif
 
 #ifndef CONFIG_SYS_INIT_L2_ADDR
diff --git a/board/freescale/p1_p2_rdb_pc/tlb.c b/board/freescale/p1_p2_rdb_pc/tlb.c
index 3e4dffd..d3cdd59 100644
--- a/board/freescale/p1_p2_rdb_pc/tlb.c
+++ b/board/freescale/p1_p2_rdb_pc/tlb.c
@@ -110,7 +110,7 @@ struct fsl_e_tlb_entry tlb_table[] = {
 			MAS3_SX|MAS3_SW|MAS3_SR, 0,
 			0, 8, BOOKE_PAGESZ_1G, 1),
 
-#ifdef CONFIG_P1020MBG
+#if defined(CONFIG_P1020MBG) || defined(CONFIG_P1020RDB_PD)
 	/* 2G DDR on P1020MBG, map the second 1G */
 	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
 			CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
@@ -120,5 +120,4 @@ struct fsl_e_tlb_entry tlb_table[] = {
 #endif /* not L2 SRAM */
 #endif /* RAMBOOT/SPL */
 };
-
 int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/freescale/p1_twr/Makefile b/board/freescale/p1_twr/Makefile
new file mode 100644
index 0000000..fb29b14
--- /dev/null
+++ b/board/freescale/p1_twr/Makefile
@@ -0,0 +1,52 @@
+#
+# Copyright 2013 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB    = $(obj)lib$(BOARD).o
+
+COBJS-y        += $(BOARD).o
+COBJS-y        += ddr.o
+COBJS-y        += law.o
+COBJS-y        += tlb.o
+
+SRCS   := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS   := $(addprefix $(obj),$(COBJS-y))
+SOBJS  := $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/p1_twr/ddr.c b/board/freescale/p1_twr/ddr.c
new file mode 100644
index 0000000..f94e1ab
--- /dev/null
+++ b/board/freescale/p1_twr/ddr.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 as published by the Free Software Foundation.
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+/* Fixed sdram init -- doesn't use serial presence detect. */
+phys_size_t fixed_sdram(void)
+{
+	sys_info_t sysinfo;
+	char buf[32];
+	size_t ddr_size;
+	fsl_ddr_cfg_regs_t ddr_cfg_regs = {
+		.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+		.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+		.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+#if CONFIG_CHIP_SELECTS_PER_CTRL > 1
+		.cs[1].bnds = CONFIG_SYS_DDR_CS1_BNDS,
+		.cs[1].config = CONFIG_SYS_DDR_CS1_CONFIG,
+		.cs[1].config_2 = CONFIG_SYS_DDR_CS1_CONFIG_2,
+#endif
+		.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3,
+		.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0,
+		.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1,
+		.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2,
+		.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+		.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+		.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1,
+		.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2,
+		.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+		.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL,
+		.ddr_data_init = CONFIG_SYS_DDR_DATA_INIT,
+		.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL,
+		.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+		.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+		.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+		.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+		.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+		.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL,
+		.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+		.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+		.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+	};
+
+	get_sys_info(&sysinfo);
+	printf("Configuring DDR for %s MT/s data rate\n",
+			strmhz(buf, sysinfo.freqDDRBus));
+
+	ddr_size = CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
+
+	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE,
+				ddr_size, LAW_TRGT_IF_DDR_1) < 0) {
+		printf("ERROR setting Local Access Windows for DDR\n");
+		return 0;
+	};
+
+	return ddr_size;
+}
diff --git a/board/freescale/p1_twr/law.c b/board/freescale/p1_twr/law.c
new file mode 100644
index 0000000..a7af200
--- /dev/null
+++ b/board/freescale/p1_twr/law.c
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_64M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_SSD_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_LBC)
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/freescale/p1_twr/p1_twr.c b/board/freescale/p1_twr/p1_twr.c
new file mode 100644
index 0000000..e7036c0
--- /dev/null
+++ b/board/freescale/p1_twr/p1_twr.c
@@ -0,0 +1,297 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <hwconfig.h>
+#include <pci.h>
+#include <i2c.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_pci.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_lbc.h>
+#include <asm/mp.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <fsl_mdio.h>
+#include <tsec.h>
+#include <ioports.h>
+#include <asm/fsl_serdes.h>
+#include <netdev.h>
+
+#define SYSCLK_64	64000000
+#define SYSCLK_66	66666666
+
+unsigned long get_board_sys_clk(ulong dummy)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	par_io_t *par_io = (par_io_t *) &(gur->qe_par_io);
+	unsigned int cpdat_val = 0;
+
+	/* Set-up up pin muxing based on board switch settings */
+	cpdat_val = par_io[1].cpdat;
+
+	/* Check switch setting for SYSCLK select (PB3)  */
+	if (cpdat_val & 0x10000000)
+		return SYSCLK_64;
+	else
+		return SYSCLK_66;
+
+	return 0;
+}
+
+#ifdef CONFIG_QE
+
+#define PCA_IOPORT_I2C_ADDR		0x23
+#define PCA_IOPORT_OUTPUT_CMD		0x2
+#define PCA_IOPORT_CFG_CMD		0x6
+
+const qe_iop_conf_t qe_iop_conf_tab[] = {
+
+#ifdef CONFIG_TWR_P1025
+	/* GPIO */
+	{1,  0, 1, 0, 0},
+	{1,  18, 1, 0, 0},
+
+	/* GPIO for switch options */
+	{1,  2, 2, 0, 0}, /* PROFIBUS_MODE_SEL */
+	{1,  3, 2, 0, 0}, /* SYS_CLK_SELECT */
+	{1,  29, 2, 0, 0}, /* LOCALBUS_QE_MUXSEL */
+	{1,  30, 2, 0, 0}, /* ETH_TDM_SEL */
+
+	/* QE_MUX_MDC */
+	{1,  19, 1, 0, 1}, /* QE_MUX_MDC */
+
+	/* QE_MUX_MDIO */
+	{1,  20, 3, 0, 1}, /* QE_MUX_MDIO */
+
+	/* UCC_1_MII */
+	{0, 23, 2, 0, 2}, /* CLK12 */
+	{0, 24, 2, 0, 1}, /* CLK9 */
+	{0,  7, 1, 0, 2}, /* ENET1_TXD0_SER1_TXD0 */
+	{0,  9, 1, 0, 2}, /* ENET1_TXD1_SER1_TXD1 */
+	{0, 11, 1, 0, 2}, /* ENET1_TXD2_SER1_TXD2 */
+	{0, 12, 1, 0, 2}, /* ENET1_TXD3_SER1_TXD3 */
+	{0,  6, 2, 0, 2}, /* ENET1_RXD0_SER1_RXD0 */
+	{0, 10, 2, 0, 2}, /* ENET1_RXD1_SER1_RXD1 */
+	{0, 14, 2, 0, 2}, /* ENET1_RXD2_SER1_RXD2 */
+	{0, 15, 2, 0, 2}, /* ENET1_RXD3_SER1_RXD3 */
+	{0,  5, 1, 0, 2}, /* ENET1_TX_EN_SER1_RTS_B */
+	{0, 13, 1, 0, 2}, /* ENET1_TX_ER */
+	{0,  4, 2, 0, 2}, /* ENET1_RX_DV_SER1_CTS_B */
+	{0,  8, 2, 0, 2}, /* ENET1_RX_ER_SER1_CD_B */
+	{0, 17, 2, 0, 2}, /* ENET1_CRS */
+	{0, 16, 2, 0, 2}, /* ENET1_COL */
+
+	/* UCC_5_RMII */
+	{1, 11, 2, 0, 1}, /* CLK13 */
+	{1, 7,  1, 0, 2}, /* ENET5_TXD0_SER5_TXD0 */
+	{1, 10, 1, 0, 2}, /* ENET5_TXD1_SER5_TXD1 */
+	{1, 6, 2, 0, 2}, /* ENET5_RXD0_SER5_RXD0 */
+	{1, 9, 2, 0, 2}, /* ENET5_RXD1_SER5_RXD1 */
+	{1, 5, 1, 0, 2}, /* ENET5_TX_EN_SER5_RTS_B */
+	{1, 4, 2, 0, 2}, /* ENET5_RX_DV_SER5_CTS_B */
+	{1, 8, 2, 0, 2}, /* ENET5_RX_ER_SER5_CD_B */
+
+	/* TDMA - clock option is configured in OS based on board setting */
+	{1, 23, 2, 0, 2}, /* TDMA_TXD */
+	{1, 25, 2, 0, 2}, /* TDMA_RXD */
+	{1, 26, 1, 0, 2}, /* TDMA_SYNC */
+#endif
+
+	{0,  0, 0, 0, QE_IOP_TAB_END} /* END of table */
+};
+#endif
+
+int board_early_init_f(void)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	setbits_be32(&gur->pmuxcr,
+			(MPC85xx_PMUXCR_SDHC_CD | MPC85xx_PMUXCR_SDHC_WP));
+
+	/* SDHC_DAT[4:7] not exposed to pins (use as SPI) */
+	clrbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_SD_DATA);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u8 boot_status;
+
+	printf("Board: %s\n", CONFIG_BOARDNAME);
+
+	boot_status = ((gur->porbmsr) >> MPC85XX_PORBMSR_ROMLOC_SHIFT) & 0xf;
+	puts("rom_loc: ");
+	if (boot_status == PORBMSR_ROMLOC_NOR)
+		puts("nor flash");
+	else if (boot_status == PORBMSR_ROMLOC_SDHC)
+		puts("sd");
+	else
+		puts("unknown");
+	puts("\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+#endif
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS, /* tlb, epn, rpn */
+		MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,           /* perms, wimge */
+		0, flash_esel, BOOKE_PAGESZ_64M, 1);/* ts, esel, tsize, iprot */
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	struct fsl_pq_mdio_info mdio_info;
+	struct tsec_info_struct tsec_info[4];
+	ccsr_gur_t *gur __attribute__((unused)) =
+		(void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	int num = 0;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	if (is_serdes_configured(SGMII_TSEC2)) {
+		printf("eTSEC2 is in sgmii mode.\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+	}
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	SET_STD_TSEC_INFO(tsec_info[num], 3);
+	num++;
+#endif
+
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+
+	mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
+	mdio_info.name = DEFAULT_MII_NAME;
+
+	fsl_pq_mdio_init(bis, &mdio_info);
+
+	tsec_eth_init(bis, tsec_info, num);
+
+#if defined(CONFIG_UEC_ETH)
+	/* QE0 and QE3 need to be exposed for UCC1
+	 * and UCC5 Eth mode (in PMUXCR register).
+	 * Currently QE/LBC muxed pins assumed to be
+	 * LBC for U-Boot and PMUXCR updated by OS if required */
+
+	uec_standard_init(bis);
+#endif
+
+	return pci_eth_init(bis);
+}
+
+#if defined(CONFIG_QE)
+static void fdt_board_fixup_qe_pins(void *blob)
+{
+	int node;
+
+	if (!hwconfig("qe")) {
+		/* For QE and eLBC pins multiplexing,
+		 * When don't use QE function, remove
+		 * qe node from dt blob.
+		 */
+		node = fdt_path_offset(blob, "/qe");
+		if (node >= 0)
+			fdt_del_node(blob, node);
+	} else {
+		/* For TWR Peripheral Modules - TWR-SER2
+		 * board only can support Signal Port MII,
+		 * so delete one UEC node when use MII port.
+		 */
+		if (hwconfig("mii"))
+			node = fdt_path_offset(blob, "/qe/ucc@2400");
+		else
+			node = fdt_path_offset(blob, "/qe/ucc@2000");
+		if (node >= 0)
+			fdt_del_node(blob, node);
+	}
+
+	return;
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+	FT_FSL_PCI_SETUP;
+
+#ifdef CONFIG_QE
+	do_fixup_by_compat(blob, "fsl,qe", "status", "okay",
+			sizeof("okay"), 0);
+#endif
+#if defined(CONFIG_TWR_P1025)
+	fdt_board_fixup_qe_pins(blob);
+#endif
+	fdt_fixup_dr_usb(blob, bd);
+}
+#endif
diff --git a/board/freescale/p1_twr/tlb.c b/board/freescale/p1_twr/tlb.c
new file mode 100644
index 0000000..68e109c
--- /dev/null
+++ b/board/freescale/p1_twr/tlb.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I,
+			0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+			MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 1, BOOKE_PAGESZ_1M, 1),
+
+#ifndef CONFIG_SPL_BUILD
+	/* W**G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 2, BOOKE_PAGESZ_64M, 1),
+
+	/* W**G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SSD_BASE, CONFIG_SYS_SSD_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 5, BOOKE_PAGESZ_1M, 1),
+
+#ifdef CONFIG_PCI
+	/* *I*G* - PCI memory 1.5G */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+			MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O effective: 192K  */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+			MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 4, BOOKE_PAGESZ_256K, 1),
+#endif
+
+#endif
+
+#ifdef CONFIG_SYS_RAMBOOT
+	/* *I*G - eSDHC boot */
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 8, BOOKE_PAGESZ_1G, 1),
+#endif
+
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/freescale/p2041rdb/eth.c b/board/freescale/p2041rdb/eth.c
index fec9777..4b0d577 100644
--- a/board/freescale/p2041rdb/eth.c
+++ b/board/freescale/p2041rdb/eth.c
@@ -136,11 +136,6 @@ void board_ft_fman_fixup_port(void *fdt, char *compat, phys_addr_t addr,
 }
 #endif /* #ifdef CONFIG_FMAN_ENET */
 
-#define CPLD_LANE_A_SEL	0x1
-#define CPLD_LANE_G_SEL	0x2
-#define CPLD_LANE_C_SEL	0x4
-#define CPLD_LANE_D_SEL	0x8
-
 int board_eth_init(bd_t *bis)
 {
 #ifdef CONFIG_FMAN_ENET
@@ -148,10 +143,6 @@ int board_eth_init(bd_t *bis)
 	struct tgec_mdio_info tgec_mdio_info;
 	unsigned int i, slot;
 	int lane;
-	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
-	int srds_prtcl = (in_be32(&gur->rcwsr[4]) &
-				FSL_CORENET_RCWSR4_SRDS_PRTCL) >> 26;
-	u8 mux = CPLD_READ(serdes_mux);
 
 	printf("Initializing Fman\n");
 
@@ -181,36 +172,6 @@ int board_eth_init(bd_t *bis)
 	fm_info_set_phy_address(FM1_DTSEC2, CONFIG_SYS_FM1_DTSEC2_PHY_ADDR);
 	fm_info_set_phy_address(FM1_DTSEC3, CONFIG_SYS_FM1_DTSEC3_PHY_ADDR);
 
-	mux &= ~(CPLD_LANE_A_SEL | CPLD_LANE_C_SEL | CPLD_LANE_D_SEL);
-	switch (srds_prtcl) {
-	case 0x2:
-	case 0xf:
-		mux &= ~CPLD_LANE_G_SEL;
-		break;
-	case 0x5:
-	case 0x9:
-	case 0xa:
-	case 0x17:
-		mux |= CPLD_LANE_G_SEL;
-		break;
-	case 0x14:
-		mux = (mux & (~CPLD_LANE_G_SEL)) | CPLD_LANE_A_SEL;
-		break;
-	case 0x8:
-	case 0x16:
-	case 0x19:
-	case 0x1a:
-		mux |= CPLD_LANE_G_SEL | CPLD_LANE_C_SEL | CPLD_LANE_D_SEL;
-		break;
-	case 0x1c:
-		mux |= CPLD_LANE_G_SEL | CPLD_LANE_A_SEL;
-		break;
-	default:
-		printf("Fman:Unsupported SerDes Protocol 0x%02x\n", srds_prtcl);
-		break;
-	}
-	CPLD_WRITE(serdes_mux, mux);
-
 	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
 		int idx = i - FM1_DTSEC1;
 
diff --git a/board/freescale/p2041rdb/p2041rdb.c b/board/freescale/p2041rdb/p2041rdb.c
index d2732f5..2c6a261 100644
--- a/board/freescale/p2041rdb/p2041rdb.c
+++ b/board/freescale/p2041rdb/p2041rdb.c
@@ -44,7 +44,6 @@ int checkboard(void)
 {
 	u8 sw;
 	struct cpu_type *cpu = gd->cpu;
-	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
 	unsigned int i;
 
 	printf("Board: %sRDB, ", cpu->name);
@@ -55,20 +54,6 @@ int checkboard(void)
 	printf("vBank: %d\n", sw & 0x1);
 
 	/*
-	 * Display the RCW, so that no one gets confused as to what RCW
-	 * we're actually using for this boot.
-	 */
-	puts("Reset Configuration Word (RCW):");
-	for (i = 0; i < ARRAY_SIZE(gur->rcwsr); i++) {
-		u32 rcw = in_be32(&gur->rcwsr[i]);
-
-		if ((i % 4) == 0)
-			printf("\n       %08x:", i * 4);
-		printf(" %08x", rcw);
-	}
-	puts("\n");
-
-	/*
 	 * Display the actual SERDES reference clocks as configured by the
 	 * dip switches on the board.  Note that the SWx registers could
 	 * technically be set to force the reference clocks to match the
@@ -84,7 +69,10 @@ int checkboard(void)
 		};
 		unsigned int clock = (sw >> (2 * i)) & 3;
 
-		printf("Bank%u=%sMhz ", i+1, freq[i][clock]);
+		if ((i == 1) && (CPLD_READ(pcba_ver) >= 5))
+			printf("Bank%u=%sMhz ", i+1, freq[i-1][clock]);
+		else
+			printf("Bank%u=%sMhz ", i+1, freq[i][clock]);
 	}
 	puts("\n");
 
@@ -101,6 +89,49 @@ int board_early_init_f(void)
 	return 0;
 }
 
+#define CPLD_LANE_A_SEL	0x1
+#define CPLD_LANE_G_SEL	0x2
+#define CPLD_LANE_C_SEL	0x4
+#define CPLD_LANE_D_SEL	0x8
+
+void board_config_lanes_mux(void)
+{
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+	int srds_prtcl = (in_be32(&gur->rcwsr[4]) &
+				FSL_CORENET_RCWSR4_SRDS_PRTCL) >> 26;
+
+	u8 mux = 0;
+	switch (srds_prtcl) {
+	case 0x2:
+	case 0x5:
+	case 0x9:
+	case 0xa:
+	case 0xf:
+		break;
+	case 0x8:
+		mux |= CPLD_LANE_C_SEL | CPLD_LANE_D_SEL;
+		break;
+	case 0x14:
+		mux |= CPLD_LANE_A_SEL;
+		break;
+	case 0x17:
+		mux |= CPLD_LANE_G_SEL;
+		break;
+	case 0x16:
+	case 0x19:
+	case 0x1a:
+		mux |= CPLD_LANE_G_SEL | CPLD_LANE_C_SEL | CPLD_LANE_D_SEL;
+		break;
+	case 0x1c:
+		mux |= CPLD_LANE_G_SEL | CPLD_LANE_A_SEL;
+		break;
+	default:
+		printf("Fman:Unsupported SerDes Protocol 0x%02x\n", srds_prtcl);
+		break;
+	}
+	CPLD_WRITE(serdes_mux, mux);
+}
+
 int board_early_init_r(void)
 {
 	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
@@ -124,6 +155,7 @@ int board_early_init_r(void)
 
 	set_liodns();
 	setup_portals();
+	board_config_lanes_mux();
 
 	return 0;
 }
@@ -183,6 +215,16 @@ int misc_init_r(void)
 				"'00' is unsupported\n");
 		else
 			actual[i] = freq[i][clock];
+
+		/*
+		 * RevD(x) board has a different clock setting with RevC(x)
+		 * board, CPLD on RevD(x) board has pcba_ver = 5. RevC(x)
+		 * board has pcba_ver = 4, it can be used to distinguish
+		 * the two boards.
+		 */
+		if ((i == 1) && (CPLD_READ(pcba_ver) >= 5))
+			/* RevD(x) board bank2 frequency */
+			actual[i] = freq[i-1][clock];
 	}
 
 	for (i = 0; i < NUM_SRDS_BANKS; i++) {
diff --git a/board/freescale/t1040qds/Makefile b/board/freescale/t1040qds/Makefile
new file mode 100644
index 0000000..cb61526
--- /dev/null
+++ b/board/freescale/t1040qds/Makefile
@@ -0,0 +1,54 @@
+#
+# Copyright 2012 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-$(CONFIG_T1040QDS)+= eth_t1040qds.o
+COBJS-$(CONFIG_PCI)     += pci.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/t1040qds/ddr.c b/board/freescale/t1040qds/ddr.c
new file mode 100644
index 0000000..9983b78
--- /dev/null
+++ b/board/freescale/t1040qds/ddr.c
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 or later as published by the Free Software Foundation.
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <hwconfig.h>
+#include <asm/mmu.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 2,
+	.rank_density = 2147483648u,
+	.capacity = 4294967296u,
+	.primary_sdram_width = 64,
+	.ec_sdram_width = 8,
+	.registered_dimm = 0,
+	.mirrored_dimm = 1,
+	.n_row_addr = 15,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 2,	/* ECC */
+	.burst_lengths_bitmask = 0x0c,
+
+	.tCKmin_X_ps = 1071,
+	.caslat_X = 0x2fe << 4,	/* 5,6,7,8,9,10,11,13 */
+	.tAA_ps = 13910,
+	.tWR_ps = 15000,
+	.tRCD_ps = 13910,
+	.tRRD_ps = 6000,
+	.tRP_ps = 13910,
+	.tRAS_ps = 34000,
+	.tRC_ps = 48910,
+	.tRFC_ps = 260000,
+	.tWTR_ps = 7500,
+	.tRTP_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tFAW_ps = 35000,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "RAW timing DDR";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+	u32 cpo;
+	u32 write_data_delay;
+	u32 force_2T;
+};
+
+/*
+ * This table contains all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz|adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+	{2,  1350,    4,     7, 0x09080807, 0x07060607,   0xff,    2,  0},
+	{2,  1666,    4,     7, 0x09080806, 0x06050607,   0xff,    2,  0},
+	{2,  1900,    3,     7, 0x08070706, 0x06040507,   0xff,    2,  0},
+	{1,  1350,    4,     7, 0x09080807, 0x07060607,   0xff,    2,  0},
+	{1,  1700,    4,     7, 0x09080806, 0x06050607,   0xff,    2,  0},
+	{1,  1900,    3,     7, 0x08070706, 0x06040507,   0xff,    2,  0},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 2) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = udimms[0];
+
+
+	/* Get clk_adjust, cpo, write_data_delay,2T, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->cpo_override = pbsp->cpo;
+				popts->write_data_delay =
+					pbsp->write_data_delay;
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				popts->twoT_en = pbsp->force_2T;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found "
+			"for data rate %lu MT/s\n"
+			"Trying to use the highest speed (%u) parameters\n",
+			ddr_freq, pbsp_highest->datarate_mhz_high);
+		popts->cpo_override = pbsp_highest->cpo;
+		popts->write_data_delay = pbsp_highest->write_data_delay;
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->twoT_en = pbsp_highest->force_2T;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+	puts("Initializing....using SPD\n");
+
+	dram_size = fsl_ddr_sdram();
+
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+
+	puts("    DDR: ");
+	return dram_size;
+}
diff --git a/board/freescale/t1040qds/eth_t1040qds.c b/board/freescale/t1040qds/eth_t1040qds.c
new file mode 100644
index 0000000..3e1e24a
--- /dev/null
+++ b/board/freescale/t1040qds/eth_t1040qds.c
@@ -0,0 +1,330 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Author: Sandeep Kumar Singh <sandeep@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* This file is based on board/freescale/b4860qds/eth_b4860qds.c */
+
+/*
+ * This file handles the board muxing between the Fman Ethernet MACs and
+ * the RGMII/SGMII/XGMII PHYs on a Freescale B4860 "Centaur". The SGMII
+ * PHYs are the two on-board 1Gb ports. There are no RGMII PHY on board.
+ * The 10Gb XGMII PHY is provided via the XAUI riser card. There is only
+ * one Fman device on B4860. The SERDES configuration is used to determine
+ * where the SGMII and XAUI cards exist, and also which Fman MACs are routed
+ * to which PHYs. So for a given Fman MAC, there is one and only PHY it
+ * connects to. MACs cannot be routed to PHYs dynamically. This configuration
+ * is done at boot time by reading SERDES protocol from RCW.
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/fsl_serdes.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+#include <fdt_support.h>
+#include <asm/fsl_dtsec.h>
+
+#include "../common/ngpixis.h"
+#include "../common/fman.h"
+#include "../common/qixis.h"
+#include "t1040qds_qixis.h"
+
+#define EMI_NONE       0xFFFFFFFF
+
+#ifdef CONFIG_FMAN_ENET
+
+/*
+ * Mapping of all 16 SERDES lanes to board slots. A value n(>0) will mean that
+ * lane at index is mapped to slot number n. A value of '0' will mean
+ * that the mapping must be determined dynamically, or that the lane maps to
+ * something other than a board slot
+ */
+static u8 lane_to_slot[] = {
+	0, 0, 0, 0,
+	0, 0, 0, 0,
+	1, 1, 1, 1,
+	0, 0, 0, 0
+};
+
+/*
+ * This function initializes the lane_to_slot[] array. It reads RCW to check
+ * if Serdes2{E,F,G,H} is configured as slot 2 or as SFP and initializes
+ * lane_to_slot[] accordingly
+ */
+static void initialize_lane_to_slot(void)
+{
+	unsigned int  serdes2_prtcl;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	serdes2_prtcl = in_be32(&gur->rcwsr[4]) &
+		FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+	serdes2_prtcl >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+	debug("Initializing lane to slot: Serdes2 protocol: %x\n",
+			serdes2_prtcl);
+
+	switch (serdes2_prtcl) {
+	case 0x18:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: SGMII
+		 * Lanes: E,F: Aur
+		 * Lanes: G,H: SRIO
+		 */
+	case 0x91:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B: SGMII
+		 * Lanes: C,D: SRIO2
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0x93:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: SGMII
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0x98:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: XAUI2
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0x9a:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B: PCI
+		 * Lanes: C,D: SGMII
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0x9e:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: PCI
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+	case 0xb2:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B,C,D: PCI
+		 * Lanes: E,F: SGMII 3&4
+		 * Lanes: G,H: XFI
+		 */
+	case 0xc2:
+		/*
+		 * Configuration:
+		 * SERDES: 2
+		 * Lanes: A,B: SGMII
+		 * Lanes: C,D: SRIO2
+		 * Lanes: E,F,G,H: XAUI2
+		 */
+		lane_to_slot[12] = 2;
+		lane_to_slot[13] = lane_to_slot[12];
+		lane_to_slot[14] = lane_to_slot[12];
+		lane_to_slot[15] = lane_to_slot[12];
+		break;
+
+	default:
+		printf("Fman: Unsupported SerDes2 Protocol 0x%02x\n",
+				serdes2_prtcl);
+			break;
+	}
+	return;
+}
+
+#endif /* #ifdef CONFIG_FMAN_ENET */
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FMAN_ENET
+	struct memac_mdio_info memac_mdio_info;
+	struct memac_mdio_info tg_memac_mdio_info;
+	unsigned int i;
+	unsigned int  serdes1_prtcl, serdes2_prtcl;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	serdes1_prtcl = in_be32(&gur->rcwsr[4]) &
+		FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+	if (!serdes1_prtcl) {
+		printf("SERDES1 is not enabled\n");
+		return 0;
+	}
+	serdes1_prtcl >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+	debug("Using SERDES1 Protocol: 0x%x:\n", serdes1_prtcl);
+
+	serdes2_prtcl = in_be32(&gur->rcwsr[4]) &
+		FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+	if (!serdes2_prtcl) {
+		printf("SERDES2 is not enabled\n");
+		return 0;
+	}
+	serdes2_prtcl >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+	debug("Using SERDES2 Protocol: 0x%x:\n", serdes2_prtcl);
+
+	printf("Initializing Fman\n");
+
+	initialize_lane_to_slot();
+
+	memac_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+	memac_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the real 1G MDIO bus */
+	fm_memac_mdio_init(bis, &memac_mdio_info);
+
+	tg_memac_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tg_memac_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the real 10G MDIO bus */
+	fm_memac_mdio_init(bis, &tg_memac_mdio_info);
+
+	/*
+	 * Program the two on board DTSEC PHY addresses assuming that they are
+	 * all SGMII. RGMII is not supported on this board. Setting SGMII 5 and
+	 * 6 to on board SGMII phys
+	 */
+	fm_info_set_phy_address(FM1_DTSEC5, CONFIG_SYS_FM1_DTSEC5_PHY_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC6, CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+
+	switch (serdes1_prtcl) {
+	case 0x2a:
+		/* Serdes 1: A-B SGMII, Configuring DTSEC 5 and 6 */
+		debug("Setting phy addresses for FM1_DTSEC5: %x and"
+			"FM1_DTSEC6: %x\n", CONFIG_SYS_FM1_DTSEC5_PHY_ADDR,
+			CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+		/* Fixing Serdes clock by programming FPGA register */
+		QIXIS_WRITE(brdcfg[4], QIXIS_SRDS1CLK_125);
+		fm_info_set_phy_address(FM1_DTSEC5,
+				CONFIG_SYS_FM1_DTSEC5_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC6,
+				CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+		break;
+#ifdef CONFIG_PPC_B4420
+	case 0x18:
+		/* Serdes 1: A-D SGMII, Configuring on board dual SGMII Phy */
+		debug("Setting phy addresses for FM1_DTSEC3: %x and"
+			"FM1_DTSEC4: %x\n", CONFIG_SYS_FM1_DTSEC5_PHY_ADDR,
+			CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+		/* Fixing Serdes clock by programming FPGA register */
+		QIXIS_WRITE(brdcfg[4], QIXIS_SRDS1CLK_125);
+		fm_info_set_phy_address(FM1_DTSEC3,
+				CONFIG_SYS_FM1_DTSEC5_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC4,
+				CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+		break;
+#endif
+	default:
+		printf("Fman:  Unsupported SerDes1 Protocol 0x%02x\n",
+				serdes1_prtcl);
+		break;
+	}
+	switch (serdes2_prtcl) {
+	case 0x18:
+		debug("Setting phy addresses on SGMII Riser card for"
+				"FM1_DTSEC1: %x\n",
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC1,
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC2,
+				CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3,
+				CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC4,
+				CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR);
+		break;
+	case 0x49:
+		debug("Setting phy addresses on SGMII Riser card for"
+				"FM1_DTSEC1: %x\n",
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC1,
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC2,
+				CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3,
+				CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR);
+		break;
+	case 0xb2:
+		debug("Setting phy addresses on SGMII Riser card for"
+				"FM1_DTSEC1: %x\n",
+				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3,
+				CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC4,
+				CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR);
+		break;
+	default:
+		printf("Fman:  Unsupported SerDes2 Protocol 0x%02x\n",
+				serdes2_prtcl);
+		break;
+	}
+
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+		int idx = i - FM1_DTSEC1;
+
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_SGMII:
+			fm_info_set_mdio(i,
+				miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+			break;
+		case PHY_INTERFACE_MODE_NONE:
+			fm_info_set_phy_address(i, 0);
+			break;
+		default:
+			printf("Fman1: DTSEC%u set to unknown interface %i\n",
+					idx + 1, fm_info_get_enet_if(i));
+			fm_info_set_phy_address(i, 0);
+			break;
+		}
+	}
+
+	cpu_eth_init(bis);
+#endif
+
+	return pci_eth_init(bis);
+}
+
+/*
+ * tbd:Fixup function not doing any fixup right now.
+ */
+
+void fdt_fixup_board_enet(void *fdt)
+{
+	int i;
+	char alias[32];
+
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_NONE:
+			sprintf(alias, "ethernet%u", i);
+			fdt_status_disabled_by_alias(fdt, alias);
+			break;
+		default:
+			break;
+		}
+	}
+}
diff --git a/board/freescale/t1040qds/law.c b/board/freescale/t1040qds/law.c
new file mode 100644
index 0000000..d46f055
--- /dev/null
+++ b/board/freescale/t1040qds/law.c
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_IFC),
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_BMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_BMAN),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
+#endif
+	SET_LAW(QIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_4M, LAW_TRGT_IF_DCSR),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/freescale/t1040qds/pci.c b/board/freescale/t1040qds/pci.c
new file mode 100644
index 0000000..b130d13
--- /dev/null
+++ b/board/freescale/t1040qds/pci.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <asm/fsl_serdes.h>
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void pci_of_setup(void *blob, bd_t *bd)
+{
+	FT_FSL_PCI_SETUP;
+}
diff --git a/board/freescale/t1040qds/t1040qds.c b/board/freescale/t1040qds/t1040qds.c
new file mode 100644
index 0000000..6ceaafc
--- /dev/null
+++ b/board/freescale/t1040qds/t1040qds.c
@@ -0,0 +1,274 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <fm_eth.h>
+
+#include "../common/qixis.h"
+#include "t1040qds.h"
+#include "t1040qds_qixis.h"
+
+#define CLK_MUX_SEL_MASK	0x4
+#define ETH_PHY_CLK_OUT		0x4
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	char buf[64];
+	u8 sw;
+	struct cpu_type *cpu = gd->cpu;
+	static const char *const freq[] = {"100", "125", "156.25", "161.13",
+						"122.88", "122.88", "122.88"};
+	int clock;
+
+	printf("Board: %sQDS, ", cpu->name);
+	printf("Sys ID: 0x%02x, Sys Ver: 0x%02x, ",
+		QIXIS_READ(id), QIXIS_READ(arch));
+
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	if (sw < 0x8)
+		printf("vBank: %d\n", sw);
+	else if (sw >= 0x8 && sw <= 0xE)
+		puts("NAND\n");
+	else
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+
+	printf("FPGA: v%d (%s), build %d",
+		(int)QIXIS_READ(scver), qixis_read_tag(buf),
+		(int)qixis_read_minor());
+	/* the timestamp string contains "\n" at the end */
+	printf(" on %s", qixis_read_time(buf));
+
+	/*
+	 * Display the actual SERDES reference clocks as configured by the
+	 * dip switches on the board.  Note that the SWx registers could
+	 * technically be set to force the reference clocks to match the
+	 * values that the SERDES expects (or vice versa).  For now, however,
+	 * we just display both values and hope the user notices when they
+	 * don't match.
+	 */
+	puts("SERDES Reference Clocks: ");
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = (sw >> 5) & 7;
+	printf("Bank1=%sMHz ", freq[clock]);
+	sw = QIXIS_READ(brdcfg[4]);
+	clock = (sw >> 6) & 3;
+	printf("Bank2=%sMHz\n", freq[clock]);
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash + promjet */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_256M, 1);
+
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch ((sysclk_conf & 0x0C) >> 2) {
+	case QIXIS_CLK_100:
+		return 100000000;
+	case QIXIS_CLK_125:
+		return 125000000;
+	case QIXIS_CLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (ddrclk_conf & 0x03) {
+	case QIXIS_CLK_100:
+		return 100000000;
+	case QIXIS_CLK_125:
+		return 125000000;
+	case QIXIS_CLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+static int serdes_refclock(u8 sw, u8 sdclk)
+{
+	unsigned int clock;
+	u32 ret = -1;
+	u8 brdcfg4;
+
+	if (sdclk == 1) {
+		brdcfg4 = QIXIS_READ(brdcfg[4]);
+		if ((brdcfg4 & CLK_MUX_SEL_MASK) == ETH_PHY_CLK_OUT)
+			return SRDS_PLLCR0_RFCK_SEL_125;
+		else
+			clock = (sw >> 5) & 7;
+	} else
+		clock = (sw >> 6) & 3;
+
+	switch (clock) {
+	case 0:
+		ret = SRDS_PLLCR0_RFCK_SEL_100;
+		break;
+	case 1:
+		ret = SRDS_PLLCR0_RFCK_SEL_125;
+		break;
+	case 2:
+		ret = SRDS_PLLCR0_RFCK_SEL_156_25;
+		break;
+	case 3:
+		ret = SRDS_PLLCR0_RFCK_SEL_161_13;
+		break;
+	case 4:
+	case 5:
+	case 6:
+		ret = SRDS_PLLCR0_RFCK_SEL_122_88;
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+static const char *serdes_clock_to_string(u32 clock)
+{
+	switch (clock) {
+	case SRDS_PLLCR0_RFCK_SEL_100:
+		return "100";
+	case SRDS_PLLCR0_RFCK_SEL_125:
+		return "125";
+	case SRDS_PLLCR0_RFCK_SEL_156_25:
+		return "156.25";
+	case SRDS_PLLCR0_RFCK_SEL_161_13:
+		return "161.13";
+	default:
+		return "122.88";
+	}
+}
+
+#define NUM_SRDS_BANKS	2
+
+int misc_init_r(void)
+{
+	u8 sw;
+	serdes_corenet_t *srds_regs =
+		(void *)CONFIG_SYS_FSL_CORENET_SERDES_ADDR;
+	u32 actual[NUM_SRDS_BANKS];
+	unsigned int i;
+	int clock;
+
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = serdes_refclock(sw, 1);
+	if (clock >= 0)
+		actual[0] = clock;
+	else
+		printf("Warning: SDREFCLK1 switch setting is unsupported\n");
+
+	sw = QIXIS_READ(brdcfg[4]);
+	clock = serdes_refclock(sw, 2);
+	if (clock >= 0)
+		actual[1] = clock;
+	else
+		printf("Warning: SDREFCLK2 switch setting unsupported\n");
+
+	for (i = 0; i < NUM_SRDS_BANKS; i++) {
+		u32 pllcr0 = srds_regs->bank[i].pllcr0;
+		u32 expected = pllcr0 & SRDS_PLLCR0_RFCK_SEL_MASK;
+		if (expected != actual[i]) {
+			printf("Warning: SERDES bank %u expects reference clock"
+			       " %sMHz, but actual is %sMHz\n", i + 1,
+			       serdes_clock_to_string(expected),
+			       serdes_clock_to_string(actual[i]));
+		}
+	}
+
+	return 0;
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+	fdt_fixup_dr_usb(blob, bd);
+#endif
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+	fdt_fixup_board_enet(blob);
+#endif
+}
diff --git a/board/freescale/t1040qds/t1040qds.h b/board/freescale/t1040qds/t1040qds.h
new file mode 100644
index 0000000..9f43b25
--- /dev/null
+++ b/board/freescale/t1040qds/t1040qds.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __T1040_QDS_H__
+#define __T1040_QDS_H__
+
+void fdt_fixup_board_enet(void *blob);
+void pci_of_setup(void *blob, bd_t *bd);
+
+#endif
diff --git a/board/freescale/t1040qds/t1040qds_qixis.h b/board/freescale/t1040qds/t1040qds_qixis.h
new file mode 100644
index 0000000..9d6e21a
--- /dev/null
+++ b/board/freescale/t1040qds/t1040qds_qixis.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __T1040QDS_QIXIS_H__
+#define __T1040QDS_QIXIS_H__
+
+/* Definitions of QIXIS Registers for T1040QDS */
+
+/* BRDCFG4[4:7]] select EC1 and EC2 as a pair */
+#define BRDCFG4_EMISEL_MASK		0xE0
+#define BRDCFG4_EMISEL_SHIFT		5
+
+/* CLK */
+#define QIXIS_CLK_66		0x0
+#define QIXIS_CLK_100		0x1
+#define QIXIS_CLK_125		0x2
+#define QIXIS_CLK_133		0x3
+
+#define QIXIS_SRDS1CLK_122		0x5a
+#define QIXIS_SRDS1CLK_125		0x5e
+#endif
diff --git a/board/freescale/t1040qds/tlb.c b/board/freescale/t1040qds/tlb.c
new file mode 100644
index 0000000..dcffe08
--- /dev/null
+++ b/board/freescale/t1040qds/tlb.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L3_ADDR)
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 1M SRAM, the address of the
+	 * SRAM is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L3_ADDR, CONFIG_SYS_INIT_L3_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_1M, 1),
+#else
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_16M, 1),
+
+	/* *I*G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_64K, 1),
+
+	/* Bman/Qman */
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE, CONFIG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 5, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_BMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE, CONFIG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 7, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_QMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 8, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_DCSRBAR, CONFIG_SYS_DCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 9, BOOKE_PAGESZ_4M, 1),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE
+	/*
+	 * *I*G - NAND
+	 * entry 14 and 15 has been used hard coded, they will be disabled
+	 * in cpu_init_f, so we use entry 16 for nand.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 10, BOOKE_PAGESZ_1M, 1),
+#endif
+	SET_TLB_ENTRY(1, QIXIS_BASE, QIXIS_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 11, BOOKE_PAGESZ_4K, 1),
+
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/freescale/t4qds/Makefile b/board/freescale/t4qds/Makefile
index ff09ffa..1923a47 100644
--- a/board/freescale/t4qds/Makefile
+++ b/board/freescale/t4qds/Makefile
@@ -24,7 +24,8 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(BOARD).o
 
-COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_T4240QDS) += t4240qds.o
+COBJS-$(CONFIG_T4240EMU) += t4240emu.o
 COBJS-y	+= ddr.o
 COBJS-$(CONFIG_T4240QDS)+= eth.o
 COBJS-$(CONFIG_PCI)	+= pci.o
diff --git a/board/freescale/t4qds/ddr.c b/board/freescale/t4qds/ddr.c
index 692616a..62ae94d 100644
--- a/board/freescale/t4qds/ddr.c
+++ b/board/freescale/t4qds/ddr.c
@@ -13,77 +13,10 @@
 #include <asm/fsl_ddr_sdram.h>
 #include <asm/fsl_ddr_dimm_params.h>
 #include <asm/fsl_law.h>
+#include "ddr.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
-struct board_specific_parameters {
-	u32 n_ranks;
-	u32 datarate_mhz_high;
-	u32 clk_adjust;
-	u32 wrlvl_start;
-	u32 wrlvl_ctl_2;
-	u32 wrlvl_ctl_3;
-	u32 cpo;
-	u32 write_data_delay;
-	u32 force_2T;
-};
-
-/*
- * This table contains all valid speeds we want to override with board
- * specific parameters. datarate_mhz_high values need to be in ascending order
- * for each n_ranks group.
- */
-static const struct board_specific_parameters udimm0[] = {
-	/*
-	 * memory controller 0
-	 *   num|  hi|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
-	 * ranks| mhz|adjst| start |   ctl2    |  ctl3  |      |delay |
-	 */
-	{2,  1350,    5,     7, 0x0809090b, 0x0c0c0d09,   0xff,    2,  0},
-	{2,  1666,    5,     8, 0x080a0a0c, 0x0c0d0e0a,   0xff,    2,  0},
-	{2,  2140,    5,     8, 0x090a0b0c, 0x0e0f100b,   0xff,    2,  0},
-	{1,  1350,    5,     8, 0x0809090b, 0x0c0c0d0a,   0xff,    2,  0},
-	{1,  1700,    5,     8, 0x080a0a0c, 0x0c0d0e0a,   0xff,    2,  0},
-	{1,  1900,    4,     8, 0x080a0a0c, 0x0e0e0f0a,   0xff,    2,  0},
-	{1,  2140,    4,     8, 0x090a0b0c, 0x0e0f100b,   0xff,    2,  0},
-	{}
-};
-
-/*
- * The three slots have slightly different timing. The center values are good
- * for all slots. We use identical speed tables for them. In future use, if
- * DIMMs require separated tables, make more entries as needed.
- */
-static const struct board_specific_parameters *udimms[] = {
-	udimm0,
-};
-
-static const struct board_specific_parameters rdimm0[] = {
-	/*
-	 * memory controller 0
-	 *   num|  hi|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
-	 * ranks| mhz|adjst| start |   ctl2    |  ctl3  |      |delay |
-	 */
-	{4,  1350,    5,     9, 0x08070605, 0x07080805,   0xff,    2,  0},
-	{4,  1666,    5,     8, 0x08070605, 0x07080805,   0xff,    2,  0},
-	{4,  2140,    5,     8, 0x08070605, 0x07081805,   0xff,    2,  0},
-	{2,  1350,    5,     7, 0x0809090b, 0x0c0c0d09,   0xff,    2,  0},
-	{2,  1666,    5,     8, 0x080a0a0c, 0x0c0d0e0a,   0xff,    2,  0},
-	{2,  2140,    5,     8, 0x090a0b0c, 0x0e0f100b,   0xff,    2,  0},
-	{1,  1350,    5,     8, 0x0809090b, 0x0c0c0d0a,   0xff,    2,  0},
-	{1,  1700,    5,     8, 0x080a0a0c, 0x0c0d0e0a,   0xff,    2,  0},
-	{1,  1900,    4,     8, 0x080a0a0c, 0x0e0e0f0a,   0xff,    2,  0},
-	{1,  2140,    4,     8, 0x090a0b0c, 0x0e0f100b,   0xff,    2,  0},
-	{}
-};
-
-/*
- * The three slots have slightly different timing. See comments above.
- */
-static const struct board_specific_parameters *rdimms[] = {
-	rdimm0,
-};
-
 void fsl_ddr_board_options(memctl_options_t *popts,
 				dimm_params_t *pdimm,
 				unsigned int ctrl_num)
@@ -113,7 +46,8 @@ void fsl_ddr_board_options(memctl_options_t *popts,
 	 */
 	ddr_freq = get_ddr_freq(0) / 1000000;
 	while (pbsp->datarate_mhz_high) {
-		if (pbsp->n_ranks == pdimm->n_ranks) {
+		if (pbsp->n_ranks == pdimm->n_ranks &&
+		   (pdimm->rank_density >> 30) >= pbsp->rank_GB) {
 			if (ddr_freq <= pbsp->datarate_mhz_high) {
 				popts->cpo_override = pbsp->cpo;
 				popts->write_data_delay =
@@ -146,6 +80,13 @@ void fsl_ddr_board_options(memctl_options_t *popts,
 		panic("DIMM is not supported by this board");
 	}
 found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_GB %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, "
+		"wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_GB,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+
 	/*
 	 * Factors to consider for half-strength driver enable:
 	 *	- number of DIMMs installed
diff --git a/board/freescale/t4qds/ddr.h b/board/freescale/t4qds/ddr.h
new file mode 100644
index 0000000..18252fc
--- /dev/null
+++ b/board/freescale/t4qds/ddr.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_GB;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+	u32 cpo;
+	u32 write_data_delay;
+	u32 force_2T;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+
+#ifdef CONFIG_T4240QDS
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+	{2,  1350, 4, 4,     8, 0x0809090b, 0x0c0c0d0a,   0xff,    2,  0},
+	{2,  1350, 0, 5,     7, 0x0709090b, 0x0c0c0d09,   0xff,    2,  0},
+	{2,  1666, 4, 4,     8, 0x080a0a0d, 0x0d10100b,   0xff,    2,  0},
+	{2,  1666, 0, 5,     7, 0x080a0a0c, 0x0d0d0e0a,   0xff,    2,  0},
+	{2,  1900, 0, 4,     8, 0x090a0b0e, 0x0f11120c,   0xff,    2,  0},
+	{2,  2140, 0, 4,     8, 0x090a0b0e, 0x0f11120c,   0xff,    2,  0},
+	{1,  1350, 0, 5,     8, 0x0809090b, 0x0c0c0d0a,   0xff,    2,  0},
+	{1,  1700, 0, 5,     8, 0x080a0a0c, 0x0c0d0e0a,   0xff,    2,  0},
+	{1,  1900, 0, 4,     8, 0x080a0a0c, 0x0e0e0f0a,   0xff,    2,  0},
+	{1,  2140, 0, 4,     8, 0x090a0b0c, 0x0e0f100b,   0xff,    2,  0},
+	{}
+};
+
+static const struct board_specific_parameters rdimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+	{4,  1350, 0, 5,     9, 0x08070605, 0x06070806,   0xff,    2,  0},
+	{4,  1666, 0, 5,    11, 0x0a080706, 0x07090906,   0xff,    2,  0},
+	{4,  2140, 0, 5,    12, 0x0b090807, 0x080a0b07,   0xff,    2,  0},
+	{2,  1350, 0, 5,     9, 0x08070605, 0x06070806,   0xff,    2,  0},
+	{2,  1666, 0, 5,    11, 0x0a090806, 0x08090a06,   0xff,    2,  0},
+	{2,  2140, 0, 5,    12, 0x0b090807, 0x080a0b07,   0xff,    2,  0},
+	{1,  1350, 0, 5,     9, 0x08070605, 0x06070806,   0xff,    2,  0},
+	{1,  1666, 0, 5,    11, 0x0a090806, 0x08090a06,   0xff,    2,  0},
+	{1,  2140, 0, 4,    12, 0x0b090807, 0x080a0b07,   0xff,    2,  0},
+	{}
+};
+
+#else	/* CONFIG_T4240EMU */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+	{2,  2140, 0, 4,     8, 0x0, 0x0,   0xff,    2,  0},
+	{1,  2140, 0, 4,     8, 0x0, 0x0,   0xff,    2,  0},
+	{}
+};
+
+static const struct board_specific_parameters rdimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+	{4,  2140, 0, 5,     8, 0x0, 0x0,   0xff,    2,  0},
+	{2,  2140, 0, 5,     8, 0x0, 0x0,   0xff,    2,  0},
+	{1,  2140, 0, 4,     8, 0x0, 0x0,   0xff,    2,  0},
+	{}
+};
+#endif	/* CONFIG_T4240EMU */
+
+/*
+ * The three slots have slightly different timing. The center values are good
+ * for all slots. We use identical speed tables for them. In future use, if
+ * DIMMs require separated tables, make more entries as needed.
+ */
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+/*
+ * The three slots have slightly different timing. See comments above.
+ */
+static const struct board_specific_parameters *rdimms[] = {
+	rdimm0,
+};
+
+
+#endif
diff --git a/board/freescale/t4qds/eth.c b/board/freescale/t4qds/eth.c
index a49c7d4..316f7dc 100644
--- a/board/freescale/t4qds/eth.c
+++ b/board/freescale/t4qds/eth.c
@@ -52,7 +52,7 @@
 #define EMI1_SLOT4	4
 #define EMI1_SLOT5	5
 #define EMI1_SLOT7	7
-#define EMI2		8 /* tmp, FIXME */
+#define EMI2		8
 /* Slot6 and Slot8 do not have EMI connections */
 
 static int mdio_mux[NUM_FM_PORTS];
@@ -71,6 +71,14 @@ static const char *mdio_names[] = {
 
 static u8 lane_to_slot_fsm1[] = {1, 1, 1, 1, 2, 2, 2, 2};
 static u8 lane_to_slot_fsm2[] = {3, 3, 3, 3, 4, 4, 4, 4};
+static u8 slot_qsgmii_phyaddr[5][4] = {
+	{0, 0, 0, 0},/* not used, to make index match slot No. */
+	{0, 1, 2, 3},
+	{4, 5, 6, 7},
+	{8, 9, 0xa, 0xb},
+	{0xc, 0xd, 0xe, 0xf},
+};
+static u8 qsgmiiphy_fix[NUM_FM_PORTS] = {0};
 
 static const char *t4240qds_mdio_name_for_muxval(u8 muxval)
 {
@@ -180,21 +188,228 @@ static int t4240qds_mdio_init(char *realbusname, u8 muxval)
 void board_ft_fman_fixup_port(void *blob, char * prop, phys_addr_t pa,
 				enum fm_port port, int offset)
 {
-	if (mdio_mux[port] == EMI1_RGMII)
-		fdt_set_phy_handle(blob, prop, pa, "phy_rgmii");
-
-	/* TODO: will do with dts */
+	if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_SGMII) {
+		switch (port) {
+		case FM1_DTSEC1:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy21");
+			break;
+		case FM1_DTSEC2:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy22");
+			break;
+		case FM1_DTSEC3:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy23");
+			break;
+		case FM1_DTSEC4:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy24");
+			break;
+		case FM1_DTSEC6:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy12");
+			break;
+		case FM1_DTSEC9:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy14");
+			else
+				fdt_set_phy_handle(blob, prop, pa,
+						"phy_sgmii4");
+			break;
+		case FM1_DTSEC10:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy13");
+			else
+				fdt_set_phy_handle(blob, prop, pa,
+						"phy_sgmii3");
+			break;
+		case FM2_DTSEC1:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy41");
+			break;
+		case FM2_DTSEC2:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy42");
+			break;
+		case FM2_DTSEC3:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy43");
+			break;
+		case FM2_DTSEC4:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy44");
+			break;
+		case FM2_DTSEC6:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy32");
+			break;
+		case FM2_DTSEC9:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy34");
+			else
+				fdt_set_phy_handle(blob, prop, pa,
+						"phy_sgmii12");
+			break;
+		case FM2_DTSEC10:
+			if (qsgmiiphy_fix[port])
+				fdt_set_phy_handle(blob, prop, pa,
+						"sgmii_phy33");
+			else
+				fdt_set_phy_handle(blob, prop, pa,
+						"phy_sgmii11");
+			break;
+		default:
+			break;
+		}
+	}
 }
 
 void fdt_fixup_board_enet(void *fdt)
 {
-	/* TODO: will do with dts */
+	int i;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 prtcl2 = in_be32(&gur->rcwsr[4]) & FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+
+	prtcl2 >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+	for (i = FM1_DTSEC1; i < NUM_FM_PORTS; i++) {
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_SGMII:
+			switch (mdio_mux[i]) {
+			case EMI1_SLOT1:
+				fdt_status_okay_by_alias(fdt, "emi1_slot1");
+				break;
+			case EMI1_SLOT2:
+				fdt_status_okay_by_alias(fdt, "emi1_slot2");
+				break;
+			case EMI1_SLOT3:
+				fdt_status_okay_by_alias(fdt, "emi1_slot3");
+				break;
+			case EMI1_SLOT4:
+				fdt_status_okay_by_alias(fdt, "emi1_slot4");
+				break;
+			default:
+				break;
+			}
+			break;
+		case PHY_INTERFACE_MODE_XGMII:
+			/* check if it's XFI interface for 10g */
+			if ((prtcl2 == 56) || (prtcl2 == 57)) {
+				fdt_status_okay_by_alias(fdt, "emi2_xfislot3");
+				break;
+			}
+			switch (i) {
+			case FM1_10GEC1:
+				fdt_status_okay_by_alias(fdt, "emi2_xauislot1");
+				break;
+			case FM1_10GEC2:
+				fdt_status_okay_by_alias(fdt, "emi2_xauislot2");
+				break;
+			case FM2_10GEC1:
+				fdt_status_okay_by_alias(fdt, "emi2_xauislot3");
+				break;
+			case FM2_10GEC2:
+				fdt_status_okay_by_alias(fdt, "emi2_xauislot4");
+				break;
+			default:
+				break;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static void initialize_qsgmiiphy_fix(void)
+{
+	int i;
+	unsigned short reg;
+
+	for (i = 1; i <= 4; i++) {
+		/*
+		 * Try to read if a SGMII card is used, we do it slot by slot.
+		 * if a SGMII PHY address is valid on a slot, then we mark
+		 * all ports on the slot, then fix the PHY address for the
+		 * marked port when doing dtb fixup.
+		 */
+		if (miiphy_read(mdio_names[i],
+			SGMII_CARD_PORT1_PHY_ADDR, MII_PHYSID2, &reg) != 0) {
+			debug("Slot%d PHY ID register 2 read failed\n", i);
+			continue;
+		}
+
+		debug("Slot%d MII_PHYSID2 @ 0x1c= 0x%04x\n", i, reg);
+
+		if (reg == 0xFFFF) {
+			/* No physical device present at this address */
+			continue;
+		}
+
+		switch (i) {
+		case 1:
+			qsgmiiphy_fix[FM1_DTSEC5] = 1;
+			qsgmiiphy_fix[FM1_DTSEC6] = 1;
+			qsgmiiphy_fix[FM1_DTSEC9] = 1;
+			qsgmiiphy_fix[FM1_DTSEC10] = 1;
+			slot_qsgmii_phyaddr[1][0] =  SGMII_CARD_PORT1_PHY_ADDR;
+			slot_qsgmii_phyaddr[1][1] =  SGMII_CARD_PORT2_PHY_ADDR;
+			slot_qsgmii_phyaddr[1][2] =  SGMII_CARD_PORT3_PHY_ADDR;
+			slot_qsgmii_phyaddr[1][3] =  SGMII_CARD_PORT4_PHY_ADDR;
+			break;
+		case 2:
+			qsgmiiphy_fix[FM1_DTSEC1] = 1;
+			qsgmiiphy_fix[FM1_DTSEC2] = 1;
+			qsgmiiphy_fix[FM1_DTSEC3] = 1;
+			qsgmiiphy_fix[FM1_DTSEC4] = 1;
+			slot_qsgmii_phyaddr[2][0] =  SGMII_CARD_PORT1_PHY_ADDR;
+			slot_qsgmii_phyaddr[2][1] =  SGMII_CARD_PORT2_PHY_ADDR;
+			slot_qsgmii_phyaddr[2][2] =  SGMII_CARD_PORT3_PHY_ADDR;
+			slot_qsgmii_phyaddr[2][3] =  SGMII_CARD_PORT4_PHY_ADDR;
+			break;
+		case 3:
+			qsgmiiphy_fix[FM2_DTSEC5] = 1;
+			qsgmiiphy_fix[FM2_DTSEC6] = 1;
+			qsgmiiphy_fix[FM2_DTSEC9] = 1;
+			qsgmiiphy_fix[FM2_DTSEC10] = 1;
+			slot_qsgmii_phyaddr[3][0] =  SGMII_CARD_PORT1_PHY_ADDR;
+			slot_qsgmii_phyaddr[3][1] =  SGMII_CARD_PORT2_PHY_ADDR;
+			slot_qsgmii_phyaddr[3][2] =  SGMII_CARD_PORT3_PHY_ADDR;
+			slot_qsgmii_phyaddr[3][3] =  SGMII_CARD_PORT4_PHY_ADDR;
+			break;
+		case 4:
+			qsgmiiphy_fix[FM2_DTSEC1] = 1;
+			qsgmiiphy_fix[FM2_DTSEC2] = 1;
+			qsgmiiphy_fix[FM2_DTSEC3] = 1;
+			qsgmiiphy_fix[FM2_DTSEC4] = 1;
+			slot_qsgmii_phyaddr[4][0] =  SGMII_CARD_PORT1_PHY_ADDR;
+			slot_qsgmii_phyaddr[4][1] =  SGMII_CARD_PORT2_PHY_ADDR;
+			slot_qsgmii_phyaddr[4][2] =  SGMII_CARD_PORT3_PHY_ADDR;
+			slot_qsgmii_phyaddr[4][3] =  SGMII_CARD_PORT4_PHY_ADDR;
+			break;
+		default:
+			break;
+		}
+	}
 }
 
 int board_eth_init(bd_t *bis)
 {
 #if defined(CONFIG_FMAN_ENET)
-	int i;
+	int i, idx, lane, slot;
 	struct memac_mdio_info dtsec_mdio_info;
 	struct memac_mdio_info tgec_mdio_info;
 	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
@@ -236,6 +451,7 @@ int board_eth_init(bd_t *bis)
 	t4240qds_mdio_init(DEFAULT_FM_MDIO_NAME, EMI1_SLOT7);
 	t4240qds_mdio_init(DEFAULT_FM_TGEC_MDIO_NAME, EMI2);
 
+	initialize_qsgmiiphy_fix();
 
 	switch (srds_prtcl_s1) {
 	case 1:
@@ -248,44 +464,48 @@ int board_eth_init(bd_t *bis)
 	case 28:
 	case 36:
 		/* SGMII in Slot1 and Slot2 */
-		fm_info_set_phy_address(FM1_DTSEC1, SGMII_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC2, SGMII_CARD_PORT2_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC3, SGMII_CARD_PORT3_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC4, SGMII_CARD_PORT4_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC5, SGMII_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC6, SGMII_CARD_PORT2_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC1, slot_qsgmii_phyaddr[2][0]);
+		fm_info_set_phy_address(FM1_DTSEC2, slot_qsgmii_phyaddr[2][1]);
+		fm_info_set_phy_address(FM1_DTSEC3, slot_qsgmii_phyaddr[2][2]);
+		fm_info_set_phy_address(FM1_DTSEC4, slot_qsgmii_phyaddr[2][3]);
+		fm_info_set_phy_address(FM1_DTSEC5, slot_qsgmii_phyaddr[1][0]);
+		fm_info_set_phy_address(FM1_DTSEC6, slot_qsgmii_phyaddr[1][1]);
 		if ((srds_prtcl_s2 != 56) && (srds_prtcl_s2 != 57)) {
 			fm_info_set_phy_address(FM1_DTSEC9,
-						SGMII_CARD_PORT4_PHY_ADDR);
+						slot_qsgmii_phyaddr[1][3]);
 			fm_info_set_phy_address(FM1_DTSEC10,
-						SGMII_CARD_PORT3_PHY_ADDR);
+						slot_qsgmii_phyaddr[1][2]);
 		}
 		break;
 	case 38:
-		fm_info_set_phy_address(FM1_DTSEC5, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC6, QSGMII_CARD_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC1, slot_qsgmii_phyaddr[2][0]);
+		fm_info_set_phy_address(FM1_DTSEC2, slot_qsgmii_phyaddr[2][1]);
+		fm_info_set_phy_address(FM1_DTSEC3, slot_qsgmii_phyaddr[2][2]);
+		fm_info_set_phy_address(FM1_DTSEC4, slot_qsgmii_phyaddr[2][3]);
+		fm_info_set_phy_address(FM1_DTSEC5, slot_qsgmii_phyaddr[1][0]);
+		fm_info_set_phy_address(FM1_DTSEC6, slot_qsgmii_phyaddr[1][1]);
 		if ((srds_prtcl_s2 != 56) && (srds_prtcl_s2 != 57)) {
 			fm_info_set_phy_address(FM1_DTSEC9,
-						QSGMII_CARD_PHY_ADDR);
+						slot_qsgmii_phyaddr[1][3]);
 			fm_info_set_phy_address(FM1_DTSEC10,
-						QSGMII_CARD_PHY_ADDR);
+						slot_qsgmii_phyaddr[1][2]);
 		}
 		break;
 	case 40:
 	case 46:
 	case 48:
-		fm_info_set_phy_address(FM1_DTSEC5, SGMII_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC6, SGMII_CARD_PORT2_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC5, slot_qsgmii_phyaddr[1][0]);
+		fm_info_set_phy_address(FM1_DTSEC6, slot_qsgmii_phyaddr[1][1]);
 		if ((srds_prtcl_s2 != 56) && (srds_prtcl_s2 != 57)) {
 			fm_info_set_phy_address(FM1_DTSEC10,
-						SGMII_CARD_PORT3_PHY_ADDR);
+						slot_qsgmii_phyaddr[1][3]);
 			fm_info_set_phy_address(FM1_DTSEC9,
-						SGMII_CARD_PORT4_PHY_ADDR);
+						slot_qsgmii_phyaddr[1][2]);
 		}
-		fm_info_set_phy_address(FM1_DTSEC1, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC2, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC3, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM1_DTSEC4, QSGMII_CARD_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC1, slot_qsgmii_phyaddr[2][0]);
+		fm_info_set_phy_address(FM1_DTSEC2, slot_qsgmii_phyaddr[2][1]);
+		fm_info_set_phy_address(FM1_DTSEC3, slot_qsgmii_phyaddr[2][2]);
+		fm_info_set_phy_address(FM1_DTSEC4, slot_qsgmii_phyaddr[2][3]);
 		break;
 	default:
 		puts("Invalid SerDes1 protocol for T4240QDS\n");
@@ -293,7 +513,7 @@ int board_eth_init(bd_t *bis)
 	}
 
 	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
-		int idx = i - FM1_DTSEC1, lane, slot;
+		idx = i - FM1_DTSEC1;
 		switch (fm_info_get_enet_if(i)) {
 		case PHY_INTERFACE_MODE_SGMII:
 			lane = serdes_get_first_lane(FSL_SRDS_1,
@@ -334,8 +554,16 @@ int board_eth_init(bd_t *bis)
 	}
 
 	for (i = FM1_10GEC1; i < FM1_10GEC1 + CONFIG_SYS_NUM_FM1_10GEC; i++) {
+		idx = i - FM1_10GEC1;
 		switch (fm_info_get_enet_if(i)) {
 		case PHY_INTERFACE_MODE_XGMII:
+			lane = serdes_get_first_lane(FSL_SRDS_1,
+						XAUI_FM1_MAC9 + idx);
+			if (lane < 0)
+				break;
+			slot = lane_to_slot_fsm1[lane];
+			if (QIXIS_READ(present2) & (1 << (slot - 1)))
+				fm_disable_port(i);
 			mdio_mux[i] = EMI2;
 			fm_info_set_mdio(i, mii_dev_for_muxval(mdio_mux[i]));
 			break;
@@ -344,7 +572,6 @@ int board_eth_init(bd_t *bis)
 		}
 	}
 
-
 #if (CONFIG_SYS_NUM_FMAN == 2)
 	switch (srds_prtcl_s2) {
 	case 1:
@@ -364,68 +591,64 @@ int board_eth_init(bd_t *bis)
 	case 26:
 		/* XAUI/HiGig in Slot3, SGMII in Slot4 */
 		fm_info_set_phy_address(FM2_10GEC1, FM2_10GEC1_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC1, SGMII_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC2, SGMII_CARD_PORT2_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC3, SGMII_CARD_PORT3_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC4, SGMII_CARD_PORT4_PHY_ADDR);
+		fm_info_set_phy_address(FM2_DTSEC1, slot_qsgmii_phyaddr[4][0]);
+		fm_info_set_phy_address(FM2_DTSEC2, slot_qsgmii_phyaddr[4][1]);
+		fm_info_set_phy_address(FM2_DTSEC3, slot_qsgmii_phyaddr[4][2]);
+		fm_info_set_phy_address(FM2_DTSEC4, slot_qsgmii_phyaddr[4][3]);
 		break;
 	case 28:
 	case 36:
 		/* SGMII in Slot3 and Slot4 */
-		fm_info_set_phy_address(FM2_DTSEC1, SGMII_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC2, SGMII_CARD_PORT2_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC3, SGMII_CARD_PORT3_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC4, SGMII_CARD_PORT4_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC5, SGMII_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC6, SGMII_CARD_PORT2_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC9, SGMII_CARD_PORT4_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC10, SGMII_CARD_PORT3_PHY_ADDR);
+		fm_info_set_phy_address(FM2_DTSEC1, slot_qsgmii_phyaddr[4][0]);
+		fm_info_set_phy_address(FM2_DTSEC2, slot_qsgmii_phyaddr[4][1]);
+		fm_info_set_phy_address(FM2_DTSEC3, slot_qsgmii_phyaddr[4][2]);
+		fm_info_set_phy_address(FM2_DTSEC4, slot_qsgmii_phyaddr[4][3]);
+		fm_info_set_phy_address(FM2_DTSEC5, slot_qsgmii_phyaddr[3][0]);
+		fm_info_set_phy_address(FM2_DTSEC6, slot_qsgmii_phyaddr[3][1]);
+		fm_info_set_phy_address(FM2_DTSEC9, slot_qsgmii_phyaddr[3][3]);
+		fm_info_set_phy_address(FM2_DTSEC10, slot_qsgmii_phyaddr[3][2]);
 		break;
 	case 38:
 		/* QSGMII in Slot3 and Slot4 */
-		fm_info_set_phy_address(FM2_DTSEC1, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC2, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC3, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC4, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC5, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC6, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC9, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC10, QSGMII_CARD_PHY_ADDR);
+		fm_info_set_phy_address(FM2_DTSEC1, slot_qsgmii_phyaddr[4][0]);
+		fm_info_set_phy_address(FM2_DTSEC2, slot_qsgmii_phyaddr[4][1]);
+		fm_info_set_phy_address(FM2_DTSEC3, slot_qsgmii_phyaddr[4][2]);
+		fm_info_set_phy_address(FM2_DTSEC4, slot_qsgmii_phyaddr[4][3]);
+		fm_info_set_phy_address(FM2_DTSEC5, slot_qsgmii_phyaddr[3][0]);
+		fm_info_set_phy_address(FM2_DTSEC6, slot_qsgmii_phyaddr[3][1]);
+		fm_info_set_phy_address(FM2_DTSEC9, slot_qsgmii_phyaddr[3][3]);
+		fm_info_set_phy_address(FM2_DTSEC10, slot_qsgmii_phyaddr[3][2]);
 		break;
 	case 40:
 	case 46:
 	case 48:
 		/* SGMII in Slot3 */
-		fm_info_set_phy_address(FM2_DTSEC5, SGMII_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC6, SGMII_CARD_PORT2_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC9, SGMII_CARD_PORT4_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC10, SGMII_CARD_PORT3_PHY_ADDR);
+		fm_info_set_phy_address(FM2_DTSEC5, slot_qsgmii_phyaddr[3][0]);
+		fm_info_set_phy_address(FM2_DTSEC6, slot_qsgmii_phyaddr[3][1]);
+		fm_info_set_phy_address(FM2_DTSEC9, slot_qsgmii_phyaddr[3][3]);
+		fm_info_set_phy_address(FM2_DTSEC10, slot_qsgmii_phyaddr[3][2]);
 		/* QSGMII in Slot4 */
-		fm_info_set_phy_address(FM2_DTSEC1, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC2, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC3, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC4, QSGMII_CARD_PHY_ADDR);
+		fm_info_set_phy_address(FM2_DTSEC1, slot_qsgmii_phyaddr[4][0]);
+		fm_info_set_phy_address(FM2_DTSEC2, slot_qsgmii_phyaddr[4][1]);
+		fm_info_set_phy_address(FM2_DTSEC3, slot_qsgmii_phyaddr[4][2]);
+		fm_info_set_phy_address(FM2_DTSEC4, slot_qsgmii_phyaddr[4][3]);
 		break;
 	case 50:
 	case 52:
 	case 54:
 		fm_info_set_phy_address(FM2_10GEC1, FM2_10GEC1_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC1, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC2, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC3, QSGMII_CARD_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC4, QSGMII_CARD_PHY_ADDR);
+		fm_info_set_phy_address(FM2_DTSEC1, slot_qsgmii_phyaddr[4][0]);
+		fm_info_set_phy_address(FM2_DTSEC2, slot_qsgmii_phyaddr[4][1]);
+		fm_info_set_phy_address(FM2_DTSEC3, slot_qsgmii_phyaddr[4][2]);
+		fm_info_set_phy_address(FM2_DTSEC4, slot_qsgmii_phyaddr[4][3]);
 		break;
 	case 56:
 	case 57:
 		/* XFI in Slot3, SGMII in Slot4 */
-		fm_info_set_phy_address(FM1_10GEC1, XFI_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM1_10GEC2, XFI_CARD_PORT2_PHY_ADDR);
-		fm_info_set_phy_address(FM2_10GEC2, XFI_CARD_PORT3_PHY_ADDR);
-		fm_info_set_phy_address(FM2_10GEC1, XFI_CARD_PORT4_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC1, SGMII_CARD_PORT1_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC2, SGMII_CARD_PORT2_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC3, SGMII_CARD_PORT3_PHY_ADDR);
-		fm_info_set_phy_address(FM2_DTSEC4, SGMII_CARD_PORT4_PHY_ADDR);
+		fm_info_set_phy_address(FM2_DTSEC1, slot_qsgmii_phyaddr[4][0]);
+		fm_info_set_phy_address(FM2_DTSEC2, slot_qsgmii_phyaddr[4][1]);
+		fm_info_set_phy_address(FM2_DTSEC3, slot_qsgmii_phyaddr[4][2]);
+		fm_info_set_phy_address(FM2_DTSEC4, slot_qsgmii_phyaddr[4][3]);
 		break;
 	default:
 		puts("Invalid SerDes2 protocol for T4240QDS\n");
@@ -433,7 +656,7 @@ int board_eth_init(bd_t *bis)
 	}
 
 	for (i = FM2_DTSEC1; i < FM2_DTSEC1 + CONFIG_SYS_NUM_FM2_DTSEC; i++) {
-		int idx = i - FM2_DTSEC1, lane, slot;
+		idx = i - FM2_DTSEC1;
 		switch (fm_info_get_enet_if(i)) {
 		case PHY_INTERFACE_MODE_SGMII:
 			lane = serdes_get_first_lane(FSL_SRDS_2,
@@ -477,8 +700,16 @@ int board_eth_init(bd_t *bis)
 	}
 
 	for (i = FM2_10GEC1; i < FM2_10GEC1 + CONFIG_SYS_NUM_FM2_10GEC; i++) {
+		idx = i - FM2_10GEC1;
 		switch (fm_info_get_enet_if(i)) {
 		case PHY_INTERFACE_MODE_XGMII:
+			lane = serdes_get_first_lane(FSL_SRDS_2,
+						XAUI_FM2_MAC9 + idx);
+			if (lane < 0)
+				break;
+			slot = lane_to_slot_fsm2[lane];
+			if (QIXIS_READ(present2) & (1 << (slot - 1)))
+				fm_disable_port(i);
 			mdio_mux[i] = EMI2;
 			fm_info_set_mdio(i, mii_dev_for_muxval(mdio_mux[i]));
 			break;
diff --git a/board/freescale/t4qds/law.c b/board/freescale/t4qds/law.c
index 5debcf6..7e41556 100644
--- a/board/freescale/t4qds/law.c
+++ b/board/freescale/t4qds/law.c
@@ -35,12 +35,15 @@ struct law_entry law_table[] = {
 #ifdef CONFIG_SYS_QMAN_MEM_PHYS
 	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
 #endif
+#ifdef QIXIS_BASE_PHYS
 	SET_LAW(QIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
+#endif
 #ifdef CONFIG_SYS_DCSRBAR_PHYS
-	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_4M, LAW_TRGT_IF_DCSR),
+	/* Limit DCSR to 32M to access NPC Trace Buffer */
+	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_DCSR),
 #endif
 #ifdef CONFIG_SYS_NAND_BASE_PHYS
-	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_IFC),
 #endif
 };
 
diff --git a/board/freescale/t4qds/t4240emu.c b/board/freescale/t4qds/t4240emu.c
new file mode 100644
index 0000000..e31770e
--- /dev/null
+++ b/board/freescale/t4qds/t4240emu.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	struct cpu_type *cpu = gd->cpu;
+
+	printf("Board: %sEMU\n", cpu->name);
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+		MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		0, flash_esel, BOOKE_PAGESZ_256M, 1);
+
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+
+	return 0;
+}
+
+int misc_init_r(void)
+{
+	return 0;
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+	fdt_fixup_liodn(blob);
+	fdt_fixup_dr_usb(blob, bd);
+}
diff --git a/board/freescale/t4qds/t4240qds.c b/board/freescale/t4qds/t4240qds.c
new file mode 100644
index 0000000..1284c99
--- /dev/null
+++ b/board/freescale/t4qds/t4240qds.c
@@ -0,0 +1,844 @@
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <fm_eth.h>
+
+#include "../common/qixis.h"
+#include "../common/vsc3316_3308.h"
+#include "t4qds.h"
+#include "t4240qds_qixis.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	char buf[64];
+	u8 sw;
+	struct cpu_type *cpu = gd->cpu;
+	unsigned int i;
+
+	printf("Board: %sQDS, ", cpu->name);
+	printf("Sys ID: 0x%02x, Sys Ver: 0x%02x, ",
+		QIXIS_READ(id), QIXIS_READ(arch));
+
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	if (sw < 0x8)
+		printf("vBank: %d\n", sw);
+	else if (sw == 0x8)
+		puts("Promjet\n");
+	else if (sw == 0x9)
+		puts("NAND\n");
+	else
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+
+	printf("FPGA: v%d (%s), build %d",
+		(int)QIXIS_READ(scver), qixis_read_tag(buf),
+		(int)qixis_read_minor());
+	/* the timestamp string contains "\n" at the end */
+	printf(" on %s", qixis_read_time(buf));
+
+	/*
+	 * Display the actual SERDES reference clocks as configured by the
+	 * dip switches on the board.  Note that the SWx registers could
+	 * technically be set to force the reference clocks to match the
+	 * values that the SERDES expects (or vice versa).  For now, however,
+	 * we just display both values and hope the user notices when they
+	 * don't match.
+	 */
+	puts("SERDES Reference Clocks: ");
+	sw = QIXIS_READ(brdcfg[2]);
+	for (i = 0; i < MAX_SERDES; i++) {
+		static const char *freq[] = {
+			"100", "125", "156.25", "161.1328125"};
+		unsigned int clock = (sw >> (6 - 2 * i)) & 3;
+
+		printf("SERDES%u=%sMHz ", i+1, freq[clock]);
+	}
+	puts("\n");
+
+	return 0;
+}
+
+int select_i2c_ch_pca9547(u8 ch)
+{
+	int ret;
+
+	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
+	if (ret) {
+		puts("PCA: failed to select proper channel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * read_voltage from sensor on I2C bus
+ * We use average of 4 readings, waiting for 532us befor another reading
+ */
+#define NUM_READINGS	4	/* prefer to be power of 2 for efficiency */
+#define WAIT_FOR_ADC	532	/* wait for 532 microseconds for ADC */
+
+static inline int read_voltage(void)
+{
+	int i, ret, voltage_read = 0;
+	u16 vol_mon;
+
+	for (i = 0; i < NUM_READINGS; i++) {
+		ret = i2c_read(I2C_VOL_MONITOR_ADDR,
+			I2C_VOL_MONITOR_BUS_V_OFFSET, 1, (void *)&vol_mon, 2);
+		if (ret) {
+			printf("VID: failed to read core voltage\n");
+			return ret;
+		}
+		if (vol_mon & I2C_VOL_MONITOR_BUS_V_OVF) {
+			printf("VID: Core voltage sensor error\n");
+			return -1;
+		}
+		debug("VID: bus voltage reads 0x%04x\n", vol_mon);
+		/* LSB = 4mv */
+		voltage_read += (vol_mon >> I2C_VOL_MONITOR_BUS_V_SHIFT) * 4;
+		udelay(WAIT_FOR_ADC);
+	}
+	/* calculate the average */
+	voltage_read /= NUM_READINGS;
+
+	return voltage_read;
+}
+
+/*
+ * We need to calculate how long before the voltage starts to drop or increase
+ * It returns with the loop count. Each loop takes several readings (532us)
+ */
+static inline int wait_for_voltage_change(int vdd_last)
+{
+	int timeout, vdd_current;
+
+	vdd_current = read_voltage();
+	/* wait until voltage starts to drop */
+	for (timeout = 0; abs(vdd_last - vdd_current) <= 4 &&
+		timeout < 100; timeout++) {
+		vdd_current = read_voltage();
+	}
+	if (timeout >= 100) {
+		printf("VID: Voltage adjustment timeout\n");
+		return -1;
+	}
+	return timeout;
+}
+
+/*
+ * argument 'wait' is the time we know the voltage difference can be measured
+ * this function keeps reading the voltage until it is stable
+ */
+static inline int wait_for_voltage_stable(int wait)
+{
+	int timeout, vdd_current, vdd_last;
+
+	vdd_last = read_voltage();
+	udelay(wait * NUM_READINGS * WAIT_FOR_ADC);
+	/* wait until voltage is stable */
+	vdd_current = read_voltage();
+	for (timeout = 0; abs(vdd_last - vdd_current) >= 4 &&
+		timeout < 100; timeout++) {
+		vdd_last = vdd_current;
+		udelay(wait * NUM_READINGS * WAIT_FOR_ADC);
+		vdd_current = read_voltage();
+	}
+	if (timeout >= 100) {
+		printf("VID: Voltage adjustment timeout\n");
+		return -1;
+	}
+
+	return vdd_current;
+}
+
+static inline int set_voltage(u8 vid)
+{
+	int wait, vdd_last;
+
+	vdd_last = read_voltage();
+	QIXIS_WRITE(brdcfg[6], vid);
+	wait = wait_for_voltage_change(vdd_last);
+	if (wait < 0)
+		return -1;
+	debug("VID: Waited %d us\n", wait * NUM_READINGS * WAIT_FOR_ADC);
+	wait = wait ? wait : 1;
+
+	vdd_last = wait_for_voltage_stable(wait);
+	if (vdd_last < 0)
+		return -1;
+	debug("VID: Current voltage is %d mV\n", vdd_last);
+
+	return vdd_last;
+}
+
+
+static int adjust_vdd(ulong vdd_override)
+{
+	int re_enable = disable_interrupts();
+	ccsr_gur_t __iomem *gur =
+		(void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 fusesr;
+	u8 vid, vid_current;
+	int vdd_target, vdd_current, vdd_last;
+	int ret;
+	unsigned long vdd_string_override;
+	char *vdd_string;
+	static const uint16_t vdd[32] = {
+		0,	/* unused */
+		9875,	/* 0.9875V */
+		9750,
+		9625,
+		9500,
+		9375,
+		9250,
+		9125,
+		9000,
+		8875,
+		8750,
+		8625,
+		8500,
+		8375,
+		8250,
+		8125,
+		10000,	/* 1.0000V */
+		10125,
+		10250,
+		10375,
+		10500,
+		10625,
+		10750,
+		10875,
+		11000,
+		0,	/* reserved */
+	};
+	struct vdd_drive {
+		u8 vid;
+		unsigned voltage;
+	};
+
+	ret = select_i2c_ch_pca9547(I2C_MUX_CH_VOL_MONITOR);
+	if (ret) {
+		debug("VID: I2c failed to switch channel\n");
+		ret = -1;
+		goto exit;
+	}
+
+	/* get the voltage ID from fuse status register */
+	fusesr = in_be32(&gur->dcfg_fusesr);
+	vid = (fusesr >> FSL_CORENET_DCFG_FUSESR_VID_SHIFT) &
+		FSL_CORENET_DCFG_FUSESR_VID_MASK;
+	if (vid == FSL_CORENET_DCFG_FUSESR_VID_MASK) {
+		vid = (fusesr >> FSL_CORENET_DCFG_FUSESR_ALTVID_SHIFT) &
+			FSL_CORENET_DCFG_FUSESR_ALTVID_MASK;
+	}
+	vdd_target = vdd[vid];
+
+	/* check override variable for overriding VDD */
+	vdd_string = getenv("t4240qds_vdd_mv");
+	if (vdd_override == 0 && vdd_string &&
+		!strict_strtoul(vdd_string, 10, &vdd_string_override))
+		vdd_override = vdd_string_override;
+	if (vdd_override >= 819 && vdd_override <= 1212) {
+		vdd_target = vdd_override * 10; /* convert to 1/10 mV */
+		debug("VDD override is %lu\n", vdd_override);
+	} else if (vdd_override != 0) {
+		printf("Invalid value.\n");
+	}
+
+	if (vdd_target == 0) {
+		debug("VID: VID not used\n");
+		ret = 0;
+		goto exit;
+	} else {
+		/* round up and divice by 10 to get a value in mV */
+		vdd_target = DIV_ROUND_UP(vdd_target, 10);
+		debug("VID: vid = %d mV\n", vdd_target);
+	}
+
+	/*
+	 * Check current board VID setting
+	 * Voltage regulator support output to 6.250mv step
+	 * The highes voltage allowed for this board is (vid=0x40) 1.21250V
+	 * the lowest is (vid=0x7f) 0.81875V
+	 */
+	vid_current =  QIXIS_READ(brdcfg[6]);
+	vdd_current = 121250 - (vid_current - 0x40) * 625;
+	debug("VID: Current vid setting is (0x%x) %d mV\n",
+		vid_current, vdd_current/100);
+
+	/*
+	 * Read voltage monitor to check real voltage.
+	 * Voltage monitor LSB is 4mv.
+	 */
+	vdd_last = read_voltage();
+	if (vdd_last < 0) {
+		printf("VID: Could not read voltage sensor "
+			"abort VID adjustment\n");
+		ret = -1;
+		goto exit;
+	}
+	debug("VID: Core voltage is at %d mV\n", vdd_last);
+	/*
+	 * Adjust voltage to at or 8mV above target.
+	 * Each step of adjustment is 6.25mV.
+	 * Stepping down too fast may cause over current.
+	 */
+	while (vdd_last > 0 && vid_current < 0x80 &&
+		vdd_last > (vdd_target + 8)) {
+		vid_current++;
+		vdd_last = set_voltage(vid_current);
+	}
+	/*
+	 * Check if we need to step up
+	 * This happens when board voltage switch was set too low
+	 */
+	while (vdd_last > 0 && vid_current >= 0x40 &&
+		vdd_last < vdd_target + 2) {
+		vid_current--;
+		vdd_last = set_voltage(vid_current);
+	}
+	if (vdd_last > 0)
+		printf("VID: Core voltage %d mV\n", vdd_last);
+	else
+		ret = -1;
+
+exit:
+	if (re_enable)
+		enable_interrupts();
+	return ret;
+}
+
+/* Configure Crossbar switches for Front-Side SerDes Ports */
+int config_frontside_crossbar_vsc3316(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 srds_prtcl_s1, srds_prtcl_s2;
+	int ret;
+
+	ret = select_i2c_ch_pca9547(I2C_MUX_CH_VSC3316_FS);
+	if (ret)
+		return ret;
+
+	srds_prtcl_s1 = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+	srds_prtcl_s1 >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+	if (srds_prtcl_s1) {
+		ret = vsc3316_config(VSC3316_FSM_TX_ADDR, vsc3316_fsm1_tx, 8);
+		if (ret)
+			return ret;
+		ret = vsc3316_config(VSC3316_FSM_RX_ADDR, vsc3316_fsm1_rx, 8);
+		if (ret)
+			return ret;
+	}
+
+	srds_prtcl_s2 = in_be32(&gur->rcwsr[4]) &
+				FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+	srds_prtcl_s2 >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+	if (srds_prtcl_s2) {
+		ret = vsc3316_config(VSC3316_FSM_TX_ADDR, vsc3316_fsm2_tx, 8);
+		if (ret)
+			return ret;
+		ret = vsc3316_config(VSC3316_FSM_RX_ADDR, vsc3316_fsm2_rx, 8);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int config_backside_crossbar_mux(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 srds_prtcl_s3, srds_prtcl_s4;
+	u8 brdcfg;
+
+	srds_prtcl_s3 = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS3_PRTCL;
+	srds_prtcl_s3 >>= FSL_CORENET2_RCWSR4_SRDS3_PRTCL_SHIFT;
+	switch (srds_prtcl_s3) {
+	case 0:
+		/* SerDes3 is not enabled */
+		break;
+	case 2:
+	case 9:
+	case 10:
+		/* SD3(0:7) => SLOT5(0:7) */
+		brdcfg = QIXIS_READ(brdcfg[12]);
+		brdcfg &= ~BRDCFG12_SD3MX_MASK;
+		brdcfg |= BRDCFG12_SD3MX_SLOT5;
+		QIXIS_WRITE(brdcfg[12], brdcfg);
+		break;
+	case 4:
+	case 6:
+	case 8:
+	case 12:
+	case 14:
+	case 16:
+	case 17:
+	case 19:
+	case 20:
+		/* SD3(4:7) => SLOT6(0:3) */
+		brdcfg = QIXIS_READ(brdcfg[12]);
+		brdcfg &= ~BRDCFG12_SD3MX_MASK;
+		brdcfg |= BRDCFG12_SD3MX_SLOT6;
+		QIXIS_WRITE(brdcfg[12], brdcfg);
+		break;
+	default:
+		printf("WARNING: unsupported for SerDes3 Protocol %d\n",
+				srds_prtcl_s3);
+		return -1;
+	}
+
+	srds_prtcl_s4 = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS4_PRTCL;
+	srds_prtcl_s4 >>= FSL_CORENET2_RCWSR4_SRDS4_PRTCL_SHIFT;
+	switch (srds_prtcl_s4) {
+	case 0:
+		/* SerDes4 is not enabled */
+		break;
+	case 2:
+		/* 10b, SD4(0:7) => SLOT7(0:7) */
+		brdcfg = QIXIS_READ(brdcfg[12]);
+		brdcfg &= ~BRDCFG12_SD4MX_MASK;
+		brdcfg |= BRDCFG12_SD4MX_SLOT7;
+		QIXIS_WRITE(brdcfg[12], brdcfg);
+		break;
+	case 4:
+	case 6:
+	case 8:
+		/* x1b, SD4(4:7) => SLOT8(0:3) */
+		brdcfg = QIXIS_READ(brdcfg[12]);
+		brdcfg &= ~BRDCFG12_SD4MX_MASK;
+		brdcfg |= BRDCFG12_SD4MX_SLOT8;
+		QIXIS_WRITE(brdcfg[12], brdcfg);
+		break;
+	case 10:
+	case 12:
+	case 14:
+	case 16:
+	case 18:
+		/* 00b, SD4(4:5) => AURORA, SD4(6:7) => SATA */
+		brdcfg = QIXIS_READ(brdcfg[12]);
+		brdcfg &= ~BRDCFG12_SD4MX_MASK;
+		brdcfg |= BRDCFG12_SD4MX_AURO_SATA;
+		QIXIS_WRITE(brdcfg[12], brdcfg);
+		break;
+	default:
+		printf("WARNING: unsupported for SerDes4 Protocol %d\n",
+				srds_prtcl_s4);
+		return -1;
+	}
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash + promjet */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_256M, 1);
+
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+
+	/* Disable remote I2C connection to qixis fpga */
+	QIXIS_WRITE(brdcfg[5], QIXIS_READ(brdcfg[5]) & ~BRDCFG5_IRE);
+
+	/*
+	 * Adjust core voltage according to voltage ID
+	 * This function changes I2C mux to channel 2.
+	 */
+	if (adjust_vdd(0))
+		printf("Warning: Adjusting core voltage failed.\n");
+
+	/* Configure board SERDES ports crossbar */
+	config_frontside_crossbar_vsc3316();
+	config_backside_crossbar_mux();
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+#ifdef CONFIG_FSL_QIXIS_CLOCK_MEASUREMENT
+	/* use accurate clock measurement */
+	int freq = QIXIS_READ(clk_freq[0]) << 8 | QIXIS_READ(clk_freq[1]);
+	int base = QIXIS_READ(clk_base[0]) << 8 | QIXIS_READ(clk_base[1]);
+	u32 val;
+
+	val =  freq * base;
+	if (val) {
+		debug("SYS Clock measurement is: %d\n", val);
+		return val;
+	} else {
+		printf("Warning: SYS clock measurement is invalid, "
+			"using value from brdcfg1.\n");
+	}
+#endif
+
+	switch (sysclk_conf & 0x0F) {
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+#ifdef CONFIG_FSL_QIXIS_CLOCK_MEASUREMENT
+	/* use accurate clock measurement */
+	int freq = QIXIS_READ(clk_freq[2]) << 8 | QIXIS_READ(clk_freq[3]);
+	int base = QIXIS_READ(clk_base[0]) << 8 | QIXIS_READ(clk_base[1]);
+	u32 val;
+
+	val =  freq * base;
+	if (val) {
+		debug("DDR Clock measurement is: %d\n", val);
+		return val;
+	} else {
+		printf("Warning: DDR clock measurement is invalid, "
+			"using value from brdcfg1.\n");
+	}
+#endif
+
+	switch ((ddrclk_conf & 0x30) >> 4) {
+	case QIXIS_DDRCLK_100:
+		return 100000000;
+	case QIXIS_DDRCLK_125:
+		return 125000000;
+	case QIXIS_DDRCLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+static const char *serdes_clock_to_string(u32 clock)
+{
+	switch (clock) {
+	case SRDS_PLLCR0_RFCK_SEL_100:
+		return "100";
+	case SRDS_PLLCR0_RFCK_SEL_125:
+		return "125";
+	case SRDS_PLLCR0_RFCK_SEL_156_25:
+		return "156.25";
+	case SRDS_PLLCR0_RFCK_SEL_161_13:
+		return "161.1328125";
+	default:
+		return "???";
+	}
+}
+
+int misc_init_r(void)
+{
+	u8 sw;
+	serdes_corenet_t *srds_regs =
+		(void *)CONFIG_SYS_FSL_CORENET_SERDES_ADDR;
+	u32 actual[MAX_SERDES];
+	unsigned int i;
+
+	sw = QIXIS_READ(brdcfg[2]);
+	for (i = 0; i < MAX_SERDES; i++) {
+		unsigned int clock = (sw >> (6 - 2 * i)) & 3;
+		switch (clock) {
+		case 0:
+			actual[i] = SRDS_PLLCR0_RFCK_SEL_100;
+			break;
+		case 1:
+			actual[i] = SRDS_PLLCR0_RFCK_SEL_125;
+			break;
+		case 2:
+			actual[i] = SRDS_PLLCR0_RFCK_SEL_156_25;
+			break;
+		case 3:
+			actual[i] = SRDS_PLLCR0_RFCK_SEL_161_13;
+			break;
+		}
+	}
+
+	for (i = 0; i < MAX_SERDES; i++) {
+		u32 pllcr0 = srds_regs->bank[i].pllcr0;
+		u32 expected = pllcr0 & SRDS_PLLCR0_RFCK_SEL_MASK;
+		if (expected != actual[i]) {
+			printf("Warning: SERDES%u expects reference clock"
+			       " %sMHz, but actual is %sMHz\n", i + 1,
+			       serdes_clock_to_string(expected),
+			       serdes_clock_to_string(actual[i]));
+		}
+	}
+
+	return 0;
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+	fdt_fixup_dr_usb(blob, bd);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+	fdt_fixup_board_enet(blob);
+#endif
+}
+
+/*
+ * This function is called by bdinfo to print detail board information.
+ * As an exmaple for future board, we organize the messages into
+ * several sections. If applicable, the message is in the format of
+ * <name>      = <value>
+ * It should aligned with normal output of bdinfo command.
+ *
+ * Voltage: Core, DDR and another configurable voltages
+ * Clock  : Critical clocks which are not printed already
+ * RCW    : RCW source if not printed already
+ * Misc   : Other important information not in above catagories
+ */
+void board_detail(void)
+{
+	int i;
+	u8 brdcfg[16], dutcfg[16], rst_ctl;
+	int vdd, rcwsrc;
+	static const char * const clk[] = {"66.67", "100", "125", "133.33"};
+
+	for (i = 0; i < 16; i++) {
+		brdcfg[i] = qixis_read(offsetof(struct qixis, brdcfg[0]) + i);
+		dutcfg[i] = qixis_read(offsetof(struct qixis, dutcfg[0]) + i);
+	}
+
+	/* Voltage secion */
+	if (!select_i2c_ch_pca9547(I2C_MUX_CH_VOL_MONITOR)) {
+		vdd = read_voltage();
+		if (vdd > 0)
+			printf("Core voltage= %d mV\n", vdd);
+		select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+	}
+
+	printf("XVDD        = 1.%d V\n", ((brdcfg[8] & 0xf) - 4) * 5 + 25);
+
+	/* clock section */
+	printf("SYSCLK      = %s MHz\nDDRCLK      = %s MHz\n",
+		clk[(brdcfg[11] >> 2) & 0x3], clk[brdcfg[11] & 3]);
+
+	/* RCW section */
+	rcwsrc = (dutcfg[0] << 1) + (dutcfg[1] & 1);
+	puts("RCW source  = ");
+	switch (rcwsrc) {
+	case 0x017:
+	case 0x01f:
+		puts("8-bit NOR\n");
+		break;
+	case 0x027:
+	case 0x02F:
+		puts("16-bit NOR\n");
+		break;
+	case 0x040:
+		puts("SDHC/eMMC\n");
+		break;
+	case 0x044:
+		puts("SPI 16-bit addressing\n");
+		break;
+	case 0x045:
+		puts("SPI 24-bit addressing\n");
+		break;
+	case 0x048:
+		puts("I2C normal addressing\n");
+		break;
+	case 0x049:
+		puts("I2C extended addressing\n");
+		break;
+	case 0x108:
+	case 0x109:
+	case 0x10a:
+	case 0x10b:
+		puts("8-bit NAND, 2KB\n");
+		break;
+	default:
+		if ((rcwsrc >= 0x080) && (rcwsrc <= 0x09f))
+			puts("Hard-coded RCW\n");
+		else if ((rcwsrc >= 0x110) && (rcwsrc <= 0x11f))
+			puts("8-bit NAND, 4KB\n");
+		else
+			puts("unknown\n");
+		break;
+	}
+
+	/* Misc section */
+	rst_ctl = QIXIS_READ(rst_ctl);
+	puts("HRESET_REQ  = ");
+	switch (rst_ctl & 0x30) {
+	case 0x00:
+		puts("Ignored\n");
+		break;
+	case 0x10:
+		puts("Assert HRESET\n");
+		break;
+	case 0x30:
+		puts("Reset system\n");
+		break;
+	default:
+		puts("N/A\n");
+		break;
+	}
+}
+
+/*
+ * Reverse engineering switch settings.
+ * Some bits cannot be figured out. They will be displayed as
+ * underscore in binary format. mask[] has those bits.
+ * Some bits are calculated differently than the actual switches
+ * if booting with overriding by FPGA.
+ */
+void qixis_dump_switch(void)
+{
+	int i;
+	u8 sw[9];
+
+	/*
+	 * Any bit with 1 means that bit cannot be reverse engineered.
+	 * It will be displayed as _ in binary format.
+	 */
+	static const u8 mask[] = {0, 0, 0, 0, 0, 0x1, 0xcf, 0x3f, 0x1f};
+	char buf[10];
+	u8 brdcfg[16], dutcfg[16];
+
+	for (i = 0; i < 16; i++) {
+		brdcfg[i] = qixis_read(offsetof(struct qixis, brdcfg[0]) + i);
+		dutcfg[i] = qixis_read(offsetof(struct qixis, dutcfg[0]) + i);
+	}
+
+	sw[0] = dutcfg[0];
+	sw[1] = (dutcfg[1] << 0x07)		| \
+		((dutcfg[12] & 0xC0) >> 1)	| \
+		((dutcfg[11] & 0xE0) >> 3)	| \
+		((dutcfg[6] & 0x80) >> 6)	| \
+		((dutcfg[1] & 0x80) >> 7);
+	sw[2] = ((brdcfg[1] & 0x0f) << 4)	| \
+		((brdcfg[1] & 0x30) >> 2)	| \
+		((brdcfg[1] & 0x40) >> 5)	| \
+		((brdcfg[1] & 0x80) >> 7);
+	sw[3] = brdcfg[2];
+	sw[4] = ((dutcfg[2] & 0x01) << 7)	| \
+		((dutcfg[2] & 0x06) << 4)	| \
+		((~QIXIS_READ(present)) & 0x10)	| \
+		((brdcfg[3] & 0x80) >> 4)	| \
+		((brdcfg[3] & 0x01) << 2)	| \
+		((brdcfg[6] == 0x62) ? 3 :	\
+		((brdcfg[6] == 0x5a) ? 2 :	\
+		((brdcfg[6] == 0x5e) ? 1 : 0)));
+	sw[5] = ((brdcfg[0] & 0x0f) << 4)	| \
+		((QIXIS_READ(rst_ctl) & 0x30) >> 2) | \
+		((brdcfg[0] & 0x40) >> 5);
+	sw[6] = (brdcfg[11] & 0x20)		| \
+		((brdcfg[5] & 0x02) << 3);
+	sw[7] = (((~QIXIS_READ(rst_ctl)) & 0x40) << 1) | \
+		((brdcfg[5] & 0x10) << 2);
+	sw[8] = ((brdcfg[12] & 0x08) << 4)	| \
+		((brdcfg[12] & 0x03) << 5);
+
+	puts("DIP switch (reverse-engineering)\n");
+	for (i = 0; i < 9; i++) {
+		printf("SW%d         = 0b%s (0x%02x)\n",
+			i + 1, byte_to_binary_mask(sw[i], mask[i], buf), sw[i]);
+	}
+}
+
+static int do_vdd_adjust(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong override;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+	if (!strict_strtoul(argv[1], 10, &override))
+		adjust_vdd(override);	/* the value is checked by callee */
+	else
+		return CMD_RET_USAGE;
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	vdd_override, 2, 0, do_vdd_adjust,
+	"Override VDD",
+	"- override with the voltage specified in mV, eg. 1050"
+);
diff --git a/board/freescale/t4qds/t4240qds_qixis.h b/board/freescale/t4qds/t4240qds_qixis.h
index efb718d..485353d 100644
--- a/board/freescale/t4qds/t4240qds_qixis.h
+++ b/board/freescale/t4qds/t4240qds_qixis.h
@@ -42,7 +42,7 @@
 #define QIXIS_DDRCLK_125		0x2
 #define QIXIS_DDRCLK_133		0x3
 
-#define BRDCFG5_RESET			0x00
+#define BRDCFG5_IRE			0x20	/* i2c Remote i2c1 enable */
 
 #define BRDCFG12_SD3EN_MASK		0x20
 #define BRDCFG12_SD3MX_MASK		0x08
diff --git a/board/freescale/t4qds/t4_pbi.cfg b/board/freescale/t4qds/t4_pbi.cfg
new file mode 100644
index 0000000..c598fb5
--- /dev/null
+++ b/board/freescale/t4qds/t4_pbi.cfg
@@ -0,0 +1,36 @@
+#PBI commands
+#Initialize CPC1
+09010000 00200400
+09138000 00000000
+091380c0 00000100
+#512KB SRAM
+09010100 00000000
+09010104 fff80009
+09010f00 08000000
+#enable CPC1
+09010000 80000000
+#Configure LAW for CPC1
+09000d00 00000000
+09000d04 fff80000
+09000d08 81000012
+#workaround for IFC bus speed
+091241c0 f03f3f3f
+091241c4 ff003f3f
+09124010 00000101
+09124130 0000000c
+#workaround for SERDES A-006031
+090ea000 064740e6
+090ea020 064740e6
+090eb000 064740e6
+090eb020 064740e6
+090ec000 064740e6
+090ec020 064740e6
+090ed000 064740e6
+090ed020 064740e6
+#Configure alternate space
+09000010 00000000
+09000014 ff000000
+09000018 81000000
+#Flush PBL data
+09138000 00000000
+091380c0 00000000
diff --git a/board/freescale/t4qds/t4_rcw.cfg b/board/freescale/t4qds/t4_rcw.cfg
new file mode 100644
index 0000000..6ac95ff
--- /dev/null
+++ b/board/freescale/t4qds/t4_rcw.cfg
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 010e0100
+#serdes protocol  1_28_6_12
+14180019 0c101916 00000000 00000000
+04383060 30548c00 6c020000 19000000
+00000000 ee0000ee 00000000 000187fc
+00000000 00000000 00000000 00000018
diff --git a/board/freescale/t4qds/tlb.c b/board/freescale/t4qds/tlb.c
index 078a6e4..10ce3de 100644
--- a/board/freescale/t4qds/tlb.c
+++ b/board/freescale/t4qds/tlb.c
@@ -55,6 +55,15 @@ struct fsl_e_tlb_entry tlb_table[] = {
 	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L3_ADDR, CONFIG_SYS_INIT_L3_ADDR,
 			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 			0, 0, BOOKE_PAGESZ_1M, 1),
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. When slave boot, the address of the
+	 * space is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR,
+			CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_W|MAS2_G,
+			0, 0, BOOKE_PAGESZ_1M, 1),
 #else
 	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
@@ -115,7 +124,7 @@ struct fsl_e_tlb_entry tlb_table[] = {
 #ifdef CONFIG_SYS_DCSRBAR_PHYS
 	SET_TLB_ENTRY(1, CONFIG_SYS_DCSRBAR, CONFIG_SYS_DCSRBAR_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
-		      0, 13, BOOKE_PAGESZ_4M, 1),
+		      0, 13, BOOKE_PAGESZ_32M, 1),
 #endif
 #ifdef CONFIG_SYS_NAND_BASE
 	/*
@@ -125,11 +134,23 @@ struct fsl_e_tlb_entry tlb_table[] = {
 	 */
 	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
 			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
-			0, 16, BOOKE_PAGESZ_1M, 1),
+			0, 16, BOOKE_PAGESZ_64K, 1),
 #endif
+#ifdef QIXIS_BASE_PHYS
 	SET_TLB_ENTRY(1, QIXIS_BASE, QIXIS_BASE_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 17, BOOKE_PAGESZ_4K, 1),
+#endif
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. 1M space from 0xffe00000 for
+	 * fetching ucode and ENV from master
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR,
+		CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS,
+		MAS3_SX|MAS3_SW|MAS3_SR, MAS2_G,
+		0, 18, BOOKE_PAGESZ_1M, 1),
+#endif
 
 };
 
diff --git a/boards.cfg b/boards.cfg
index e4b0d44..8348ace 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -732,6 +732,12 @@ MPC8569MDS_NAND              powerpc     mpc85xx     mpc8569mds          freesca
 MPC8572DS                    powerpc     mpc85xx     mpc8572ds           freescale      -           MPC8572DS
 MPC8572DS_36BIT              powerpc     mpc85xx     mpc8572ds           freescale      -           MPC8572DS:36BIT
 MPC8572DS_NAND               powerpc     mpc85xx     mpc8572ds           freescale      -           MPC8572DS:NAND
+C291PCIE                     powerpc     mpc85xx     c29xpcie            freescale      -           C29XPCIE:C291PCIE,36BIT
+C291PCIE_SPIFLASH            powerpc     mpc85xx     c29xpcie            freescale      -           C29XPCIE:C291PCIE,36BIT,SPIFLASH
+C292PCIE                     powerpc     mpc85xx     c29xpcie            freescale      -           C29XPCIE:C292PCIE,36BIT
+C292PCIE_SPIFLASH            powerpc     mpc85xx     c29xpcie            freescale      -           C29XPCIE:C292PCIE,36BIT,SPIFLASH
+C293PCIE                     powerpc     mpc85xx     c29xpcie            freescale      -           C29XPCIE:C293PCIE,36BIT
+C293PCIE_SPIFLASH            powerpc     mpc85xx     c29xpcie            freescale      -           C29XPCIE:C293PCIE,36BIT,SPIFLASH
 P1010RDB_36BIT_NAND          powerpc     mpc85xx     p1010rdb            freescale      -           P1010RDB:P1010RDB,36BIT,NAND
 P1010RDB_36BIT_NAND_SECBOOT  powerpc     mpc85xx     p1010rdb            freescale      -           P1010RDB:P1010RDB,36BIT,NAND_SECBOOT,SECURE_BOOT
 P1010RDB_36BIT_NOR           powerpc     mpc85xx     p1010rdb            freescale      -           P1010RDB:P1010RDB,36BIT
@@ -772,6 +778,10 @@ P1020RDB-PC_SDCARD           powerpc     mpc85xx     p1_p2_rdb_pc        freesca
 P1020RDB-PC_SPIFLASH         powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1020RDB,SPIFLASH
 P1020RDB_SDCARD              powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P1020RDB,SDCARD
 P1020RDB_SPIFLASH            powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P1020RDB,SPIFLASH
+P1020RDB-PD                  powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1020RDB_PD
+P1020RDB-PD_NAND             powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1020RDB_PD,NAND
+P1020RDB-PD_SDCARD           powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1020RDB_PD,SDCARD
+P1020RDB-PD_SPIFLASH         powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1020RDB_PD,SPIFLASH
 P1020UTM-PC                  powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1020UTM
 P1020UTM-PC_36BIT            powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1020UTM,36BIT
 P1020UTM-PC_36BIT_SDCARD     powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1020UTM,36BIT,SDCARD
@@ -785,11 +795,14 @@ P1021RDB-PC_NAND             powerpc     mpc85xx     p1_p2_rdb_pc        freesca
 P1021RDB-PC_SDCARD           powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1021RDB,SDCARD
 P1021RDB-PC_SPIFLASH         powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1021RDB,SPIFLASH
 P1022DS                      powerpc     mpc85xx     p1022ds             freescale
+P1022DS_NAND                 powerpc     mpc85xx     p1022ds             freescale	-	    P1022DS:NAND
+P1022DS_36BIT_NAND           powerpc     mpc85xx     p1022ds             freescale	-	    P1022DS:36BIT,NAND
 P1022DS_SPIFLASH             powerpc     mpc85xx     p1022ds             freescale	-	    P1022DS:SPIFLASH
 P1022DS_36BIT_SPIFLASH       powerpc     mpc85xx     p1022ds             freescale	-	    P1022DS:36BIT,SPIFLASH
 P1022DS_SDCARD               powerpc     mpc85xx     p1022ds             freescale	-	    P1022DS:SDCARD
 P1022DS_36BIT_SDCARD         powerpc     mpc85xx     p1022ds             freescale	-	    P1022DS:36BIT,SDCARD
 P1022DS_36BIT                powerpc     mpc85xx     p1022ds             freescale      -           P1022DS:36BIT
+P1023RDB                     powerpc     mpc85xx     p1023rdb            freescale      -           P1023RDB
 P1023RDS                     powerpc     mpc85xx     p1023rds            freescale      -           P1023RDS
 P1023RDS_NAND                powerpc     mpc85xx     p1023rds            freescale      -           P1023RDS:NAND
 P1024RDB                     powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1024RDB
@@ -802,6 +815,7 @@ P1025RDB_36BIT               powerpc     mpc85xx     p1_p2_rdb_pc        freesca
 P1025RDB_NAND                powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1025RDB,NAND
 P1025RDB_SDCARD              powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1025RDB,SDCARD
 P1025RDB_SPIFLASH            powerpc     mpc85xx     p1_p2_rdb_pc        freescale      -           p1_p2_rdb_pc:P1025RDB,SPIFLASH
+TWR-P1025                    powerpc     mpc85xx     p1_twr              freescale      -           p1_twr:TWR_P1025
 P2010RDB                     powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2010RDB
 P2010RDB_36BIT               powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2010RDB,36BIT
 P2010RDB_36BIT_SDCARD        powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2010RDB,36BIT,SDCARD
@@ -836,6 +850,8 @@ P2041RDB_NAND	             powerpc     mpc85xx     p2041rdb            freescale
 P2041RDB_SDCARD              powerpc     mpc85xx     p2041rdb            freescale      -           P2041RDB:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
 P2041RDB_SECURE_BOOT         powerpc     mpc85xx     p2041rdb            freescale      -           P2041RDB:SECURE_BOOT
 P2041RDB_SPIFLASH            powerpc     mpc85xx     p2041rdb            freescale      -           P2041RDB:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
+ACCTON_AS6700_32X-R0         powerpc     mpc85xx     as6700_32x          freescale      -           ACCTON_AS6700_32X-R0:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
+ACCTON_AS6700_32X-R1         powerpc     mpc85xx     as6700_32x          freescale      -           ACCTON_AS6700_32X-R1:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
 P2041RDB_SRIO_PCIE_BOOT          powerpc     mpc85xx     p2041rdb          freescale      -           P2041RDB:SRIO_PCIE_BOOT_SLAVE,SYS_TEXT_BASE=0xFFF80000
 P3041DS                      powerpc     mpc85xx     corenet_ds          freescale
 P3041DS_NAND		     powerpc     mpc85xx     corenet_ds          freescale      -           P3041DS:RAMBOOT_PBL,NAND,SYS_TEXT_BASE=0xFFF80000
@@ -855,13 +871,52 @@ P5020DS_SECURE_BOOT          powerpc     mpc85xx     corenet_ds          freesca
 P5020DS_SPIFLASH	     powerpc     mpc85xx     corenet_ds          freescale      -           P5020DS:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
 P5020DS_SRIO_PCIE_BOOT          powerpc     mpc85xx     corenet_ds          freescale      -           P5020DS:SRIO_PCIE_BOOT_SLAVE,SYS_TEXT_BASE=0xFFF80000
 P5040DS                      powerpc     mpc85xx     corenet_ds          freescale
+P5040DS_SECURE_BOOT          powerpc     mpc85xx     corenet_ds          freescale	-	    P5040DS:SECURE_BOOT
+P5040DS_NAND		     powerpc     mpc85xx     corenet_ds          freescale      -           P5040DS:RAMBOOT_PBL,NAND,SYS_TEXT_BASE=0xFFF80000
+P5040DS_SDCARD		     powerpc     mpc85xx     corenet_ds          freescale      -           P5040DS:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
+P5040DS_SPIFLASH	     powerpc     mpc85xx     corenet_ds          freescale      -           P5040DS:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
+BSC9131RDB_NAND              powerpc     mpc85xx     bsc9131rdb          freescale      -           BSC9131RDB:BSC9131RDB,NAND
+BSC9131RDB_NAND_SYSCLK100    powerpc     mpc85xx     bsc9131rdb          freescale      -           BSC9131RDB:BSC9131RDB,NAND,SYS_CLK_100
 BSC9131RDB_SPIFLASH          powerpc     mpc85xx     bsc9131rdb          freescale      -           BSC9131RDB:BSC9131RDB,SPIFLASH
+BSC9131RDB_SPIFLASH_SYSCLK100 powerpc     mpc85xx     bsc9131rdb          freescale      -           BSC9131RDB:BSC9131RDB,SPIFLASH,SYS_CLK_100
+BSC9132QDS_NOR_DDRCLK100     powerpc     mpc85xx     bsc9132qds          freescale      -           BSC9132QDS:BSC9132QDS,SYS_CLK_100_DDR_100
+BSC9132QDS_NOR_DDRCLK133     powerpc     mpc85xx     bsc9132qds          freescale      -           BSC9132QDS:BSC9132QDS,SYS_CLK_100_DDR_133
+BSC9132QDS_NAND_DDRCLK100    powerpc     mpc85xx     bsc9132qds          freescale      -           BSC9132QDS:BSC9132QDS,NAND,SYS_CLK_100_DDR_100
+BSC9132QDS_NAND_DDRCLK133    powerpc     mpc85xx     bsc9132qds          freescale      -           BSC9132QDS:BSC9132QDS,NAND,SYS_CLK_100_DDR_133
+BSC9132QDS_SDCARD_DDRCLK100  powerpc     mpc85xx     bsc9132qds          freescale      -           BSC9132QDS:BSC9132QDS,SDCARD,SYS_CLK_100_DDR_100
+BSC9132QDS_SDCARD_DDRCLK133  powerpc     mpc85xx     bsc9132qds          freescale      -           BSC9132QDS:BSC9132QDS,SDCARD,SYS_CLK_100_DDR_133
+BSC9132QDS_SPIFLASH_DDRCLK100 powerpc    mpc85xx     bsc9132qds          freescale      -           BSC9132QDS:BSC9132QDS,SPIFLASH,SYS_CLK_100_DDR_100
+BSC9132QDS_SPIFLASH_DDRCLK133 powerpc    mpc85xx     bsc9132qds          freescale      -           BSC9132QDS:BSC9132QDS,SPIFLASH,SYS_CLK_100_DDR_133
+BSC9132QDS_NOR_DDRCLK100_SECURE_BOOT       powerpc     mpc85xx     bsc9132qds    freescale      -   BSC9132QDS:BSC9132QDS,SYS_CLK_100_DDR_100,SECURE_BOOT
+BSC9132QDS_NOR_DDRCLK133_SECURE_BOOT       powerpc     mpc85xx     bsc9132qds    freescale      -   BSC9132QDS:BSC9132QDS,SYS_CLK_100_DDR_133,SECURE_BOOT
+BSC9132QDS_NAND_DDRCLK100_SECURE_BOOT      powerpc     mpc85xx     bsc9132qds    freescale      -   BSC9132QDS:BSC9132QDS,NAND_SECBOOT,SYS_CLK_100_DDR_100,SECURE_BOOT
+BSC9132QDS_NAND_DDRCLK133_SECURE_BOOT      powerpc     mpc85xx     bsc9132qds    freescale      -   BSC9132QDS:BSC9132QDS,NAND_SECBOOT,SYS_CLK_100_DDR_133,SECURE_BOOT
+BSC9132QDS_SDCARD_DDRCLK100_SECURE_BOOT    powerpc     mpc85xx     bsc9132qds    freescale      -   BSC9132QDS:BSC9132QDS,SDCARD,SYS_CLK_100_DDR_100,SECURE_BOOT
+BSC9132QDS_SDCARD_DDRCLK133_SECURE_BOOT    powerpc     mpc85xx     bsc9132qds    freescale      -   BSC9132QDS:BSC9132QDS,SDCARD,SYS_CLK_100_DDR_133,SECURE_BOOT
+BSC9132QDS_SPIFLASH_DDRCLK100_SECURE_BOOT  powerpc     mpc85xx     bsc9132qds    freescale      -   BSC9132QDS:BSC9132QDS,SPIFLASH,SYS_CLK_100_DDR_100,SECURE_BOOT
+BSC9132QDS_SPIFLASH_DDRCLK133_SECURE_BOOT  powerpc     mpc85xx     bsc9132qds    freescale      -   BSC9132QDS:BSC9132QDS,SPIFLASH,SYS_CLK_100_DDR_133,SECURE_BOOT
 stxgp3                       powerpc     mpc85xx     stxgp3              stx
 stxssa                       powerpc     mpc85xx     stxssa              stx            -           stxssa
 stxssa_4M                    powerpc     mpc85xx     stxssa              stx            -           stxssa:STXSSA_4M
-T4240QDS                     powerpc     mpc85xx     t4qds               freescale
-T4240QDS_SDCARD              powerpc     mpc85xx     t4qds               freescale	-           T4240QDS:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
-T4240QDS_SPIFLASH            powerpc     mpc85xx     t4qds               freescale	-           T4240QDS:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
+T4240QDS                     powerpc     mpc85xx     t4qds               freescale      -           T4240QDS:PPC_T4240
+T4240QDS_SECURE_BOOT         powerpc     mpc85xx     t4qds               freescale      -           T4240QDS:PPC_T4240,SECURE_BOOT
+T4240EMU                     powerpc     mpc85xx     t4qds               freescale	-           T4240EMU:PPC_T4240
+T4240EMU_AP1                 powerpc     mpc85xx     t4qds               freescale	-           T4240EMU:PPC_T4240,SYS_FSL_EMU_AP1
+T4240QDS_SDCARD              powerpc     mpc85xx     t4qds               freescale	-           T4240QDS:PPC_T4240,RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
+T4240QDS_SPIFLASH            powerpc     mpc85xx     t4qds               freescale	-           T4240QDS:PPC_T4240,RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
+T4240QDS_SRIO_PCIE_BOOT	     powerpc     mpc85xx     t4qds            freescale      -           T4240QDS:PPC_T4240,SRIO_PCIE_BOOT_SLAVE,SYS_TEXT_BASE=0xFFF80000
+T4160QDS                     powerpc     mpc85xx     t4qds               freescale      -           T4240QDS:PPC_T4160
+T4160QDS_SECURE_BOOT         powerpc     mpc85xx     t4qds               freescale      -           T4240QDS:PPC_T4160,SECURE_BOOT
+T4160QDS_SDCARD              powerpc     mpc85xx     t4qds               freescale	-           T4240QDS:PPC_T4160,RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
+T4160QDS_SPIFLASH            powerpc     mpc85xx     t4qds               freescale	-           T4240QDS:PPC_T4160,RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
+T4160QDS_SRIO_PCIE_BOOT	     powerpc     mpc85xx     t4qds            freescale      -           T4240QDS:PPC_T4160,SRIO_PCIE_BOOT_SLAVE,SYS_TEXT_BASE=0xFFF80000
+B4860QDS                     powerpc     mpc85xx     b4860qds            freescale      -           B4860QDS:PPC_B4860
+B4860QDS_SECURE_BOOT         powerpc     mpc85xx     b4860qds            freescale      -           B4860QDS:PPC_B4860,SECURE_BOOT
+B4860QDS_NAND		     powerpc     mpc85xx     b4860qds            freescale      -           B4860QDS:PPC_B4860,RAMBOOT_PBL,NAND,SYS_TEXT_BASE=0xFFF80000
+B4860QDS_SRIO_PCIE_BOOT	     powerpc     mpc85xx     b4860qds            freescale      -           B4860QDS:PPC_B4860,SRIO_PCIE_BOOT_SLAVE,SYS_TEXT_BASE=0xFFF80000
+B4420QDS                     powerpc     mpc85xx     b4860qds            freescale	-	    B4860QDS:PPC_B4420
+B4420QDS_NAND		     powerpc     mpc85xx     b4860qds            freescale      -           B4860QDS:PPC_B4420,RAMBOOT_PBL,NAND,SYS_TEXT_BASE=0xFFF80000
+T1040QDS                     powerpc     mpc85xx     t1040qds            freescale      -
 xpedite520x                  powerpc     mpc85xx     -                   xes
 xpedite537x                  powerpc     mpc85xx     -                   xes
 xpedite550x                  powerpc     mpc85xx     -                   xes
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index 48cdd16..daac62f 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -65,6 +65,12 @@ static void print_mhz(const char *name, unsigned long hz)
 }
 
 #if defined(CONFIG_PPC)
+static void __board_detail(void)
+{
+	/* Please define boot_detail() for your platform */
+}
+
+void board_detail(void) __attribute__((weak, alias("__board_detail")));
 
 int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -150,6 +156,7 @@ int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	printf("IP addr     = %s\n", getenv("ipaddr"));
 	printf("baudrate    = %6u bps\n", bd->bi_baudrate);
 	print_num("relocaddr", gd->relocaddr);
+	board_detail();
 	return 0;
 }
 
diff --git a/common/cmd_cache.c b/common/cmd_cache.c
index 5512f92..c228e0c 100644
--- a/common/cmd_cache.c
+++ b/common/cmd_cache.c
@@ -120,3 +120,29 @@ U_BOOT_CMD(
 	"[on, off, flush]\n"
 	"    - enable, disable, or flush data (writethrough) cache"
 );
+
+#ifdef CONFIG_CMD_CACHE_FLUSH
+int do_flush_cache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong addr, size;
+
+	switch (argc) {
+	case 3:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		size = simple_strtoul(argv[2], NULL, 16);
+		flush_cache(addr, size);
+		break;
+	default:
+		return cmd_usage(cmdtp);
+	}
+	return 0;
+
+}
+
+U_BOOT_CMD(
+	flush,   3,   0,     do_flush_cache,
+	"flush cache for a range",
+	"<addr> <size>\n"
+	"    - flush cache for specificed range"
+);
+#endif
diff --git a/common/cmd_mmc.c b/common/cmd_mmc.c
index 7dacd51..732ed7f 100644
--- a/common/cmd_mmc.c
+++ b/common/cmd_mmc.c
@@ -131,9 +131,8 @@ static int do_mmcinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	mmc = find_mmc_device(curr_device);
 
 	if (mmc) {
-		mmc_init(mmc);
-
-		print_mmcinfo(mmc);
+		if (!mmc_init(mmc))
+			print_mmcinfo(mmc);
 		return 0;
 	} else {
 		printf("no mmc device at slot %x\n", curr_device);
@@ -171,8 +170,6 @@ static int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			return 1;
 		}
 
-		mmc->has_init = 0;
-
 		if (mmc_init(mmc))
 			return 1;
 		else
diff --git a/common/cmd_sf.c b/common/cmd_sf.c
index b175358..099a3cb 100644
--- a/common/cmd_sf.c
+++ b/common/cmd_sf.c
@@ -5,8 +5,8 @@
  * Licensed under the GPL-2 or later.
  */
 
-#include <div64.h>
 #include <common.h>
+#include <div64.h>
 #include <malloc.h>
 #include <spi_flash.h>
 
@@ -234,7 +234,7 @@ static int do_spi_flash_read_write(int argc, char * const argv[])
 	unsigned long len;
 	void *buf;
 	char *endp;
-	int ret;
+	int ret = 1;
 
 	if (argc < 4)
 		return -1;
@@ -264,19 +264,23 @@ static int do_spi_flash_read_write(int argc, char * const argv[])
 
 	if (strcmp(argv[0], "update") == 0)
 		ret = spi_flash_update(flash, offset, len, buf);
-	else if (strcmp(argv[0], "read") == 0)
+    else if (strncmp(argv[0], "read", 4) == 0 ||
+                    strncmp(argv[0], "write", 5) == 0) {
+        int read;
+
+        read = strncmp(argv[0], "read", 4) == 0;
+        if (read)
 		ret = spi_flash_read(flash, offset, len, buf);
 	else
 		ret = spi_flash_write(flash, offset, len, buf);
 
-	unmap_physmem(buf, len);
+        printf("SF: %zu bytes @ %#x %s: %s\n", (size_t)len, (u32)offset,
+                read ? "Read" : "Written", ret ? "ERROR" : "OK");
+    }
 
-	if (ret) {
-		printf("SPI flash %s failed\n", argv[0]);
-		return 1;
-	}
+	unmap_physmem(buf, len);
 
-	return 0;
+	return ret == 0 ? 0 : 1;
 }
 
 static int do_spi_flash_erase(int argc, char * const argv[])
@@ -305,12 +309,10 @@ static int do_spi_flash_erase(int argc, char * const argv[])
 	}
 
 	ret = spi_flash_erase(flash, offset, len);
-	if (ret) {
-		printf("SPI flash %s failed\n", argv[0]);
-		return 1;
-	}
+    printf("SF: %zu bytes @ %#x Erased: %s\n", (size_t)len, (u32)offset,
+        ret ? "ERROR" : "OK");
 
-	return 0;
+    return ret == 0 ? 0 : 1;
 }
 
 #ifdef CONFIG_CMD_SF_TEST
diff --git a/common/cmd_sys_eeprom.c b/common/cmd_sys_eeprom.c
index cf2ed1c..3677c1e 100644
--- a/common/cmd_sys_eeprom.c
+++ b/common/cmd_sys_eeprom.c
@@ -1199,18 +1199,35 @@ int mac_read_from_eeprom(void)
 
 	for (i = 0; i < min(maccount, CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS); i++) {
 		if (is_valid_ether_addr(macbase)) {
-			char ethaddr[18];
+            char ethaddr[18], *env;
 			char enetvar[11];
 
 			sprintf(ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
 				macbase[0], macbase[1], macbase[2],
 				macbase[3], macbase[4], macbase[5]);
 			sprintf(enetvar, i ? "eth%daddr" : "ethaddr", i);
+
+#if 1
+            /* aaron_lien, 2013/08/05,
+             * Initialize $ethaddr if it is blank or
+             * if the current value is different from non-volatile board information
+             * then change it.
+             */
+            env = getenv(enetvar);
+            if (!env) {
+                setenv(enetvar, ethaddr);
+            } else {
+                if(strcmp(env, ethaddr))
+                    setenv(enetvar, ethaddr);
+            }
+
+#else
 			/* Only initialize environment variables that are blank
 			 * (i.e. have not yet been set)
 			 */
 			if (!getenv(enetvar))
 				setenv(enetvar, ethaddr);
+#endif
 
 			macbase[5]++;
 			if (macbase[5] == 0) {
@@ -1274,3 +1291,36 @@ int populate_serial_number(void)
 }
 
 #endif /* CONFIG_POPULATE_SERIAL_NUMBER */
+
+/* ------------------------------------------------------------------------
+ * FUNCTION NAME: populate_env
+ * PURPOSE:	Read the board information from non-volatile device and
+ *          set the appropriate environment variable.
+ * INPUT:   None
+ * OUTPUT:	None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ * NOTES:
+ *  The environment variable is set always.
+ */
+int populate_env(char *env_name,  u8 type_code)
+{
+    char env_str_buf[257];
+    int index;
+    tlvinfo_tlv_t * tlv_item;
+
+    if (read_eeprom(eeprom)) {
+        printf("[Error] Failed to read board information.\n");
+        return -1;
+    }
+
+    if (tlvinfo_find_tlv(eeprom, type_code, &index)) {
+        tlv_item = (tlvinfo_tlv_t *) &eeprom[index];
+        memcpy(env_str_buf, tlv_item->value, tlv_item->length);
+        env_str_buf[tlv_item->length] = 0;
+        setenv(env_name, env_str_buf);
+    }
+
+    return 0;
+}
diff --git a/common/image.c b/common/image.c
index 95498e6..2edd747 100644
--- a/common/image.c
+++ b/common/image.c
@@ -830,6 +830,16 @@ int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
 	*rd_start = 0;
 	*rd_end = 0;
 
+#ifdef CONFIG_FASTPATH
+	if(argc >= 3 && strncmp(argv[2], "-f", 2) ==  0) {
+		/* Look for a "-f" which indicates to skip FASTPATH image block.*/
+		debug ("## Using FASTPATH application image\n");
+
+		/* At next line, we expect this image is a legacy mult-component image. */
+		argc=2;
+     }
+#endif
+
 	/*
 	 * Look for a '-' which indicates to ignore the
 	 * ramdisk argument
@@ -1675,7 +1685,7 @@ int boot_get_fdt(int flag, int argc, char * const argv[],
 			image_check_type(&images->legacy_hdr_os_copy,
 						IH_TYPE_MULTI)) {
 
-		ulong fdt_data, fdt_len;
+		ulong fdt_data, fdt_len, fdt_idx;
 
 		/*
 		 * Now check if we have a legacy multi-component image,
@@ -1685,8 +1695,14 @@ int boot_get_fdt(int flag, int argc, char * const argv[],
 			"component Image at %08lX\n",
 			(ulong)images->legacy_hdr_os);
 
-		image_multi_getimg(images->legacy_hdr_os, 2, &fdt_data,
-					&fdt_len);
+		fdt_idx=2;  /* default fdt index = 2 */
+#ifdef CONFIG_FASTPATH
+		if (argc >= 3 && strncmp(argv[2], "-f", 2) ==  0) {
+			fdt_idx = simple_strtoul(&argv[2][2], NULL, 10);  /* fdt image # */
+			debug("fdt is at image#%ld, argv[2]=%s\n", fdt_idx, argv[2]);
+		}
+#endif
+		image_multi_getimg(images->legacy_hdr_os, fdt_idx, &fdt_data, &fdt_len);
 		if (fdt_len) {
 
 			fdt_blob = (char *)fdt_data;
diff --git a/common/main.c b/common/main.c
index d43c6ae..b9777e1 100644
--- a/common/main.c
+++ b/common/main.c
@@ -53,6 +53,10 @@
 #include <linux/ctype.h>
 #include <menu.h>
 
+#ifdef CONFIG_SYNC_VERSION_VARIABLE_TO_FLASH
+#include <spi_flash.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 /*
@@ -348,6 +352,98 @@ static void process_fdt_options(const void *blob)
 #endif /* CONFIG_OF_CONTROL */
 
 
+
+
+#ifdef CONFIG_SYNC_VERSION_VARIABLE_TO_FLASH
+int update_uboot_version_variable_to_flash(void)
+{
+    char *var_str;
+    char *var;
+    unsigned int var_str_len;
+    unsigned int var_len;
+    int ret;
+    int i, j, k;
+    struct spi_flash *env_flash = NULL;
+
+    char *buff = (char *)malloc(sizeof(char)*CONFIG_ENV_SIZE);
+    if(buff==NULL)
+        printf("malloc fail\n");
+
+    memset(buff, 0, sizeof(char)*CONFIG_ENV_SIZE);
+
+#ifdef CONFIG_SPI_FLASH
+    env_flash = spi_flash_probe(CONFIG_ENV_SPI_BUS,
+            CONFIG_ENV_SPI_CS,
+            CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+    if(!env_flash)
+        printf("spi_flash_probe fail!\n");
+
+    ret = spi_flash_read(env_flash, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE, buff);
+    if(0 != ret)
+        printf("spi_flash_read fail\n");
+#else
+#error CONFIG_SPI_FLASH is not defined.
+#error This function only support updated uboot version variable to spi flash.
+#endif
+
+    i = 4; /*skip 4 bytes checksum of u-boot env*/
+    while(i < CONFIG_ENV_SIZE)
+    {
+        if(buff[i] == 0x3d) { /* 0x3d is '=' (equal sign) */
+
+            /*get env variable name*/
+            j = i;
+            var_len = 0;
+            while(j>3 && buff[j] != 0) {
+                j--;
+                var_len++;
+            }
+            var = (char *)malloc(sizeof(char)*var_len);
+            k = 0;
+            while(k<var_len-1) {
+                var[k] = buff[j+k+1];
+                k++;
+            }
+            var[k] = '\0';
+
+            /* find uboot version variable "ver" */
+            if (0 == strcmp(var, "ver")) {
+                /*get env variable value*/
+                var_str = &buff[i+1];
+
+                /* update ver if not match */
+                if (0 != strcmp(var_str, version_string)) {
+                    printf("update the uboot ver variable to flash.\n");
+                    saveenv();
+                    free(var);
+                    free(buff);
+                    return 0;
+                } else {
+                    /*match*/
+                    return 0;
+                }
+
+                var_str_len = strlen(var_str);
+                i += var_str_len;
+            }
+            free(var);
+        }
+        /*find next equal sign*/
+        i++;
+    }
+
+    /* update if ver not exist */
+    if(i>=CONFIG_ENV_SIZE) {
+        printf("Update the uboot \"ver\" variable to flash.\n");
+        saveenv();
+    }
+
+    free(buff);
+
+    return 0;
+}
+#endif
+
 /****************************************************************************/
 
 void main_loop (void)
@@ -402,6 +498,10 @@ void main_loop (void)
 #ifdef CONFIG_VERSION_VARIABLE
 	{
 		setenv ("ver", version_string);  /* set version variable */
+
+        #ifdef CONFIG_SYNC_VERSION_VARIABLE_TO_FLASH
+        update_uboot_version_variable_to_flash();
+        #endif
 	}
 #endif /* CONFIG_VERSION_VARIABLE */
 
@@ -1454,6 +1554,7 @@ static int builtin_run_command(const char *cmd, int flag)
 
 		if (cmd_process(flag, argc, argv, &repeatable))
 			rc = -1;
+
 #ifdef CONFIG_SYS_NO_REPEATABLE
 		repeatable = 0;
 #endif
diff --git a/common/usb.c b/common/usb.c
index 6fc0fc1..6cca567 100644
--- a/common/usb.c
+++ b/common/usb.c
@@ -77,7 +77,7 @@ static int asynch_allowed;
 char usb_started; /* flag for the started/stopped USB status */
 
 #ifndef CONFIG_USB_MAX_CONTROLLER_COUNT
-#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
 #endif
 
 /***************************************************************************
diff --git a/common/usb_storage.c b/common/usb_storage.c
index fb322b4..141337c 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -159,10 +159,11 @@ struct us_data {
 #ifdef CONFIG_USB_EHCI
 /*
  * The U-Boot EHCI driver can handle any transfer length as long as there is
- * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are
- * limited to 65535 blocks.
+ * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands
+ * are limited to 65535 blocks. However some of the popular devices do not
+ * respond with xfer data greater then 40 blocks
  */
-#define USB_MAX_XFER_BLK	65535
+#define USB_MAX_XFER_BLK	40
 #else
 #define USB_MAX_XFER_BLK	20
 #endif
@@ -714,7 +715,7 @@ static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
 	else
 		pipe = pipeout;
 	result = usb_bulk_msg(us->pusb_dev, pipe, srb->pdata, srb->datalen,
-			      &data_actlen, USB_CNTL_TIMEOUT * 5);
+			      &data_actlen, USB_CNTL_TIMEOUT * 20);
 	/* special handling of STALL in DATA phase */
 	if ((result < 0) && (us->pusb_dev->status & USB_ST_STALLED)) {
 		USB_STOR_PRINTF("DATA:stall\n");
@@ -742,7 +743,7 @@ st:
 again:
 	USB_STOR_PRINTF("STATUS phase\n");
 	result = usb_bulk_msg(us->pusb_dev, pipein, csw, UMASS_BBB_CSW_SIZE,
-				&actlen, USB_CNTL_TIMEOUT*5);
+				&actlen, USB_CNTL_TIMEOUT * 20);
 
 	/* special handling of STALL in STATUS phase */
 	if ((result < 0) && (retry < 1) &&
diff --git a/config.mk b/config.mk
index b7cd481..9f3cc05 100644
--- a/config.mk
+++ b/config.mk
@@ -189,7 +189,7 @@ endif
 # who are porting old code to latest mainline but not updating $(AR).
 ARFLAGS = $(error update your Makefile to use cmd_link_o_target and not AR)
 RELFLAGS= $(PLATFORM_RELFLAGS)
-DBGFLAGS= -g # -DDEBUG
+DBGFLAGS= -g -gdwarf-2 # -DDEBUG
 OPTFLAGS= -Os #-fomit-frame-pointer
 
 OBJCFLAGS += --gap-fill=0xff
diff --git a/doc/README.b4860qds b/doc/README.b4860qds
new file mode 100644
index 0000000..5da7b5e
--- /dev/null
+++ b/doc/README.b4860qds
@@ -0,0 +1,20 @@
+Overview
+--------
+The B4860QDS is a Freescale reference board that hosts the B4860 SoC (and variants).
+
+Memory map
+----------
+The addresses in brackets are physical addresses.
+
+0x0_0000_0000 (0x0_0000_0000) - 0x0_7fff_ffff   2GB DDR (more than 2GB is initialized but not mapped under with TLB)
+0x0_8000_0000 (0xc_0000_0000) - 0x0_8fff_ffff 512MB PCIE memory
+0x0_f000_0000 (0xf_0000_0000) - 0x0_f1ff_ffff  32MB DCSR (includes trace buffers)
+0x0_f400_0000 (0xf_f400_0000) - 0x0_f5ff_ffff  32MB BMan
+0x0_f600_0000 (0xf_f500_0000) - 0x0_f7ff_ffff  32MB QMan
+0x0_f800_0000 (0xf_f800_0000) - 0x0_f800_ffff  64KB PCIE IO
+0x0_e000_0000 (0xf_e000_0000) - 0x0_efff_ffff 256MB NOR flash
+0x0_fe00_0000 (0xf_fe00_0000) - 0x0_feff_ffff  16MB CCSR
+0x0_ffdf_0000 (0xf_ffdf_0000) - 0x0_ffdf_03ff   4KB QIXIS
+0x0_ffff_f000 (0x0_7fff_fff0) - 0x0_ffff_ffff   4KB Boot page translation for secondary cores
+
+The physical address of the last (boot page translation) varies with the actual DDR size.
diff --git a/doc/README.fsl-ddr b/doc/README.fsl-ddr
index 3992640..1243a12 100644
--- a/doc/README.fsl-ddr
+++ b/doc/README.fsl-ddr
@@ -263,23 +263,38 @@ Reference http://www.samsung.com/global/business/semiconductor/products/dram/dow
 Interactive DDR debugging
 ===========================
 
-For DDR parameter tuning up and debugging, the interactive DDR debugging can
-be activated by saving an environment variable "ddr_interactive". The value
-doesn't matter. Once activated, U-boot prompts "FSL DDR>" before enabling DDR
-controller. The available commands can be seen by typing "help".
+For DDR parameter tuning up and debugging, the interactive DDR debugger can
+be activated by setting the environment variable "ddr_interactive" to any
+value.  (The value of ddr_interactive may have a meaning in the future, but,
+for now, the presence of the variable will cause the debugger to run.)  Once
+activated, U-boot will show the prompt "FSL DDR>" before enabling the DDR
+controller.  The available commands are printed by typing "help".
+
+Another way to enter the interactive DDR debugger without setting the
+environment variable is to send the 'd' character early during the boot
+process.  To save booting time, no additional delay is added, so the window
+to send the key press is very short -- basically, it is the time before the
+memory controller code starts to run.  For example, when rebooting from
+within u-boot, the user must press 'd' IMMEDIATELY after hitting enter to
+initiate a 'reset' command.  In case of power on/reset, the user can hold
+down the 'd' key while applying power or hitting the board's reset button.
 
 The example flow of using interactive debugging is
 type command "compute" to calculate the parameters from the default
 type command "print" with arguments to show SPD, options, registers
 type command "edit" with arguments to change any if desired
+type command "copy" with arguments to copy controller/dimm settings
 type command "go" to continue calculation and enable DDR controller
+
+Additional commands to restart the debugging are:
 type command "reset" to reset the board
 type command "recompute" to reload SPD and start over
 
 Note, check "next_step" to show the flow. For example, after edit opts, the
 next_step is STEP_ASSIGN_ADDRESSES. After editing registers, the next_step is
-STEP_PROGRAM_REGS. Upon issuing command "go", DDR controller will be enabled
-with current setting without further calculation.
+STEP_PROGRAM_REGS.  Upon issuing command "go", the debugger will program the
+DDR controller with the current setting without further calculation and then
+exit to resume the booting of the machine.
 
 The detail syntax for each commands are
 
@@ -306,6 +321,10 @@ edit <c#> <d#> <spd|dimmparms|commonparms|opts|addresses|regs> <element> <value>
 			  byte number if the object is SPD
 	<value>		- decimal or heximal (prefixed with 0x) numbers
 
+copy <src c#> <src d#> <spd|dimmparms|commonparms|opts|addresses|regs> <dst c#> <dst d#>
+	same as for "edit" command
+	DIMM numbers ignored for commonparms, opts, and regs
+
 reset
 	no arguement	- reset the board
 
@@ -328,7 +347,7 @@ Examples of debugging flow
 
 	FSL DDR>compute
 	Detected UDIMM UG51U6400N8SU-ACF
-	SL DDR>print
+	FSL DDR>print
 	print [c<n>] [d<n>] [spd] [dimmparms] [commonparms] [opts] [addresses] [regs]
 	FSL DDR>print dimmparms
 	DIMM parameters:  Controller=0 DIMM=0
diff --git a/doc/README.p1010rdb b/doc/README.p1010rdb
new file mode 100644
index 0000000..cb9c236
--- /dev/null
+++ b/doc/README.p1010rdb
@@ -0,0 +1,199 @@
+Overview
+=========
+The P1010RDB is a Freescale reference design board that hosts the P1010 SoC.
+
+The P1010 is a cost-effective, low-power, highly integrated host processor
+based on a Power Architecture e500v2 core (maximum core frequency 800/1000 MHz),
+that addresses the requirements of several routing, gateways, storage, consumer,
+and industrial applications. Applications of interest include the main CPUs and
+I/O processors in network attached storage (NAS), the voice over IP (VoIP)
+router/gateway, and wireless LAN (WLAN) and industrial controllers.
+
+The P1010RDB board features are as follows:
+Memory subsystem:
+	- 1Gbyte unbuffered DDR3 SDRAM discrete devices (32-bit bus)
+	- 32 Mbyte NOR flash single-chip memory
+	- 32 Mbyte NAND flash memory
+	- 256 Kbit M24256 I2C EEPROM
+	- 16 Mbyte SPI memory
+	- I2C Board EEPROM 128x8 bit memory
+	- SD/MMC connector to interface with the SD memory card
+Interfaces:
+	- PCIe:
+		– Lane0: x1 mini-PCIe slot
+		– Lane1: x1 PCIe standard slot
+	- SATA:
+		– 1 internal SATA connector to 2.5” 160G SATA2 HDD
+		– 1 eSATA connector to rear panel
+	- 10/100/1000 BaseT Ethernet ports:
+		– eTSEC1, RGMII: one 10/100/1000 port using Vitesse VSC8641XKO
+		– eTSEC2, SGMII: one 10/100/1000 port using Vitesse VSC8221
+		– eTSEC3, SGMII: one 10/100/1000 port using Vitesse VSC8221
+	- USB 2.0 port:
+		– x1 USB2.0 port: via an ULPI PHY to micro-AB connector
+		– x1 USB2.0 poort via an internal PHY to micro-AB connector
+	- FlexCAN ports:
+		– x2 DB-9 female connectors for FlexCAN bus(revision 2.0B)
+		   interface;
+	- DUART interface:
+		– DUART interface: supports two UARTs up to 115200 bps for
+		   console display
+		– RJ45 connectors are used for these 2 UART ports.
+	- TDM
+		– 2 FXS ports connected via an external SLIC to the TDM
+		   interface. SLIC is controllled via SPI.
+		– 1 FXO port connected via a relay to FXS for switchover to
+		   POTS
+Board connectors:
+	- Mini-ITX power supply connector
+	- JTAG/COP for debugging
+IEEE Std. 1588 signals for test and measurement
+Real-time clock on I2C bus
+POR
+	- support critical POR setting changed via switch on board
+PCB
+	- 6-layer routing (4-layer signals, 2-layer power and ground)
+
+
+Serial Port Configuration on P1010RDB
+=====================================
+Configure the serial port of the attached computer with the following values:
+	-Data rate: 115200 bps
+	-Number of data bits: 8
+	-Parity: None
+	-Number of Stop bits: 1
+	-Flow Control: Hardware/None
+
+
+Settings of DIP-switch
+======================
+  SW4[1:4]= 1111 and SW6[4]=0 for boot from 16bit NOR flash
+  SW4[1:4]= 1000 and SW6[4]=1 for boot from 8bit NAND flash
+  SW4[1:4]= 0110 and SW6[4]=0 for boot from SPI flash
+Note: 1 stands for 'on', 0 stands for 'off'
+
+
+Setting of hwconfig
+===================
+If FlexCAN or TDM is needed, please set "fsl_p1010mux:tdm_can=can" or
+"fsl_p1010mux:tdm_can=tdm" explicitly in u-booot prompt as below for example:
+setenv hwconfig "fsl_p1010mux:tdm_can=tdm;usb1:dr_mode=host,phy_type=utmi"
+By default, don't set fsl_p1010mux:tdm_can, in this case, spi chip selection
+is set to spi-flash instead of to SLIC/TDM/DAC and tdm_can_sel is set to TDM
+instead of to CAN/UART1.
+
+
+Build and burn u-boot to NOR flash
+==================================
+1. Build u-boot.bin image
+	export ARCH=powerpc
+	export CROSS_COMPILE=/your_path/powerpc-linux-gnu-
+	make P1010RDB_NOR
+
+2. Burn u-boot.bin into NOR flash
+	=> tftp $loadaddr $uboot
+	=> protect off eff80000 +$filesize
+	=> erase eff80000 +$filesize
+	=> cp.b $loadaddr eff80000 $filesize
+
+3. Check SW4[1:4]= 1111 and SW6[4]=0, then power on.
+
+
+Alternate NOR bank
+============================
+1. Burn u-boot.bin into alternate NOR bank
+	=> tftp $loadaddr $uboot
+	=> protect off eef80000 +$filesize
+	=> erase eef80000 +$filesize
+	=> cp.b $loadaddr eef80000 $filesize
+
+2. Switch to alternate NOR bank
+	=> mw.b ffb00009 1
+	=> reset
+	or set SW1[8]= ON
+
+SW1[8]= OFF: Upper bank used for booting start
+SW1[8]= ON:  Lower bank used for booting start
+CPLD NOR bank selection register address 0xFFB00009 Bit[0]:
+0 - boot from upper 4 sectors
+1 - boot from lower 4 sectors
+
+
+Build and burn u-boot to NAND flash
+===================================
+1. Build u-boot.bin image
+	export ARCH=powerpc
+	export CROSS_COMPILE=/your_path/powerpc-linux-gnu-
+	make P1010RDB_NAND
+
+2. Burn u-boot-nand.bin into NAND flash
+	=> tftp $loadaddr $uboot-nand
+	=> nand erase 0 $filesize
+	=> nand write $loadaddr 0 $filesize
+
+3. Check SW4[1:4]= 1000 and SW6[4]=1, then power on.
+
+
+
+Build and burn u-boot to SPI flash
+==================================
+1. Build u-boot-spi.bin image
+	make P1010RDB_SPIFLASH_config; make
+	Boot up kernel with rootfs.ext2.gz.uboot.p1010rdb
+	Download u-boot.bin to linux and you can find some config files
+	under /usr/share such as config_xx.dat. Do below command:
+	boot_format config_ddr3_1gb_p1010rdb_800M.dat u-boot.bin -spi \
+			u-boot-spi.bin
+	to generate u-boot-spi.bin.
+
+2. Burn u-boot-spi.bin into SPI flash
+	=> tftp $loadaddr $uboot-spi
+	=> sf erase 0 100000
+	=> sf write $loadaddr 0 $filesize
+
+3. Check SW4[1:4]= 0110 and SW6[4]=0, then power on.
+
+
+
+CPLD POR setting registers
+==========================
+1. Set POR switch selection register (addr 0xFFB00011) to 0.
+2. Write CPLD POR registers (BCSR0~BCSR3, addr 0xFFB00014~0xFFB00017) with
+   proper values.
+   If change boot ROM location to NOR or NAND flash, need write the IFC_CS0
+   switch command by I2C.
+3. Send reset command.
+   After reset, the new POR setting will be implemented.
+
+Two examples are given in below:
+Switch from NOR to NAND boot with default frequency:
+	=> i2c dev 0
+	=> i2c mw 18 1 f9
+	=> i2c mw 18 3 f0
+	=> mw.b ffb00011 0
+	=> mw.b ffb00017 1
+	=> reset
+Switch from NAND to NOR boot with Core/CCB/DDR (800/400/667 MHz):
+	=> i2c dev 0
+	=> i2c mw 18 1 f1
+	=> i2c mw 18 3 f0
+	=> mw.b ffb00011 0
+	=> mw.b ffb00014 2
+	=> mw.b ffb00015 5
+	=> mw.b ffb00016 3
+	=> mw.b ffb00017 f
+	=> reset
+
+
+
+Boot Linux from network using TFTP on P1010RDB
+==============================================
+Place uImage, p1010rdb.dtb and rootfs files in the TFTP disk area.
+	=> tftp 1000000 uImage
+	=> tftp 2000000 p1010rdb.dtb
+	=> tftp 3000000 rootfs.ext2.gz.uboot.p1010rdb
+	=> bootm 1000000 3000000 2000000
+
+
+Please contact your local field applications engineer or sales representative
+to obtain related documents, such as P1010-RDB User Guide for details.
diff --git a/doc/README.ramboot-ppc85xx b/doc/README.ramboot-ppc85xx
new file mode 100644
index 0000000..8ed45fb
--- /dev/null
+++ b/doc/README.ramboot-ppc85xx
@@ -0,0 +1,102 @@
+			RAMBOOT for MPC85xx Platforms
+			==============================
+
+RAMBOOT literally means boot from DDR. But since DDR is volatile memory some
+pre-mechanism is required to load the DDR with the bootloader binary.
+- In case of SD and SPI boot this is done by BootROM code inside the chip
+  itself.
+- In case of NAND boot FCM supports loading initial 4K code from NAND flash
+  which can initialize the DDR and get the complete bootloader copied to DDR.
+
+In addition to the above there could be some more methods to initialize the DDR
+and load it manually.
+Two of them are described below.There is also an explanation as to where these
+methods could be handy.
+1. Load the RAM based bootloader onto DDR via JTAG/BDI interface. And then
+   execute the bootloader from DDR.
+   This may be handy in the following cases:
+     - In very early stage of platform bringup where other boot options are not
+       functional because of various reasons.
+     - In case the support to program the flashes on the board is not available.
+
+2. Load the RAM based bootloader onto DDR using already existing bootloader on
+   the board.And then execute the bootloader from DDR.
+   Some usecases where this may be used:
+      - While developing some new feature of u-boot, for example USB driver or
+        SPI driver.
+        Suppose the board already has a working bootloader on it. And you would
+        prefer to keep it intact, at the same time want to test your bootloader.
+        In this case you can get your test bootloader binary into DDR via tftp
+        for example. Then execute the test bootloader.
+     - Suppose a platform already has a propreitery bootloader which does not
+       support for example AMP boot. In this case also RAM boot loader can be
+       utilized.
+
+   So basically when the original bootloader is required to be kept intact
+   RAM based bootloader can offer an updated bootloader on the system.
+
+Both the above Bootloaders are slight variants of SDcard or SPI Flash
+bootloader or for that matter even NAND bootloader.
+All of them define CONFIG_SYS_RAMBOOT.
+The main difference among all of them is the way the pre-environment is getting
+configured and who is doing that.
+- In case of SD card and SPI flash bootloader this is done by On Chip BootROM inside the Si itself.
+- In case of NAND boot SPL/TPL code does it with some support from Si itself.
+- In case of the pure RAM based bootloaders we have to do it by JTAG manually or already existing bootloader.
+
+How to use them:
+1. Using JTAG
+   Boot up in core hold off mode or stop the core after reset using JTAG
+   interface.
+   Preconfigure DDR/L2SRAM through JTAG interface.
+	- setup DDR controller registers.
+	- setup DDR LAWs
+	- setup DDR TLB
+   Load the RAM based boot loader to the proper location in DDR/L2SRAM.
+   set up IAR (Instruction counter properly)
+   Enable the core to execute.
+
+2. Using already existing bootloader.
+   get the rambased boot loader binary into DDR/L2SRAM via tftp.
+   execute the RAM based bootloader.
+      => tftp 11000000 u-boot-ram.bin
+      => go 1107f000
+
+Please note that L2SRAM can also be used instead of DDR if the SOC has
+sufficient size of L2SRAM.
+
+Necessary Code changes Required:
+=====================================
+Please note that below mentioned changes are for 85xx platforms.
+They have been tested on P1020/P2020/P1010 RDB.
+
+The main difference between the above two methods from technical perspective is
+that in 1st case SOC is just out of reset so it is in default configuration.
+(CCSRBAR is at 0xff700000).
+In the 2nd case bootloader has already re-located CCSRBAR to 0xffe00000
+
+1. File name-> boards.cfg
+   There can be added specific Make options for RAMBoot. We can keep different
+   options for the two cases mentioned above.
+   for example
+   P1020RDB_JTAG_RAMBOOT and P1020RDB_GO_RAMBOOT.
+
+2. platform config file
+   for example include/configs/P1_P2_RDB.h
+
+   #ifdef CONFIG_RAMBOOT
+   #define CONFIG_SDCARD
+   #endif
+
+   This will finally use the CONFIG_SYS_RAMBOOT.
+
+3. File name-> arch/powerpc/include/asm/config_mpc85xx.h
+   In the section of the particular SOC, for example P1020,
+
+   #if defined(CONFIG_GO)
+   #define CONFIG_SYS_CCSRBAR_DEFAULT	0xffe00000
+   #else
+   #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
+   #endif
+
+For JTAG  RAMBOOT this is not required because CCSRBAR is at ff700000.
diff --git a/doc/README.srio-pcie-boot-corenet b/doc/README.srio-pcie-boot-corenet
index cd7e7ee..7e68174 100644
--- a/doc/README.srio-pcie-boot-corenet
+++ b/doc/README.srio-pcie-boot-corenet
@@ -21,13 +21,13 @@ Environment of the SRIO or PCIE boot:
 	e) Slave's RCW should configure the SerDes for SRIO or PCIE boot port, set
 	   the boot location to SRIO or PCIE, and holdoff all the cores.
 
-	----------        -----------             -----------
-	|		  |       |         |             |         |
-	|		  |       |         |             |         |
+	-----------       -----------             -----------
+	|         |       |         |             |         |
+	|         |       |         |             |         |
 	| NorFlash|<----->| Master  |SRIO or PCIE |  Slave  |<---->[EEPROM]
-	|		  |       |         |<===========>|         |
-	|		  |       |         |             |         |
-	----------        -----------             -----------
+	|         |       |         |<===========>|         |
+	|         |       |         |             |         |
+	-----------       -----------             -----------
 
 The example based on P4080DS platform:
 	Two P4080DS platforms can be used to implement the boot from SRIO or PCIE.
diff --git a/doc/README.t4240qds b/doc/README.t4240qds
index 677d120..a9841fb 100644
--- a/doc/README.t4240qds
+++ b/doc/README.t4240qds
@@ -86,7 +86,7 @@ The addresses in brackets are physical addresses.
 
 0x0_0000_0000 (0x0_0000_0000) - 0x0_7fff_ffff   2GB DDR (more than 2GB is initialized but not mapped under with TLB)
 0x0_8000_0000 (0xc_0000_0000) - 0x0_dfff_ffff 1.5GB PCIE memory
-0x0_f000_0000 (0xf_0000_0000) - 0x0_f03f_ffff  4MB  DCSR
+0x0_f000_0000 (0xf_0000_0000) - 0x0_f1ff_ffff  32MB DCSR (includes trace buffers)
 0x0_f400_0000 (0xf_f400_0000) - 0x0_f5ff_ffff  32MB BMan
 0x0_f600_0000 (0xf_f600_0000) - 0x0_f7ff_ffff  32MB QMan
 0x0_f800_0000 (0xf_f800_0000) - 0x0_f803_ffff 256KB PCIE IO
@@ -96,3 +96,27 @@ The addresses in brackets are physical addresses.
 0x0_ffff_f000 (0x0_7fff_fff0) - 0x0_ffff_ffff   4KB Boot page translation for secondary cores
 
 The physical address of the last (boot page translation) varies with the actual DDR size.
+
+Voltage ID and VDD override
+--------------------
+T4240 has a VID feature. U-boot reads the VID efuses and adjust the voltage
+accordingly. The voltage can also be override by command vdd_override. The
+syntax is
+
+vdd_override <voltage in mV>, eg. 1050 is for 1.050v.
+
+Upon success, the actual voltage will be read back. The value is checked
+for safety and any invalid value will not adjust the voltage.
+
+Another way to override VDD is to use environmental variable, in case of using
+command is too late for some debugging. The syntax is
+
+setenv t4240qds_vdd_mv <voltage in mV>
+saveenv
+reset
+
+The override voltage takes effect when booting.
+
+Note: voltage adjustment needs to be done step by step. Changing voltage too
+rapidly may cause current surge. The voltage stepping is done by software.
+Users can set the final voltage directly.
diff --git a/doc/SPI/README.dual-flash b/doc/SPI/README.dual-flash
new file mode 100644
index 0000000..73d29ba
--- /dev/null
+++ b/doc/SPI/README.dual-flash
@@ -0,0 +1,92 @@
+SPI/QSPI Dual flash connection modes:
+=====================================
+
+This describes how SPI/QSPI flash memories are connected to a given
+controller in a single chip select line.
+
+Current spi_flash framework supports, single flash memory connected
+to a given controller with single chip select line, but there are some
+hw logics(ex: xilinx zynq qspi) that describes two/dual memories are
+connected with a single chip select line from a controller.
+
+"dual_flash" from include/spi.h describes these types of connection mode
+
+Possible connections:
+--------------------
+SF_SINGLE_FLASH:
+       - single spi flash memory connected with single chip select line.
+
+  +------------+             CS         +---------------+
+  |            |----------------------->|               |
+  | Controller |         I0[3:0]        | Flash memory  |
+  | SPI/QSPI   |<======================>| (SPI/QSPI)    |
+  |            |           CLK          |               |
+  |            |----------------------->|               |
+  +------------+                        +---------------+
+
+SF_DUAL_STACKED_FLASH:
+       - dual spi/qspi flash memories are connected with a single chipselect
+         line and these two memories are operating stacked fasion with shared buses.
+       - xilinx zynq qspi controller has implemented this feature [1]
+
+  +------------+        CS             +---------------+
+  |            |---------------------->|               |
+  |            |              I0[3:0]  | Upper Flash   |
+  |            |            +=========>| memory        |
+  |            |            |     CLK  | (SPI/QSPI)    |
+  |            |            |    +---->|               |
+  | Controller |        CS  |    |     +---------------+
+  | SPI/QSPI   |------------|----|---->|               |
+  |            |    I0[3:0] |    |     | Lower Flash   |
+  |            |<===========+====|====>| memory        |
+  |            |          CLK    |     | (SPI/QSPI)    |
+  |            |-----------------+---->|               |
+  +------------+                       +---------------+
+
+       - two memory flash devices should has same hw part attributes (like size,
+         vendor..etc)
+       - Configurations:
+               on LQSPI_CFG register, Enable TWO_MEM[BIT:30] on LQSPI_CFG
+               Enable U_PAGE[BIT:28] if U_PAGE flag set - upper memory
+               Disable U_PAGE[BIT:28] if U_PAGE flag unset - lower memory
+       - Operation:
+               accessing memories serially like one after another.
+               by default, if U_PAGE is unset lower memory should accessible,
+               once user wants to access upper memory need to set U_PAGE.
+
+SPI_FLASH_CONN_DUALPARALLEL:
+       - dual spi/qspi flash memories are connected with a single chipselect
+         line and these two memories are operating parallel with separate buses.
+       - xilinx zynq qspi controller has implemented this feature [1]
+
+  +-------------+           CS         +---------------+
+  |            |---------------------->|               |
+  |            |        I0[3:0]        | Upper Flash   |
+  |            |<=====================>| memory        |
+  |            |          CLK          | (SPI/QSPI)    |
+  |            |---------------------->|               |
+  | Controller |           CS          +---------------+
+  | SPI/QSPI   |---------------------->|               |
+  |            |        I0[3:0]        | Lower Flash   |
+  |            |<=====================>| memory        |
+  |            |          CLK          | (SPI/QSPI)    |
+  |            |---------------------->|               |
+  +-------------+                      +---------------+
+
+       - two memory flash devices should has same hw part attributes (like size,
+         vendor..etc)
+       - Configurations:
+               Need to enable SEP_BUS[BIT:29],TWO_MEM[BIT:30] on LQSPI_CFG register.
+       - Operation:
+               Even bits, i.e. bit 0, 2, 4 ., of a data word is located in the lower memory
+               and odd bits, i.e. bit 1, 3, 5, ., of a data word is located in the upper memory.
+
+Note: Technically there is only one CS line from the controller, but
+zynq qspi controller has an internal hw logic to enable additional CS
+when controller is configured for dual memories.
+
+[1] http://www.xilinx.com/support/documentation/user_guides/ug585-Zynq-7000-TRM.pdf
+
+--
+Jagannadha Sutradharudu Teki <jaganna@xilinx.com>
+05-01-2014.
diff --git a/drivers/i2c/fsl_i2c.c b/drivers/i2c/fsl_i2c.c
index 3cb232f..015e624 100644
--- a/drivers/i2c/fsl_i2c.c
+++ b/drivers/i2c/fsl_i2c.c
@@ -60,12 +60,25 @@ static unsigned int i2c_bus_num __attribute__ ((section (".data"))) = CONFIG_SYS
 static unsigned int i2c_bus_num_mux __attribute__ ((section ("data"))) = 0;
 #endif
 
-static unsigned int i2c_bus_speed[2] = {CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SPEED};
+static unsigned int i2c_bus_speed[4] = {
+    CONFIG_SYS_I2C_SPEED,
+    CONFIG_SYS_I2C_SPEED,
+    CONFIG_SYS_I2C_SPEED,
+    CONFIG_SYS_I2C_SPEED
+};
 
-static const struct fsl_i2c *i2c_dev[2] = {
+static const struct fsl_i2c *i2c_dev[4] = {
 	(struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C_OFFSET),
 #ifdef CONFIG_SYS_I2C2_OFFSET
-	(struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C2_OFFSET)
+	(struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C2_OFFSET),
+#endif
+
+#ifdef CONFIG_SYS_I2C3_OFFSET
+	(struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C3_OFFSET),
+#endif
+
+#ifdef CONFIG_SYS_I2C4_OFFSET
+	(struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C4_OFFSET)
 #endif
 };
 
@@ -222,9 +235,63 @@ static unsigned int get_i2c_clock(int bus)
 		return gd->i2c1_clk;	/* I2C1 clock */
 }
 
+static int i2c_fixup(const struct fsl_i2c *dev)
+{
+	const unsigned long long timeout = usec2ticks(CONFIG_I2C_MBB_TIMEOUT);
+	unsigned long long timeval = 0;
+	int ret = -1;
+	unsigned int flags = 0;
+#ifdef CONFIG_SYS_FSL_ERRATUM_I2C_A004447
+	unsigned int svr = get_svr();
+
+	if ((SVR_SOC_VER(svr) == SVR_8548 && IS_SVR_REV(svr, 3, 1)) ||
+	    (SVR_SOC_VER(svr) == SVR_P1010 && IS_SVR_REV(svr, 1, 0)) ||
+	    (SVR_SOC_VER(svr) == SVR_P1023 && (svr & 0xff) <= 0x11) ||
+	    (SVR_SOC_VER(svr) == SVR_P3041 && (svr & 0xff) <= 0x20) ||
+	    (SVR_SOC_VER(svr) == SVR_P4080 && (svr & 0xff) <= 0x20) ||
+	    (SVR_SOC_VER(svr) == SVR_P5020 && (svr & 0xff) <= 0x20) ||
+	    (SVR_SOC_VER(svr) == SVR_9131 && (svr & 0xff) <= 0x11))
+		flags = I2C_CR_BIT6;
+#endif
+
+	writeb(I2C_CR_MEN | I2C_CR_MSTA, &dev->cr);
+
+	timeval = get_ticks();
+	while (!(readb(&dev->sr) & I2C_SR_MBB)) {
+		if ((get_ticks() - timeval) > timeout)
+			goto err;
+	}
+
+	if (readb(&dev->sr) & I2C_SR_MAL) {
+		/* SDA is stuck low */
+		writeb(0, &dev->cr);
+		udelay(100);
+		writeb(I2C_CR_MSTA | flags, &dev->cr);
+		writeb(I2C_CR_MEN | I2C_CR_MSTA | flags, &dev->cr);
+	}
+
+	readb(&dev->dr);
+
+	timeval = get_ticks();
+	while (!(readb(&dev->sr) & I2C_SR_MIF)) {
+		if ((get_ticks() - timeval) > timeout)
+			goto err;
+	}
+	ret = 0;
+
+err:
+	writeb(I2C_CR_MEN | flags, &dev->cr);
+	writeb(0, &dev->sr);
+	udelay(100);
+
+	return ret;
+}
+
 void
 i2c_init(int speed, int slaveadd)
 {
+	const unsigned long long timeout = usec2ticks(CONFIG_I2C_MBB_TIMEOUT);
+	unsigned long long timeval;
 	const struct fsl_i2c *dev;
 	unsigned int temp;
 	int bus_num, i;
@@ -236,10 +303,23 @@ i2c_init(int speed, int slaveadd)
 	*/
 	i2c_init_board();
 #endif
+
+    bus_num = 0;
+
+#ifdef CONFIG_SYS_I2C_OFFSET
+    bus_num += 1;
+#endif
+
 #ifdef CONFIG_SYS_I2C2_OFFSET
-	bus_num = 2;
-#else
-	bus_num = 1;
+    bus_num += 1;
+#endif
+
+#ifdef CONFIG_SYS_I2C3_OFFSET
+    bus_num += 1;
+#endif
+
+#ifdef CONFIG_SYS_I2C4_OFFSET
+	bus_num += 1;
 #endif
 	for (i = 0; i < bus_num; i++) {
 		dev = i2c_dev[i];
@@ -252,6 +332,17 @@ i2c_init(int speed, int slaveadd)
 		writeb(slaveadd << 1, &dev->adr);/* write slave address */
 		writeb(0x0, &dev->sr);		/* clear status register */
 		writeb(I2C_CR_MEN, &dev->cr);	/* start I2C controller */
+
+		timeval = get_ticks();
+		while (readb(&dev->sr) & I2C_SR_MBB) {
+			if ((get_ticks() - timeval) < timeout)
+				continue;
+
+			if (i2c_fixup(dev))
+				debug("i2c_init: BUS#%d failed to init\n", i);
+
+			break;
+		}
 	}
 
 #ifdef CONFIG_SYS_I2C_BOARD_LATE_INIT
@@ -383,8 +474,10 @@ i2c_read(u8 dev, uint addr, int alen, u8 *data, int length)
 	int i = -1; /* signal error */
 	u8 *a = (u8*)&addr;
 
-	if (i2c_wait4bus() >= 0
-	    && i2c_write_addr(dev, I2C_WRITE_BIT, 0) != 0
+	if (i2c_wait4bus())
+		return -1;
+
+	if (i2c_write_addr(dev, I2C_WRITE_BIT, 0) != 0
 	    && __i2c_write(&a[4 - alen], alen) == alen)
 		i = 0; /* No error so far */
 
@@ -409,8 +502,10 @@ i2c_write(u8 dev, uint addr, int alen, u8 *data, int length)
 	int i = -1; /* signal error */
 	u8 *a = (u8*)&addr;
 
-	if (i2c_wait4bus() >= 0
-	    && i2c_write_addr(dev, I2C_WRITE_BIT, 0) != 0
+	if (i2c_wait4bus())
+		return -1;
+
+	if (i2c_write_addr(dev, I2C_WRITE_BIT, 0) != 0
 	    && __i2c_write(&a[4 - alen], alen) == alen) {
 		i = __i2c_write(data, length);
 	}
@@ -453,11 +548,27 @@ int i2c_set_bus_num(unsigned int bus)
 	}
 	i2c_bus_num_mux = bus;
 #else
+    switch(bus)
+    {
+#ifdef CONFIG_SYS_I2C_OFFSET
+        case 0:
+            break;
+#endif
 #ifdef CONFIG_SYS_I2C2_OFFSET
-	if (bus > 1) {
-#else
-	if (bus > 0) {
+        case 1:
+            break;
+#endif
+
+#ifdef CONFIG_SYS_I2C3_OFFSET
+        case 2:
+            break;
+#endif
+
+#ifdef CONFIG_SYS_I2C4_OFFSET
+        case 3:
+            break;
 #endif
+        default:
 		return -1;
 	}
 
diff --git a/drivers/mmc/fsl_esdhc.c b/drivers/mmc/fsl_esdhc.c
index 3d5c9c0..589288b 100644
--- a/drivers/mmc/fsl_esdhc.c
+++ b/drivers/mmc/fsl_esdhc.c
@@ -100,7 +100,7 @@ static uint esdhc_xfertyp(struct mmc_cmd *cmd, struct mmc_data *data)
 	else if (cmd->resp_type & MMC_RSP_PRESENT)
 		xfertyp |= XFERTYP_RSPTYP_48;
 
-#ifdef CONFIG_MX53
+#if defined(CONFIG_MX53) || defined(CONFIG_T4240QDS)
 	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
 		xfertyp |= XFERTYP_CMDTYP_ABORT;
 #endif
@@ -178,7 +178,7 @@ static int esdhc_setup_data(struct mmc *mmc, struct mmc_data *data)
 	int timeout;
 	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
 	struct fsl_esdhc *regs = (struct fsl_esdhc *)cfg->esdhc_base;
-#ifndef CONFIG_SYS_FSL_ESDHC_USE_PIO
+#ifdef CONFIG_SYS_FSL_ESDHC_USE_PIO
 	uint wml_value;
 
 	wml_value = data->blocksize/4;
@@ -271,25 +271,43 @@ esdhc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 {
 	uint	xfertyp;
 	uint	irqstat;
+	uint	mask, timeout;
 	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
 	volatile struct fsl_esdhc *regs = (struct fsl_esdhc *)cfg->esdhc_base;
 
-#ifdef CONFIG_SYS_FSL_ERRATUM_ESDHC111
-	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
-		return 0;
-#endif
-
 	esdhc_write32(&regs->irqstat, -1);
 
 	sync();
 
-	/* Wait for the bus to be idle */
-	while ((esdhc_read32(&regs->prsstat) & PRSSTAT_CICHB) ||
-			(esdhc_read32(&regs->prsstat) & PRSSTAT_CIDHB))
-		;
+	mask = PRSSTAT_CICHB | PRSSTAT_CIDHB;
 
-	while (esdhc_read32(&regs->prsstat) & PRSSTAT_DLA)
-		;
+#ifdef CONFIG_SYS_FSL_ERRATUM_ESDHC111
+	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
+		return 0;
+#else
+	/*
+	 * We shouldn't wait for data inihibit for stop commands,
+	 * even though they might use busy signaling
+	 */
+	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
+		mask &= ~PRSSTAT_CIDHB;
+#endif
+
+	/*
+	 * Wait max 10ms for the bus to be idle
+	 * This redundancy check is intend to make sure the bus line
+	 * is ready to use and there is no other unknow err come from
+	 * the last command.
+	 */
+	timeout = 10;
+	while (esdhc_read32(&regs->prsstat) & mask) {
+		if (timeout == 0) {
+			printf("Controller never released inhibit bit(s).\n");
+			return COMM_ERR;
+		}
+		timeout--;
+		udelay(1000);
+	}
 
 	/* Wait at least 8 SD clock cycles before the next command */
 	/*
@@ -560,6 +578,12 @@ int fsl_esdhc_initialize(bd_t *bis, struct fsl_esdhc_cfg *cfg)
 	caps = caps & ~(ESDHC_HOSTCAPBLT_SRS |
 			ESDHC_HOSTCAPBLT_VS18 | ESDHC_HOSTCAPBLT_VS30);
 #endif
+
+/* T4240 host controller capabilities register should have VS33 bit */
+#ifdef CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
+	caps = caps | ESDHC_HOSTCAPBLT_VS33;
+#endif
+
 	if (caps & ESDHC_HOSTCAPBLT_VS18)
 		voltage_caps |= MMC_VDD_165_195;
 	if (caps & ESDHC_HOSTCAPBLT_VS30)
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 72e8ce6..b5d3bc8 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008, Freescale Semiconductor, Inc
+ * Copyright 2008,2011 Freescale Semiconductor, Inc
  * Andy Fleming
  *
  * Based vaguely on the Linux code
@@ -1083,9 +1083,17 @@ static int mmc_startup(struct mmc *mmc)
 		}
 
 		if (mmc->card_caps & MMC_MODE_HS)
+#ifdef CONFIG_SYS_FSL_ESDHC_P1010_BROKEN_SDCLK
+			mmc->tran_speed = 40000000;
+#else
 			mmc->tran_speed = 50000000;
+#endif
 		else
+#ifdef CONFIG_SYS_FSL_ESDHC_P1010_BROKEN_SDCLK
+			mmc->tran_speed = 20000000;
+#else
 			mmc->tran_speed = 25000000;
+#endif
 	} else {
 		int idx;
 
@@ -1145,10 +1153,23 @@ static int mmc_startup(struct mmc *mmc)
 
 		if (mmc->card_caps & MMC_MODE_HS) {
 			if (mmc->card_caps & MMC_MODE_HS_52MHz)
+#ifdef CONFIG_SYS_FSL_ESDHC_P1010_BROKEN_SDCLK
+				mmc->tran_speed = 40000000;
+#else
 				mmc->tran_speed = 52000000;
+#endif
 			else
+#ifdef CONFIG_SYS_FSL_ESDHC_P1010_BROKEN_SDCLK
+				mmc->tran_speed = 20000000;
+#else
 				mmc->tran_speed = 26000000;
-		}
+#endif
+		} else
+#ifdef CONFIG_SYS_FSL_ESDHC_P1010_BROKEN_SDCLK
+			mmc->tran_speed = 15000000;
+#else
+			mmc->tran_speed = 20000000;
+#endif
 	}
 
 	mmc_set_clock(mmc, mmc->tran_speed);
@@ -1232,14 +1253,10 @@ int mmc_init(struct mmc *mmc)
 	int err;
 
 	if (mmc_getcd(mmc) == 0) {
-		mmc->has_init = 0;
 		printf("MMC: no card present\n");
 		return NO_CARD_ERR;
 	}
 
-	if (mmc->has_init)
-		return 0;
-
 	err = mmc->init(mmc);
 
 	if (err)
@@ -1274,10 +1291,7 @@ int mmc_init(struct mmc *mmc)
 	}
 
 	err = mmc_startup(mmc);
-	if (err)
-		mmc->has_init = 0;
-	else
-		mmc->has_init = 1;
+
 	return err;
 }
 
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index c77c0c4..9d7deb8 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -82,6 +82,7 @@ COBJS-$(CONFIG_NAND_PLAT) += nand_plat.o
 else  # minimal SPL drivers
 
 COBJS-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_spl.o
+COBJS-$(CONFIG_NAND_FSL_IFC) += fsl_ifc_spl.o
 
 endif # drivers
 endif # nand
diff --git a/drivers/mtd/nand/fsl_elbc_nand.c b/drivers/mtd/nand/fsl_elbc_nand.c
index 834a8a6..fb34d12 100644
--- a/drivers/mtd/nand/fsl_elbc_nand.c
+++ b/drivers/mtd/nand/fsl_elbc_nand.c
@@ -756,20 +756,8 @@ static int fsl_elbc_chip_init(int devnum, u8 *addr)
 	nand->ecc.read_page = fsl_elbc_read_page;
 	nand->ecc.write_page = fsl_elbc_write_page;
 
-#ifdef CONFIG_FSL_ELBC_FMR
-	priv->fmr = CONFIG_FSL_ELBC_FMR;
-#else
 	priv->fmr = (15 << FMR_CWTO_SHIFT) | (2 << FMR_AL_SHIFT);
 
-	/*
-	 * Hardware expects small page has ECCM0, large page has ECCM1
-	 * when booting from NAND.  Board config can override if not
-	 * booting from NAND.
-	 */
-	if (or & OR_FCM_PGS)
-		priv->fmr |= FMR_ECCM;
-#endif
-
 	/* If CS Base Register selects full hardware ECC then use it */
 	if ((br & BR_DECC) == BR_DECC_CHK_GEN) {
 		nand->ecc.mode = NAND_ECC_HW;
@@ -786,11 +774,26 @@ static int fsl_elbc_chip_init(int devnum, u8 *addr)
 		nand->ecc.mode = NAND_ECC_SOFT;
 	}
 
+	ret = nand_scan_ident(mtd, 1, NULL);
+	if (ret)
+		return ret;
+
 	/* Large-page-specific setup */
-	if (or & OR_FCM_PGS) {
+	if (mtd->writesize == 2048) {
+		setbits_be32(&elbc_ctrl->regs->bank[priv->bank].or,
+			     OR_FCM_PGS);
+		in_be32(&elbc_ctrl->regs->bank[priv->bank].or);
+
 		priv->page_size = 1;
 		nand->badblock_pattern = &largepage_memorybased;
 
+		/*
+		 * Hardware expects small page has ECCM0, large page has
+		 * ECCM1 when booting from NAND, and we follow that even
+		 * when not booting from NAND.
+		 */
+		priv->fmr |= FMR_ECCM;
+
 		/* adjust ecc setup if needed */
 		if ((br & BR_DECC) == BR_DECC_CHK_GEN) {
 			nand->ecc.steps = 4;
@@ -798,12 +801,14 @@ static int fsl_elbc_chip_init(int devnum, u8 *addr)
 					   &fsl_elbc_oob_lp_eccm1 :
 					   &fsl_elbc_oob_lp_eccm0;
 		}
+	} else if (mtd->writesize == 512) {
+		clrbits_be32(&elbc_ctrl->regs->bank[priv->bank].or,
+			     OR_FCM_PGS);
+		in_be32(&elbc_ctrl->regs->bank[priv->bank].or);
+	} else {
+		return -ENODEV;
 	}
 
-	ret = nand_scan_ident(mtd, 1, NULL);
-	if (ret)
-		return ret;
-
 	ret = nand_scan_tail(mtd);
 	if (ret)
 		return ret;
diff --git a/drivers/mtd/nand/fsl_ifc_spl.c b/drivers/mtd/nand/fsl_ifc_spl.c
new file mode 100644
index 0000000..c4a9ba1
--- /dev/null
+++ b/drivers/mtd/nand/fsl_ifc_spl.c
@@ -0,0 +1,258 @@
+/*
+ * NAND boot for Freescale Integrated Flash Controller, NAND FCM
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ * Author: Dipen Dudhat <dipen.dudhat@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/fsl_ifc.h>
+#include <linux/mtd/nand.h>
+
+static inline int is_blank(uchar *addr, int page_size)
+{
+	int i;
+
+	for (i = 0; i < page_size; i++) {
+		if (__raw_readb(&addr[i]) != 0xff)
+			return 0;
+	}
+
+	/*
+	 * For the SPL, don't worry about uncorrectable errors
+	 * where the main area is all FFs but shouldn't be.
+	 */
+	return 1;
+}
+
+/* returns nonzero if entire page is blank */
+static inline int check_read_ecc(uchar *buf, u32 *eccstat,
+				 unsigned int bufnum, int page_size)
+{
+	u32 reg = eccstat[bufnum / 4];
+	int errors = (reg >> ((3 - bufnum % 4) * 8)) & 15;
+
+	if (errors == 15) { /* uncorrectable */
+		/* Blank pages fail hw ECC checks */
+		if (is_blank(buf, page_size))
+			return 1;
+
+		puts("ecc error\n");
+		for (;;)
+			;
+	}
+
+	return 0;
+}
+
+static inline void nand_wait(uchar *buf, int bufnum, int page_size)
+{
+	struct fsl_ifc *ifc = IFC_BASE_ADDR;
+	u32 status;
+	u32 eccstat[4];
+	int bufperpage = page_size / 512;
+	int bufnum_end, i;
+
+	bufnum *= bufperpage;
+	bufnum_end = bufnum + bufperpage - 1;
+
+	do {
+		status = in_be32(&ifc->ifc_nand.nand_evter_stat);
+	} while (!(status & IFC_NAND_EVTER_STAT_OPC));
+
+	if (status & IFC_NAND_EVTER_STAT_FTOER) {
+		puts("flash time out error\n");
+		for (;;)
+			;
+	}
+
+	for (i = bufnum / 4; i <= bufnum_end / 4; i++)
+		eccstat[i] = in_be32(&ifc->ifc_nand.nand_eccstat[i]);
+
+	for (i = bufnum; i <= bufnum_end; i++) {
+		if (check_read_ecc(buf, eccstat, i, page_size))
+			break;
+	}
+
+	out_be32(&ifc->ifc_nand.nand_evter_stat, status);
+}
+
+static inline int bad_block(uchar *marker, int port_size)
+{
+	if (port_size == 8)
+		return __raw_readb(marker) != 0xff;
+	else
+		return __raw_readw((u16 *)marker) != 0xffff;
+}
+
+static void nand_load(unsigned int offs, int uboot_size, uchar *dst)
+{
+	struct fsl_ifc *ifc = IFC_BASE_ADDR;
+	uchar *buf = (uchar *)CONFIG_SYS_NAND_BASE;
+	int page_size;
+	int port_size;
+	int pages_per_blk;
+	int blk_size;
+	int bad_marker = 0;
+	int bufnum_mask, bufnum;
+
+	int csor, cspr;
+	int pos = 0;
+	int j = 0;
+
+	int sram_addr;
+	int pg_no;
+
+	/* Get NAND Flash configuration */
+	csor = CONFIG_SYS_NAND_CSOR;
+	cspr = CONFIG_SYS_NAND_CSPR;
+
+	port_size = (cspr & CSPR_PORT_SIZE_16) ? 16 : 8;
+
+	if (csor & CSOR_NAND_PGS_4K) {
+		page_size = 4096;
+		bufnum_mask = 1;
+	} else if (csor & CSOR_NAND_PGS_2K) {
+		page_size = 2048;
+		bufnum_mask = 3;
+	} else {
+		page_size = 512;
+		bufnum_mask = 15;
+
+		if (port_size == 8)
+			bad_marker = 5;
+	}
+
+	pages_per_blk =
+		32 << ((csor & CSOR_NAND_PB_MASK) >> CSOR_NAND_PB_SHIFT);
+
+	blk_size = pages_per_blk * page_size;
+
+	/* Open Full SRAM mapping for spare are access */
+	out_be32(&ifc->ifc_nand.ncfgr, 0x0);
+
+	/* Clear Boot events */
+	out_be32(&ifc->ifc_nand.nand_evter_stat, 0xffffffff);
+
+	/* Program FIR/FCR for Large/Small page */
+	if (page_size > 512) {
+		out_be32(&ifc->ifc_nand.nand_fir0,
+			 (IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+			 (IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |
+			 (IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP2_SHIFT) |
+			 (IFC_FIR_OP_CMD1 << IFC_NAND_FIR0_OP3_SHIFT) |
+			 (IFC_FIR_OP_BTRD << IFC_NAND_FIR0_OP4_SHIFT));
+		out_be32(&ifc->ifc_nand.nand_fir1, 0x0);
+
+		out_be32(&ifc->ifc_nand.nand_fcr0,
+			(NAND_CMD_READ0 << IFC_NAND_FCR0_CMD0_SHIFT) |
+			(NAND_CMD_READSTART << IFC_NAND_FCR0_CMD1_SHIFT));
+	} else {
+		out_be32(&ifc->ifc_nand.nand_fir0,
+			 (IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+			 (IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |
+			 (IFC_FIR_OP_RA0  << IFC_NAND_FIR0_OP2_SHIFT) |
+			 (IFC_FIR_OP_BTRD << IFC_NAND_FIR0_OP3_SHIFT));
+		out_be32(&ifc->ifc_nand.nand_fir1, 0x0);
+
+		out_be32(&ifc->ifc_nand.nand_fcr0,
+			NAND_CMD_READ0 << IFC_NAND_FCR0_CMD0_SHIFT);
+	}
+
+	/* Program FBCR = 0 for full page read */
+	out_be32(&ifc->ifc_nand.nand_fbcr, 0);
+
+	/* Read and copy u-boot on SDRAM from NAND device, In parallel
+	 * check for Bad block if found skip it and read continue to
+	 * next Block
+	 */
+	while (pos < uboot_size) {
+		int i = 0;
+		do {
+			pg_no = offs / page_size;
+			bufnum = pg_no & bufnum_mask;
+			sram_addr = bufnum * page_size * 2;
+
+			out_be32(&ifc->ifc_nand.row0, pg_no);
+			out_be32(&ifc->ifc_nand.col0, 0);
+			/* start read */
+			out_be32(&ifc->ifc_nand.nandseq_strt,
+				IFC_NAND_SEQ_STRT_FIR_STRT);
+
+			/* wait for read to complete */
+			nand_wait(&buf[sram_addr], bufnum, page_size);
+
+			/*
+			 * If either of the first two pages are marked bad,
+			 * continue to the next block.
+			 */
+			if (i++ < 2 &&
+			    bad_block(&buf[sram_addr + page_size + bad_marker],
+				      port_size)) {
+				puts("skipping\n");
+				offs = (offs + blk_size) & ~(blk_size - 1);
+				pos &= ~(blk_size - 1);
+				break;
+			}
+
+			for (j = 0; j < page_size; j++)
+				dst[pos + j] = __raw_readb(&buf[sram_addr + j]);
+
+			pos += page_size;
+			offs += page_size;
+		} while ((offs & (blk_size - 1)) && (pos < uboot_size));
+	}
+}
+
+/*
+ * Main entrypoint for NAND Boot. It's necessary that SDRAM is already
+ * configured and available since this code loads the main U-boot image
+ * from NAND into SDRAM and starts from there.
+ */
+void nand_boot(void)
+{
+	__attribute__((noreturn)) void (*uboot)(void);
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	nand_load(CONFIG_SYS_NAND_U_BOOT_OFFS, CONFIG_SYS_NAND_U_BOOT_SIZE,
+		  (uchar *)CONFIG_SYS_NAND_U_BOOT_DST);
+
+#ifdef CONFIG_NAND_ENV_DST
+	nand_load(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+		  (uchar *)CONFIG_NAND_ENV_DST);
+
+#ifdef CONFIG_ENV_OFFSET_REDUND
+	nand_load(CONFIG_ENV_OFFSET_REDUND, CONFIG_ENV_SIZE,
+		  (uchar *)CONFIG_NAND_ENV_DST + CONFIG_ENV_SIZE);
+#endif
+#endif
+	/*
+	 * Jump to U-Boot image
+	 */
+#ifdef CONFIG_SPL_FLUSH_IMAGE
+	/*
+	 * Clean d-cache and invalidate i-cache, to
+	 * make sure that no stale data is executed.
+	 */
+	flush_cache(CONFIG_SYS_NAND_U_BOOT_DST, CONFIG_SYS_NAND_U_BOOT_SIZE);
+#endif
+	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
+	uboot();
+}
diff --git a/drivers/mtd/spi/Makefile b/drivers/mtd/spi/Makefile
index 90f8392..8da6e43 100644
--- a/drivers/mtd/spi/Makefile
+++ b/drivers/mtd/spi/Makefile
@@ -2,23 +2,7 @@
 # (C) Copyright 2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
+# SPDX-License-Identifier:	GPL-2.0+
 #
 
 include $(TOPDIR)/config.mk
@@ -27,17 +11,15 @@ LIB	:= $(obj)libspi_flash.o
 
 ifdef CONFIG_SPL_BUILD
 COBJS-$(CONFIG_SPL_SPI_LOAD)	+= spi_spl_load.o
+COBJS-$(CONFIG_SPL_SPI_BOOT)    += fsl_espi_spl.o
 endif
 
-COBJS-$(CONFIG_SPI_FLASH)	+= spi_flash.o
-COBJS-$(CONFIG_SPI_FLASH_ATMEL)	+= atmel.o
-COBJS-$(CONFIG_SPI_FLASH_EON)	+= eon.o
-COBJS-$(CONFIG_SPI_FLASH_MACRONIX)	+= macronix.o
-COBJS-$(CONFIG_SPI_FLASH_SPANSION)	+= spansion.o
-COBJS-$(CONFIG_SPI_FLASH_SST)	+= sst.o
-COBJS-$(CONFIG_SPI_FLASH_STMICRO)	+= stmicro.o
-COBJS-$(CONFIG_SPI_FLASH_WINBOND)	+= winbond.o
-COBJS-$(CONFIG_SPI_FRAM_RAMTRON)	+= ramtron.o
+ifdef CONFIG_CMD_SF
+COBJS-y        += sf.o
+endif
+COBJS-$(CONFIG_SPI_FLASH) += sf_params.o sf_probe.o sf_ops.o
+COBJS-$(CONFIG_SPI_FRAM_RAMTRON) += ramtron.o
+COBJS-$(CONFIG_SPI_FLASH_SANDBOX) += sandbox.o
 COBJS-$(CONFIG_SPI_M95XXX) += eeprom_m95xxx.o
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/mtd/spi/atmel.c b/drivers/mtd/spi/atmel.c
deleted file mode 100644
index 006f6d5..0000000
--- a/drivers/mtd/spi/atmel.c
+++ /dev/null
@@ -1,550 +0,0 @@
-/*
- * Atmel SPI DataFlash support
- *
- * Copyright (C) 2008 Atmel Corporation
- * Licensed under the GPL-2 or later.
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <spi_flash.h>
-
-#include "spi_flash_internal.h"
-
-/* AT45-specific commands */
-#define CMD_AT45_READ_STATUS		0xd7
-#define CMD_AT45_ERASE_PAGE		0x81
-#define CMD_AT45_LOAD_PROG_BUF1		0x82
-#define CMD_AT45_LOAD_BUF1		0x84
-#define CMD_AT45_LOAD_PROG_BUF2		0x85
-#define CMD_AT45_LOAD_BUF2		0x87
-#define CMD_AT45_PROG_BUF1		0x88
-#define CMD_AT45_PROG_BUF2		0x89
-
-/* AT45 status register bits */
-#define AT45_STATUS_P2_PAGE_SIZE	(1 << 0)
-#define AT45_STATUS_READY		(1 << 7)
-
-/* DataFlash family IDs, as obtained from the second idcode byte */
-#define DF_FAMILY_AT26F			0
-#define DF_FAMILY_AT45			1
-#define DF_FAMILY_AT26DF		2	/* AT25DF and AT26DF */
-
-struct atmel_spi_flash_params {
-	u8		idcode1;
-	/* Log2 of page size in power-of-two mode */
-	u8		l2_page_size;
-	u8		pages_per_block;
-	u8		blocks_per_sector;
-	u8		nr_sectors;
-	const char	*name;
-};
-
-/* spi_flash needs to be first so upper layers can free() it */
-struct atmel_spi_flash {
-	struct spi_flash flash;
-	const struct atmel_spi_flash_params *params;
-};
-
-static inline struct atmel_spi_flash *
-to_atmel_spi_flash(struct spi_flash *flash)
-{
-	return container_of(flash, struct atmel_spi_flash, flash);
-}
-
-static const struct atmel_spi_flash_params atmel_spi_flash_table[] = {
-	{
-		.idcode1		= 0x22,
-		.l2_page_size		= 8,
-		.pages_per_block	= 8,
-		.blocks_per_sector	= 16,
-		.nr_sectors		= 4,
-		.name			= "AT45DB011D",
-	},
-	{
-		.idcode1		= 0x23,
-		.l2_page_size		= 8,
-		.pages_per_block	= 8,
-		.blocks_per_sector	= 16,
-		.nr_sectors		= 8,
-		.name			= "AT45DB021D",
-	},
-	{
-		.idcode1		= 0x24,
-		.l2_page_size		= 8,
-		.pages_per_block	= 8,
-		.blocks_per_sector	= 32,
-		.nr_sectors		= 8,
-		.name			= "AT45DB041D",
-	},
-	{
-		.idcode1		= 0x25,
-		.l2_page_size		= 8,
-		.pages_per_block	= 8,
-		.blocks_per_sector	= 32,
-		.nr_sectors		= 16,
-		.name			= "AT45DB081D",
-	},
-	{
-		.idcode1		= 0x26,
-		.l2_page_size		= 9,
-		.pages_per_block	= 8,
-		.blocks_per_sector	= 32,
-		.nr_sectors		= 16,
-		.name			= "AT45DB161D",
-	},
-	{
-		.idcode1		= 0x27,
-		.l2_page_size		= 9,
-		.pages_per_block	= 8,
-		.blocks_per_sector	= 64,
-		.nr_sectors		= 64,
-		.name			= "AT45DB321D",
-	},
-	{
-		.idcode1		= 0x28,
-		.l2_page_size		= 10,
-		.pages_per_block	= 8,
-		.blocks_per_sector	= 32,
-		.nr_sectors		= 32,
-		.name			= "AT45DB642D",
-	},
-	{
-		.idcode1		= 0x47,
-		.l2_page_size		= 8,
-		.pages_per_block	= 16,
-		.blocks_per_sector	= 16,
-		.nr_sectors		= 64,
-		.name			= "AT25DF321",
-	},
-};
-
-static int at45_wait_ready(struct spi_flash *flash, unsigned long timeout)
-{
-	struct spi_slave *spi = flash->spi;
-	unsigned long timebase;
-	int ret;
-	u8 cmd = CMD_AT45_READ_STATUS;
-	u8 status;
-
-	timebase = get_timer(0);
-
-	ret = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
-	if (ret)
-		return -1;
-
-	do {
-		ret = spi_xfer(spi, 8, NULL, &status, 0);
-		if (ret)
-			return -1;
-
-		if (status & AT45_STATUS_READY)
-			break;
-	} while (get_timer(timebase) < timeout);
-
-	/* Deactivate CS */
-	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
-
-	if (status & AT45_STATUS_READY)
-		return 0;
-
-	/* Timed out */
-	return -1;
-}
-
-/*
- * Assemble the address part of a command for AT45 devices in
- * non-power-of-two page size mode.
- */
-static void at45_build_address(struct atmel_spi_flash *asf, u8 *cmd, u32 offset)
-{
-	unsigned long page_addr;
-	unsigned long byte_addr;
-	unsigned long page_size;
-	unsigned int page_shift;
-
-	/*
-	 * The "extra" space per page is the power-of-two page size
-	 * divided by 32.
-	 */
-	page_shift = asf->params->l2_page_size;
-	page_size = (1 << page_shift) + (1 << (page_shift - 5));
-	page_shift++;
-	page_addr = offset / page_size;
-	byte_addr = offset % page_size;
-
-	cmd[0] = page_addr >> (16 - page_shift);
-	cmd[1] = page_addr << (page_shift - 8) | (byte_addr >> 8);
-	cmd[2] = byte_addr;
-}
-
-static int dataflash_read_fast_at45(struct spi_flash *flash,
-		u32 offset, size_t len, void *buf)
-{
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
-	u8 cmd[5];
-
-	cmd[0] = CMD_READ_ARRAY_FAST;
-	at45_build_address(asf, cmd + 1, offset);
-	cmd[4] = 0x00;
-
-	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
-}
-
-/*
- * TODO: the two write funcs (_p2/_at45) should get unified ...
- */
-static int dataflash_write_p2(struct spi_flash *flash,
-		u32 offset, size_t len, const void *buf)
-{
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
-	unsigned long page_size;
-	u32 addr = offset;
-	size_t chunk_len;
-	size_t actual;
-	int ret;
-	u8 cmd[4];
-
-	/*
-	 * TODO: This function currently uses only page buffer #1.  We can
-	 * speed this up by using both buffers and loading one buffer while
-	 * the other is being programmed into main memory.
-	 */
-
-	page_size = (1 << asf->params->l2_page_size);
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	for (actual = 0; actual < len; actual += chunk_len) {
-		chunk_len = min(len - actual, page_size - (addr % page_size));
-
-		/* Use the same address bits for both commands */
-		cmd[0] = CMD_AT45_LOAD_BUF1;
-		cmd[1] = addr >> 16;
-		cmd[2] = addr >> 8;
-		cmd[3] = addr;
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
-				buf + actual, chunk_len);
-		if (ret < 0) {
-			debug("SF: Loading AT45 buffer failed\n");
-			goto out;
-		}
-
-		cmd[0] = CMD_AT45_PROG_BUF1;
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
-		if (ret < 0) {
-			debug("SF: AT45 page programming failed\n");
-			goto out;
-		}
-
-		ret = at45_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret < 0) {
-			debug("SF: AT45 page programming timed out\n");
-			goto out;
-		}
-
-		addr += chunk_len;
-	}
-
-	debug("SF: AT45: Successfully programmed %zu bytes @ 0x%x\n",
-			len, offset);
-	ret = 0;
-
-out:
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
-static int dataflash_write_at45(struct spi_flash *flash,
-		u32 offset, size_t len, const void *buf)
-{
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
-	unsigned long page_addr;
-	unsigned long byte_addr;
-	unsigned long page_size;
-	unsigned int page_shift;
-	size_t chunk_len;
-	size_t actual;
-	int ret;
-	u8 cmd[4];
-
-	/*
-	 * TODO: This function currently uses only page buffer #1.  We can
-	 * speed this up by using both buffers and loading one buffer while
-	 * the other is being programmed into main memory.
-	 */
-
-	page_shift = asf->params->l2_page_size;
-	page_size = (1 << page_shift) + (1 << (page_shift - 5));
-	page_shift++;
-	page_addr = offset / page_size;
-	byte_addr = offset % page_size;
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	for (actual = 0; actual < len; actual += chunk_len) {
-		chunk_len = min(len - actual, page_size - byte_addr);
-
-		/* Use the same address bits for both commands */
-		cmd[0] = CMD_AT45_LOAD_BUF1;
-		cmd[1] = page_addr >> (16 - page_shift);
-		cmd[2] = page_addr << (page_shift - 8) | (byte_addr >> 8);
-		cmd[3] = byte_addr;
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
-				buf + actual, chunk_len);
-		if (ret < 0) {
-			debug("SF: Loading AT45 buffer failed\n");
-			goto out;
-		}
-
-		cmd[0] = CMD_AT45_PROG_BUF1;
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
-		if (ret < 0) {
-			debug("SF: AT45 page programming failed\n");
-			goto out;
-		}
-
-		ret = at45_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret < 0) {
-			debug("SF: AT45 page programming timed out\n");
-			goto out;
-		}
-
-		page_addr++;
-		byte_addr = 0;
-	}
-
-	debug("SF: AT45: Successfully programmed %zu bytes @ 0x%x\n",
-			len, offset);
-	ret = 0;
-
-out:
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
-/*
- * TODO: the two erase funcs (_p2/_at45) should get unified ...
- */
-static int dataflash_erase_p2(struct spi_flash *flash, u32 offset, size_t len)
-{
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
-	unsigned long page_size;
-
-	size_t actual;
-	int ret;
-	u8 cmd[4];
-
-	/*
-	 * TODO: This function currently uses page erase only. We can
-	 * probably speed things up by using block and/or sector erase
-	 * when possible.
-	 */
-
-	page_size = (1 << asf->params->l2_page_size);
-
-	if (offset % page_size || len % page_size) {
-		debug("SF: Erase offset/length not multiple of page size\n");
-		return -1;
-	}
-
-	cmd[0] = CMD_AT45_ERASE_PAGE;
-	cmd[3] = 0x00;
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	for (actual = 0; actual < len; actual += page_size) {
-		cmd[1] = offset >> 16;
-		cmd[2] = offset >> 8;
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
-		if (ret < 0) {
-			debug("SF: AT45 page erase failed\n");
-			goto out;
-		}
-
-		ret = at45_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
-		if (ret < 0) {
-			debug("SF: AT45 page erase timed out\n");
-			goto out;
-		}
-
-		offset += page_size;
-	}
-
-	debug("SF: AT45: Successfully erased %zu bytes @ 0x%x\n",
-			len, offset);
-	ret = 0;
-
-out:
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
-static int dataflash_erase_at45(struct spi_flash *flash, u32 offset, size_t len)
-{
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
-	unsigned long page_addr;
-	unsigned long page_size;
-	unsigned int page_shift;
-	size_t actual;
-	int ret;
-	u8 cmd[4];
-
-	/*
-	 * TODO: This function currently uses page erase only. We can
-	 * probably speed things up by using block and/or sector erase
-	 * when possible.
-	 */
-
-	page_shift = asf->params->l2_page_size;
-	page_size = (1 << page_shift) + (1 << (page_shift - 5));
-	page_shift++;
-	page_addr = offset / page_size;
-
-	if (offset % page_size || len % page_size) {
-		debug("SF: Erase offset/length not multiple of page size\n");
-		return -1;
-	}
-
-	cmd[0] = CMD_AT45_ERASE_PAGE;
-	cmd[3] = 0x00;
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	for (actual = 0; actual < len; actual += page_size) {
-		cmd[1] = page_addr >> (16 - page_shift);
-		cmd[2] = page_addr << (page_shift - 8);
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
-		if (ret < 0) {
-			debug("SF: AT45 page erase failed\n");
-			goto out;
-		}
-
-		ret = at45_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
-		if (ret < 0) {
-			debug("SF: AT45 page erase timed out\n");
-			goto out;
-		}
-
-		page_addr++;
-	}
-
-	debug("SF: AT45: Successfully erased %zu bytes @ 0x%x\n",
-			len, offset);
-	ret = 0;
-
-out:
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
-struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode)
-{
-	const struct atmel_spi_flash_params *params;
-	unsigned page_size;
-	unsigned int family;
-	struct atmel_spi_flash *asf;
-	unsigned int i;
-	int ret;
-	u8 status;
-
-	for (i = 0; i < ARRAY_SIZE(atmel_spi_flash_table); i++) {
-		params = &atmel_spi_flash_table[i];
-		if (params->idcode1 == idcode[1])
-			break;
-	}
-
-	if (i == ARRAY_SIZE(atmel_spi_flash_table)) {
-		debug("SF: Unsupported DataFlash ID %02x\n",
-				idcode[1]);
-		return NULL;
-	}
-
-	asf = malloc(sizeof(struct atmel_spi_flash));
-	if (!asf) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
-
-	asf->params = params;
-	asf->flash.spi = spi;
-	asf->flash.name = params->name;
-
-	/* Assuming power-of-two page size initially. */
-	page_size = 1 << params->l2_page_size;
-
-	family = idcode[1] >> 5;
-
-	switch (family) {
-	case DF_FAMILY_AT45:
-		/*
-		 * AT45 chips have configurable page size. The status
-		 * register indicates which configuration is active.
-		 */
-		ret = spi_flash_cmd(spi, CMD_AT45_READ_STATUS, &status, 1);
-		if (ret)
-			goto err;
-
-		debug("SF: AT45 status register: %02x\n", status);
-
-		if (!(status & AT45_STATUS_P2_PAGE_SIZE)) {
-			asf->flash.read = dataflash_read_fast_at45;
-			asf->flash.write = dataflash_write_at45;
-			asf->flash.erase = dataflash_erase_at45;
-			page_size += 1 << (params->l2_page_size - 5);
-		} else {
-			asf->flash.read = spi_flash_cmd_read_fast;
-			asf->flash.write = dataflash_write_p2;
-			asf->flash.erase = dataflash_erase_p2;
-		}
-
-		asf->flash.page_size = page_size;
-		asf->flash.sector_size = page_size;
-		break;
-
-	case DF_FAMILY_AT26F:
-	case DF_FAMILY_AT26DF:
-		asf->flash.read = spi_flash_cmd_read_fast;
-		asf->flash.write = spi_flash_cmd_write_multi;
-		asf->flash.erase = spi_flash_cmd_erase;
-		asf->flash.page_size = page_size;
-		asf->flash.sector_size = 4096;
-		/* clear SPRL# bit for locked flash */
-		spi_flash_cmd_write_status(&asf->flash, 0);
-		break;
-
-	default:
-		debug("SF: Unsupported DataFlash family %u\n", family);
-		goto err;
-	}
-
-	asf->flash.size = page_size * params->pages_per_block
-				* params->blocks_per_sector
-				* params->nr_sectors;
-
-	return &asf->flash;
-
-err:
-	free(asf);
-	return NULL;
-}
diff --git a/drivers/mtd/spi/eeprom_m95xxx.c b/drivers/mtd/spi/eeprom_m95xxx.c
index 88b6c34..a019939 100644
--- a/drivers/mtd/spi/eeprom_m95xxx.c
+++ b/drivers/mtd/spi/eeprom_m95xxx.c
@@ -2,23 +2,7 @@
  * Copyright (C) 2009
  * Albin Tonnerre, Free Electrons <albin.tonnerre@free-electrons.com>
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
diff --git a/drivers/mtd/spi/eon.c b/drivers/mtd/spi/eon.c
deleted file mode 100644
index 691ed4e..0000000
--- a/drivers/mtd/spi/eon.c
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * (C) Copyright 2010, ucRobotics Inc.
- * Author: Chong Huang <chuang@ucrobotics.com>
- * Licensed under the GPL-2 or later.
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <spi_flash.h>
-
-#include "spi_flash_internal.h"
-
-struct eon_spi_flash_params {
-	u8 idcode1;
-	u16 nr_sectors;
-	const char *name;
-};
-
-static const struct eon_spi_flash_params eon_spi_flash_table[] = {
-	{
-		.idcode1 = 0x16,
-		.nr_sectors = 1024,
-		.name = "EN25Q32B",
-	},
-	{
-		.idcode1 = 0x18,
-		.nr_sectors = 4096,
-		.name = "EN25Q128",
-	},
-};
-
-struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode)
-{
-	const struct eon_spi_flash_params *params;
-	struct spi_flash *flash;
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(eon_spi_flash_table); ++i) {
-		params = &eon_spi_flash_table[i];
-		if (params->idcode1 == idcode[2])
-			break;
-	}
-
-	if (i == ARRAY_SIZE(eon_spi_flash_table)) {
-		debug("SF: Unsupported EON ID %02x\n", idcode[1]);
-		return NULL;
-	}
-
-	flash = malloc(sizeof(*flash));
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
-
-	flash->spi = spi;
-	flash->name = params->name;
-
-	flash->write = spi_flash_cmd_write_multi;
-	flash->erase = spi_flash_cmd_erase;
-	flash->read = spi_flash_cmd_read_fast;
-	flash->page_size = 256;
-	flash->sector_size = 256 * 16 * 16;
-	flash->size = 256 * 16
-	    * params->nr_sectors;
-
-	return flash;
-}
diff --git a/drivers/mtd/spi/fsl_espi_spl.c b/drivers/mtd/spi/fsl_espi_spl.c
new file mode 100644
index 0000000..b915469
--- /dev/null
+++ b/drivers/mtd/spi/fsl_espi_spl.c
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spi_flash.h>
+#include <malloc.h>
+
+#define ESPI_BOOT_IMAGE_SIZE	0x48
+#define ESPI_BOOT_IMAGE_ADDR	0x50
+#define CONFIG_CFG_DATA_SECTOR	0
+
+void spi_spl_load_image(uint32_t offs, unsigned int size, void *vdst)
+{
+	struct spi_flash *flash;
+
+	flash = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+			CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	if (flash == NULL) {
+		puts("\nspi_flash_probe failed");
+		hang();
+	}
+
+	spi_flash_read(flash, offs, size, vdst);
+}
+
+/*
+ * The main entry for SPI booting. It's necessary that SDRAM is already
+ * configured and available since this code loads the main U-Boot image
+ * from SPI into SDRAM and starts it from there.
+ */
+void spi_boot(void)
+{
+	void (*uboot)(void) __noreturn;
+	u32 offset, code_len, copy_len = 0;
+#ifndef CONFIG_FSL_CORENET
+	unsigned char *buf = NULL;
+#endif
+	struct spi_flash *flash;
+
+	flash = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+			CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	if (flash == NULL) {
+		puts("\nspi_flash_probe failed");
+		hang();
+	}
+
+#ifdef CONFIG_FSL_CORENET
+	offset = CONFIG_SYS_SPI_FLASH_U_BOOT_OFFS;
+	code_len = CONFIG_SYS_SPI_FLASH_U_BOOT_SIZE;
+#else
+	/*
+	* Load U-Boot image from SPI flash into RAM
+	*/
+	buf = malloc(flash->page_size);
+	if (buf == NULL) {
+		puts("\nmalloc failed");
+		hang();
+	}
+	memset(buf, 0, flash->page_size);
+
+	spi_flash_read(flash, CONFIG_CFG_DATA_SECTOR,
+		       flash->page_size, (void *)buf);
+	offset = *(u32 *)(buf + ESPI_BOOT_IMAGE_ADDR);
+	/* Skip spl code */
+	offset += CONFIG_SYS_SPI_FLASH_U_BOOT_OFFS;
+	/* Get the code size from offset 0x48 */
+	code_len = *(u32 *)(buf + ESPI_BOOT_IMAGE_SIZE);
+	/* Skip spl code */
+	code_len = code_len - CONFIG_SPL_MAX_SIZE;
+#endif
+	/* copy code to DDR */
+	printf("Loading second stage boot loader ");
+	while (copy_len <= code_len) {
+		spi_flash_read(flash, offset + copy_len, 0x2000,
+			       (void *)(CONFIG_SYS_SPI_FLASH_U_BOOT_DST
+			       + copy_len));
+		copy_len = copy_len + 0x2000;
+		putc('.');
+	}
+
+	/*
+	* Jump to U-Boot image
+	*/
+	flush_cache(CONFIG_SYS_SPI_FLASH_U_BOOT_DST, code_len);
+	uboot = (void *)CONFIG_SYS_SPI_FLASH_U_BOOT_START;
+	(*uboot)();
+}
diff --git a/drivers/mtd/spi/macronix.c b/drivers/mtd/spi/macronix.c
deleted file mode 100644
index c97a39d..0000000
--- a/drivers/mtd/spi/macronix.c
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright 2009(C) Marvell International Ltd. and its affiliates
- * Prafulla Wadaskar <prafulla@marvell.com>
- *
- * Based on drivers/mtd/spi/stmicro.c
- *
- * Copyright 2008, Network Appliance Inc.
- * Jason McMullan <mcmullan@netapp.com>
- *
- * Copyright (C) 2004-2007 Freescale Semiconductor, Inc.
- * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301 USA
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <spi_flash.h>
-
-#include "spi_flash_internal.h"
-
-struct macronix_spi_flash_params {
-	u16 idcode;
-	u16 nr_blocks;
-	const char *name;
-};
-
-static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
-	{
-		.idcode = 0x2013,
-		.nr_blocks = 8,
-		.name = "MX25L4005",
-	},
-	{
-		.idcode = 0x2014,
-		.nr_blocks = 16,
-		.name = "MX25L8005",
-	},
-	{
-		.idcode = 0x2015,
-		.nr_blocks = 32,
-		.name = "MX25L1605D",
-	},
-	{
-		.idcode = 0x2016,
-		.nr_blocks = 64,
-		.name = "MX25L3205D",
-	},
-	{
-		.idcode = 0x2017,
-		.nr_blocks = 128,
-		.name = "MX25L6405D",
-	},
-	{
-		.idcode = 0x2018,
-		.nr_blocks = 256,
-		.name = "MX25L12805D",
-	},
-	{
-		.idcode = 0x2618,
-		.nr_blocks = 256,
-		.name = "MX25L12855E",
-	},
-};
-
-struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode)
-{
-	const struct macronix_spi_flash_params *params;
-	struct spi_flash *flash;
-	unsigned int i;
-	u16 id = idcode[2] | idcode[1] << 8;
-
-	for (i = 0; i < ARRAY_SIZE(macronix_spi_flash_table); i++) {
-		params = &macronix_spi_flash_table[i];
-		if (params->idcode == id)
-			break;
-	}
-
-	if (i == ARRAY_SIZE(macronix_spi_flash_table)) {
-		debug("SF: Unsupported Macronix ID %04x\n", id);
-		return NULL;
-	}
-
-	flash = malloc(sizeof(*flash));
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
-
-	flash->spi = spi;
-	flash->name = params->name;
-
-	flash->write = spi_flash_cmd_write_multi;
-	flash->erase = spi_flash_cmd_erase;
-	flash->read = spi_flash_cmd_read_fast;
-	flash->page_size = 256;
-	flash->sector_size = 256 * 16 * 16;
-	flash->size = flash->sector_size * params->nr_blocks;
-
-	/* Clear BP# bits for read-only flash */
-	spi_flash_cmd_write_status(flash, 0);
-
-	return flash;
-}
diff --git a/drivers/mtd/spi/ramtron.c b/drivers/mtd/spi/ramtron.c
index 0999781..d50da37 100644
--- a/drivers/mtd/spi/ramtron.c
+++ b/drivers/mtd/spi/ramtron.c
@@ -2,23 +2,7 @@
  * (C) Copyright 2010
  * Reinhard Meyer, EMK Elektronik, reinhard.meyer@emk-elektronik.de
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 /*
@@ -52,7 +36,7 @@
 #include <common.h>
 #include <malloc.h>
 #include <spi_flash.h>
-#include "spi_flash_internal.h"
+#include "sf_internal.h"
 
 /*
  * Properties of supported FRAMs
@@ -230,7 +214,8 @@ static int ramtron_erase(struct spi_flash *flash, u32 offset, size_t len)
  * nore: we are called here with idcode pointing to the first non-0x7f byte
  * already!
  */
-struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode)
+static struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi,
+		u8 *idcode)
 {
 	const struct ramtron_spi_fram_params *params;
 	struct ramtron_spi_fram *sn;
@@ -246,7 +231,8 @@ struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode)
 		/* JEDEC conformant RAMTRON id */
 		for (i = 0; i < ARRAY_SIZE(ramtron_spi_fram_table); i++) {
 			params = &ramtron_spi_fram_table[i];
-			if (idcode[1] == params->id1 && idcode[2] == params->id2)
+			if (idcode[1] == params->id1 &&
+			    idcode[2] == params->id2)
 				goto found;
 		}
 		break;
@@ -267,7 +253,8 @@ struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode)
 		/* now find the device */
 		for (i = 0; i < ARRAY_SIZE(ramtron_spi_fram_table); i++) {
 			params = &ramtron_spi_fram_table[i];
-			if (!strcmp(params->name, CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC))
+			if (!strcmp(params->name,
+				    CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC))
 				goto found;
 		}
 		debug("SF: Unsupported non-JEDEC RAMTRON device "
@@ -280,7 +267,7 @@ struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode)
 
 	/* arriving here means no method has found a device we can handle */
 	debug("SF/ramtron: unsupported device id0=%02x id1=%02x id2=%02x\n",
-		idcode[0], idcode[1], idcode[2]);
+	      idcode[0], idcode[1], idcode[2]);
 	return NULL;
 
 found:
@@ -291,8 +278,6 @@ found:
 	}
 
 	sn->params = params;
-	sn->flash.spi = spi;
-	sn->flash.name = params->name;
 
 	sn->flash.write = ramtron_write;
 	sn->flash.read = ramtron_read;
@@ -301,3 +286,118 @@ found:
 
 	return &sn->flash;
 }
+
+/*
+ * The following table holds all device probe functions
+ * (All flashes are removed and implemented a common probe at
+ *  spi_flash_probe.c)
+ *
+ * shift:  number of continuation bytes before the ID
+ * idcode: the expected IDCODE or 0xff for non JEDEC devices
+ * probe:  the function to call
+ *
+ * Non JEDEC devices should be ordered in the table such that
+ * the probe functions with best detection algorithms come first.
+ *
+ * Several matching entries are permitted, they will be tried
+ * in sequence until a probe function returns non NULL.
+ *
+ * IDCODE_CONT_LEN may be redefined if a device needs to declare a
+ * larger "shift" value.  IDCODE_PART_LEN generally shouldn't be
+ * changed.  This is the max number of bytes probe functions may
+ * examine when looking up part-specific identification info.
+ *
+ * Probe functions will be given the idcode buffer starting at their
+ * manu id byte (the "idcode" in the table below).  In other words,
+ * all of the continuation bytes will be skipped (the "shift" below).
+ */
+#define IDCODE_CONT_LEN 0
+#define IDCODE_PART_LEN 5
+static const struct {
+	const u8 shift;
+	const u8 idcode;
+	struct spi_flash *(*probe) (struct spi_slave *spi, u8 *idcode);
+} flashes[] = {
+	/* Keep it sorted by define name */
+#ifdef CONFIG_SPI_FRAM_RAMTRON
+	{ 6, 0xc2, spi_fram_probe_ramtron, },
+# undef IDCODE_CONT_LEN
+# define IDCODE_CONT_LEN 6
+#endif
+#ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
+	{ 0, 0xff, spi_fram_probe_ramtron, },
+#endif
+};
+#define IDCODE_LEN (IDCODE_CONT_LEN + IDCODE_PART_LEN)
+
+struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int spi_mode)
+{
+	struct spi_slave *spi;
+	struct spi_flash *flash = NULL;
+	int ret, i, shift;
+	u8 idcode[IDCODE_LEN], *idp;
+
+	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
+	if (!spi) {
+		printf("SF: Failed to set up slave\n");
+		return NULL;
+	}
+
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("SF: Failed to claim SPI bus: %d\n", ret);
+		goto err_claim_bus;
+	}
+
+	/* Read the ID codes */
+	ret = spi_flash_cmd(spi, CMD_READ_ID, idcode, sizeof(idcode));
+	if (ret)
+		goto err_read_id;
+
+#ifdef DEBUG
+	printf("SF: Got idcodes\n");
+	print_buffer(0, idcode, 1, sizeof(idcode), 0);
+#endif
+
+	/* count the number of continuation bytes */
+	for (shift = 0, idp = idcode;
+	     shift < IDCODE_CONT_LEN && *idp == 0x7f;
+	     ++shift, ++idp)
+		continue;
+
+	/* search the table for matches in shift and id */
+	for (i = 0; i < ARRAY_SIZE(flashes); ++i)
+		if (flashes[i].shift == shift && flashes[i].idcode == *idp) {
+			/* we have a match, call probe */
+			flash = flashes[i].probe(spi, idp);
+			if (flash)
+				break;
+		}
+
+	if (!flash) {
+		printf("SF: Unsupported manufacturer %02x\n", *idp);
+		goto err_manufacturer_probe;
+	}
+
+	printf("SF: Detected %s with total size ", flash->name);
+	print_size(flash->size, "");
+	puts("\n");
+
+	spi_release_bus(spi);
+
+	return flash;
+
+err_manufacturer_probe:
+err_read_id:
+	spi_release_bus(spi);
+err_claim_bus:
+	spi_free_slave(spi);
+	return NULL;
+}
+
+void spi_flash_free(struct spi_flash *flash)
+{
+	spi_free_slave(flash->spi);
+	free(flash);
+}
diff --git a/drivers/mtd/spi/sandbox.c b/drivers/mtd/spi/sandbox.c
new file mode 100644
index 0000000..a62ef4c
--- /dev/null
+++ b/drivers/mtd/spi/sandbox.c
@@ -0,0 +1,483 @@
+/*
+ * Simulate a SPI flash
+ *
+ * Copyright (c) 2011-2013 The Chromium OS Authors.
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <os.h>
+
+#include <spi_flash.h>
+#include "sf_internal.h"
+
+#include <asm/getopt.h>
+#include <asm/spi.h>
+#include <asm/state.h>
+
+/*
+ * The different states that our SPI flash transitions between.
+ * We need to keep track of this across multiple xfer calls since
+ * the SPI bus could possibly call down into us multiple times.
+ */
+enum sandbox_sf_state {
+	SF_CMD,   /* default state -- we're awaiting a command */
+	SF_ID,    /* read the flash's (jedec) ID code */
+	SF_ADDR,  /* processing the offset in the flash to read/etc... */
+	SF_READ,  /* reading data from the flash */
+	SF_WRITE, /* writing data to the flash, i.e. page programming */
+	SF_ERASE, /* erase the flash */
+	SF_READ_STATUS, /* read the flash's status register */
+	SF_READ_STATUS1, /* read the flash's status register upper 8 bits*/
+};
+
+static const char *sandbox_sf_state_name(enum sandbox_sf_state state)
+{
+	static const char * const states[] = {
+		"CMD", "ID", "ADDR", "READ", "WRITE", "ERASE", "READ_STATUS",
+	};
+	return states[state];
+}
+
+/* Bits for the status register */
+#define STAT_WIP	(1 << 0)
+#define STAT_WEL	(1 << 1)
+
+/* Assume all SPI flashes have 3 byte addresses since they do atm */
+#define SF_ADDR_LEN	3
+
+struct sandbox_spi_flash_erase_commands {
+	u8 cmd;
+	u32 size;
+};
+#define IDCODE_LEN 5
+#define MAX_ERASE_CMDS 3
+struct sandbox_spi_flash_data {
+	const char *name;
+	u8 idcode[IDCODE_LEN];
+	u32 size;
+	const struct sandbox_spi_flash_erase_commands
+						erase_cmds[MAX_ERASE_CMDS];
+};
+
+/* Structure describing all the flashes we know how to emulate */
+static const struct sandbox_spi_flash_data sandbox_sf_flashes[] = {
+	{
+		"M25P16", { 0x20, 0x20, 0x15 }, (2 << 20),
+		{	/* erase commands */
+			{ 0xd8, (64 << 10), }, /* sector */
+			{ 0xc7, (2 << 20), }, /* bulk */
+		},
+	},
+	{
+		"W25Q32", { 0xef, 0x40, 0x16 }, (4 << 20),
+		{	/* erase commands */
+			{ 0x20, (4 << 10), }, /* 4KB */
+			{ 0xd8, (64 << 10), }, /* sector */
+			{ 0xc7, (4 << 20), }, /* bulk */
+		},
+	},
+	{
+		"W25Q128", { 0xef, 0x40, 0x18 }, (16 << 20),
+		{	/* erase commands */
+			{ 0x20, (4 << 10), }, /* 4KB */
+			{ 0xd8, (64 << 10), }, /* sector */
+			{ 0xc7, (16 << 20), }, /* bulk */
+		},
+	},
+};
+
+/* Used to quickly bulk erase backing store */
+static u8 sandbox_sf_0xff[0x1000];
+
+/* Internal state data for each SPI flash */
+struct sandbox_spi_flash {
+	/*
+	 * As we receive data over the SPI bus, our flash transitions
+	 * between states.  For example, we start off in the SF_CMD
+	 * state where the first byte tells us what operation to perform
+	 * (such as read or write the flash).  But the operation itself
+	 * can go through a few states such as first reading in the
+	 * offset in the flash to perform the requested operation.
+	 * Thus "state" stores the exact state that our machine is in
+	 * while "cmd" stores the overall command we're processing.
+	 */
+	enum sandbox_sf_state state;
+	uint cmd;
+	const void *cmd_data;
+	/* Current position in the flash; used when reading/writing/etc... */
+	uint off;
+	/* How many address bytes we've consumed */
+	uint addr_bytes, pad_addr_bytes;
+	/* The current flash status (see STAT_XXX defines above) */
+	u16 status;
+	/* Data describing the flash we're emulating */
+	const struct sandbox_spi_flash_data *data;
+	/* The file on disk to serv up data from */
+	int fd;
+};
+
+static int sandbox_sf_setup(void **priv, const char *spec)
+{
+	/* spec = idcode:file */
+	struct sandbox_spi_flash *sbsf;
+	const char *file;
+	size_t i, len, idname_len;
+	const struct sandbox_spi_flash_data *data;
+
+	file = strchr(spec, ':');
+	if (!file) {
+		printf("sandbox_sf: unable to parse file\n");
+		goto error;
+	}
+	idname_len = file - spec;
+	++file;
+
+	for (i = 0; i < ARRAY_SIZE(sandbox_sf_flashes); ++i) {
+		data = &sandbox_sf_flashes[i];
+		len = strlen(data->name);
+		if (idname_len != len)
+			continue;
+		if (!memcmp(spec, data->name, len))
+			break;
+	}
+	if (i == ARRAY_SIZE(sandbox_sf_flashes)) {
+		printf("sandbox_sf: unknown flash '%*s'\n", (int)idname_len,
+		       spec);
+		goto error;
+	}
+
+	if (sandbox_sf_0xff[0] == 0x00)
+		memset(sandbox_sf_0xff, 0xff, sizeof(sandbox_sf_0xff));
+
+	sbsf = calloc(sizeof(*sbsf), 1);
+	if (!sbsf) {
+		printf("sandbox_sf: out of memory\n");
+		goto error;
+	}
+
+	sbsf->fd = os_open(file, 02);
+	if (sbsf->fd == -1) {
+		free(sbsf);
+		printf("sandbox_sf: unable to open file '%s'\n", file);
+		goto error;
+	}
+
+	sbsf->data = data;
+
+	*priv = sbsf;
+	return 0;
+
+ error:
+	return 1;
+}
+
+static void sandbox_sf_free(void *priv)
+{
+	struct sandbox_spi_flash *sbsf = priv;
+
+	os_close(sbsf->fd);
+	free(sbsf);
+}
+
+static void sandbox_sf_cs_activate(void *priv)
+{
+	struct sandbox_spi_flash *sbsf = priv;
+
+	debug("sandbox_sf: CS activated; state is fresh!\n");
+
+	/* CS is asserted, so reset state */
+	sbsf->off = 0;
+	sbsf->addr_bytes = 0;
+	sbsf->pad_addr_bytes = 0;
+	sbsf->state = SF_CMD;
+	sbsf->cmd = SF_CMD;
+}
+
+static void sandbox_sf_cs_deactivate(void *priv)
+{
+	debug("sandbox_sf: CS deactivated; cmd done processing!\n");
+}
+
+/* Figure out what command this stream is telling us to do */
+static int sandbox_sf_process_cmd(struct sandbox_spi_flash *sbsf, const u8 *rx,
+				  u8 *tx)
+{
+	enum sandbox_sf_state oldstate = sbsf->state;
+
+	/* We need to output a byte for the cmd byte we just ate */
+	sandbox_spi_tristate(tx, 1);
+
+	sbsf->cmd = rx[0];
+	switch (sbsf->cmd) {
+	case CMD_READ_ID:
+		sbsf->state = SF_ID;
+		sbsf->cmd = SF_ID;
+		break;
+	case CMD_READ_ARRAY_FAST:
+		sbsf->pad_addr_bytes = 1;
+	case CMD_READ_ARRAY_SLOW:
+	case CMD_PAGE_PROGRAM:
+ state_addr:
+		sbsf->state = SF_ADDR;
+		break;
+	case CMD_WRITE_DISABLE:
+		debug(" write disabled\n");
+		sbsf->status &= ~STAT_WEL;
+		break;
+	case CMD_READ_STATUS:
+		sbsf->state = SF_READ_STATUS;
+		break;
+	case CMD_READ_STATUS1:
+		sbsf->state = SF_READ_STATUS1;
+		break;
+	case CMD_WRITE_ENABLE:
+		debug(" write enabled\n");
+		sbsf->status |= STAT_WEL;
+		break;
+	default: {
+		size_t i;
+
+		/* handle erase commands first */
+		for (i = 0; i < MAX_ERASE_CMDS; ++i) {
+			const struct sandbox_spi_flash_erase_commands *
+				erase_cmd = &sbsf->data->erase_cmds[i];
+
+			if (erase_cmd->cmd == 0x00)
+				continue;
+			if (sbsf->cmd != erase_cmd->cmd)
+				continue;
+
+			sbsf->cmd_data = erase_cmd;
+			goto state_addr;
+		}
+
+		debug(" cmd unknown: %#x\n", sbsf->cmd);
+		return 1;
+	}
+	}
+
+	if (oldstate != sbsf->state)
+		debug(" cmd: transition to %s state\n",
+		      sandbox_sf_state_name(sbsf->state));
+
+	return 0;
+}
+
+int sandbox_erase_part(struct sandbox_spi_flash *sbsf, int size)
+{
+	int todo;
+	int ret;
+
+	while (size > 0) {
+		todo = min(size, sizeof(sandbox_sf_0xff));
+		ret = os_write(sbsf->fd, sandbox_sf_0xff, todo);
+		if (ret != todo)
+			return ret;
+		size -= todo;
+	}
+
+	return 0;
+}
+
+static int sandbox_sf_xfer(void *priv, const u8 *rx, u8 *tx,
+		uint bytes)
+{
+	struct sandbox_spi_flash *sbsf = priv;
+	uint cnt, pos = 0;
+	int ret;
+
+	debug("sandbox_sf: state:%x(%s) bytes:%u\n", sbsf->state,
+	      sandbox_sf_state_name(sbsf->state), bytes);
+
+	if (sbsf->state == SF_CMD) {
+		/* Figure out the initial state */
+		if (sandbox_sf_process_cmd(sbsf, rx, tx))
+			return 1;
+		++pos;
+	}
+
+	/* Process the remaining data */
+	while (pos < bytes) {
+		switch (sbsf->state) {
+		case SF_ID: {
+			u8 id;
+
+			debug(" id: off:%u tx:", sbsf->off);
+			if (sbsf->off < IDCODE_LEN)
+				id = sbsf->data->idcode[sbsf->off];
+			else
+				id = 0;
+			debug("%02x\n", id);
+			tx[pos++] = id;
+			++sbsf->off;
+			break;
+		}
+		case SF_ADDR:
+			debug(" addr: bytes:%u rx:%02x ", sbsf->addr_bytes,
+			      rx[pos]);
+
+			if (sbsf->addr_bytes++ < SF_ADDR_LEN)
+				sbsf->off = (sbsf->off << 8) | rx[pos];
+			debug("addr:%06x\n", sbsf->off);
+
+			sandbox_spi_tristate(&tx[pos++], 1);
+
+			/* See if we're done processing */
+			if (sbsf->addr_bytes <
+					SF_ADDR_LEN + sbsf->pad_addr_bytes)
+				break;
+
+			/* Next state! */
+			if (os_lseek(sbsf->fd, sbsf->off, OS_SEEK_SET) < 0) {
+				puts("sandbox_sf: os_lseek() failed");
+				return 1;
+			}
+			switch (sbsf->cmd) {
+			case CMD_READ_ARRAY_FAST:
+			case CMD_READ_ARRAY_SLOW:
+				sbsf->state = SF_READ;
+				break;
+			case CMD_PAGE_PROGRAM:
+				sbsf->state = SF_WRITE;
+				break;
+			default:
+				/* assume erase state ... */
+				sbsf->state = SF_ERASE;
+				goto case_sf_erase;
+			}
+			debug(" cmd: transition to %s state\n",
+			      sandbox_sf_state_name(sbsf->state));
+			break;
+		case SF_READ:
+			/*
+			 * XXX: need to handle exotic behavior:
+			 *      - reading past end of device
+			 */
+
+			cnt = bytes - pos;
+			debug(" tx: read(%u)\n", cnt);
+			ret = os_read(sbsf->fd, tx + pos, cnt);
+			if (ret < 0) {
+				puts("sandbox_spi: os_read() failed\n");
+				return 1;
+			}
+			pos += ret;
+			break;
+		case SF_READ_STATUS:
+			debug(" read status: %#x\n", sbsf->status);
+			cnt = bytes - pos;
+			memset(tx + pos, sbsf->status, cnt);
+			pos += cnt;
+			break;
+		case SF_READ_STATUS1:
+			debug(" read status: %#x\n", sbsf->status);
+			cnt = bytes - pos;
+			memset(tx + pos, sbsf->status >> 8, cnt);
+			pos += cnt;
+			break;
+		case SF_WRITE:
+			/*
+			 * XXX: need to handle exotic behavior:
+			 *      - unaligned addresses
+			 *      - more than a page (256) worth of data
+			 *      - reading past end of device
+			 */
+			if (!(sbsf->status & STAT_WEL)) {
+				puts("sandbox_sf: write enable not set before write\n");
+				goto done;
+			}
+
+			cnt = bytes - pos;
+			debug(" rx: write(%u)\n", cnt);
+			sandbox_spi_tristate(&tx[pos], cnt);
+			ret = os_write(sbsf->fd, rx + pos, cnt);
+			if (ret < 0) {
+				puts("sandbox_spi: os_write() failed\n");
+				return 1;
+			}
+			pos += ret;
+			sbsf->status &= ~STAT_WEL;
+			break;
+		case SF_ERASE:
+ case_sf_erase: {
+			const struct sandbox_spi_flash_erase_commands *
+						erase_cmd = sbsf->cmd_data;
+
+			if (!(sbsf->status & STAT_WEL)) {
+				puts("sandbox_sf: write enable not set before erase\n");
+				goto done;
+			}
+
+			/* verify address is aligned */
+			if (sbsf->off & (erase_cmd->size - 1)) {
+				debug(" sector erase: cmd:%#x needs align:%#x, but we got %#x\n",
+				      erase_cmd->cmd, erase_cmd->size,
+				      sbsf->off);
+				sbsf->status &= ~STAT_WEL;
+				goto done;
+			}
+
+			debug(" sector erase addr: %u\n", sbsf->off);
+
+			cnt = bytes - pos;
+			sandbox_spi_tristate(&tx[pos], cnt);
+			pos += cnt;
+
+			/*
+			 * TODO(vapier@gentoo.org): latch WIP in status, and
+			 * delay before clearing it ?
+			 */
+			ret = sandbox_erase_part(sbsf, erase_cmd->size);
+			sbsf->status &= ~STAT_WEL;
+			if (ret) {
+				debug("sandbox_sf: Erase failed\n");
+				goto done;
+			}
+			goto done;
+		}
+		default:
+			debug(" ??? no idea what to do ???\n");
+			goto done;
+		}
+	}
+
+ done:
+	return pos == bytes ? 0 : 1;
+}
+
+static const struct sandbox_spi_emu_ops sandbox_sf_ops = {
+	.setup         = sandbox_sf_setup,
+	.free          = sandbox_sf_free,
+	.cs_activate   = sandbox_sf_cs_activate,
+	.cs_deactivate = sandbox_sf_cs_deactivate,
+	.xfer          = sandbox_sf_xfer,
+};
+
+static int sandbox_cmdline_cb_spi_sf(struct sandbox_state *state,
+				     const char *arg)
+{
+	unsigned long bus, cs;
+	const char *spec = sandbox_spi_parse_spec(arg, &bus, &cs);
+
+	if (!spec)
+		return 1;
+
+	/*
+	 * It is safe to not make a copy of 'spec' because it comes from the
+	 * command line.
+	 *
+	 * TODO(sjg@chromium.org): It would be nice if we could parse the
+	 * spec here, but the problem is that no U-Boot init has been done
+	 * yet. Perhaps we can figure something out.
+	 */
+	state->spi[bus][cs].ops = &sandbox_sf_ops;
+	state->spi[bus][cs].spec = spec;
+	return 0;
+}
+SANDBOX_CMDLINE_OPT(spi_sf, 1, "connect a SPI flash: <bus>:<cs>:<id>:<file>");
diff --git a/drivers/mtd/spi/sf.c b/drivers/mtd/spi/sf.c
new file mode 100644
index 0000000..664e860
--- /dev/null
+++ b/drivers/mtd/spi/sf.c
@@ -0,0 +1,58 @@
+/*
+ * SPI flash interface
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ * Copyright (C) 2010 Reinhard Meyer, EMK Elektronik
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spi.h>
+
+static int spi_flash_read_write(struct spi_slave *spi,
+				const u8 *cmd, size_t cmd_len,
+				const u8 *data_out, u8 *data_in,
+				size_t data_len)
+{
+	unsigned long flags = SPI_XFER_BEGIN;
+	int ret;
+
+#ifdef CONFIG_SF_DUAL_FLASH
+	if (spi->flags & SPI_XFER_U_PAGE)
+		flags |= SPI_XFER_U_PAGE;
+#endif
+	if (data_len == 0)
+		flags |= SPI_XFER_END;
+
+	ret = spi_xfer(spi, cmd_len * 8, cmd, NULL, flags);
+	if (ret) {
+		debug("SF: Failed to send command (%zu bytes): %d\n",
+		      cmd_len, ret);
+	} else if (data_len != 0) {
+		ret = spi_xfer(spi, data_len * 8, data_out, data_in,
+					SPI_XFER_END);
+		if (ret)
+			debug("SF: Failed to transfer %zu bytes of data: %d\n",
+			      data_len, ret);
+	}
+
+	return ret;
+}
+
+int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
+		size_t cmd_len, void *data, size_t data_len)
+{
+	return spi_flash_read_write(spi, cmd, cmd_len, NULL, data, data_len);
+}
+
+int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len)
+{
+	return spi_flash_cmd_read(spi, &cmd, 1, response, len);
+}
+
+int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
+		const void *data, size_t data_len)
+{
+	return spi_flash_read_write(spi, cmd, cmd_len, data, NULL, data_len);
+}
diff --git a/drivers/mtd/spi/sf_internal.h b/drivers/mtd/spi/sf_internal.h
new file mode 100644
index 0000000..19d4914
--- /dev/null
+++ b/drivers/mtd/spi/sf_internal.h
@@ -0,0 +1,163 @@
+/*
+ * SPI flash internal definitions
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SF_INTERNAL_H_
+#define _SF_INTERNAL_H_
+
+#define SPI_FLASH_3B_ADDR_LEN		3
+#define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_3B_ADDR_LEN)
+#define SPI_FLASH_16MB_BOUN		0x1000000
+
+/* CFI Manufacture ID's */
+#define SPI_FLASH_CFI_MFR_SPANSION	0x01
+#define SPI_FLASH_CFI_MFR_STMICRO	0x20
+#define SPI_FLASH_CFI_MFR_MACRONIX	0xc2
+#define SPI_FLASH_CFI_MFR_WINBOND	0xef
+
+/* Erase commands */
+#define CMD_ERASE_4K			0x20
+#define CMD_ERASE_32K			0x52
+#define CMD_ERASE_CHIP			0xc7
+#define CMD_ERASE_64K			0xd8
+
+/* Write commands */
+#define CMD_WRITE_STATUS		0x01
+#define CMD_PAGE_PROGRAM		0x02
+#define CMD_WRITE_DISABLE		0x04
+#define CMD_READ_STATUS			0x05
+#define CMD_QUAD_PAGE_PROGRAM		0x32
+#define CMD_READ_STATUS1		0x35
+#define CMD_WRITE_ENABLE		0x06
+#define CMD_READ_CONFIG			0x35
+#define CMD_FLAG_STATUS			0x70
+
+/* Read commands */
+#define CMD_READ_ARRAY_SLOW		0x03
+#define CMD_READ_ARRAY_FAST		0x0b
+#define CMD_READ_DUAL_OUTPUT_FAST	0x3b
+#define CMD_READ_DUAL_IO_FAST		0xbb
+#define CMD_READ_QUAD_OUTPUT_FAST	0x6b
+#define CMD_READ_QUAD_IO_FAST		0xeb
+#define CMD_READ_ID			0x9f
+
+/* Bank addr access commands */
+#ifdef CONFIG_SPI_FLASH_BAR
+# define CMD_BANKADDR_BRWR		0x17
+# define CMD_BANKADDR_BRRD		0x16
+# define CMD_EXTNADDR_WREAR		0xC5
+# define CMD_EXTNADDR_RDEAR		0xC8
+#endif
+
+/* Common status */
+#define STATUS_WIP			(1 << 0)
+#define STATUS_QEB_WINSPAN		(1 << 1)
+#define STATUS_QEB_MXIC			(1 << 6)
+#define STATUS_PEC			(1 << 7)
+
+#ifdef CONFIG_SYS_SPI_ST_ENABLE_WP_PIN
+#define STATUS_SRWD			(1 << 7) /* SR write protect */
+#endif
+
+/* Flash timeout values */
+#define SPI_FLASH_PROG_TIMEOUT		(2 * CONFIG_SYS_HZ)
+#define SPI_FLASH_PAGE_ERASE_TIMEOUT	(5 * CONFIG_SYS_HZ)
+#define SPI_FLASH_SECTOR_ERASE_TIMEOUT	(10 * CONFIG_SYS_HZ)
+
+/* SST specific */
+#ifdef CONFIG_SPI_FLASH_SST
+# define SST_WP			0x01	/* Supports AAI word program */
+# define CMD_SST_BP		0x02    /* Byte Program */
+# define CMD_SST_AAI_WP		0xAD	/* Auto Address Incr Word Program */
+
+int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
+		const void *buf);
+#endif
+
+/* Send a single-byte command to the device and read the response */
+int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len);
+
+/*
+ * Send a multi-byte command to the device and read the response. Used
+ * for flash array reads, etc.
+ */
+int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
+		size_t cmd_len, void *data, size_t data_len);
+
+/*
+ * Send a multi-byte command to the device followed by (optional)
+ * data. Used for programming the flash array, etc.
+ */
+int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
+		const void *data, size_t data_len);
+
+
+/* Flash erase(sectors) operation, support all possible erase commands */
+int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len);
+
+/* Read the status register */
+int spi_flash_cmd_read_status(struct spi_flash *flash, u8 *rs);
+
+/* Program the status register */
+int spi_flash_cmd_write_status(struct spi_flash *flash, u8 ws);
+
+/* Read the config register */
+int spi_flash_cmd_read_config(struct spi_flash *flash, u8 *rc);
+
+/* Program the config register */
+int spi_flash_cmd_write_config(struct spi_flash *flash, u8 wc);
+
+/* Enable writing on the SPI flash */
+static inline int spi_flash_cmd_write_enable(struct spi_flash *flash)
+{
+	return spi_flash_cmd(flash->spi, CMD_WRITE_ENABLE, NULL, 0);
+}
+
+/* Disable writing on the SPI flash */
+static inline int spi_flash_cmd_write_disable(struct spi_flash *flash)
+{
+	return spi_flash_cmd(flash->spi, CMD_WRITE_DISABLE, NULL, 0);
+}
+
+/*
+ * Send the read status command to the device and wait for the wip
+ * (write-in-progress) bit to clear itself.
+ */
+int spi_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout);
+
+/*
+ * Used for spi_flash write operation
+ * - SPI claim
+ * - spi_flash_cmd_write_enable
+ * - spi_flash_cmd_write
+ * - spi_flash_cmd_wait_ready
+ * - SPI release
+ */
+int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
+		size_t cmd_len, const void *buf, size_t buf_len);
+
+/*
+ * Flash write operation, support all possible write commands.
+ * Write the requested data out breaking it up into multiple write
+ * commands as needed per the write size.
+ */
+int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
+		size_t len, const void *buf);
+
+/*
+ * Same as spi_flash_cmd_read() except it also claims/releases the SPI
+ * bus. Used as common part of the ->read() operation.
+ */
+int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
+		size_t cmd_len, void *data, size_t data_len);
+
+/* Flash read operation, support all possible read commands */
+int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
+		size_t len, void *data);
+
+#endif /* _SF_INTERNAL_H_ */
diff --git a/drivers/mtd/spi/sf_ops.c b/drivers/mtd/spi/sf_ops.c
new file mode 100644
index 0000000..ddddcdb
--- /dev/null
+++ b/drivers/mtd/spi/sf_ops.c
@@ -0,0 +1,537 @@
+/*
+ * SPI flash operations
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ * Copyright (C) 2010 Reinhard Meyer, EMK Elektronik
+ * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <watchdog.h>
+
+#include "sf_internal.h"
+
+static void spi_flash_addr(u32 addr, u8 *cmd)
+{
+	/* cmd[0] is actual command */
+	cmd[1] = addr >> 16;
+	cmd[2] = addr >> 8;
+	cmd[3] = addr >> 0;
+}
+
+int spi_flash_cmd_read_status(struct spi_flash *flash, u8 *rs)
+{
+	int ret;
+	u8 cmd;
+
+	cmd = CMD_READ_STATUS;
+	ret = spi_flash_read_common(flash, &cmd, 1, rs, 1);
+	if (ret < 0) {
+		debug("SF: fail to read status register\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int spi_flash_cmd_write_status(struct spi_flash *flash, u8 ws)
+{
+	u8 cmd;
+	int ret;
+
+	cmd = CMD_WRITE_STATUS;
+	ret = spi_flash_write_common(flash, &cmd, 1, &ws, 1);
+	if (ret < 0) {
+		debug("SF: fail to write status register\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_SPI_FLASH_SPANSION) || defined(CONFIG_SPI_FLASH_WINBOND)
+int spi_flash_cmd_read_config(struct spi_flash *flash, u8 *rc)
+{
+	int ret;
+	u8 cmd;
+
+	cmd = CMD_READ_CONFIG;
+	ret = spi_flash_read_common(flash, &cmd, 1, rc, 1);
+	if (ret < 0) {
+		debug("SF: fail to read config register\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int spi_flash_cmd_write_config(struct spi_flash *flash, u8 wc)
+{
+	u8 data[2];
+	u8 cmd;
+	int ret;
+
+	ret = spi_flash_cmd_read_status(flash, &data[0]);
+	if (ret < 0)
+		return ret;
+
+	cmd = CMD_WRITE_STATUS;
+	data[1] = wc;
+	ret = spi_flash_write_common(flash, &cmd, 1, &data, 2);
+	if (ret) {
+		debug("SF: fail to write config register\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SPI_FLASH_BAR
+static int spi_flash_cmd_bankaddr_write(struct spi_flash *flash, u8 bank_sel)
+{
+	u8 cmd;
+	int ret;
+
+	if (flash->bank_curr == bank_sel) {
+		debug("SF: not require to enable bank%d\n", bank_sel);
+		return 0;
+	}
+
+	cmd = flash->bank_write_cmd;
+	ret = spi_flash_write_common(flash, &cmd, 1, &bank_sel, 1);
+	if (ret < 0) {
+		debug("SF: fail to write bank register\n");
+		return ret;
+	}
+	flash->bank_curr = bank_sel;
+
+	return 0;
+}
+
+static int spi_flash_bank(struct spi_flash *flash, u32 offset)
+{
+	u8 bank_sel;
+	int ret;
+
+	bank_sel = offset / (SPI_FLASH_16MB_BOUN << flash->shift);
+
+	ret = spi_flash_cmd_bankaddr_write(flash, bank_sel);
+	if (ret) {
+		debug("SF: fail to set bank%d\n", bank_sel);
+		return ret;
+	}
+
+	return bank_sel;
+}
+#endif
+
+#ifdef CONFIG_SF_DUAL_FLASH
+static void spi_flash_dual_flash(struct spi_flash *flash, u32 *addr)
+{
+	switch (flash->dual_flash) {
+	case SF_DUAL_STACKED_FLASH:
+		if (*addr >= (flash->size >> 1)) {
+			*addr -= flash->size >> 1;
+			flash->spi->flags |= SPI_XFER_U_PAGE;
+		} else {
+			flash->spi->flags &= ~SPI_XFER_U_PAGE;
+		}
+		break;
+	case SF_DUAL_PARALLEL_FLASH:
+		*addr >>= flash->shift;
+		break;
+	default:
+		debug("SF: Unsupported dual_flash=%d\n", flash->dual_flash);
+		break;
+	}
+}
+#endif
+
+int spi_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	unsigned long flags = SPI_XFER_BEGIN;
+	int ret;
+	u8 status;
+	u8 check_status = 0x0;
+	u8 poll_bit = STATUS_WIP;
+	u8 cmd = flash->poll_cmd;
+
+	if (cmd == CMD_FLAG_STATUS) {
+		poll_bit = STATUS_PEC;
+		check_status = poll_bit;
+	}
+
+#ifdef CONFIG_SF_DUAL_FLASH
+	if (spi->flags & SPI_XFER_U_PAGE)
+		flags |= SPI_XFER_U_PAGE;
+#endif
+	ret = spi_xfer(spi, 8, &cmd, NULL, flags);
+	if (ret) {
+		debug("SF: fail to read %s status register\n",
+		      cmd == CMD_READ_STATUS ? "read" : "flag");
+		return ret;
+	}
+
+	timebase = get_timer(0);
+	do {
+		WATCHDOG_RESET();
+
+		ret = spi_xfer(spi, 8, NULL, &status, 0);
+		if (ret)
+			return -1;
+
+		if ((status & poll_bit) == check_status)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
+
+	if ((status & poll_bit) == check_status)
+		return 0;
+
+	/* Timed out */
+	debug("SF: time out!\n");
+	return -1;
+}
+
+int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
+		size_t cmd_len, const void *buf, size_t buf_len)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timeout = SPI_FLASH_PROG_TIMEOUT;
+	int ret;
+
+	if (buf == NULL)
+		timeout = SPI_FLASH_PAGE_ERASE_TIMEOUT;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = spi_flash_cmd_write_enable(flash);
+	if (ret < 0) {
+		debug("SF: enabling write failed\n");
+		return ret;
+	}
+
+	ret = spi_flash_cmd_write(spi, cmd, cmd_len, buf, buf_len);
+	if (ret < 0) {
+		debug("SF: write cmd failed\n");
+		return ret;
+	}
+
+	ret = spi_flash_cmd_wait_ready(flash, timeout);
+	if (ret < 0) {
+		debug("SF: write %s timed out\n",
+		      timeout == SPI_FLASH_PROG_TIMEOUT ?
+			"program" : "page erase");
+		return ret;
+	}
+
+	spi_release_bus(spi);
+
+	return ret;
+}
+
+int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
+{
+	u32 erase_size, erase_addr;
+	u8 cmd[SPI_FLASH_CMD_LEN];
+	int ret = -1;
+
+	erase_size = flash->erase_size;
+	if (offset % erase_size || len % erase_size) {
+		debug("SF: Erase offset/length not multiple of erase size\n");
+		return -1;
+	}
+
+	cmd[0] = flash->erase_cmd;
+	while (len) {
+		erase_addr = offset;
+
+#ifdef CONFIG_SF_DUAL_FLASH
+		if (flash->dual_flash > SF_SINGLE_FLASH)
+			spi_flash_dual_flash(flash, &erase_addr);
+#endif
+#ifdef CONFIG_SPI_FLASH_BAR
+		ret = spi_flash_bank(flash, erase_addr);
+		if (ret < 0)
+			return ret;
+#endif
+		spi_flash_addr(erase_addr, cmd);
+
+		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
+		      cmd[2], cmd[3], erase_addr);
+
+		ret = spi_flash_write_common(flash, cmd, sizeof(cmd), NULL, 0);
+		if (ret < 0) {
+			debug("SF: erase failed\n");
+			break;
+		}
+
+		offset += erase_size;
+		len -= erase_size;
+	}
+
+#ifdef CONFIG_SPI_FLASH_BAR
+		ret = spi_flash_bank(flash, 0);
+		if (ret < 0)
+			return ret;
+#endif
+
+	return ret;
+}
+
+int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
+		size_t len, const void *buf)
+{
+	unsigned long byte_addr, page_size;
+	u32 write_addr;
+	size_t chunk_len, actual;
+	u8 cmd[SPI_FLASH_CMD_LEN];
+	int ret = -1;
+
+	page_size = flash->page_size;
+
+	cmd[0] = flash->write_cmd;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		write_addr = offset;
+
+#ifdef CONFIG_SF_DUAL_FLASH
+		if (flash->dual_flash > SF_SINGLE_FLASH)
+			spi_flash_dual_flash(flash, &write_addr);
+#endif
+#ifdef CONFIG_SPI_FLASH_BAR
+		ret = spi_flash_bank(flash, write_addr);
+		if (ret < 0)
+			return ret;
+#endif
+		byte_addr = offset % page_size;
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		if (flash->spi->max_write_size)
+			chunk_len = min(chunk_len, flash->spi->max_write_size);
+
+		spi_flash_addr(write_addr, cmd);
+
+		debug("SF: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %zu\n",
+		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_write_common(flash, cmd, sizeof(cmd),
+					buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: write failed\n");
+			break;
+		}
+
+		offset += chunk_len;
+	}
+
+#ifdef CONFIG_SPI_FLASH_BAR
+		ret = spi_flash_bank(flash, 0);
+		if (ret < 0)
+			return ret;
+#endif
+
+	return ret;
+}
+
+int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
+		size_t cmd_len, void *data, size_t data_len)
+{
+	struct spi_slave *spi = flash->spi;
+	int ret;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = spi_flash_cmd_read(spi, cmd, cmd_len, data, data_len);
+	if (ret < 0) {
+		debug("SF: read cmd failed\n");
+		return ret;
+	}
+
+	spi_release_bus(spi);
+
+	return ret;
+}
+
+int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
+		size_t len, void *data)
+{
+	u8 *cmd, cmdsz;
+	u32 remain_len, read_len, read_addr;
+	int bank_sel = 0;
+	int ret = -1;
+
+	/* Handle memory-mapped SPI */
+	if (flash->memory_map) {
+		ret = spi_claim_bus(flash->spi);
+		if (ret) {
+			debug("SF: unable to claim SPI bus\n");
+			return ret;
+		}
+		spi_xfer(flash->spi, 0, NULL, NULL, SPI_XFER_MMAP);
+		memcpy(data, flash->memory_map + offset, len);
+		spi_xfer(flash->spi, 0, NULL, NULL, SPI_XFER_MMAP_END);
+		spi_release_bus(flash->spi);
+		return 0;
+	}
+
+	cmdsz = SPI_FLASH_CMD_LEN + flash->dummy_byte;
+	cmd = calloc(1, cmdsz);
+	if (!cmd) {
+		debug("SF: Failed to allocate cmd\n");
+		return -ENOMEM;
+	}
+
+	cmd[0] = flash->read_cmd;
+	while (len) {
+		read_addr = offset;
+
+#ifdef CONFIG_SF_DUAL_FLASH
+		if (flash->dual_flash > SF_SINGLE_FLASH)
+			spi_flash_dual_flash(flash, &read_addr);
+#endif
+#ifdef CONFIG_SPI_FLASH_BAR
+		bank_sel = spi_flash_bank(flash, read_addr);
+		if (bank_sel < 0)
+			return ret;
+#endif
+		remain_len = ((SPI_FLASH_16MB_BOUN << flash->shift) *
+				(bank_sel + 1)) - offset;
+		if (len < remain_len)
+			read_len = len;
+		else
+			read_len = remain_len;
+
+		spi_flash_addr(read_addr, cmd);
+
+		ret = spi_flash_read_common(flash, cmd, cmdsz, data, read_len);
+		if (ret < 0) {
+			debug("SF: read failed\n");
+			break;
+		}
+
+		offset += read_len;
+		len -= read_len;
+		data += read_len;
+	}
+
+#ifdef CONFIG_SPI_FLASH_BAR
+		ret = spi_flash_bank(flash, 0);
+		if (ret < 0)
+			return ret;
+#endif
+
+	free(cmd);
+	return ret;
+}
+
+#ifdef CONFIG_SPI_FLASH_SST
+static int sst_byte_write(struct spi_flash *flash, u32 offset, const void *buf)
+{
+	int ret;
+	u8 cmd[4] = {
+		CMD_SST_BP,
+		offset >> 16,
+		offset >> 8,
+		offset,
+	};
+
+	debug("BP[%02x]: 0x%p => cmd = { 0x%02x 0x%06x }\n",
+	      spi_w8r8(flash->spi, CMD_READ_STATUS), buf, cmd[0], offset);
+
+	ret = spi_flash_cmd_write_enable(flash);
+	if (ret)
+		return ret;
+
+	ret = spi_flash_cmd_write(flash->spi, cmd, sizeof(cmd), buf, 1);
+	if (ret)
+		return ret;
+
+	return spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+}
+
+int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
+		const void *buf)
+{
+	size_t actual, cmd_len;
+	int ret;
+	u8 cmd[4];
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	/* If the data is not word aligned, write out leading single byte */
+	actual = offset % 2;
+	if (actual) {
+		ret = sst_byte_write(flash, offset, buf);
+		if (ret)
+			goto done;
+	}
+	offset += actual;
+
+	ret = spi_flash_cmd_write_enable(flash);
+	if (ret)
+		goto done;
+
+	cmd_len = 4;
+	cmd[0] = CMD_SST_AAI_WP;
+	cmd[1] = offset >> 16;
+	cmd[2] = offset >> 8;
+	cmd[3] = offset;
+
+	for (; actual < len - 1; actual += 2) {
+		debug("WP[%02x]: 0x%p => cmd = { 0x%02x 0x%06x }\n",
+		      spi_w8r8(flash->spi, CMD_READ_STATUS), buf + actual,
+		      cmd[0], offset);
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, cmd_len,
+					buf + actual, 2);
+		if (ret) {
+			debug("SF: sst word program failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret)
+			break;
+
+		cmd_len = 1;
+		offset += 2;
+	}
+
+	if (!ret)
+		ret = spi_flash_cmd_write_disable(flash);
+
+	/* If there is a single trailing byte, write it out */
+	if (!ret && actual != len)
+		ret = sst_byte_write(flash, offset, buf + actual);
+
+ done:
+	debug("SF: sst: program %s %zu bytes @ 0x%zx\n",
+	      ret ? "failure" : "success", len, offset - actual);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+#endif
diff --git a/drivers/mtd/spi/sf_params.c b/drivers/mtd/spi/sf_params.c
new file mode 100644
index 0000000..ac886fd
--- /dev/null
+++ b/drivers/mtd/spi/sf_params.c
@@ -0,0 +1,132 @@
+/*
+ * SPI flash Params table
+ *
+ * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spi_flash.h>
+
+#include "sf_internal.h"
+
+/* SPI/QSPI flash device params structure */
+const struct spi_flash_params spi_flash_params_table[] = {
+#ifdef CONFIG_SPI_FLASH_ATMEL		/* ATMEL */
+	{"AT45DB011D",	   0x1f2200, 0x0,	64 * 1024,     4,	0,		    SECT_4K},
+	{"AT45DB021D",	   0x1f2300, 0x0,	64 * 1024,     8,	0,		    SECT_4K},
+	{"AT45DB041D",	   0x1f2400, 0x0,	64 * 1024,     8,	0,		    SECT_4K},
+	{"AT45DB081D",	   0x1f2500, 0x0,	64 * 1024,    16,	0,		    SECT_4K},
+	{"AT45DB161D",	   0x1f2600, 0x0,	64 * 1024,    32,	0,		    SECT_4K},
+	{"AT45DB321D",	   0x1f2700, 0x0,	64 * 1024,    64,	0,		    SECT_4K},
+	{"AT45DB641D",	   0x1f2800, 0x0,	64 * 1024,   128,	0,		    SECT_4K},
+	{"AT25DF321",      0x1f4701, 0x0,	64 * 1024,    64,	0,		    SECT_4K},
+#endif
+#ifdef CONFIG_SPI_FLASH_EON		/* EON */
+	{"EN25Q32B",	   0x1c3016, 0x0,	64 * 1024,    64,	0,			  0},
+	{"EN25Q64",	   0x1c3017, 0x0,	64 * 1024,   128,	0,		    SECT_4K},
+	{"EN25Q128B",	   0x1c3018, 0x0,       64 * 1024,   256,	0,			  0},
+	{"EN25S64",	   0x1c3817, 0x0,	64 * 1024,   128,	0,			  0},
+#endif
+#ifdef CONFIG_SPI_FLASH_GIGADEVICE	/* GIGADEVICE */
+	{"GD25Q64B",	   0xc84017, 0x0,	64 * 1024,   128,	0,		    SECT_4K},
+	{"GD25LQ32",	   0xc86016, 0x0,	64 * 1024,    64,	0,		    SECT_4K},
+#endif
+#ifdef CONFIG_SPI_FLASH_MACRONIX	/* MACRONIX */
+	{"MX25L2006E",	   0xc22012, 0x0,	64 * 1024,     4,	0,			  0},
+	{"MX25L4005",	   0xc22013, 0x0,	64 * 1024,     8,	0,			  0},
+	{"MX25L8005",	   0xc22014, 0x0,	64 * 1024,    16,	0,			  0},
+	{"MX25L1605D",	   0xc22015, 0x0,	64 * 1024,    32,	0,			  0},
+	{"MX25L3205D",	   0xc22016, 0x0,	64 * 1024,    64,	0,			  0},
+	{"MX25L6405D",	   0xc22017, 0x0,	64 * 1024,   128,	0,			  0},
+	{"MX25L12805",	   0xc22018, 0x0,	64 * 1024,   256, RD_FULL,		     WR_QPP},
+	{"MX25L25635F",	   0xc22019, 0x0,	64 * 1024,   512, RD_FULL,		     WR_QPP},
+	{"MX25L51235F",	   0xc2201a, 0x0,	64 * 1024,  1024, RD_FULL,		     WR_QPP},
+	{"MX25L12855E",	   0xc22618, 0x0,	64 * 1024,   256, RD_FULL,		     WR_QPP},
+#endif
+#ifdef CONFIG_SPI_FLASH_SPANSION	/* SPANSION */
+	{"S25FL008A",	   0x010213, 0x0,	64 * 1024,    16,	0,			  0},
+	{"S25FL016A",	   0x010214, 0x0,	64 * 1024,    32,	0,			  0},
+	{"S25FL032A",	   0x010215, 0x0,	64 * 1024,    64,	0,			  0},
+	{"S25FL064A",	   0x010216, 0x0,	64 * 1024,   128,	0,			  0},
+	{"S25FL128P_256K", 0x012018, 0x0300,   256 * 1024,    64, RD_FULL,		     WR_QPP},
+	{"S25FL128P_64K",  0x012018, 0x0301,    64 * 1024,   256, RD_FULL,		     WR_QPP},
+	{"S25FL032P",	   0x010215, 0x4d00,    64 * 1024,    64, RD_FULL,		     WR_QPP},
+	{"S25FL064P",	   0x010216, 0x4d00,    64 * 1024,   128, RD_FULL,		     WR_QPP},
+	{"S25FL128S_256K", 0x012018, 0x4d00,   256 * 1024,    64, RD_FULL,		     WR_QPP},
+	{"S25FL128S_64K",  0x012018, 0x4d01,    64 * 1024,   256, RD_FULL,		     WR_QPP},
+	{"S25FL256S_256K", 0x010219, 0x4d00,   256 * 1024,   128, RD_FULL,		     WR_QPP},
+	{"S25FL256S_64K",  0x010219, 0x4d01,	64 * 1024,   512, RD_FULL,		     WR_QPP},
+	{"S25FL512S_256K", 0x010220, 0x4d00,   256 * 1024,   256, RD_FULL,		     WR_QPP},
+	{"S25FL512S_64K",  0x010220, 0x4d01,    64 * 1024,  1024, RD_FULL,		     WR_QPP},
+	{"S25FL512S_512K", 0x010220, 0x4f00,   256 * 1024,   256, RD_FULL,		     WR_QPP},
+#endif
+#ifdef CONFIG_SPI_FLASH_STMICRO		/* STMICRO */
+	{"M25P10",	   0x202011, 0x0,	32 * 1024,     4,	0,			  0},
+	{"M25P20",	   0x202012, 0x0,       64 * 1024,     4,	0,			  0},
+	{"M25P40",	   0x202013, 0x0,       64 * 1024,     8,	0,			  0},
+	{"M25P80",	   0x202014, 0x0,       64 * 1024,    16,	0,			  0},
+	{"M25P16",	   0x202015, 0x0,       64 * 1024,    32,	0,			  0},
+	{"M25P32",	   0x202016, 0x0,       64 * 1024,    64,	0,			  0},
+	{"M25P64",	   0x202017, 0x0,       64 * 1024,   128,	0,			  0},
+	{"M25P128",	   0x202018, 0x0,      256 * 1024,    64,	0,			  0},
+	{"N25Q32",	   0x20ba16, 0x0,       64 * 1024,    64, RD_FULL,	   WR_QPP | SECT_4K},
+	{"N25Q32A",	   0x20bb16, 0x0,       64 * 1024,    64, RD_FULL,	   WR_QPP | SECT_4K},
+	{"N25Q64",	   0x20ba17, 0x0,       64 * 1024,   128, RD_FULL,	   WR_QPP | SECT_4K},
+	{"N25Q64A",	   0x20bb17, 0x0,       64 * 1024,   128, RD_FULL,	   WR_QPP | SECT_4K},
+	{"N25Q128",	   0x20ba18, 0x0,       64 * 1024,   256, RD_FULL,		     WR_QPP},
+	{"N25Q128A",	   0x20bb18, 0x0,       64 * 1024,   256, RD_FULL,		     WR_QPP},
+	{"N25Q256",	   0x20ba19, 0x0,       64 * 1024,   512, RD_FULL,	   WR_QPP | SECT_4K},
+	{"N25Q256A",	   0x20bb19, 0x0,       64 * 1024,   512, RD_FULL,	   WR_QPP | SECT_4K},
+	{"N25Q512",	   0x20ba20, 0x0,       64 * 1024,  1024, RD_FULL, WR_QPP | E_FSR | SECT_4K},
+	{"N25Q512A",	   0x20bb20, 0x0,       64 * 1024,  1024, RD_FULL, WR_QPP | E_FSR | SECT_4K},
+	{"N25Q1024",	   0x20ba21, 0x0,       64 * 1024,  2048, RD_FULL, WR_QPP | E_FSR | SECT_4K},
+	{"N25Q1024A",	   0x20bb21, 0x0,       64 * 1024,  2048, RD_FULL, WR_QPP | E_FSR | SECT_4K},
+#endif
+#ifdef CONFIG_SPI_FLASH_SST		/* SST */
+	{"SST25VF040B",	   0xbf258d, 0x0,	64 * 1024,     8,	0,          SECT_4K | SST_WP},
+	{"SST25VF080B",	   0xbf258e, 0x0,	64 * 1024,    16,	0,	    SECT_4K | SST_WP},
+	{"SST25VF016B",	   0xbf2541, 0x0,	64 * 1024,    32,	0,	    SECT_4K | SST_WP},
+	{"SST25VF032B",	   0xbf254a, 0x0,	64 * 1024,    64,	0,	    SECT_4K | SST_WP},
+	{"SST25VF064C",	   0xbf254b, 0x0,	64 * 1024,   128,	0,		     SECT_4K},
+	{"SST25WF512",	   0xbf2501, 0x0,	64 * 1024,     1,	0,	    SECT_4K | SST_WP},
+	{"SST25WF010",	   0xbf2502, 0x0,	64 * 1024,     2,       0,          SECT_4K | SST_WP},
+	{"SST25WF020",	   0xbf2503, 0x0,	64 * 1024,     4,       0,	    SECT_4K | SST_WP},
+	{"SST25WF040",	   0xbf2504, 0x0,	64 * 1024,     8,       0,	    SECT_4K | SST_WP},
+	{"SST25WF080",	   0xbf2505, 0x0,	64 * 1024,    16,       0,	    SECT_4K | SST_WP},
+#endif
+#ifdef CONFIG_SPI_FLASH_WINBOND		/* WINBOND */
+	{"W25P80",	   0xef2014, 0x0,	64 * 1024,    16,	0,		           0},
+	{"W25P16",	   0xef2015, 0x0,	64 * 1024,    32,	0,		           0},
+	{"W25P32",	   0xef2016, 0x0,	64 * 1024,    64,	0,		           0},
+	{"W25X40",	   0xef3013, 0x0,	64 * 1024,     8,	0,		     SECT_4K},
+	{"W25X16",	   0xef3015, 0x0,	64 * 1024,    32,	0,		     SECT_4K},
+	{"W25X32",	   0xef3016, 0x0,	64 * 1024,    64,	0,		     SECT_4K},
+	{"W25X64",	   0xef3017, 0x0,	64 * 1024,   128,	0,		     SECT_4K},
+	{"W25Q80BL",	   0xef4014, 0x0,	64 * 1024,    16, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q16CL",	   0xef4015, 0x0,	64 * 1024,    32, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q32BV",	   0xef4016, 0x0,	64 * 1024,    64, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q64CV",	   0xef4017, 0x0,	64 * 1024,   128, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q128BV",	   0xef4018, 0x0,	64 * 1024,   256, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q256",	   0xef4019, 0x0,	64 * 1024,   512, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q80BW",	   0xef5014, 0x0,	64 * 1024,    16, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q16DW",	   0xef6015, 0x0,	64 * 1024,    32, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q32DW",	   0xef6016, 0x0,	64 * 1024,    64, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q64DW",	   0xef6017, 0x0,	64 * 1024,   128, RD_FULL,	    WR_QPP | SECT_4K},
+	{"W25Q128FW",	   0xef6018, 0x0,	64 * 1024,   256, RD_FULL,	    WR_QPP | SECT_4K},
+#endif
+	/*
+	 * Note:
+	 * Below paired flash devices has similar spi_flash params.
+	 * (S25FL129P_64K, S25FL128S_64K)
+	 * (W25Q80BL, W25Q80BV)
+	 * (W25Q16CL, W25Q16DV)
+	 * (W25Q32BV, W25Q32FV_SPI)
+	 * (W25Q64CV, W25Q64FV_SPI)
+	 * (W25Q128BV, W25Q128FV_SPI)
+	 * (W25Q32DW, W25Q32FV_QPI)
+	 * (W25Q64DW, W25Q64FV_QPI)
+	 * (W25Q128FW, W25Q128FV_QPI)
+	 */
+};
diff --git a/drivers/mtd/spi/sf_probe.c b/drivers/mtd/spi/sf_probe.c
new file mode 100644
index 0000000..f0cc71a
--- /dev/null
+++ b/drivers/mtd/spi/sf_probe.c
@@ -0,0 +1,436 @@
+/*
+ * SPI flash probing
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ * Copyright (C) 2010 Reinhard Meyer, EMK Elektronik
+ * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fdtdec.h>
+#include <malloc.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <asm/io.h>
+
+#ifdef MILES_DEBUG
+#define miles_printf(fmt, args...) printf("    miles: "); printf(fmt, ##args)
+#else
+#define miles_printf(fmt, args...)
+#endif
+
+#include "sf_internal.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* Read commands array */
+static u8 spi_read_cmds_array[] = {
+	CMD_READ_ARRAY_SLOW,
+	CMD_READ_DUAL_OUTPUT_FAST,
+	CMD_READ_DUAL_IO_FAST,
+	CMD_READ_QUAD_OUTPUT_FAST,
+	CMD_READ_QUAD_IO_FAST,
+};
+
+#ifdef CONFIG_SPI_FLASH_MACRONIX
+static int spi_flash_set_qeb_mxic(struct spi_flash *flash)
+{
+	u8 qeb_status;
+	int ret;
+
+	ret = spi_flash_cmd_read_status(flash, &qeb_status);
+	if (ret < 0)
+		return ret;
+
+	if (qeb_status & STATUS_QEB_MXIC) {
+		debug("SF: mxic: QEB is already set\n");
+	} else {
+		ret = spi_flash_cmd_write_status(flash, STATUS_QEB_MXIC);
+		if (ret < 0)
+			return ret;
+	}
+
+	return ret;
+}
+#endif
+
+#if defined(CONFIG_SPI_FLASH_SPANSION) || defined(CONFIG_SPI_FLASH_WINBOND)
+static int spi_flash_set_qeb_winspan(struct spi_flash *flash)
+{
+	u8 qeb_status;
+	int ret;
+	ret = spi_flash_cmd_read_config(flash, &qeb_status);
+	if (ret < 0)
+		return ret;
+
+	if (qeb_status & STATUS_QEB_WINSPAN) {
+		debug("SF: winspan: QEB is already set\n");
+	} else {
+		ret = spi_flash_cmd_write_config(flash, STATUS_QEB_WINSPAN);
+		if (ret < 0)
+			return ret;
+	}
+
+	return ret;
+}
+#endif
+
+static int spi_flash_set_qeb(struct spi_flash *flash, u8 idcode0)
+{
+	switch (idcode0) {
+#ifdef CONFIG_SPI_FLASH_MACRONIX
+	case SPI_FLASH_CFI_MFR_MACRONIX:
+		return spi_flash_set_qeb_mxic(flash);
+#endif
+#if defined(CONFIG_SPI_FLASH_SPANSION) || defined(CONFIG_SPI_FLASH_WINBOND)
+	case SPI_FLASH_CFI_MFR_SPANSION:
+	case SPI_FLASH_CFI_MFR_WINBOND:
+		return spi_flash_set_qeb_winspan(flash);
+#endif
+#ifdef CONFIG_SPI_FLASH_STMICRO
+	case SPI_FLASH_CFI_MFR_STMICRO:
+		debug("SF: QEB is volatile for %02x flash\n", idcode0);
+		return 0;
+#endif
+	default:
+		printf("SF: Need set QEB func for %02x flash\n", idcode0);
+		return -1;
+	}
+}
+
+static struct spi_flash *spi_flash_validate_params(struct spi_slave *spi,
+		u8 *idcode)
+{
+	const struct spi_flash_params *params;
+	struct spi_flash *flash;
+	u8 cmd;
+	u16 jedec = idcode[1] << 8 | idcode[2];
+	u16 ext_jedec = idcode[3] << 8 | idcode[4];
+	params = spi_flash_params_table;
+	for (; params->name != NULL; params++) {
+		if ((params->jedec >> 16) == idcode[0]) {
+			if ((params->jedec & 0xFFFF) == jedec) {
+				if (params->ext_jedec == 0)
+					break;
+				else if (params->ext_jedec == ext_jedec)
+					break;
+			}
+		}
+	}
+
+	if (!params->name) {
+		printf("SF: Unsupported flash IDs: ");
+		printf("manuf %02x, jedec %04x, ext_jedec %04x\n",
+		       idcode[0], jedec, ext_jedec);
+		return NULL;
+	}
+
+	flash = calloc(1, sizeof(*flash));
+	if (!flash) {
+		debug("SF: Failed to allocate spi_flash\n");
+		return NULL;
+	}
+
+	/* Assign spi data */
+	flash->spi = spi;
+	flash->name = params->name;
+	flash->memory_map = spi->memory_map;
+	flash->dual_flash = flash->spi->option;
+
+	/* Assign spi_flash ops */
+	flash->write = spi_flash_cmd_write_ops;
+#ifdef CONFIG_SPI_FLASH_SST
+	if (params->flags & SST_WP)
+		flash->write = sst_write_wp;
+#endif
+	flash->erase = spi_flash_cmd_erase_ops;
+	flash->read = spi_flash_cmd_read_ops;
+
+	/* Compute the flash size */
+	flash->shift = (flash->dual_flash & SF_DUAL_PARALLEL_FLASH) ? 1 : 0;
+	/*
+	 * The Spansion S25FL032P and S25FL064P have 256b pages, yet use the
+	 * 0x4d00 Extended JEDEC code. The rest of the Spansion flashes with
+	 * the 0x4d00 Extended JEDEC code have 512b pages. All of the others
+	 * have 256b pages.
+	 */
+	if (ext_jedec == 0x4d00) {
+		if ((jedec == 0x0215) || (jedec == 0x216))
+			flash->page_size = 256;
+		else
+			flash->page_size = 512;
+	} else {
+		flash->page_size = 256;
+	}
+	flash->page_size <<= flash->shift;
+	flash->sector_size = params->sector_size << flash->shift;
+	flash->size = flash->sector_size * params->nr_sectors << flash->shift;
+#ifdef CONFIG_SF_DUAL_FLASH
+	if (flash->dual_flash & SF_DUAL_STACKED_FLASH)
+		flash->size <<= 1;
+#endif
+
+	/* Compute erase sector and command */
+	if (params->flags & SECT_4K) {
+		flash->erase_cmd = CMD_ERASE_4K;
+		flash->erase_size = 4096 << flash->shift;
+	} else if (params->flags & SECT_32K) {
+		flash->erase_cmd = CMD_ERASE_32K;
+		flash->erase_size = 32768 << flash->shift;
+	} else {
+		flash->erase_cmd = CMD_ERASE_64K;
+		flash->erase_size = flash->sector_size;
+	}
+
+	/* Look for the fastest read cmd */
+	cmd = fls(params->e_rd_cmd & flash->spi->op_mode_rx);
+	if (cmd) {
+		cmd = spi_read_cmds_array[cmd - 1];
+		flash->read_cmd = cmd;
+	} else {
+		/* Go for default supported read cmd */
+		flash->read_cmd = CMD_READ_ARRAY_FAST;
+	}
+
+	/* Not require to look for fastest only two write cmds yet */
+	if (params->flags & WR_QPP && flash->spi->op_mode_tx & SPI_OPM_TX_QPP)
+		flash->write_cmd = CMD_QUAD_PAGE_PROGRAM;
+	else
+		/* Go for default supported write cmd */
+		flash->write_cmd = CMD_PAGE_PROGRAM;
+
+	/* Read dummy_byte: dummy byte is determined based on the
+	 * dummy cycles of a particular command.
+	 * Fast commands - dummy_byte = dummy_cycles/8
+	 * I/O commands- dummy_byte = (dummy_cycles * no.of lines)/8
+	 * For I/O commands except cmd[0] everything goes on no.of lines
+	 * based on particular command but incase of fast commands except
+	 * data all go on single line irrespective of command.
+	 */
+	switch (flash->read_cmd) {
+	case CMD_READ_QUAD_IO_FAST:
+		flash->dummy_byte = 2;
+		break;
+	case CMD_READ_ARRAY_SLOW:
+		flash->dummy_byte = 0;
+		break;
+	default:
+		flash->dummy_byte = 1;
+	}
+
+	/* Poll cmd selection */
+	flash->poll_cmd = CMD_READ_STATUS;
+#ifdef CONFIG_SPI_FLASH_STMICRO
+	if (params->flags & E_FSR)
+		flash->poll_cmd = CMD_FLAG_STATUS;
+#endif
+
+	/* Configure the BAR - discover bank cmds and read current bank */
+#ifdef CONFIG_SPI_FLASH_BAR
+	u8 curr_bank = 0;
+	if (flash->size > SPI_FLASH_16MB_BOUN) {
+		flash->bank_read_cmd = (idcode[0] == 0x01) ?
+					CMD_BANKADDR_BRRD : CMD_EXTNADDR_RDEAR;
+		flash->bank_write_cmd = (idcode[0] == 0x01) ?
+					CMD_BANKADDR_BRWR : CMD_EXTNADDR_WREAR;
+
+		if (spi_flash_read_common(flash, &flash->bank_read_cmd, 1,
+					  &curr_bank, 1)) {
+			debug("SF: fail to read bank addr register\n");
+			return NULL;
+		}
+		flash->bank_curr = curr_bank;
+	} else {
+		flash->bank_curr = curr_bank;
+	}
+#endif
+
+	/* Flash powers up read-only, so clear BP# bits */
+#if defined(CONFIG_SPI_FLASH_ATMEL) || \
+	defined(CONFIG_SPI_FLASH_MACRONIX) || \
+	defined(CONFIG_SPI_FLASH_SST)
+		spi_flash_cmd_write_status(flash, 0);
+#endif
+
+	return flash;
+}
+
+#ifdef CONFIG_OF_CONTROL
+int spi_flash_decode_fdt(const void *blob, struct spi_flash *flash)
+{
+	fdt_addr_t addr;
+	fdt_size_t size;
+	int node;
+
+	/* If there is no node, do nothing */
+	node = fdtdec_next_compatible(blob, 0, COMPAT_GENERIC_SPI_FLASH);
+	if (node < 0)
+		return 0;
+
+	addr = fdtdec_get_addr_size(blob, node, "memory-map", &size);
+	if (addr == FDT_ADDR_T_NONE) {
+		debug("%s: Cannot decode address\n", __func__);
+		return 0;
+	}
+
+	if (flash->size != size) {
+		debug("%s: Memory map must cover entire device\n", __func__);
+		return -1;
+	}
+	flash->memory_map = map_sysmem(addr, size);
+
+	return 0;
+}
+#endif /* CONFIG_OF_CONTROL */
+
+#ifdef CONFIG_SYS_SPI_ST_ENABLE_WP_PIN
+#error miles
+/* enable the W#/Vpp signal to disable writing to the status register */
+static int spi_enable_wp_pin(struct spi_flash *flash)
+{
+	u8 status;
+	int ret;
+
+	ret = spi_flash_cmd_read_status(flash, &status);
+	if (ret < 0)
+		return ret;
+
+	ret = spi_flash_cmd_write_status(flash, STATUS_SRWD);
+	if (ret < 0)
+		return ret;
+
+	ret = spi_flash_cmd_write_disable(flash);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+#else
+static int spi_enable_wp_pin(struct spi_flash *flash)
+{
+	return 0;
+}
+#endif
+
+static struct spi_flash *spi_flash_probe_slave(struct spi_slave *spi)
+{
+    miles_printf("%d, %s\n", __LINE__, __func__);
+	struct spi_flash *flash = NULL;
+	u8 idcode[5];
+	int ret;
+	/* Setup spi_slave */
+	if (!spi) {
+		printf("SF: Failed to set up slave\n");
+		return NULL;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("SF: Failed to claim SPI bus: %d\n", ret);
+		goto err_claim_bus;
+	}
+
+	/* Read the ID codes */
+	ret = spi_flash_cmd(spi, CMD_READ_ID, idcode, sizeof(idcode));
+	if (ret) {
+		printf("SF: Failed to get idcodes\n");
+		goto err_read_id;
+	}
+
+#ifdef DEBUG
+	printf("SF: Got idcodes\n");
+	print_buffer(0, idcode, 1, sizeof(idcode), 0);
+#endif
+
+	/* Validate params from spi_flash_params table */
+	flash = spi_flash_validate_params(spi, idcode);
+	if (!flash)
+		goto err_read_id;
+
+	/* Set the quad enable bit - only for quad commands */
+	if ((flash->read_cmd == CMD_READ_QUAD_OUTPUT_FAST) ||
+	    (flash->read_cmd == CMD_READ_QUAD_IO_FAST) ||
+	    (flash->write_cmd == CMD_QUAD_PAGE_PROGRAM)) {
+		if (spi_flash_set_qeb(flash, idcode[0])) {
+			debug("SF: Fail to set QEB for %02x\n", idcode[0]);
+			return NULL;
+		}
+	}
+
+#ifdef CONFIG_OF_CONTROL
+#error miles
+	if (spi_flash_decode_fdt(gd->fdt_blob, flash)) {
+		debug("SF: FDT decode error\n");
+		goto err_read_id;
+	}
+#endif
+#ifndef CONFIG_SPL_BUILD
+	printf("SF: Detected %s with page size ", flash->name);
+	print_size(flash->page_size, ", erase size ");
+	print_size(flash->erase_size, ", total ");
+	print_size(flash->size, "");
+	if (flash->memory_map)
+		printf(", mapped at %p", flash->memory_map);
+	puts("\n");
+#endif
+#ifndef CONFIG_SPI_FLASH_BAR
+#error miles
+	if (((flash->dual_flash == SF_SINGLE_FLASH) &&
+	     (flash->size > SPI_FLASH_16MB_BOUN)) ||
+	     ((flash->dual_flash > SF_SINGLE_FLASH) &&
+	     (flash->size > SPI_FLASH_16MB_BOUN << 1))) {
+		puts("SF: Warning - Only lower 16MiB accessible,");
+		puts(" Full access #define CONFIG_SPI_FLASH_BAR\n");
+	}
+#endif
+	if (spi_enable_wp_pin(flash))
+		puts("Enable WP pin failed\n");
+
+	/* Release spi bus */
+	spi_release_bus(spi);
+
+	return flash;
+
+err_read_id:
+	spi_release_bus(spi);
+err_claim_bus:
+	spi_free_slave(spi);
+	return NULL;
+}
+
+struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int spi_mode)
+{
+    miles_printf("file: %s\n", __FILE__);
+    miles_printf("line: %d\n", __LINE__);
+    miles_printf("func: %s\n", __func__);
+    miles_printf("arg - bus:      %u\n", bus);
+    miles_printf("arg - cs:       %u\n", cs);
+    miles_printf("arg - max_hz:   %u\n", max_hz);
+    miles_printf("arg - spi_mode: %u\n", spi_mode);
+
+	struct spi_slave *spi;
+
+	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
+	return spi_flash_probe_slave(spi);
+}
+
+#ifdef CONFIG_OF_SPI_FLASH
+struct spi_flash *spi_flash_probe_fdt(const void *blob, int slave_node,
+				      int spi_node)
+{
+	struct spi_slave *spi;
+
+	spi = spi_setup_slave_fdt(blob, slave_node, spi_node);
+	return spi_flash_probe_slave(spi);
+}
+#endif
+
+void spi_flash_free(struct spi_flash *flash)
+{
+	spi_free_slave(flash->spi);
+	free(flash);
+}
diff --git a/drivers/mtd/spi/spansion.c b/drivers/mtd/spi/spansion.c
deleted file mode 100644
index 32b76e0..0000000
--- a/drivers/mtd/spi/spansion.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2009 Freescale Semiconductor, Inc.
- *
- * Author: Mingkai Hu (Mingkai.hu@freescale.com)
- * Based on stmicro.c by Wolfgang Denk (wd@denx.de),
- * TsiChung Liew (Tsi-Chung.Liew@freescale.com),
- * and  Jason McMullan (mcmullan@netapp.com)
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <spi_flash.h>
-
-#include "spi_flash_internal.h"
-
-struct spansion_spi_flash_params {
-	u16 idcode1;
-	u16 idcode2;
-	u16 pages_per_sector;
-	u16 nr_sectors;
-	const char *name;
-};
-
-static const struct spansion_spi_flash_params spansion_spi_flash_table[] = {
-	{
-		.idcode1 = 0x0213,
-		.idcode2 = 0,
-		.pages_per_sector = 256,
-		.nr_sectors = 16,
-		.name = "S25FL008A",
-	},
-	{
-		.idcode1 = 0x0214,
-		.idcode2 = 0,
-		.pages_per_sector = 256,
-		.nr_sectors = 32,
-		.name = "S25FL016A",
-	},
-	{
-		.idcode1 = 0x0215,
-		.idcode2 = 0,
-		.pages_per_sector = 256,
-		.nr_sectors = 64,
-		.name = "S25FL032A",
-	},
-	{
-		.idcode1 = 0x0216,
-		.idcode2 = 0,
-		.pages_per_sector = 256,
-		.nr_sectors = 128,
-		.name = "S25FL064A",
-	},
-	{
-		.idcode1 = 0x2018,
-		.idcode2 = 0x0301,
-		.pages_per_sector = 256,
-		.nr_sectors = 256,
-		.name = "S25FL128P_64K",
-	},
-	{
-		.idcode1 = 0x2018,
-		.idcode2 = 0x0300,
-		.pages_per_sector = 1024,
-		.nr_sectors = 64,
-		.name = "S25FL128P_256K",
-	},
-	{
-		.idcode1 = 0x0215,
-		.idcode2 = 0x4d00,
-		.pages_per_sector = 256,
-		.nr_sectors = 64,
-		.name = "S25FL032P",
-	},
-	{
-		.idcode1 = 0x2018,
-		.idcode2 = 0x4d01,
-		.pages_per_sector = 256,
-		.nr_sectors = 256,
-		.name = "S25FL129P_64K",
-	},
-	{
-		.idcode1 = 0x2019,
-		.idcode2 = 0x4d01,
-		.pages_per_sector = 256,
-		.nr_sectors = 512,
-		.name = "S25FL256S",
-	},
-};
-
-struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode)
-{
-	const struct spansion_spi_flash_params *params;
-	struct spi_flash *flash;
-	unsigned int i;
-	unsigned short jedec, ext_jedec;
-
-	jedec = idcode[1] << 8 | idcode[2];
-	ext_jedec = idcode[3] << 8 | idcode[4];
-
-	for (i = 0; i < ARRAY_SIZE(spansion_spi_flash_table); i++) {
-		params = &spansion_spi_flash_table[i];
-		if (params->idcode1 == jedec) {
-			if (params->idcode2 == ext_jedec)
-				break;
-		}
-	}
-
-	if (i == ARRAY_SIZE(spansion_spi_flash_table)) {
-		debug("SF: Unsupported SPANSION ID %04x %04x\n", jedec, ext_jedec);
-		return NULL;
-	}
-
-	flash = malloc(sizeof(*flash));
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
-
-	flash->spi = spi;
-	flash->name = params->name;
-
-	flash->write = spi_flash_cmd_write_multi;
-	flash->erase = spi_flash_cmd_erase;
-	flash->read = spi_flash_cmd_read_fast;
-	flash->page_size = 256;
-	flash->sector_size = 256 * params->pages_per_sector;
-	flash->size = flash->sector_size * params->nr_sectors;
-
-	return flash;
-}
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
deleted file mode 100644
index 00aece9..0000000
--- a/drivers/mtd/spi/spi_flash.c
+++ /dev/null
@@ -1,408 +0,0 @@
-/*
- * SPI flash interface
- *
- * Copyright (C) 2008 Atmel Corporation
- * Copyright (C) 2010 Reinhard Meyer, EMK Elektronik
- *
- * Licensed under the GPL-2 or later.
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <spi.h>
-#include <spi_flash.h>
-#include <watchdog.h>
-
-#include "spi_flash_internal.h"
-
-static void spi_flash_addr(u32 addr, u8 *cmd)
-{
-	/* cmd[0] is actual command */
-	cmd[1] = addr >> 16;
-	cmd[2] = addr >> 8;
-	cmd[3] = addr >> 0;
-}
-
-static int spi_flash_read_write(struct spi_slave *spi,
-				const u8 *cmd, size_t cmd_len,
-				const u8 *data_out, u8 *data_in,
-				size_t data_len)
-{
-	unsigned long flags = SPI_XFER_BEGIN;
-	int ret;
-
-	if (data_len == 0)
-		flags |= SPI_XFER_END;
-
-	ret = spi_xfer(spi, cmd_len * 8, cmd, NULL, flags);
-	if (ret) {
-		debug("SF: Failed to send command (%zu bytes): %d\n",
-				cmd_len, ret);
-	} else if (data_len != 0) {
-		ret = spi_xfer(spi, data_len * 8, data_out, data_in, SPI_XFER_END);
-		if (ret)
-			debug("SF: Failed to transfer %zu bytes of data: %d\n",
-					data_len, ret);
-	}
-
-	return ret;
-}
-
-int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len)
-{
-	return spi_flash_cmd_read(spi, &cmd, 1, response, len);
-}
-
-int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len)
-{
-	return spi_flash_read_write(spi, cmd, cmd_len, NULL, data, data_len);
-}
-
-int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
-		const void *data, size_t data_len)
-{
-	return spi_flash_read_write(spi, cmd, cmd_len, data, NULL, data_len);
-}
-
-int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
-		size_t len, const void *buf)
-{
-	unsigned long page_addr, byte_addr, page_size;
-	size_t chunk_len, actual;
-	int ret;
-	u8 cmd[4];
-
-	page_size = flash->page_size;
-	page_addr = offset / page_size;
-	byte_addr = offset % page_size;
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: unable to claim SPI bus\n");
-		return ret;
-	}
-
-	cmd[0] = CMD_PAGE_PROGRAM;
-	for (actual = 0; actual < len; actual += chunk_len) {
-		chunk_len = min(len - actual, page_size - byte_addr);
-
-		cmd[1] = page_addr >> 8;
-		cmd[2] = page_addr;
-		cmd[3] = byte_addr;
-
-		debug("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %zu\n",
-		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
-
-		ret = spi_flash_cmd_write_enable(flash);
-		if (ret < 0) {
-			debug("SF: enabling write failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
-					  buf + actual, chunk_len);
-		if (ret < 0) {
-			debug("SF: write failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret)
-			break;
-
-		page_addr++;
-		byte_addr = 0;
-	}
-
-	debug("SF: program %s %zu bytes @ %#x\n",
-	      ret ? "failure" : "success", len, offset);
-
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
-int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len)
-{
-	struct spi_slave *spi = flash->spi;
-	int ret;
-
-	spi_claim_bus(spi);
-	ret = spi_flash_cmd_read(spi, cmd, cmd_len, data, data_len);
-	spi_release_bus(spi);
-
-	return ret;
-}
-
-int spi_flash_cmd_read_fast(struct spi_flash *flash, u32 offset,
-		size_t len, void *data)
-{
-	u8 cmd[5];
-
-	cmd[0] = CMD_READ_ARRAY_FAST;
-	spi_flash_addr(offset, cmd);
-	cmd[4] = 0x00;
-
-	return spi_flash_read_common(flash, cmd, sizeof(cmd), data, len);
-}
-
-int spi_flash_cmd_poll_bit(struct spi_flash *flash, unsigned long timeout,
-			   u8 cmd, u8 poll_bit)
-{
-	struct spi_slave *spi = flash->spi;
-	unsigned long timebase;
-	int ret;
-	u8 status;
-
-	ret = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
-	if (ret) {
-		debug("SF: Failed to send command %02x: %d\n", cmd, ret);
-		return ret;
-	}
-
-	timebase = get_timer(0);
-	do {
-		WATCHDOG_RESET();
-
-		ret = spi_xfer(spi, 8, NULL, &status, 0);
-		if (ret)
-			return -1;
-
-		if ((status & poll_bit) == 0)
-			break;
-
-	} while (get_timer(timebase) < timeout);
-
-	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
-
-	if ((status & poll_bit) == 0)
-		return 0;
-
-	/* Timed out */
-	debug("SF: time out!\n");
-	return -1;
-}
-
-int spi_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout)
-{
-	return spi_flash_cmd_poll_bit(flash, timeout,
-		CMD_READ_STATUS, STATUS_WIP);
-}
-
-int spi_flash_cmd_erase(struct spi_flash *flash, u32 offset, size_t len)
-{
-	u32 start, end, erase_size;
-	int ret;
-	u8 cmd[4];
-
-	erase_size = flash->sector_size;
-	if (offset % erase_size || len % erase_size) {
-		debug("SF: Erase offset/length not multiple of erase size\n");
-		return -1;
-	}
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	if (erase_size == 4096)
-		cmd[0] = CMD_ERASE_4K;
-	else
-		cmd[0] = CMD_ERASE_64K;
-	start = offset;
-	end = start + len;
-
-	while (offset < end) {
-		spi_flash_addr(offset, cmd);
-		offset += erase_size;
-
-		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
-		      cmd[2], cmd[3], offset);
-
-		ret = spi_flash_cmd_write_enable(flash);
-		if (ret)
-			goto out;
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, sizeof(cmd), NULL, 0);
-		if (ret)
-			goto out;
-
-		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
-		if (ret)
-			goto out;
-	}
-
-	debug("SF: Successfully erased %zu bytes @ %#x\n", len, start);
-
- out:
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
-int spi_flash_cmd_write_status(struct spi_flash *flash, u8 sr)
-{
-	u8 cmd;
-	int ret;
-
-	ret = spi_flash_cmd_write_enable(flash);
-	if (ret < 0) {
-		debug("SF: enabling write failed\n");
-		return ret;
-	}
-
-	cmd = CMD_WRITE_STATUS;
-	ret = spi_flash_cmd_write(flash->spi, &cmd, 1, &sr, 1);
-	if (ret) {
-		debug("SF: fail to write status register\n");
-		return ret;
-	}
-
-	ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-	if (ret < 0) {
-		debug("SF: write status register timed out\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-/*
- * The following table holds all device probe functions
- *
- * shift:  number of continuation bytes before the ID
- * idcode: the expected IDCODE or 0xff for non JEDEC devices
- * probe:  the function to call
- *
- * Non JEDEC devices should be ordered in the table such that
- * the probe functions with best detection algorithms come first.
- *
- * Several matching entries are permitted, they will be tried
- * in sequence until a probe function returns non NULL.
- *
- * IDCODE_CONT_LEN may be redefined if a device needs to declare a
- * larger "shift" value.  IDCODE_PART_LEN generally shouldn't be
- * changed.  This is the max number of bytes probe functions may
- * examine when looking up part-specific identification info.
- *
- * Probe functions will be given the idcode buffer starting at their
- * manu id byte (the "idcode" in the table below).  In other words,
- * all of the continuation bytes will be skipped (the "shift" below).
- */
-#define IDCODE_CONT_LEN 0
-#define IDCODE_PART_LEN 5
-static const struct {
-	const u8 shift;
-	const u8 idcode;
-	struct spi_flash *(*probe) (struct spi_slave *spi, u8 *idcode);
-} flashes[] = {
-	/* Keep it sorted by define name */
-#ifdef CONFIG_SPI_FLASH_ATMEL
-	{ 0, 0x1f, spi_flash_probe_atmel, },
-#endif
-#ifdef CONFIG_SPI_FLASH_EON
-	{ 0, 0x1c, spi_flash_probe_eon, },
-#endif
-#ifdef CONFIG_SPI_FLASH_MACRONIX
-	{ 0, 0xc2, spi_flash_probe_macronix, },
-#endif
-#ifdef CONFIG_SPI_FLASH_SPANSION
-	{ 0, 0x01, spi_flash_probe_spansion, },
-#endif
-#ifdef CONFIG_SPI_FLASH_SST
-	{ 0, 0xbf, spi_flash_probe_sst, },
-#endif
-#ifdef CONFIG_SPI_FLASH_STMICRO
-	{ 0, 0x20, spi_flash_probe_stmicro, },
-#endif
-#ifdef CONFIG_SPI_FLASH_WINBOND
-	{ 0, 0xef, spi_flash_probe_winbond, },
-#endif
-#ifdef CONFIG_SPI_FRAM_RAMTRON
-	{ 6, 0xc2, spi_fram_probe_ramtron, },
-# undef IDCODE_CONT_LEN
-# define IDCODE_CONT_LEN 6
-#endif
-	/* Keep it sorted by best detection */
-#ifdef CONFIG_SPI_FLASH_STMICRO
-	{ 0, 0xff, spi_flash_probe_stmicro, },
-#endif
-#ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
-	{ 0, 0xff, spi_fram_probe_ramtron, },
-#endif
-};
-#define IDCODE_LEN (IDCODE_CONT_LEN + IDCODE_PART_LEN)
-
-struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
-		unsigned int max_hz, unsigned int spi_mode)
-{
-	struct spi_slave *spi;
-	struct spi_flash *flash = NULL;
-	int ret, i, shift;
-	u8 idcode[IDCODE_LEN], *idp;
-
-	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
-	if (!spi) {
-		printf("SF: Failed to set up slave\n");
-		return NULL;
-	}
-
-	ret = spi_claim_bus(spi);
-	if (ret) {
-		debug("SF: Failed to claim SPI bus: %d\n", ret);
-		goto err_claim_bus;
-	}
-
-	/* Read the ID codes */
-	ret = spi_flash_cmd(spi, CMD_READ_ID, idcode, sizeof(idcode));
-	if (ret)
-		goto err_read_id;
-
-#ifdef DEBUG
-	printf("SF: Got idcodes\n");
-	print_buffer(0, idcode, 1, sizeof(idcode), 0);
-#endif
-
-	/* count the number of continuation bytes */
-	for (shift = 0, idp = idcode;
-	     shift < IDCODE_CONT_LEN && *idp == 0x7f;
-	     ++shift, ++idp)
-		continue;
-
-	/* search the table for matches in shift and id */
-	for (i = 0; i < ARRAY_SIZE(flashes); ++i)
-		if (flashes[i].shift == shift && flashes[i].idcode == *idp) {
-			/* we have a match, call probe */
-			flash = flashes[i].probe(spi, idp);
-			if (flash)
-				break;
-		}
-
-	if (!flash) {
-		printf("SF: Unsupported manufacturer %02x\n", *idp);
-		goto err_manufacturer_probe;
-	}
-
-	printf("SF: Detected %s with page size ", flash->name);
-	print_size(flash->sector_size, ", total ");
-	print_size(flash->size, "\n");
-
-	spi_release_bus(spi);
-
-	return flash;
-
-err_manufacturer_probe:
-err_read_id:
-	spi_release_bus(spi);
-err_claim_bus:
-	spi_free_slave(spi);
-	return NULL;
-}
-
-void spi_flash_free(struct spi_flash *flash)
-{
-	spi_free_slave(flash->spi);
-	free(flash);
-}
diff --git a/drivers/mtd/spi/spi_flash_internal.h b/drivers/mtd/spi/spi_flash_internal.h
deleted file mode 100644
index 141cfa8..0000000
--- a/drivers/mtd/spi/spi_flash_internal.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * SPI flash internal definitions
- *
- * Copyright (C) 2008 Atmel Corporation
- */
-
-/* Common parameters -- kind of high, but they should only occur when there
- * is a problem (and well your system already is broken), so err on the side
- * of caution in case we're dealing with slower SPI buses and/or processors.
- */
-#define SPI_FLASH_PROG_TIMEOUT		(2 * CONFIG_SYS_HZ)
-#define SPI_FLASH_PAGE_ERASE_TIMEOUT	(5 * CONFIG_SYS_HZ)
-#define SPI_FLASH_SECTOR_ERASE_TIMEOUT	(10 * CONFIG_SYS_HZ)
-
-/* Common commands */
-#define CMD_READ_ID			0x9f
-
-#define CMD_READ_ARRAY_SLOW		0x03
-#define CMD_READ_ARRAY_FAST		0x0b
-
-#define CMD_WRITE_STATUS		0x01
-#define CMD_PAGE_PROGRAM		0x02
-#define CMD_WRITE_DISABLE		0x04
-#define CMD_READ_STATUS			0x05
-#define CMD_WRITE_ENABLE		0x06
-#define CMD_ERASE_4K			0x20
-#define CMD_ERASE_32K			0x52
-#define CMD_ERASE_64K			0xd8
-#define CMD_ERASE_CHIP			0xc7
-
-/* Common status */
-#define STATUS_WIP			0x01
-
-/* Send a single-byte command to the device and read the response */
-int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len);
-
-/*
- * Send a multi-byte command to the device and read the response. Used
- * for flash array reads, etc.
- */
-int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len);
-
-int spi_flash_cmd_read_fast(struct spi_flash *flash, u32 offset,
-		size_t len, void *data);
-
-/*
- * Send a multi-byte command to the device followed by (optional)
- * data. Used for programming the flash array, etc.
- */
-int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
-		const void *data, size_t data_len);
-
-/*
- * Write the requested data out breaking it up into multiple write
- * commands as needed per the write size.
- */
-int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
-		size_t len, const void *buf);
-
-/*
- * Enable writing on the SPI flash.
- */
-static inline int spi_flash_cmd_write_enable(struct spi_flash *flash)
-{
-	return spi_flash_cmd(flash->spi, CMD_WRITE_ENABLE, NULL, 0);
-}
-
-/*
- * Disable writing on the SPI flash.
- */
-static inline int spi_flash_cmd_write_disable(struct spi_flash *flash)
-{
-	return spi_flash_cmd(flash->spi, CMD_WRITE_DISABLE, NULL, 0);
-}
-
-/* Program the status register. */
-int spi_flash_cmd_write_status(struct spi_flash *flash, u8 sr);
-
-/*
- * Same as spi_flash_cmd_read() except it also claims/releases the SPI
- * bus. Used as common part of the ->read() operation.
- */
-int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len);
-
-/* Send a command to the device and wait for some bit to clear itself. */
-int spi_flash_cmd_poll_bit(struct spi_flash *flash, unsigned long timeout,
-			   u8 cmd, u8 poll_bit);
-
-/*
- * Send the read status command to the device and wait for the wip
- * (write-in-progress) bit to clear itself.
- */
-int spi_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout);
-
-/* Erase sectors. */
-int spi_flash_cmd_erase(struct spi_flash *flash, u32 offset, size_t len);
-
-/* Manufacturer-specific probe functions */
-struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_sst(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode);
diff --git a/drivers/mtd/spi/spi_spl_load.c b/drivers/mtd/spi/spi_spl_load.c
index d4f81f2..1954b7e 100644
--- a/drivers/mtd/spi/spi_spl_load.c
+++ b/drivers/mtd/spi/spi_spl_load.c
@@ -6,26 +6,42 @@
  * Copyright (C) 2011
  * Heiko Schocher, DENX Software Engineering, hs@denx.de.
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
 #include <spi_flash.h>
 #include <spl.h>
 
+#ifdef CONFIG_SPL_OS_BOOT
+/*
+ * Load the kernel, check for a valid header we can parse, and if found load
+ * the kernel and then device tree.
+ */
+static int spi_load_image_os(struct spi_flash *flash,
+			     struct image_header *header)
+{
+	/* Read for a header, parse or error out. */
+	spi_flash_read(flash, CONFIG_SYS_SPI_KERNEL_OFFS, 0x40,
+		       (void *)header);
+
+	if (image_get_magic(header) != IH_MAGIC)
+		return -1;
+
+	spl_parse_image_header(header);
+
+	spi_flash_read(flash, CONFIG_SYS_SPI_KERNEL_OFFS,
+		       spl_image.size, (void *)spl_image.load_addr);
+
+	/* Read device tree. */
+	spi_flash_read(flash, CONFIG_SYS_SPI_ARGS_OFFS,
+		       CONFIG_SYS_SPI_ARGS_SIZE,
+		       (void *)CONFIG_SYS_SPL_ARGS_ADDR);
+
+	return 0;
+}
+#endif
+
 /*
  * The main entry for SPI booting. It's necessary that SDRAM is already
  * configured and available since this code loads the main U-Boot image
@@ -50,10 +66,15 @@ void spl_spi_load_image(void)
 	/* use CONFIG_SYS_TEXT_BASE as temporary storage area */
 	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
 
-	/* Load u-boot, mkimage header is 64 bytes. */
-	spi_flash_read(flash, CONFIG_SYS_SPI_U_BOOT_OFFS, 0x40,
-			(void *) header);
-	spl_parse_image_header(header);
-	spi_flash_read(flash, CONFIG_SYS_SPI_U_BOOT_OFFS,
-		       spl_image.size, (void *)spl_image.load_addr);
+#ifdef CONFIG_SPL_OS_BOOT
+	if (spl_start_uboot() || spi_load_image_os(flash, header))
+#endif
+	{
+		/* Load u-boot, mkimage header is 64 bytes. */
+		spi_flash_read(flash, CONFIG_SYS_SPI_U_BOOT_OFFS, 0x40,
+			       (void *)header);
+		spl_parse_image_header(header);
+		spi_flash_read(flash, CONFIG_SYS_SPI_U_BOOT_OFFS,
+			       spl_image.size, (void *)spl_image.load_addr);
+	}
 }
diff --git a/drivers/mtd/spi/sst.c b/drivers/mtd/spi/sst.c
deleted file mode 100644
index ced4f24..0000000
--- a/drivers/mtd/spi/sst.c
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Driver for SST serial flashes
- *
- * (C) Copyright 2000-2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- * Copyright 2008, Network Appliance Inc.
- * Jason McMullan <mcmullan@netapp.com>
- * Copyright (C) 2004-2007 Freescale Semiconductor, Inc.
- * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
- * Copyright (c) 2008-2009 Analog Devices Inc.
- *
- * Licensed under the GPL-2 or later.
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <spi_flash.h>
-
-#include "spi_flash_internal.h"
-
-#define CMD_SST_BP		0x02	/* Byte Program */
-#define CMD_SST_AAI_WP		0xAD	/* Auto Address Increment Word Program */
-
-#define SST_SR_WIP		(1 << 0)	/* Write-in-Progress */
-#define SST_SR_WEL		(1 << 1)	/* Write enable */
-#define SST_SR_BP0		(1 << 2)	/* Block Protection 0 */
-#define SST_SR_BP1		(1 << 3)	/* Block Protection 1 */
-#define SST_SR_BP2		(1 << 4)	/* Block Protection 2 */
-#define SST_SR_AAI		(1 << 6)	/* Addressing mode */
-#define SST_SR_BPL		(1 << 7)	/* BP bits lock */
-
-#define SST_FEAT_WP		(1 << 0)	/* Supports AAI word program */
-#define SST_FEAT_MBP		(1 << 1)	/* Supports multibyte program */
-
-struct sst_spi_flash_params {
-	u8 idcode1;
-	u8 flags;
-	u16 nr_sectors;
-	const char *name;
-};
-
-struct sst_spi_flash {
-	struct spi_flash flash;
-	const struct sst_spi_flash_params *params;
-};
-
-static const struct sst_spi_flash_params sst_spi_flash_table[] = {
-	{
-		.idcode1 = 0x8d,
-		.flags = SST_FEAT_WP,
-		.nr_sectors = 128,
-		.name = "SST25VF040B",
-	},{
-		.idcode1 = 0x8e,
-		.flags = SST_FEAT_WP,
-		.nr_sectors = 256,
-		.name = "SST25VF080B",
-	},{
-		.idcode1 = 0x41,
-		.flags = SST_FEAT_WP,
-		.nr_sectors = 512,
-		.name = "SST25VF016B",
-	},{
-		.idcode1 = 0x4a,
-		.flags = SST_FEAT_WP,
-		.nr_sectors = 1024,
-		.name = "SST25VF032B",
-	},{
-		.idcode1 = 0x4b,
-		.flags = SST_FEAT_MBP,
-		.nr_sectors = 2048,
-		.name = "SST25VF064C",
-	},{
-		.idcode1 = 0x01,
-		.flags = SST_FEAT_WP,
-		.nr_sectors = 16,
-		.name = "SST25WF512",
-	},{
-		.idcode1 = 0x02,
-		.flags = SST_FEAT_WP,
-		.nr_sectors = 32,
-		.name = "SST25WF010",
-	},{
-		.idcode1 = 0x03,
-		.flags = SST_FEAT_WP,
-		.nr_sectors = 64,
-		.name = "SST25WF020",
-	},{
-		.idcode1 = 0x04,
-		.flags = SST_FEAT_WP,
-		.nr_sectors = 128,
-		.name = "SST25WF040",
-	},
-};
-
-static int
-sst_byte_write(struct spi_flash *flash, u32 offset, const void *buf)
-{
-	int ret;
-	u8 cmd[4] = {
-		CMD_SST_BP,
-		offset >> 16,
-		offset >> 8,
-		offset,
-	};
-
-	debug("BP[%02x]: 0x%p => cmd = { 0x%02x 0x%06x }\n",
-		spi_w8r8(flash->spi, CMD_READ_STATUS), buf, cmd[0], offset);
-
-	ret = spi_flash_cmd_write_enable(flash);
-	if (ret)
-		return ret;
-
-	ret = spi_flash_cmd_write(flash->spi, cmd, sizeof(cmd), buf, 1);
-	if (ret)
-		return ret;
-
-	return spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-}
-
-static int
-sst_write_wp(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
-{
-	size_t actual, cmd_len;
-	int ret;
-	u8 cmd[4];
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	/* If the data is not word aligned, write out leading single byte */
-	actual = offset % 2;
-	if (actual) {
-		ret = sst_byte_write(flash, offset, buf);
-		if (ret)
-			goto done;
-	}
-	offset += actual;
-
-	ret = spi_flash_cmd_write_enable(flash);
-	if (ret)
-		goto done;
-
-	cmd_len = 4;
-	cmd[0] = CMD_SST_AAI_WP;
-	cmd[1] = offset >> 16;
-	cmd[2] = offset >> 8;
-	cmd[3] = offset;
-
-	for (; actual < len - 1; actual += 2) {
-		debug("WP[%02x]: 0x%p => cmd = { 0x%02x 0x%06x }\n",
-		     spi_w8r8(flash->spi, CMD_READ_STATUS), buf + actual, cmd[0],
-		     offset);
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, cmd_len,
-		                          buf + actual, 2);
-		if (ret) {
-			debug("SF: sst word program failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret)
-			break;
-
-		cmd_len = 1;
-		offset += 2;
-	}
-
-	if (!ret)
-		ret = spi_flash_cmd_write_disable(flash);
-
-	/* If there is a single trailing byte, write it out */
-	if (!ret && actual != len)
-		ret = sst_byte_write(flash, offset, buf + actual);
-
- done:
-	debug("SF: sst: program %s %zu bytes @ 0x%zx\n",
-	      ret ? "failure" : "success", len, offset - actual);
-
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
-struct spi_flash *
-spi_flash_probe_sst(struct spi_slave *spi, u8 *idcode)
-{
-	const struct sst_spi_flash_params *params;
-	struct sst_spi_flash *stm;
-	size_t i;
-
-	for (i = 0; i < ARRAY_SIZE(sst_spi_flash_table); ++i) {
-		params = &sst_spi_flash_table[i];
-		if (params->idcode1 == idcode[2])
-			break;
-	}
-
-	if (i == ARRAY_SIZE(sst_spi_flash_table)) {
-		debug("SF: Unsupported SST ID %02x\n", idcode[1]);
-		return NULL;
-	}
-
-	stm = malloc(sizeof(*stm));
-	if (!stm) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
-
-	stm->params = params;
-	stm->flash.spi = spi;
-	stm->flash.name = params->name;
-
-	if (stm->params->flags & SST_FEAT_WP)
-		stm->flash.write = sst_write_wp;
-	else
-		stm->flash.write = spi_flash_cmd_write_multi;
-	stm->flash.erase = spi_flash_cmd_erase;
-	stm->flash.read = spi_flash_cmd_read_fast;
-	stm->flash.page_size = 256;
-	stm->flash.sector_size = 4096;
-	stm->flash.size = stm->flash.sector_size * params->nr_sectors;
-
-	/* Flash powers up read-only, so clear BP# bits */
-	spi_flash_cmd_write_status(&stm->flash, 0);
-
-	return &stm->flash;
-}
diff --git a/drivers/mtd/spi/stmicro.c b/drivers/mtd/spi/stmicro.c
deleted file mode 100644
index 30b626a..0000000
--- a/drivers/mtd/spi/stmicro.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * (C) Copyright 2000-2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * Copyright 2008, Network Appliance Inc.
- * Jason McMullan <mcmullan@netapp.com>
- *
- * Copyright (C) 2004-2007 Freescale Semiconductor, Inc.
- * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <spi_flash.h>
-
-#include "spi_flash_internal.h"
-
-/* M25Pxx-specific commands */
-#define CMD_M25PXX_RES		0xab	/* Release from DP, and Read Signature */
-
-struct stmicro_spi_flash_params {
-	u16 id;
-	u16 pages_per_sector;
-	u16 nr_sectors;
-	const char *name;
-};
-
-static const struct stmicro_spi_flash_params stmicro_spi_flash_table[] = {
-	{
-		.id = 0x2011,
-		.pages_per_sector = 128,
-		.nr_sectors = 4,
-		.name = "M25P10",
-	},
-	{
-		.id = 0x2015,
-		.pages_per_sector = 256,
-		.nr_sectors = 32,
-		.name = "M25P16",
-	},
-	{
-		.id = 0x2012,
-		.pages_per_sector = 256,
-		.nr_sectors = 4,
-		.name = "M25P20",
-	},
-	{
-		.id = 0x2016,
-		.pages_per_sector = 256,
-		.nr_sectors = 64,
-		.name = "M25P32",
-	},
-	{
-		.id = 0x2013,
-		.pages_per_sector = 256,
-		.nr_sectors = 8,
-		.name = "M25P40",
-	},
-	{
-		.id = 0x2017,
-		.pages_per_sector = 256,
-		.nr_sectors = 128,
-		.name = "M25P64",
-	},
-	{
-		.id = 0x2014,
-		.pages_per_sector = 256,
-		.nr_sectors = 16,
-		.name = "M25P80",
-	},
-	{
-		.id = 0x2018,
-		.pages_per_sector = 1024,
-		.nr_sectors = 64,
-		.name = "M25P128",
-	},
-	{
-		.id = 0xba18,
-		.pages_per_sector = 256,
-		.nr_sectors = 256,
-		.name = "N25Q128",
-	},
-	{
-		.id = 0xbb18,
-		.pages_per_sector = 256,
-		.nr_sectors = 256,
-		.name = "N25Q128A",
-	},
-	{
-		.id = 0xba19,
-		.pages_per_sector = 256,
-		.nr_sectors = 512,
-		.name = "N25Q256",
-	},
-};
-
-struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 * idcode)
-{
-	const struct stmicro_spi_flash_params *params;
-	struct spi_flash *flash;
-	unsigned int i;
-	u16 id;
-
-	if (idcode[0] == 0xff) {
-		i = spi_flash_cmd(spi, CMD_M25PXX_RES,
-				  idcode, 4);
-		if (i)
-			return NULL;
-		if ((idcode[3] & 0xf0) == 0x10) {
-			idcode[0] = 0x20;
-			idcode[1] = 0x20;
-			idcode[2] = idcode[3] + 1;
-		} else
-			return NULL;
-	}
-
-	id = ((idcode[1] << 8) | idcode[2]);
-
-	for (i = 0; i < ARRAY_SIZE(stmicro_spi_flash_table); i++) {
-		params = &stmicro_spi_flash_table[i];
-		if (params->id == id) {
-			break;
-		}
-	}
-
-	if (i == ARRAY_SIZE(stmicro_spi_flash_table)) {
-		debug("SF: Unsupported STMicro ID %04x\n", id);
-		return NULL;
-	}
-
-	flash = malloc(sizeof(*flash));
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
-
-	flash->spi = spi;
-	flash->name = params->name;
-
-	flash->write = spi_flash_cmd_write_multi;
-	flash->erase = spi_flash_cmd_erase;
-	flash->read = spi_flash_cmd_read_fast;
-	flash->page_size = 256;
-	flash->sector_size = 256 * params->pages_per_sector;
-	flash->size = flash->sector_size * params->nr_sectors;
-
-	return flash;
-}
diff --git a/drivers/mtd/spi/winbond.c b/drivers/mtd/spi/winbond.c
deleted file mode 100644
index f6aab3d..0000000
--- a/drivers/mtd/spi/winbond.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright 2008, Network Appliance Inc.
- * Author: Jason McMullan <mcmullan <at> netapp.com>
- * Licensed under the GPL-2 or later.
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <spi_flash.h>
-
-#include "spi_flash_internal.h"
-
-struct winbond_spi_flash_params {
-	uint16_t	id;
-	uint16_t	nr_blocks;
-	const char	*name;
-};
-
-static const struct winbond_spi_flash_params winbond_spi_flash_table[] = {
-	{
-		.id			= 0x3013,
-		.nr_blocks		= 8,
-		.name			= "W25X40",
-	},
-	{
-		.id			= 0x3015,
-		.nr_blocks		= 32,
-		.name			= "W25X16",
-	},
-	{
-		.id			= 0x3016,
-		.nr_blocks		= 64,
-		.name			= "W25X32",
-	},
-	{
-		.id			= 0x3017,
-		.nr_blocks		= 128,
-		.name			= "W25X64",
-	},
-	{
-		.id			= 0x4014,
-		.nr_blocks		= 16,
-		.name			= "W25Q80BL",
-	},
-	{
-		.id			= 0x4015,
-		.nr_blocks		= 32,
-		.name			= "W25Q16",
-	},
-	{
-		.id			= 0x4016,
-		.nr_blocks		= 64,
-		.name			= "W25Q32",
-	},
-	{
-		.id			= 0x4017,
-		.nr_blocks		= 128,
-		.name			= "W25Q64",
-	},
-	{
-		.id			= 0x4018,
-		.nr_blocks		= 256,
-		.name			= "W25Q128",
-	},
-	{
-		.id			= 0x5014,
-		.nr_blocks		= 128,
-		.name			= "W25Q80",
-	},
-};
-
-struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode)
-{
-	const struct winbond_spi_flash_params *params;
-	struct spi_flash *flash;
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(winbond_spi_flash_table); i++) {
-		params = &winbond_spi_flash_table[i];
-		if (params->id == ((idcode[1] << 8) | idcode[2]))
-			break;
-	}
-
-	if (i == ARRAY_SIZE(winbond_spi_flash_table)) {
-		debug("SF: Unsupported Winbond ID %02x%02x\n",
-				idcode[1], idcode[2]);
-		return NULL;
-	}
-
-	flash = malloc(sizeof(*flash));
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
-
-	flash->spi = spi;
-	flash->name = params->name;
-
-	flash->write = spi_flash_cmd_write_multi;
-	flash->erase = spi_flash_cmd_erase;
-	flash->read = spi_flash_cmd_read_fast;
-	flash->page_size = 256;
-	flash->sector_size = 4096;
-	flash->size = 4096 * 16 * params->nr_blocks;
-
-	return flash;
-}
diff --git a/drivers/net/e1000.c b/drivers/net/e1000.c
index 8ba98b2..faa90b1 100644
--- a/drivers/net/e1000.c
+++ b/drivers/net/e1000.c
@@ -4946,13 +4946,6 @@ e1000_configure_rx(struct e1000_hw *hw)
 	/* make sure receives are disabled while setting up the descriptors */
 	rctl = E1000_READ_REG(hw, RCTL);
 	E1000_WRITE_REG(hw, RCTL, rctl & ~E1000_RCTL_EN);
-	if (hw->mac_type >= e1000_82540) {
-		/* Set the interrupt throttling rate.  Value is calculated
-		 * as DEFAULT_ITR = 1/(MAX_INTS_PER_SEC * 256ns) */
-#define MAX_INTS_PER_SEC	8000
-#define DEFAULT_ITR		1000000000/(MAX_INTS_PER_SEC * 256)
-		E1000_WRITE_REG(hw, ITR, DEFAULT_ITR);
-	}
 
 	if (hw->mac_type >= e1000_82571) {
 		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
diff --git a/drivers/net/fm/Makefile b/drivers/net/fm/Makefile
index 7fbb50a..c01b31e 100644
--- a/drivers/net/fm/Makefile
+++ b/drivers/net/fm/Makefile
@@ -46,7 +46,10 @@ COBJS-$(CONFIG_PPC_P4080) += p4080.o
 COBJS-$(CONFIG_PPC_P5020) += p5020.o
 COBJS-$(CONFIG_PPC_P5040) += p5040.o
 COBJS-$(CONFIG_PPC_T4240) += t4240.o
+COBJS-$(CONFIG_PPC_T4160) += t4240.o
+COBJS-$(CONFIG_PPC_B4420) += b4860.o
 COBJS-$(CONFIG_PPC_B4860) += b4860.o
+COBJS-$(CONFIG_PPC_T1040) += b4860.o
 endif
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/net/fm/b4860.c b/drivers/net/fm/b4860.c
new file mode 100644
index 0000000..aaca5d5
--- /dev/null
+++ b/drivers/net/fm/b4860.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *	Roy Zang <tie-fei.zang@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <phy.h>
+#include <fm_eth.h>
+#include <asm/io.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+#include <hwconfig.h>
+
+u32 port_to_devdisr[] = {
+	[FM1_DTSEC1] = FSL_CORENET_DEVDISR2_DTSEC1_1,
+	[FM1_DTSEC2] = FSL_CORENET_DEVDISR2_DTSEC1_2,
+	[FM1_DTSEC3] = FSL_CORENET_DEVDISR2_DTSEC1_3,
+	[FM1_DTSEC4] = FSL_CORENET_DEVDISR2_DTSEC1_4,
+	[FM1_DTSEC5] = FSL_CORENET_DEVDISR2_DTSEC1_5,
+	[FM1_DTSEC6] = FSL_CORENET_DEVDISR2_DTSEC1_6,
+	[FM1_10GEC1] = FSL_CORENET_DEVDISR2_10GEC1_1,
+	[FM1_10GEC2] = FSL_CORENET_DEVDISR2_10GEC1_2,
+};
+
+static int is_device_disabled(enum fm_port port)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 devdisr2 = in_be32(&gur->devdisr2);
+
+	return port_to_devdisr[port] & devdisr2;
+}
+
+void fman_disable_port(enum fm_port port)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	setbits_be32(&gur->devdisr2, port_to_devdisr[port]);
+}
+
+phy_interface_t fman_port_enet_if(enum fm_port port)
+{
+#if defined(CONFIG_B4860QDS)
+	u32 serdes2_prtcl;
+	char buffer[HWCONFIG_BUFFER_SIZE];
+	char *buf = NULL;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+#endif
+
+	if (is_device_disabled(port))
+		return PHY_INTERFACE_MODE_NONE;
+
+	/*B4860 has two 10Gig Mac*/
+	if ((port == FM1_10GEC1 || port == FM1_10GEC2)
+			&& ((is_serdes_configured(XAUI_FM1_MAC9))
+			|| (is_serdes_configured(XAUI_FM1_MAC10))
+			#if !defined(CONFIG_B4860QDS)
+			|| (is_serdes_configured(XFI_FM1_MAC9))
+			|| (is_serdes_configured(XFI_FM1_MAC10))
+			#endif
+			))
+		return PHY_INTERFACE_MODE_XGMII;
+
+#if defined(CONFIG_B4860QDS)
+	serdes2_prtcl = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+
+	if (serdes2_prtcl) {
+		serdes2_prtcl >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+		switch (serdes2_prtcl) {
+		case 0x81:
+		case 0x82:
+		case 0x84:
+		case 0x85:
+		case 0x87:
+		case 0x88:
+		case 0x8a:
+		case 0x8b:
+		case 0x8d:
+		case 0x8e:
+		case 0xb2:
+			/*
+			 * Extract hwconfig from environment since environment
+			 * is not setup yet
+			 */
+			getenv_f("hwconfig", buffer, sizeof(buffer));
+			buf = buffer;
+
+			/* check if XFI interface enable in hwconfig for 10g */
+			if (hwconfig_subarg_cmp_f("fsl_b4860_serdes2",
+						"sfp_amc", "sfp", buf)) {
+				if ((port == FM1_10GEC1 || port == FM1_10GEC2)
+					&& ((is_serdes_configured(XFI_FM1_MAC9))
+					|| (is_serdes_configured(XFI_FM1_MAC10))
+					))
+					return PHY_INTERFACE_MODE_XGMII;
+				else if ((port == FM1_DTSEC1)
+					|| (port == FM1_DTSEC2)
+					|| (port == FM1_DTSEC3)
+					|| (port == FM1_DTSEC4))
+					return PHY_INTERFACE_MODE_NONE;
+			}
+		}
+	}
+#endif
+
+	/* Fix me need to handle RGMII here first */
+
+	switch (port) {
+	case FM1_DTSEC1:
+	case FM1_DTSEC2:
+	case FM1_DTSEC3:
+	case FM1_DTSEC4:
+	case FM1_DTSEC5:
+	case FM1_DTSEC6:
+		if (is_serdes_configured(SGMII_FM1_DTSEC1 + port - FM1_DTSEC1))
+			return PHY_INTERFACE_MODE_SGMII;
+		break;
+	default:
+		return PHY_INTERFACE_MODE_NONE;
+	}
+
+	return PHY_INTERFACE_MODE_NONE;
+}
diff --git a/drivers/net/fm/eth.c b/drivers/net/fm/eth.c
index 54b142f..1c988c5 100644
--- a/drivers/net/fm/eth.c
+++ b/drivers/net/fm/eth.c
@@ -353,9 +353,9 @@ static int fm_eth_startup(struct fm_eth *fm_eth)
 	/* setup the MAC controller */
 	mac->init_mac(mac);
 
-	/* For some reason we need to set SPEED_100 */
+	/* For some reason we need to set SPEED_100 */ /* change to SPEED_1000 */
 	if ((fm_eth->enet_if == PHY_INTERFACE_MODE_SGMII) && mac->set_if_mode)
-		mac->set_if_mode(mac, fm_eth->enet_if, SPEED_100);
+		mac->set_if_mode(mac, fm_eth->enet_if, SPEED_1000);
 
 	/* init bmi rx port, IM mode and disable */
 	bmi_rx_port_init(fm_eth->rx_port);
@@ -568,6 +568,8 @@ static int fm_eth_init_mac(struct fm_eth *fm_eth, struct ccsr_fman *reg)
 	num = fm_eth->num;
 
 #ifdef CONFIG_SYS_FMAN_V3
+	if (fm_eth->type == FM_ETH_10G_E)
+		num += 8;
 	base = &reg->memac[num].fm_memac;
 	phyregs = &reg->memac[num].fm_memac_mdio;
 #else
diff --git a/drivers/net/fm/fm.c b/drivers/net/fm/fm.c
index 49c74c2..53eefc6 100644
--- a/drivers/net/fm/fm.c
+++ b/drivers/net/fm/fm.c
@@ -410,6 +410,8 @@ int fm_init_common(int index, struct ccsr_fman *reg)
 	}
 #elif defined(CONFIG_SYS_QE_FMAN_FW_IN_REMOTE)
 	void *addr = (void *)CONFIG_SYS_QE_FMAN_FW_ADDR;
+#else
+	void *addr = NULL;
 #endif
 
 	/* Upload the Fman microcode if it's present */
diff --git a/drivers/net/fm/fm.h b/drivers/net/fm/fm.h
index 228df33..ba581e9 100644
--- a/drivers/net/fm/fm.h
+++ b/drivers/net/fm/fm.h
@@ -152,4 +152,6 @@ struct fm_eth {
 #define MAX_RXBUF_LOG2		11
 #define MAX_RXBUF_LEN		(1 << MAX_RXBUF_LOG2)
 
+#define PORT_IS_ENABLED(port)	fm_info[fm_port_to_index(port)].enabled
+
 #endif /* __FM_H__ */
diff --git a/drivers/net/fm/init.c b/drivers/net/fm/init.c
index ae389b8..bcec525 100644
--- a/drivers/net/fm/init.c
+++ b/drivers/net/fm/init.c
@@ -74,9 +74,15 @@ struct fm_eth_info fm_info[] = {
 #if (CONFIG_SYS_NUM_FM1_10GEC >= 1)
 	FM_TGEC_INFO_INITIALIZER(1, 1),
 #endif
+#if (CONFIG_SYS_NUM_FM1_10GEC >= 2)
+	FM_TGEC_INFO_INITIALIZER(1, 2),
+#endif
 #if (CONFIG_SYS_NUM_FM2_10GEC >= 1)
 	FM_TGEC_INFO_INITIALIZER(2, 1),
 #endif
+#if (CONFIG_SYS_NUM_FM2_10GEC >= 2)
+	FM_TGEC_INFO_INITIALIZER(2, 2),
+#endif
 };
 
 int fm_standard_init(bd_t *bis)
@@ -232,6 +238,25 @@ static void ft_fixup_port(void *blob, struct fm_eth_info *info, char *prop)
 		return ;
 	}
 
+#ifdef CONFIG_SYS_FMAN_V3
+	/*
+	 * Physically FM1_DTSEC9 and FM1_10GEC1 use the same dual-role MAC, when
+	 * FM1_10GEC1 is enabled and  FM1_DTSEC9 is disabled, ensure that the
+	 * dual-role MAC is not disabled, ditto for other dual-role MACs.
+	 */
+	if (((info->port == FM1_DTSEC9) && (PORT_IS_ENABLED(FM1_10GEC1)))
+	    || ((info->port == FM1_DTSEC10) && (PORT_IS_ENABLED(FM1_10GEC2)))
+	    || ((info->port == FM1_10GEC1) && (PORT_IS_ENABLED(FM1_DTSEC9)))
+	    || ((info->port == FM1_10GEC2) && (PORT_IS_ENABLED(FM1_DTSEC10)))
+#if (CONFIG_SYS_NUM_FMAN == 2)
+	    || ((info->port == FM2_DTSEC9) && (PORT_IS_ENABLED(FM2_10GEC1)))
+	    || ((info->port == FM2_DTSEC10) && (PORT_IS_ENABLED(FM2_10GEC2)))
+	    || ((info->port == FM2_10GEC1) && (PORT_IS_ENABLED(FM2_DTSEC9)))
+	    || ((info->port == FM2_10GEC2) && (PORT_IS_ENABLED(FM2_DTSEC10)))
+#endif
+	)
+		return;
+#endif
 	/* board code might have caused offset to change */
 	off = fdt_node_offset_by_compat_reg(blob, prop, paddr);
 
@@ -249,10 +274,15 @@ void fdt_fixup_fman_ethernet(void *blob)
 {
 	int i;
 
+#ifdef CONFIG_SYS_FMAN_V3
+	for (i = 0; i < ARRAY_SIZE(fm_info); i++)
+		ft_fixup_port(blob, &fm_info[i], "fsl,fman-memac");
+#else
 	for (i = 0; i < ARRAY_SIZE(fm_info); i++) {
 		if (fm_info[i].type == FM_ETH_1G_E)
 			ft_fixup_port(blob, &fm_info[i], "fsl,fman-1g-mac");
 		else
 			ft_fixup_port(blob, &fm_info[i], "fsl,fman-10g-mac");
 	}
+#endif
 }
diff --git a/drivers/net/fm/memac.c b/drivers/net/fm/memac.c
index 32c7054..c734269 100644
--- a/drivers/net/fm/memac.c
+++ b/drivers/net/fm/memac.c
@@ -51,7 +51,8 @@ static void memac_enable_mac(struct fsl_enet_mac *mac)
 {
 	struct memac *regs = mac->base;
 
-	setbits_be32(&regs->command_config, MEMAC_CMD_CFG_RXTX_EN);
+	setbits_be32(&regs->command_config, MEMAC_CMD_CFG_RXTX_EN
+					| MEMAC_CMD_CFG_NO_LEN_CHK);
 }
 
 static void memac_disable_mac(struct fsl_enet_mac *mac)
@@ -106,11 +107,33 @@ static void memac_set_interface_mode(struct fsl_enet_mac *mac,
 		if_mode &= ~IF_MODE_MASK;
 		if_mode |= (IF_MODE_GMII);
 		break;
+	case PHY_INTERFACE_MODE_XGMII:
+		if_mode &= ~IF_MODE_MASK;
+		if_mode |= IF_MODE_XGMII;
+		break;
 	default:
 		break;
 	}
-	/* Enable automatic speed selection */
-	if_mode |= IF_MODE_EN_AUTO;
+	/* Enable automatic speed selection for Non-XGMII */
+	if (type != PHY_INTERFACE_MODE_XGMII)
+		if_mode |= IF_MODE_EN_AUTO;
+
+	if (type == PHY_INTERFACE_MODE_RGMII) {
+		if_mode &= ~IF_MODE_EN_AUTO;
+		if_mode &= ~IF_MODE_SETSP_MASK;
+		switch (speed) {
+		case SPEED_1000:
+			if_mode |= IF_MODE_SETSP_1000M;
+			break;
+		case SPEED_100:
+			if_mode |= IF_MODE_SETSP_100M;
+			break;
+		case SPEED_10:
+			if_mode |= IF_MODE_SETSP_10M;
+		default:
+			break;
+		}
+	}
 
 	debug(" %s, if_mode = %x\n", __func__,  if_mode);
 	debug(" %s, if_status = %x\n", __func__,  if_status);
diff --git a/drivers/net/fm/memac_phy.c b/drivers/net/fm/memac_phy.c
index ea6118b..18dc2aa 100644
--- a/drivers/net/fm/memac_phy.c
+++ b/drivers/net/fm/memac_phy.c
@@ -86,6 +86,8 @@ int memac_mdio_read(struct mii_dev *bus, int port_addr, int dev_addr,
 	u32 c45 = 1;
 
 	if (dev_addr == MDIO_DEVAD_NONE) {
+		if (!strcmp(bus->name, DEFAULT_FM_TGEC_MDIO_NAME))
+			return 0xffff;
 		c45 = 0; /* clause 22 */
 		dev_addr = regnum & 0x1f;
 		clrbits_be32(&regs->mdio_stat, MDIO_STAT_ENC);
diff --git a/drivers/net/fm/p5020.c b/drivers/net/fm/p5020.c
index 5391044..6435c6e 100644
--- a/drivers/net/fm/p5020.c
+++ b/drivers/net/fm/p5020.c
@@ -44,10 +44,6 @@ void fman_disable_port(enum fm_port port)
 {
 	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 
-	/* don't allow disabling of DTSEC1 as its needed for MDIO */
-	if (port == FM1_DTSEC1)
-		return;
-
 	setbits_be32(&gur->devdisr2, port_to_devdisr[port]);
 }
 
diff --git a/drivers/net/fm/t4240.c b/drivers/net/fm/t4240.c
index 48c530c..401ffd1 100644
--- a/drivers/net/fm/t4240.c
+++ b/drivers/net/fm/t4240.c
@@ -71,11 +71,17 @@ phy_interface_t fman_port_enet_if(enum fm_port port)
 		return PHY_INTERFACE_MODE_NONE;
 
 	if ((port == FM1_10GEC1 || port == FM1_10GEC2)
-			&& (is_serdes_configured(XAUI_FM1)))
+			&& ((is_serdes_configured(XAUI_FM1_MAC9))
+		       || (is_serdes_configured(XAUI_FM1_MAC10))
+		       || (is_serdes_configured(XFI_FM1_MAC9))
+		       || (is_serdes_configured(XFI_FM1_MAC10))))
 		return PHY_INTERFACE_MODE_XGMII;
 
 	if ((port == FM2_10GEC1 || port == FM2_10GEC2)
-			&& (is_serdes_configured(XAUI_FM2)))
+			&& ((is_serdes_configured(XAUI_FM2_MAC9))
+		       || (is_serdes_configured(XAUI_FM2_MAC10))
+		       || (is_serdes_configured(XFI_FM2_MAC9))
+		       || (is_serdes_configured(XFI_FM2_MAC10))))
 		return PHY_INTERFACE_MODE_XGMII;
 
 #define FSL_CORENET_RCWSR13_EC1			0x60000000 /* bits 417..418 */
diff --git a/drivers/net/phy/atheros.c b/drivers/net/phy/atheros.c
index 9b3808b..a49d5b1 100644
--- a/drivers/net/phy/atheros.c
+++ b/drivers/net/phy/atheros.c
@@ -30,6 +30,27 @@ static int ar8021_config(struct phy_device *phydev)
 	return 0;
 }
 
+static int ar8035_config(struct phy_device *phydev)
+{
+	int regval;
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x0007);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+	regval = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, (regval|0x0018));
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	regval = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, (regval|0x0100));
+
+	genphy_config_aneg(phydev);
+
+	phy_reset(phydev);
+
+	return 0;
+}
+
 static struct phy_driver AR8021_driver =  {
 	.name = "AR8021",
 	.uid = 0x4dd040,
@@ -40,9 +61,20 @@ static struct phy_driver AR8021_driver =  {
 	.shutdown = genphy_shutdown,
 };
 
+struct phy_driver AR8035_driver =  {
+	.name = "AR8035",
+	.uid = 0x4dd072,
+	.mask = 0x4fffff,
+	.features = PHY_GBIT_FEATURES,
+	.config = ar8035_config,
+	.startup = genphy_startup,
+	.shutdown = genphy_shutdown,
+};
+
 int phy_atheros_init(void)
 {
 	phy_register(&AR8021_driver);
+	phy_register(&AR8035_driver);
 
 	return 0;
 }
diff --git a/drivers/net/phy/broadcom.c b/drivers/net/phy/broadcom.c
index 16c813f..14c8f06 100644
--- a/drivers/net/phy/broadcom.c
+++ b/drivers/net/phy/broadcom.c
@@ -86,121 +86,6 @@ static int bcm54xx_startup(struct phy_device *phydev)
 	return 0;
 }
 
-/* Broadcom BCM54616S */
-/*
- * "Ethernet@Wirespeed" needs to be enabled to achieve link in certain
- * circumstances.  eg a gigabit TSEC connected to a gigabit switch with
- * a 4-wire ethernet cable.  Both ends advertise gigabit, but can't
- * link.  "Ethernet@Wirespeed" reduces advertised speed until link
- * can be achieved.
- */
-static u32 bcm54616_read_wirespeed(struct phy_device *phydev, u32 reg)
-{
-	return (phy_read(phydev, MDIO_DEVAD_NONE, reg) & 0x8FFF) | 0x8010;
-}
-
-static int bcm54616_config(struct phy_device *phydev)
-{
-	unsigned int reg;
-
-	/* reset the PHY */
-	reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
-	reg |= BMCR_RESET;
-	phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, reg);
-
-	/* Setup read from auxilary control shadow register 7 */
-	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54xx_AUXCNTL,
-			MIIM_BCM54xx_AUXCNTL_ENCODE(7));
-	/* Read Misc Control register and or in Ethernet@Wirespeed */
-	reg = bcm54616_read_wirespeed(phydev, MIIM_BCM54xx_AUXCNTL);
-	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54xx_AUXCNTL, reg);
-
-	/* Enable copper/fiber auto-detect */
-	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD,
-			MIIM_BCM54XX_SHD_WR_ENCODE(0x1e, 0x027));
-
-	genphy_config_aneg(phydev);
-
-	return 0;
-}
-
-/*
- * Find out if PHY is in copper or serdes mode by looking at Shadow Reg
- * 0x1F - "Mode Control Register"
- */
-static int bcm54616_is_serdes(struct phy_device *phydev)
-{
-	u16 val;
-
-	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD,
-			MIIM_BCM54XX_SHD_VAL(0x1F));
-	val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD);
-	return (val & 0x0001);
-}
-
-/*
- * Determine SerDes link speed and duplex from Expansion reg 0x42 "Operating
- * Mode Status Register"
- */
-static u32 bcm54616_parse_serdes_sr(struct phy_device *phydev)
-{
-	u16 val;
-	int i = 0;
-
-	/* Wait 1s for link - Clause 37 autonegotiation happens very fast */
-	while (1) {
-		phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD,
-			MIIM_BCM54XX_SHD_VAL(0x15));
-		val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD);
-
-		if (val & 0x0200)
-			break;
-
-		if (i++ > 1000) {
-			phydev->link = 0;
-			return 1;
-		}
-
-		udelay(1000);	/* 1 ms */
-	}
-
-	phydev->link = 1;
-	switch ((val >> 6) & 0x3) {
-	case (0x00):
-		phydev->speed = 10;
-		break;
-	case (0x01):
-		phydev->speed = 100;
-		break;
-	case (0x02):
-		phydev->speed = 1000;
-		break;
-	}
-
-	phydev->duplex = (val & 0x0100) == 0x0100;
-
-	return 0;
-}
-
-/*
- * Figure out if BCM54616 is in serdes or copper mode and determine link
- * configuration accordingly
- */
-static int bcm54616_startup(struct phy_device *phydev)
-{
-	if (bcm54616_is_serdes(phydev)) {
-		bcm54616_parse_serdes_sr(phydev);
-		phydev->port = PORT_FIBRE;
-	} else {
-		/* Wait for auto-negotiation to complete or fail */
-		genphy_update_link(phydev);
-		/* Parse BCM54xx copper aux status register */
-		bcm54xx_parse_status(phydev);
-	}
-
-	return 0;
-}
-
 /* Broadcom BCM5482S */
 /*
  * "Ethernet@Wirespeed" needs to be enabled to achieve link in certain
@@ -344,6 +229,7 @@ static int bcm5482_startup(struct phy_device *phydev)
 	return 0;
 }
 
+#if 0
 static struct phy_driver BCM5461S_driver = {
 	.name = "Broadcom BCM5461S",
 	.uid = 0x2060c0,
@@ -353,6 +239,17 @@ static struct phy_driver BCM5461S_driver = {
 	.startup = &bcm54xx_startup,
 	.shutdown = &genphy_shutdown,
 };
+#else
+static struct phy_driver BCM5461S_driver = {
+	.name = "Broadcom BCM5461S",
+	.uid = 0x03625d12,
+	.mask = 0xfffff0,
+	.features = PHY_GBIT_FEATURES,
+	.config = &bcm5461_config,
+	.startup = &bcm54xx_startup,
+	.shutdown = &genphy_shutdown,
+};
+#endif
 
 static struct phy_driver BCM5464S_driver = {
 	.name = "Broadcom BCM5464S",
@@ -394,16 +291,6 @@ static struct phy_driver BCM5481_A2_driver = {
 	.shutdown = &genphy_shutdown,
 };
 
-static struct phy_driver BCM54616S_driver = {
-	.name = "Broadcom BCM54616S",
-	.uid = 0x03625D10,
-	.mask = 0xfffffff0,
-	.features = PHY_GBIT_FEATURES,
-	.config = &bcm54616_config,
-	.startup = &bcm54616_startup,
-	.shutdown = &genphy_shutdown,
-};
-
 int phy_broadcom_init(void)
 {
 	phy_register(&BCM5482S_driver);
@@ -411,7 +298,6 @@ int phy_broadcom_init(void)
 	phy_register(&BCM5461S_driver);
 	phy_register(&BCM54610_A3_driver);
 	phy_register(&BCM5481_A2_driver);
-	phy_register(&BCM54616S_driver);
 
 	return 0;
 }
diff --git a/drivers/net/phy/teranetics.c b/drivers/net/phy/teranetics.c
index 78447b7..c0f13b8 100644
--- a/drivers/net/phy/teranetics.c
+++ b/drivers/net/phy/teranetics.c
@@ -34,9 +34,20 @@ int tn2020_config(struct phy_device *phydev)
 		unsigned short restart_an = (MDIO_AN_CTRL1_RESTART |
 						MDIO_AN_CTRL1_ENABLE |
 						MDIO_AN_CTRL1_XNP);
+		u8 phy_hwversion;
 
-		phy_write(phydev, 30, 93, 2);
-		phy_write(phydev, MDIO_MMD_AN, MDIO_CTRL1, restart_an);
+		/*
+		 * bit 15:12 of register 30.32 indicates PHY hardware
+		 * version. It can be used to distinguish TN80xx from
+		 * TN2020. TN2020 needs write 0x2 to 30.93, but TN80xx
+		 * needs 0x1.
+		 */
+		phy_hwversion = (phy_read(phydev, 30, 32) >> 12) & 0xf;
+		if (phy_hwversion <= 3) {
+			phy_write(phydev, 30, 93, 2);
+			phy_write(phydev, MDIO_MMD_AN, MDIO_CTRL1, restart_an);
+		} else
+			phy_write(phydev, 30, 93, 1);
 	}
 
 	return 0;
diff --git a/drivers/net/phy/vitesse.c b/drivers/net/phy/vitesse.c
index 6c5cb99..61f863e 100644
--- a/drivers/net/phy/vitesse.c
+++ b/drivers/net/phy/vitesse.c
@@ -48,6 +48,19 @@
 #define MIIM_VSC8601_SKEW_CTRL		0x1c
 
 #define PHY_EXT_PAGE_ACCESS    0x1f
+#define PHY_EXT_PAGE_ACCESS_GENERAL	0x10
+#define PHY_EXT_PAGE_ACCESS_EXTENDED3	0x3
+
+/* Vitesse VSC8574 control register */
+#define MIIM_VSC8574_MAC_SERDES_CON	0x10
+#define MIIM_VSC8574_MAC_SERDES_ANEG	0x80
+#define MIIM_VSC8574_GENERAL18		0x12
+#define MIIM_VSC8574_GENERAL19		0x13
+
+/* Vitesse VSC8574 gerenal purpose register 18 */
+#define MIIM_VSC8574_18G_SGMII		0x80f0
+#define MIIM_VSC8574_18G_QSGMII		0x80e0
+#define MIIM_VSC8574_18G_CMDSTAT	0x8000
 
 /* CIS8201 */
 static int vitesse_config(struct phy_device *phydev)
@@ -145,6 +158,49 @@ static int vsc8601_config(struct phy_device *phydev)
 	return 0;
 }
 
+static int vsc8574_config(struct phy_device *phydev)
+{
+	u32 val;
+	/* configure regiser 19G for MAC */
+	phy_write(phydev, MDIO_DEVAD_NONE, PHY_EXT_PAGE_ACCESS,
+			PHY_EXT_PAGE_ACCESS_GENERAL);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_VSC8574_GENERAL19);
+	if (phydev->interface == PHY_INTERFACE_MODE_QSGMII) {
+		/* set bit 15:14 to '01' for QSGMII mode */
+		val = (val & 0x3fff) | (1 << 14);
+		phy_write(phydev, MDIO_DEVAD_NONE,
+				MIIM_VSC8574_GENERAL19, val);
+		/* Enable 4 ports MAC QSGMII */
+		phy_write(phydev, MDIO_DEVAD_NONE, MIIM_VSC8574_GENERAL18,
+				MIIM_VSC8574_18G_QSGMII);
+	} else {
+		/* set bit 15:14 to '00' for SGMII mode */
+		val = val & 0x3fff;
+		phy_write(phydev, MDIO_DEVAD_NONE, MIIM_VSC8574_GENERAL19, val);
+		/* Enable 4 ports MAC SGMII */
+		phy_write(phydev, MDIO_DEVAD_NONE, MIIM_VSC8574_GENERAL18,
+				MIIM_VSC8574_18G_SGMII);
+	}
+	val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_VSC8574_GENERAL18);
+	/* When bit 15 is cleared the command has completed */
+	while (val & MIIM_VSC8574_18G_CMDSTAT)
+		val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_VSC8574_GENERAL18);
+
+	/* Enable Serdes Auto-negotiation */
+	phy_write(phydev, MDIO_DEVAD_NONE, PHY_EXT_PAGE_ACCESS,
+			PHY_EXT_PAGE_ACCESS_EXTENDED3);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_VSC8574_MAC_SERDES_CON);
+	val = val | MIIM_VSC8574_MAC_SERDES_ANEG;
+	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_VSC8574_MAC_SERDES_CON, val);
+
+	phy_write(phydev, MDIO_DEVAD_NONE, PHY_EXT_PAGE_ACCESS, 0);
+
+	genphy_config_aneg(phydev);
+
+	return 0;
+}
+
 static struct phy_driver VSC8211_driver = {
 	.name	= "Vitesse VSC8211",
 	.uid	= 0xfc4b0,
@@ -185,6 +241,16 @@ static struct phy_driver VSC8234_driver = {
 	.shutdown = &genphy_shutdown,
 };
 
+static struct phy_driver VSC8574_driver = {
+	.name = "Vitesse VSC8574",
+	.uid = 0x704a0,
+	.mask = 0xffff0,
+	.features = PHY_GBIT_FEATURES,
+	.config = &vsc8574_config,
+	.startup = &vitesse_startup,
+	.shutdown = &genphy_shutdown,
+};
+
 static struct phy_driver VSC8601_driver = {
 	.name = "Vitesse VSC8601",
 	.uid = 0x70420,
@@ -244,6 +310,7 @@ int phy_vitesse_init(void)
 	phy_register(&VSC8244_driver);
 	phy_register(&VSC8211_driver);
 	phy_register(&VSC8221_driver);
+	phy_register(&VSC8574_driver);
 	phy_register(&VSC8662_driver);
 	phy_register(&cis8201_driver);
 	phy_register(&cis8204_driver);
diff --git a/drivers/pci/fsl_pci_init.c b/drivers/pci/fsl_pci_init.c
index 77ac1f7..8e67d1c 100644
--- a/drivers/pci/fsl_pci_init.c
+++ b/drivers/pci/fsl_pci_init.c
@@ -41,12 +41,6 @@ DECLARE_GLOBAL_DATA_PTR;
 #include <asm/io.h>
 #include <asm/fsl_pci.h>
 
-/* Freescale-specific PCI config registers */
-#define FSL_PCI_PBFR		0x44
-#define FSL_PCIE_CAP_ID		0x4c
-#define FSL_PCIE_CFG_RDY	0x4b0
-#define FSL_PROG_IF_AGENT	0x1
-
 #ifndef CONFIG_SYS_PCI_MEMORY_BUS
 #define CONFIG_SYS_PCI_MEMORY_BUS 0
 #endif
@@ -211,7 +205,7 @@ static int fsl_pci_setup_inbound_windows(struct pci_controller *hose,
 	return 1;
 }
 
-#ifdef CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
+#ifdef CONFIG_SRIO_PCIE_BOOT_MASTER
 static void fsl_pcie_boot_master(pit_t *pi)
 {
 	/* configure inbound window for slave's u-boot image */
@@ -313,7 +307,7 @@ void fsl_pci_init(struct pci_controller *hose, struct fsl_pci_info *pci_info)
 	u32 block_rev;
 	int enabled, r, inbound = 0;
 	u16 ltssm;
-	u8 temp8, pcie_cap;
+	u8 pcie_cap;
 	volatile ccsr_fsl_pci_t *pci = (ccsr_fsl_pci_t *)cfg_addr;
 	struct pci_region *reg = hose->regions + hose->region_count;
 	pci_dev_t dev = PCI_BDF(hose->first_busno, 0, 0);
@@ -388,7 +382,7 @@ void fsl_pci_init(struct pci_controller *hose, struct fsl_pci_info *pci_info)
 	/* see if we are a PCIe or PCI controller */
 	pci_hose_read_config_byte(hose, dev, FSL_PCIE_CAP_ID, &pcie_cap);
 
-#ifdef CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
+#ifdef CONFIG_SRIO_PCIE_BOOT_MASTER
 	/* boot from PCIE --master */
 	char *s = getenv("bootmaster");
 	char pcie[6];
@@ -437,6 +431,15 @@ void fsl_pci_init(struct pci_controller *hose, struct fsl_pci_info *pci_info)
 	udelay(1);
 #endif
 	if (pcie_cap == PCI_CAP_ID_EXP) {
+		if (block_rev >= PEX_IP_BLK_REV_3_0) {
+#define PEX_CSR0_LTSSM_MASK	0xFC
+#define PEX_CSR0_LTSSM_SHIFT	2
+			ltssm = (in_be32(&pci->pex_csr0)
+				& PEX_CSR0_LTSSM_MASK) >> PEX_CSR0_LTSSM_SHIFT;
+			enabled = (ltssm == 0x11) ? 1 : 0;
+		} else {
+		/* pci_hose_read_config_word(hose, dev, PCI_LTSSM, &ltssm); */
+		/* enabled = ltssm >= PCI_LTSSM_L0; */
 		pci_hose_read_config_word(hose, dev, PCI_LTSSM, &ltssm);
 		enabled = ltssm >= PCI_LTSSM_L0;
 
@@ -469,6 +472,7 @@ void fsl_pci_init(struct pci_controller *hose, struct fsl_pci_info *pci_info)
 					PCI_BASE_ADDRESS_0, pcicsrbar);
 		}
 #endif
+	}
 
 #ifdef CONFIG_SYS_P4080_ERRATUM_PCIE_A003
 		if (enabled == 0) {
@@ -530,8 +534,8 @@ void fsl_pci_init(struct pci_controller *hose, struct fsl_pci_info *pci_info)
 			hose->current_busno);
 		hose->last_busno = pci_hose_scan_bus(hose, hose->current_busno);
 	} else {
-		debug("           Not scanning PCI bus %02x. PI=%x\n",
-			hose->current_busno, temp8);
+		debug("           Not scanning PCI bus %02x.\n",
+			hose->current_busno);
 		hose->last_busno = hose->current_busno;
 	}
 
@@ -577,6 +581,10 @@ int fsl_is_pci_agent(struct pci_controller *hose)
 		u8 prog_if;
 
 		pci_hose_read_config_byte(hose, dev, PCI_CLASS_PROG, &prog_if);
+		/* Programming Interface (PCI_CLASS_PROG)
+		 * 0 == pci host or pcie root-complex,
+		 * 1 == pci agent or pcie end-point
+		 */
 		return (prog_if == FSL_PROG_IF_AGENT);
 	}
 }
@@ -624,7 +632,7 @@ int fsl_pci_init_port(struct fsl_pci_info *pci_info,
 	if (fsl_is_pci_agent(hose)) {
 		fsl_pci_config_unlock(hose);
 		hose->last_busno = hose->first_busno;
-#ifdef CONFIG_SYS_FSL_SRIO_PCIE_BOOT_MASTER
+#ifdef CONFIG_SRIO_PCIE_BOOT_MASTER
 	} else {
 		/* boot from PCIE --master releases slave's core 0 */
 		char *s = getenv("bootmaster");
@@ -657,7 +665,13 @@ void fsl_pci_config_unlock(struct pci_controller *hose)
 	pci_hose_read_config_byte(hose, dev, FSL_PCIE_CAP_ID, &pcie_cap);
 	if (pcie_cap != 0x0) {
 		/* PCIe - set CFG_READY bit of Configuration Ready Register */
-		pci_hose_write_config_byte(hose, dev, FSL_PCIE_CFG_RDY, 0x1);
+#ifdef CONFIG_SYS_FSL_PCI_VER_3_X
+		ccsr_fsl_pci_t *pci = (ccsr_fsl_pci_t *)hose->cfg_addr;
+		setbits_be32(&pci->config, FSL_PCI_CFG_READY);
+#else
+		pci_hose_write_config_byte(hose, dev, FSL_PCIE_CFG_RDY,
+					   FSL_PCI_CFG_READY);
+#endif
 	} else {
 		/* PCI - clear ACL bit of PBFR */
 		pci_hose_read_config_word(hose, dev, FSL_PCI_PBFR, &pbfr);
diff --git a/drivers/sec/Makefile b/drivers/sec/Makefile
new file mode 100644
index 0000000..45d38cf
--- /dev/null
+++ b/drivers/sec/Makefile
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2000-2007, 2012
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libsec.o
+
+COBJS-$(CONFIG_SECURE_BOOT) += jr.o sha.o rsa_sec.o jobdesc.o error.o rng.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/drivers/sec/error.c b/drivers/sec/error.c
new file mode 100644
index 0000000..f8bd273
--- /dev/null
+++ b/drivers/sec/error.c
@@ -0,0 +1,259 @@
+/*
+ * CAAM Error Reporting
+ *
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <jr.h>
+#include <malloc.h>
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define JRSTA_SSRC_SHIFT            28
+#define JRSTA_CCBERR_CHAID_MASK     0x00f0
+#define JRSTA_CCBERR_CHAID_SHIFT    4
+#define JRSTA_CCBERR_ERRID_MASK     0x000
+
+#define JRSTA_DECOERR_JUMP          0x08000000
+#define JRSTA_DECOERR_INDEX_SHIFT   8
+#define JRSTA_DECOERR_INDEX_MASK    0xff00
+#define JRSTA_DECOERR_ERROR_MASK    0x00ff
+
+#define SPRINTFCAT(str, format, param, max_alloc)		\
+{								\
+	char *tmp;						\
+								\
+	tmp = malloc(sizeof(format) + max_alloc);		\
+	sprintf(tmp, format, param);				\
+	strcat(str, tmp);					\
+	free(tmp);						\
+}
+
+static void report_jump_idx(u32 status, char *outstr)
+{
+	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
+		  JRSTA_DECOERR_INDEX_SHIFT;
+
+	if (status & JRSTA_DECOERR_JUMP)
+		strcat(outstr, "jump tgt desc idx ");
+	else
+		strcat(outstr, "desc idx ");
+
+	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
+}
+
+static void report_ccb_status(u32 status, char *outstr)
+{
+	char *cha_id_list[] = {
+		"",
+		"AES",
+		"DES, 3DES",
+		"ARC4",
+		"MD5, SHA-1, SH-224, SHA-256, SHA-384, SHA-512",
+		"RNG",
+		"SNOW f8",
+		"Kasumi f8, f9",
+		"All Public Key Algorithms",
+		"CRC",
+		"SNOW f9",
+	};
+	char *err_id_list[] = {
+		"None. No error.",
+		"Mode error.",
+		"Data size error.",
+		"Key size error.",
+		"PKHA A memory size error.",
+		"PKHA B memory size error.",
+		"Data arrived out of sequence error.",
+		"PKHA divide-by-zero error.",
+		"PKHA modulus even error.",
+		"DES key parity error.",
+		"ICV check failed.",
+		"Hardware error.",
+		"Unsupported CCM AAD size.",
+		"Class 1 CHA is not reset",
+		"Invalid CHA combination was selected",
+		"Invalid CHA selected.",
+	};
+	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
+		    JRSTA_CCBERR_CHAID_SHIFT;
+	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
+
+	report_jump_idx(status, outstr);
+
+	if (cha_id < ARRAY_SIZE(cha_id_list)) {
+		SPRINTFCAT(outstr, "%s: ", cha_id_list[cha_id],
+			   strlen(cha_id_list[cha_id]));
+	} else {
+		SPRINTFCAT(outstr, "unidentified cha_id value 0x%02x: ",
+			   cha_id, sizeof("ff"));
+	}
+
+	if (err_id < ARRAY_SIZE(err_id_list)) {
+		SPRINTFCAT(outstr, "%s", err_id_list[err_id],
+			   strlen(err_id_list[err_id]));
+	} else {
+		SPRINTFCAT(outstr, "unidentified err_id value 0x%02x",
+			   err_id, sizeof("ff"));
+	}
+}
+
+static void report_jump_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+static void report_deco_status(u32 status, char *outstr)
+{
+	const struct {
+		u8 value;
+		char *error_text;
+	} desc_error_list[] = {
+		{ 0x00, "None. No error." },
+		{ 0x01, "SGT Length Error. The descriptor is trying to read "
+			"more data than is contained in the SGT table." },
+		{ 0x02, "Reserved." },
+		{ 0x03, "Job Ring Control Error. There is a bad value in the "
+			"Job Ring Control register." },
+		{ 0x04, "Invalid Descriptor Command. The Descriptor Command "
+			"field is invalid." },
+		{ 0x05, "Reserved." },
+		{ 0x06, "Invalid KEY Command" },
+		{ 0x07, "Invalid LOAD Command" },
+		{ 0x08, "Invalid STORE Command" },
+		{ 0x09, "Invalid OPERATION Command" },
+		{ 0x0A, "Invalid FIFO LOAD Command" },
+		{ 0x0B, "Invalid FIFO STORE Command" },
+		{ 0x0C, "Invalid MOVE Command" },
+		{ 0x0D, "Invalid JUMP Command. A nonlocal JUMP Command is "
+			"invalid because the target is not a Job Header "
+			"Command, or the jump is from a Trusted Descriptor to "
+			"a Job Descriptor, or because the target Descriptor "
+			"contains a Shared Descriptor." },
+		{ 0x0E, "Invalid MATH Command" },
+		{ 0x0F, "Invalid SIGNATURE Command" },
+		{ 0x10, "Invalid Sequence Command. A SEQ IN PTR OR SEQ OUT PTR "
+			"Command is invalid or a SEQ KEY, SEQ LOAD, SEQ FIFO "
+			"LOAD, or SEQ FIFO STORE decremented the input or "
+			"output sequence length below 0. This error may result "
+			"if a built-in PROTOCOL Command has encountered a "
+			"malformed PDU." },
+		{ 0x11, "Skip data type invalid. The type must be 0xE or 0xF."},
+		{ 0x12, "Shared Descriptor Header Error" },
+		{ 0x13, "Header Error. Invalid length or parity, or certain "
+			"other problems." },
+		{ 0x14, "Burster Error. Burster has gotten to an illegal "
+			"state" },
+		{ 0x15, "Context Register Length Error. The descriptor is "
+			"trying to read or write past the end of the Context "
+			"Register. A SEQ LOAD or SEQ STORE with the VLF bit "
+			"set was executed with too large a length in the "
+			"variable length register (VSOL for SEQ STORE or VSIL "
+			"for SEQ LOAD)." },
+		{ 0x16, "DMA Error" },
+		{ 0x17, "Reserved." },
+		{ 0x1A, "Job failed due to JR reset" },
+		{ 0x1B, "Job failed due to Fail Mode" },
+		{ 0x1C, "DECO Watchdog timer timeout error" },
+		{ 0x1D, "DECO tried to copy a key from another DECO but the "
+			"other DECO's Key Registers were locked" },
+		{ 0x1E, "DECO attempted to copy data from a DECO that had an "
+			"unmasked Descriptor error" },
+		{ 0x1F, "LIODN error. DECO was trying to share from itself or "
+			"from another DECO but the two Non-SEQ LIODN values "
+			"didn't match or the 'shared from' DECO's Descriptor "
+			"required that the SEQ LIODNs be the same and they "
+			"aren't." },
+		{ 0x20, "DECO has completed a reset initiated via the DRR "
+			"register" },
+		{ 0x21, "Nonce error. When using EKT (CCM) key encryption "
+			"option in the FIFO STORE Command, the Nonce counter "
+			"reached its maximum value and this encryption mode "
+			"can no longer be used." },
+		{ 0x22, "Meta data is too large (> 511 bytes) for TLS decap "
+			"(input frame; block ciphers) and IPsec decap (output "
+			"frame, when doing the next header byte update) and "
+			"DCRC (output frame)." },
+		{ 0x80, "DNR (do not run) error" },
+		{ 0x81, "undefined protocol command" },
+		{ 0x82, "invalid setting in PDB" },
+		{ 0x83, "Anti-replay LATE error" },
+		{ 0x84, "Anti-replay REPLAY error" },
+		{ 0x85, "Sequence number overflow" },
+		{ 0x86, "Sigver invalid signature" },
+		{ 0x87, "DSA Sign Illegal test descriptor" },
+		{ 0x88, "Protocol Format Error - A protocol has seen an error "
+			"in the format of data received. When running RSA, "
+			"this means that formatting with random padding was "
+			"used, and did not follow the form: 0x00, 0x02, 8-to-N "
+			"bytes of non-zero pad, 0x00, F data." },
+		{ 0x89, "Protocol Size Error - A protocol has seen an error in "
+			"size. When running RSA, pdb size N < (size of F) when "
+			"no formatting is used; or pdb size N < (F + 11) when "
+			"formatting is used." },
+		{ 0xC1, "Blob Command error: Undefined mode" },
+		{ 0xC2, "Blob Command error: Secure Memory Blob mode error" },
+		{ 0xC4, "Blob Command error: Black Blob key or input size "
+			"error" },
+		{ 0xC5, "Blob Command error: Invalid key destination" },
+		{ 0xC8, "Blob Command error: Trusted/Secure mode error" },
+		{ 0xF0, "IPsec TTL or hop limit field either came in as 0, "
+			"or was decremented to 0" },
+		{ 0xF1, "3GPP HFN matches or exceeds the Threshold" },
+	};
+	u8 desc_error = status & JRSTA_DECOERR_ERROR_MASK;
+	int i;
+
+	report_jump_idx(status, outstr);
+
+	for (i = 0; i < ARRAY_SIZE(desc_error_list); i++)
+		if (desc_error_list[i].value == desc_error)
+			break;
+
+	if (i != ARRAY_SIZE(desc_error_list) && desc_error_list[i].error_text) {
+		SPRINTFCAT(outstr, "%s", desc_error_list[i].error_text,
+			   strlen(desc_error_list[i].error_text));
+	} else {
+		SPRINTFCAT(outstr, "unidentified error value 0x%02x",
+			   desc_error, sizeof("ff"));
+	}
+}
+
+static void report_jr_status(u32 status, char *outstr)
+{
+}
+
+static void report_cond_code_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+int caam_jr_strstatus(char *outstr, u32 status)
+{
+	int ret = 0;
+	struct stat_src {
+		void (*report_ssed)(u32 status, char *outstr);
+		char *error;
+	} status_src[] = {
+		{ NULL, "No error" },
+		{ NULL, NULL },
+		{ report_ccb_status, "CCB" },
+		{ report_jump_status, "Jump" },
+		{ report_deco_status, "DECO" },
+		{ NULL, NULL },
+		{ report_jr_status, "Job Ring" },
+		{ report_cond_code_status, "Condition Code" },
+	};
+	u32 ssrc = status >> JRSTA_SSRC_SHIFT;
+
+	sprintf(outstr, "%s: ", status_src[ssrc].error);
+
+	if (status_src[ssrc].report_ssed) {
+		status_src[ssrc].report_ssed(status, outstr);
+		ret = -1;
+	} else
+		ret = 0;
+
+	return ret;
+}
diff --git a/drivers/sec/jobdesc.c b/drivers/sec/jobdesc.c
new file mode 100644
index 0000000..089dda0
--- /dev/null
+++ b/drivers/sec/jobdesc.c
@@ -0,0 +1,164 @@
+/*
+ * SEC Descriptor Construction Library
+ * Basic job descriptor construction
+ *
+ * Copyright (c) 2012 Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <common.h>
+#include <desc_constr.h>
+#include <jobdesc.h>
+
+#define KEY_BLOB_SIZE			32
+#define MAC_SIZE			16
+
+void inline_cnstr_jobdesc_blob_encap(uint32_t *desc, uint8_t *key_idnfr,
+				     uint8_t *plain_txt, uint8_t *enc_blob,
+				     uint32_t in_sz)
+{
+
+	dma_addr_t dma_addr_key_idnfr, dma_addr_in, dma_addr_out;
+	uint32_t key_sz = KEY_IDNFR_SZ_BYTES;
+	/* output blob will have 32 bytes key blob in beginning and
+	 * 16 byte HMAC identifier at end of data blob */
+	uint32_t out_sz = in_sz + KEY_BLOB_SIZE + MAC_SIZE;
+
+	dma_addr_key_idnfr = virt_to_phys((void *)key_idnfr);
+	dma_addr_in	= virt_to_phys((void *)plain_txt);
+	dma_addr_out	= virt_to_phys((void *)enc_blob);
+
+	init_job_desc(desc, 0);
+	append_key(desc, dma_addr_key_idnfr, key_sz, CLASS_2);
+
+	if (in_sz > 0xffff) {
+		append_seq_in_ptr(desc, dma_addr_in, 0, SQIN_EXT);
+		append_cmd(desc, in_sz);
+	} else {
+		append_seq_in_ptr(desc, dma_addr_in, in_sz, 0);
+	}
+
+	if (out_sz > 0xffff) {
+		append_seq_out_ptr(desc, dma_addr_out, 0, SQOUT_EXT);
+		append_cmd(desc, out_sz);
+	} else {
+		append_seq_out_ptr(desc, dma_addr_out, out_sz, 0);
+	}
+	append_operation(desc, OP_TYPE_ENCAP_PROTOCOL | OP_PCLID_BLOB);
+}
+
+void inline_cnstr_jobdesc_blob_decap(uint32_t *desc, uint8_t *key_idnfr,
+				     uint8_t *enc_blob, uint8_t *plain_txt,
+				     uint32_t out_sz)
+{
+	dma_addr_t dma_addr_key_idnfr, dma_addr_in, dma_addr_out;
+	uint32_t key_sz = KEY_IDNFR_SZ_BYTES;
+	uint32_t in_sz = out_sz + KEY_BLOB_SIZE + MAC_SIZE;
+
+	dma_addr_key_idnfr = virt_to_phys((void *)key_idnfr);
+	dma_addr_in	= virt_to_phys((void *)enc_blob);
+	dma_addr_out	= virt_to_phys((void *)plain_txt);
+
+	init_job_desc(desc, 0);
+	append_key(desc, dma_addr_key_idnfr, key_sz, CLASS_2);
+	if (in_sz > 0xffff) {
+		append_seq_in_ptr(desc, dma_addr_in, 0, SQIN_EXT);
+		append_cmd(desc, in_sz);
+	} else {
+		append_seq_in_ptr(desc, dma_addr_in, in_sz, 0);
+	}
+
+	if (out_sz > 0xffff) {
+		append_seq_out_ptr(desc, dma_addr_out, 0, SQOUT_EXT);
+		append_cmd(desc, out_sz);
+	} else {
+		append_seq_out_ptr(desc, dma_addr_out, out_sz, 0);
+	}
+
+	append_operation(desc, OP_TYPE_DECAP_PROTOCOL | OP_PCLID_BLOB);
+}
+
+
+/* Change key size to bytes form bits in calling function*/
+void inline_cnstr_jobdesc_pkha_rsaexp(uint32_t *desc,
+				      struct pk_in_params *pkin, uint8_t *out,
+				      uint32_t out_siz)
+{
+	dma_addr_t dma_addr_e, dma_addr_a, dma_addr_n, dma_addr_out;
+
+	dma_addr_e = virt_to_phys((void *)pkin->e);
+	dma_addr_a = virt_to_phys((void *)pkin->a);
+	dma_addr_n = virt_to_phys((void *)pkin->n);
+	dma_addr_out = virt_to_phys((void *)out);
+
+	init_job_desc(desc, 0);
+	append_key(desc, dma_addr_e, pkin->e_siz, KEY_DEST_PKHA_E | CLASS_1);
+
+	append_fifo_load(desc, dma_addr_a,
+			 pkin->a_siz, LDST_CLASS_1_CCB | FIFOLD_TYPE_PK_A);
+
+	append_fifo_load(desc, dma_addr_n,
+			 pkin->n_siz, LDST_CLASS_1_CCB | FIFOLD_TYPE_PK_N);
+
+	append_operation(desc, OP_TYPE_PK | OP_ALG_PK | OP_ALG_PKMODE_MOD_EXPO);
+
+	append_fifo_store(desc, dma_addr_out, out_siz,
+			  LDST_CLASS_1_CCB | FIFOST_TYPE_PKHA_B);
+}
+
+void inline_cnstr_jobdesc_sha256(uint32_t *desc,
+				 uint8_t *msg, uint32_t msgsz,
+				 uint8_t *digest)
+{
+	/* SHA 256 , output is of length 32 words */
+	uint32_t storelen = 32;
+	dma_addr_t dma_addr_in, dma_addr_out;
+
+	dma_addr_in = virt_to_phys((void *)msg);
+	dma_addr_out = virt_to_phys((void *)digest);
+
+	init_job_desc(desc, 0);
+	append_operation(desc,
+			 OP_TYPE_CLASS2_ALG | OP_ALG_ALGSEL_SHA256 |
+			 OP_ALG_AAI_HASH | OP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT
+			 | OP_ALG_ICV_OFF);
+	if (msgsz > 0xffff) {
+		append_fifo_load(desc, dma_addr_in, 0,
+				 LDST_CLASS_2_CCB | FIFOLDST_SGF |
+				 FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2 |
+				 FIFOLDST_EXT);
+		append_cmd(desc, msgsz);
+	} else
+		append_fifo_load(desc, dma_addr_in, msgsz,
+				 LDST_CLASS_2_CCB | FIFOLDST_SGF |
+				 FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2);
+	append_store(desc, dma_addr_out, storelen,
+		     LDST_CLASS_2_CCB | LDST_SRCDST_BYTE_CONTEXT);
+}
diff --git a/drivers/sec/jr.c b/drivers/sec/jr.c
new file mode 100644
index 0000000..ea66df6
--- /dev/null
+++ b/drivers/sec/jr.c
@@ -0,0 +1,305 @@
+/*
+ * Copyright 2011, 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/immap_85xx.h>
+#include <jr.h>
+#include <asm/fsl_pamu.h>
+#include <fsl_secboot_err.h>
+
+#define CIRC_CNT(head, tail, size)	(((head) - (tail)) & (size - 1))
+#define CIRC_SPACE(head, tail, size)	CIRC_CNT((tail), (head) + 1, (size))
+
+static inline void jr_reset_liodn(void)
+{
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	out_be32(&sec->jrliodnr[0].ls, 0);
+	asm volatile("sync" : : : "memory");
+}
+
+static inline void jr_disable_irq(void)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	uint32_t jrcfg = in_be32(&regs->jrcfg1);
+
+	jrcfg = jrcfg | JR_INTMASK;
+
+	out_be32(&regs->jrcfg1, jrcfg);
+	asm volatile("sync" : : : "memory");
+
+}
+
+static void jr_initregs(struct jobring *jr)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	phys_addr_t ip_base = virt_to_phys((void *)jr->input_ring);
+	phys_addr_t op_base = virt_to_phys((void *)jr->output_ring);
+
+#ifdef CONFIG_PHYS_64BIT
+	out_be32(&regs->irba_h, ip_base >> 32);
+#else
+	out_be32(&regs->irba_h, 0x0);
+#endif
+	out_be32(&regs->irba_l, (uint32_t)ip_base);
+#ifdef CONFIG_PHYS_64BIT
+	out_be32(&regs->orba_h, op_base >> 32);
+#else
+	out_be32(&regs->orba_h, 0x0);
+#endif
+	out_be32(&regs->orba_l, (uint32_t)op_base);
+	out_be32(&regs->ors, JR_SIZE);
+	out_be32(&regs->irs, JR_SIZE);
+
+	asm volatile("sync" : : : "memory");
+	if (!jr->irq)
+		jr_disable_irq();
+}
+
+int jr_init(struct jobring *jr)
+{
+	memset(jr, 0, sizeof(struct jobring));
+
+	jr->jq_id = DEFAULT_JR_ID;
+	jr->irq = DEFAULT_IRQ;
+
+#ifdef CONFIG_FSL_CORENET
+	jr->liodn = DEFAULT_JR_LIODN;
+#endif
+	jr->size = JR_SIZE;
+	jr->input_ring = (dma_addr_t *) malloc(JR_SIZE * sizeof(dma_addr_t));
+	if (!jr->input_ring)
+		return -1;
+	jr->output_ring =
+	    (struct op_ring *)malloc(JR_SIZE * sizeof(struct op_ring));
+	if (!jr->output_ring)
+		return -1;
+
+	memset(jr->input_ring, 0, JR_SIZE * sizeof(dma_addr_t));
+	memset(jr->output_ring, 0, JR_SIZE * sizeof(struct op_ring));
+
+	jr_initregs(jr);
+
+	return 0;
+}
+
+int jr_sw_cleanup(struct jobring *jr)
+{
+	jr->head = 0;
+	jr->tail = 0;
+	jr->read_idx = 0;
+	jr->write_idx = 0;
+	memset(jr->info, 0, sizeof(jr->info));
+	memset(jr->input_ring, 0, jr->size * sizeof(dma_addr_t));
+	memset(jr->output_ring, 0, jr->size * sizeof(struct op_ring));
+
+	return 0;
+}
+
+int sec_init(struct jobring *jr)
+{
+	int ret = 0;
+
+#ifdef CONFIG_FSL_CORENET
+	uint32_t liodnr;
+	uint32_t liodn_ns;
+	uint32_t liodn_s;
+#endif
+
+#ifdef CONFIG_PHYS_64BIT
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	uint32_t mcr = in_be32(&sec->mcfgr);
+
+	out_be32(&sec->mcfgr, mcr | 1 << MCFGR_PS_SHIFT);
+#endif
+
+#ifdef CONFIG_FSL_CORENET
+	liodnr = in_be32(&sec->jrliodnr[0].ls);
+	liodn_ns = (liodnr & JRNSLIODN_MASK) >> JRNSLIODN_SHIFT;
+	liodn_s = (liodnr & JRSLIODN_MASK) >> JRSLIODN_SHIFT;
+#endif
+	ret = jr_init(jr);
+	if (ret < 0)
+		return -1;
+
+#ifdef CONFIG_FSL_CORENET
+	ret = sec_config_pamu_table(liodn_ns, liodn_s);
+	if (ret < 0)
+		return -1;
+
+#ifdef CONFIG_FSL_CORENET
+	pamu_enable();
+#endif
+
+#endif
+
+	return ret;
+}
+
+int jr_hw_reset(void)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	uint32_t timeout = 100000;
+	uint32_t jrint, jrcr;
+
+	out_be32(&regs->jrcr, JRCR_RESET);
+	do {
+		jrint = in_be32(&regs->jrint);
+	} while (((jrint & JRINT_ERR_HALT_MASK) ==
+		  JRINT_ERR_HALT_INPROGRESS) && --timeout);
+
+	jrint = in_be32(&regs->jrint);
+	if (((jrint & JRINT_ERR_HALT_MASK) !=
+	     JRINT_ERR_HALT_INPROGRESS) && timeout == 0)
+		return -1;
+
+	timeout = 100000;
+	out_be32(&regs->jrcr, JRCR_RESET);
+	do {
+		jrcr = in_be32(&regs->jrcr);
+	} while ((jrcr & JRCR_RESET) && --timeout);
+
+	if (timeout == 0)
+		return -1;
+
+	return 0;
+}
+
+int jr_reset(struct jobring *jr)
+{
+	if (jr_hw_reset() < 0)
+		return -1;
+
+	/* Clean up the jobring structure maintained by software */
+	jr_sw_cleanup(jr);
+
+	return 0;
+}
+
+int sec_reset(void)
+{
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	uint32_t mcfgr = in_be32(&sec->mcfgr);
+	uint32_t timeout = 100000;
+
+	mcfgr |= MCFGR_SWRST;
+	out_be32(&sec->mcfgr, mcfgr);
+
+	mcfgr |= MCFGR_DMA_RST;
+	out_be32(&sec->mcfgr, mcfgr);
+	do {
+		mcfgr = in_be32(&sec->mcfgr);
+	} while ((mcfgr & MCFGR_DMA_RST) == MCFGR_DMA_RST && --timeout);
+
+	if (timeout == 0)
+		return -1;
+
+	timeout = 100000;
+	do {
+		mcfgr = in_be32(&sec->mcfgr);
+	} while ((mcfgr & MCFGR_SWRST) == MCFGR_SWRST && --timeout);
+
+	if (timeout == 0)
+		return -1;
+
+	return 0;
+}
+
+/* -1 --- error, can't enqueue -- no space available */
+int jr_enqueue(struct jobring *jr, uint32_t * desc_addr,
+	       void (*callback) (uint32_t desc, uint32_t status, void *arg),
+	       void *arg)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	int head = jr->head;
+	dma_addr_t desc_phys_addr = virt_to_phys(desc_addr);
+
+	if (in_be32(&regs->irsa) == 0
+	    || CIRC_SPACE(jr->head, jr->tail, jr->size) <= 0)
+		return ERROR_ESBC_SEC_ENQ;
+
+	jr->input_ring[head] = desc_phys_addr;
+	jr->info[head].desc_phys_addr = desc_phys_addr;
+	jr->info[head].desc_addr = (uint32_t) desc_addr;
+	jr->info[head].callback = (void *) callback;
+	jr->info[head].arg = arg;
+	jr->info[head].op_done = 0;
+
+	jr->head = (head + 1) & (jr->size - 1);
+
+	out_be32(&regs->irja, 1);
+	asm volatile("sync" : : : "memory");
+
+	return 0;
+}
+
+int jr_dequeue(struct jobring *jr)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	int head = jr->head;
+	int tail = jr->tail;
+	int idx, i, found;
+	void (*callback) (uint32_t desc, uint32_t status, void *arg);
+	void *arg = NULL;
+
+	while (in_be32(&regs->orsf) && CIRC_CNT(jr->head, jr->tail, jr->size)) {
+		found = 0;
+
+		dma_addr_t op_desc = jr->output_ring[jr->tail].desc;
+		uint32_t status = jr->output_ring[jr->tail].status;
+		uint32_t desc_virt;
+
+		for (i = 0; CIRC_CNT(head, tail + i, jr->size) >= 1; i++) {
+			idx = (tail + i) & (jr->size - 1);
+			if (op_desc == jr->info[idx].desc_phys_addr) {
+				desc_virt = jr->info[idx].desc_addr;
+				found = 1;
+				break;
+			}
+		}
+
+		/* Error condition if match not found */
+		if (!found)
+			return ERROR_ESBC_SEC_DEQ;
+
+		jr->info[idx].op_done = 1;
+		callback = (void *) jr->info[idx].callback;
+		arg = jr->info[idx].arg;
+
+		/* When the job on tail idx gets done, increment
+		 * tail till the point where job completed out of oredr has
+		 * been taken into account
+		 */
+		if (idx == tail)
+			do {
+				tail = (tail + 1) & (jr->size - 1);
+			} while (jr->info[tail].op_done);
+
+		jr->tail = tail;
+		jr->read_idx = (jr->read_idx + 1) & (jr->size - 1);
+
+		out_be32(&regs->orjr, 1);
+		asm volatile("sync" : : : "memory");
+		jr->info[idx].op_done = 0;
+
+		callback(desc_virt, status, arg);
+	}
+
+	return 0;
+}
diff --git a/drivers/sec/rng.c b/drivers/sec/rng.c
new file mode 100644
index 0000000..944f31a
--- /dev/null
+++ b/drivers/sec/rng.c
@@ -0,0 +1,182 @@
+/*
+ * RNG initialization
+ *
+ * Derived from linux caam driver ctrl.c
+ *
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <jr.h>
+#include <desc_constr.h>
+#include <desc.h>
+
+u8 get_rng_vid(void)
+{
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	u32 cha_vid = in_be32(&sec->chavid_ls);
+
+	return (cha_vid & SEC_CHAVID_RNG_LS_MASK) >> SEC_CHAVID_LS_RNG_SHIFT;
+}
+
+/*
+ * Descriptor to instantiate RNG State Handle 0 in normal mode and
+ * load the JDKEK, TDKEK and TDSK registers
+ */
+static void build_instantiation_desc(u32 *desc)
+{
+	u32 *jump_cmd;
+
+	init_job_desc(desc, 0);
+
+	/* INIT RNG in non-test mode */
+	append_operation(desc, OP_TYPE_CLASS1_ALG | OP_ALG_ALGSEL_RNG |
+			 OP_ALG_AS_INIT);
+
+	/* wait for done */
+	jump_cmd = append_jump(desc, JUMP_CLASS_CLASS1);
+	set_jump_tgt_here(desc, jump_cmd);
+
+	/*
+	 * load 1 to clear written reg:
+	 * resets the done interrrupt and returns the RNG to idle.
+	 */
+	append_load_imm_u32(desc, 1, LDST_SRCDST_WORD_CLRW);
+
+	/* generate secure keys (non-test) */
+	append_operation(desc, OP_TYPE_CLASS1_ALG | OP_ALG_ALGSEL_RNG |
+			 OP_ALG_RNG4_SK);
+}
+
+void rng4_init_done(uint32_t desc, uint32_t status, void *arg)
+{
+	struct result *instantiation = arg;
+	instantiation->status = status;
+	instantiation->err = caam_jr_strstatus(instantiation->outstr, status);
+	instantiation->done = 1;
+}
+
+static int instantiate_rng(struct jobring *jr)
+{
+	struct result op;
+	u32 *desc;
+	int ret = 0;
+	unsigned long long timeval;
+	unsigned long long timeout;
+
+	memset(&op, 0, sizeof(struct result));
+
+	desc = malloc(CAAM_CMD_SZ * 6);
+	if (!desc) {
+		printf("cannot allocate RNG init descriptor memory\n");
+		return -1;
+	}
+
+	build_instantiation_desc(desc);
+	ret = jr_enqueue(jr, desc, rng4_init_done, &op);
+	if (ret)
+		return -1;
+
+	timeval = get_ticks();
+	timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+
+	while (op.done != 1) {
+		if (jr_dequeue(jr)) {
+			printf("RNG Instantiation :deq error\n");
+			return -1;
+		}
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("RNG Instantiation : SEC Dequeue timed out\n");
+			return -1;
+		}
+	}
+
+	if (op.status) {
+		printf("RNG: Instantiation failed with error %x\n", op.status);
+		return -1;
+	}
+
+	return ret;
+}
+
+/*
+ * By default, the TRNG runs for 200 clocks per sample;
+ * 1600 clocks per sample generates better entropy.
+ */
+static void kick_trng(void)
+{
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	struct rng4tst __iomem *rng =
+			(struct rng4tst __iomem *)&sec->rng;
+	u32 val;
+
+	/* put RNG4 into program mode */
+	setbits_be32(&rng->rtmctl, RTMCTL_PRGM);
+	/* 1600 clocks per sample */
+	val = in_be32(&rng->rtsdctl);
+	val = (val & ~RTSDCTL_ENT_DLY_MASK) | (1600 << RTSDCTL_ENT_DLY_SHIFT);
+	out_be32(&rng->rtsdctl, val);
+	/* min. freq. count */
+	out_be32(&rng->rtfreqmin, 400);
+	/* max. freq. count */
+	out_be32(&rng->rtfreqmax, 6400);
+	/* put RNG4 into run mode */
+	clrbits_be32(&rng->rtmctl, RTMCTL_PRGM);
+}
+
+int rng_init(struct jobring *jr)
+{
+	int ret;
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	struct rng4tst __iomem *rng =
+			(struct rng4tst __iomem *)&sec->rng;
+
+	u32 rdsta = in_be32(&rng->rdsta);
+
+	/* Check if RNG state 0 handler is already instantiated */
+	if (rdsta & RNG_STATE0_HANDLE_INSTANTIATED) {
+		printf("RNG: Already instantiated\n");
+		return 0;
+	}
+
+	kick_trng();
+
+	ret = instantiate_rng(jr);
+	if (ret)
+		return ret;
+
+	 /* Enable RDB bit so that RNG works faster */
+	setbits_be32(&sec->scfgr, SEC_SCFGR_RDBENABLE);
+
+	return ret;
+}
diff --git a/drivers/sec/rsa_sec.c b/drivers/sec/rsa_sec.c
new file mode 100644
index 0000000..f902990
--- /dev/null
+++ b/drivers/sec/rsa_sec.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <rsa_sec.h>
+#include <jobdesc.h>
+#include <fsl_secboot_err.h>
+
+void rsa_done(uint32_t desc, uint32_t status, void *arg)
+{
+	struct result *x = arg;
+	x->status = status;
+#ifdef DEBUG
+	x->err = caam_jr_strstatus(x->outstr, status);
+#else
+	if (status)
+		x->err = -1;
+#endif
+
+	x->done = 1;
+}
+
+/* This functionw ould return teh status returned by SEC .
+ * If non zero , means there was some error reported by SEC */
+int rsa_public_verif_sec(unsigned char *sign, uint8_t *to, uint8_t *rsa_pub_key,
+			int klen, struct rsa_context *ctx, struct jobring *jr)
+{
+	unsigned long long timeval;
+	unsigned long long timeout;
+	int ret = 0;
+	memset(ctx, 0, sizeof(struct rsa_context));
+
+	ctx->pkin.a = sign;
+	ctx->pkin.a_siz = klen;
+	ctx->pkin.n = rsa_pub_key;
+	ctx->pkin.n_siz = klen;
+	ctx->pkin.e = rsa_pub_key + klen;
+	ctx->pkin.e_siz = klen;
+
+	inline_cnstr_jobdesc_pkha_rsaexp(ctx->rsa_desc,
+			      &ctx->pkin, to,
+			      klen);
+
+	ret = jr_enqueue(jr, ctx->rsa_desc, rsa_done, &ctx->op);
+	if (ret)
+		return ret;
+
+	timeval = get_ticks();
+	timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+
+	while (ctx->op.done != 1) {
+		if (jr_dequeue(jr))
+			return ERROR_ESBC_SEC_DEQ;
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("SEC Dequeue timed out\n");
+			return ERROR_ESBC_SEC_DEQ_TO;
+		}
+	}
+
+	if (ctx->op.err < 0)
+		return ctx->op.status;
+
+	return 0;
+}
diff --git a/drivers/sec/sha.c b/drivers/sec/sha.c
new file mode 100644
index 0000000..fb6dcff
--- /dev/null
+++ b/drivers/sec/sha.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <jobdesc.h>
+#include <sha.h>
+#include <fsl_secboot_err.h>
+
+void sha_done(uint32_t desc, uint32_t status, void *arg)
+{
+	struct result *x = arg;
+	x->status = status;
+	x->err = caam_jr_strstatus(x->outstr, status);
+	x->done = 1;
+}
+
+/* This function initializes the sha-256 context */
+void sha_init(struct sha_ctx *ctx, struct jobring *jr)
+{
+	memset(ctx, 0, sizeof(struct sha_ctx));
+	ctx->jr = jr;
+}
+
+void sha_update(struct sha_ctx *ctx, u8 *buffer, u32 length)
+{
+	dma_addr_t addr = virt_to_phys((void *)buffer);
+#ifdef CONFIG_PHYS_64BIT
+	ctx->sg_tbl[ctx->sg_num].addr_hi = addr >> 32;
+#else
+	ctx->sg_tbl[ctx->sg_num].addr_hi = 0x0;
+#endif
+	ctx->sg_tbl[ctx->sg_num].addr_lo = addr;
+	ctx->sg_tbl[ctx->sg_num].length = length;
+	ctx->sg_num++;
+}
+
+int sha_final(struct sha_ctx *ctx)
+{
+	int ret = 0, i = 0;
+	ctx->sg_tbl[ctx->sg_num - 1].final = 1;
+	uint32_t len = 0;
+
+	for (i = 0; i < ctx->sg_num; i++)
+		len +=  ctx->sg_tbl[i].length;
+
+	inline_cnstr_jobdesc_sha256(ctx->sha_desc,
+			   (uint8_t *)ctx->sg_tbl, len, ctx->hash);
+
+	ret = jr_enqueue(ctx->jr, ctx->sha_desc, sha_done, &ctx->op);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+
+/* This  function  completes the calulation of the sha-256 */
+int sha_digest(struct sha_ctx *ctx, uint8_t *digest)
+{
+	unsigned long long timeval = get_ticks();
+	unsigned long long timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+	int ret = 0;
+
+	while (ctx->op.done != 1) {
+		ret = jr_dequeue(ctx->jr);
+		if (ret)
+			return ret;
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("SEC Dequeue timed out\n");
+			return ERROR_ESBC_SEC_DEQ_TO;
+		}
+	}
+
+	if (ctx->op.err < 0)
+		return ctx->op.status;
+
+	memcpy(digest, ctx->hash, sizeof(ctx->hash));
+
+	return 0;
+}
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 824d357..6168bfc 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -2,39 +2,30 @@
 # (C) Copyright 2000-2007
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
+# SPDX-License-Identifier:	GPL-2.0+
 #
 
 include $(TOPDIR)/config.mk
 
 LIB	:= $(obj)libspi.o
 
+# There are many options which enable SPI, so make this library available
+COBJS-y += spi.o
+
+COBJS-$(CONFIG_EP93XX_SPI) += ep93xx_spi.o
 COBJS-$(CONFIG_ALTERA_SPI) += altera_spi.o
 COBJS-$(CONFIG_ANDES_SPI) += andes_spi.o
 COBJS-$(CONFIG_ARMADA100_SPI) += armada100_spi.o
 COBJS-$(CONFIG_ATMEL_DATAFLASH_SPI) += atmel_dataflash_spi.o
 COBJS-$(CONFIG_ATMEL_SPI) += atmel_spi.o
 COBJS-$(CONFIG_BFIN_SPI) += bfin_spi.o
+COBJS-$(CONFIG_BFIN_SPI6XX) += bfin_spi6xx.o
 COBJS-$(CONFIG_CF_SPI) += cf_spi.o
 COBJS-$(CONFIG_CF_QSPI) += cf_qspi.o
 COBJS-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
 COBJS-$(CONFIG_EXYNOS_SPI) += exynos_spi.o
+COBJS-$(CONFIG_FTSSP010_SPI) += ftssp010_spi.o
+COBJS-$(CONFIG_ICH_SPI) +=  ich.o
 COBJS-$(CONFIG_KIRKWOOD_SPI) += kirkwood_spi.o
 COBJS-$(CONFIG_MPC52XX_SPI) += mpc52xx_spi.o
 COBJS-$(CONFIG_MPC8XXX_SPI) += mpc8xxx_spi.o
@@ -42,11 +33,19 @@ COBJS-$(CONFIG_MXC_SPI) += mxc_spi.o
 COBJS-$(CONFIG_MXS_SPI) += mxs_spi.o
 COBJS-$(CONFIG_OC_TINY_SPI) += oc_tiny_spi.o
 COBJS-$(CONFIG_OMAP3_SPI) += omap3_spi.o
+COBJS-$(CONFIG_SANDBOX_SPI) += sandbox_spi.o
 COBJS-$(CONFIG_SOFT_SPI) += soft_spi.o
 COBJS-$(CONFIG_SH_SPI) += sh_spi.o
+COBJS-$(CONFIG_SH_QSPI) += sh_qspi.o
 COBJS-$(CONFIG_FSL_ESPI) += fsl_espi.o
-COBJS-$(CONFIG_TEGRA_SPI) += tegra_spi.o
+COBJS-$(CONFIG_FDT_SPI) += fdt_spi.o
+COBJS-$(CONFIG_TEGRA20_SFLASH) += tegra20_sflash.o
+COBJS-$(CONFIG_TEGRA20_SLINK) += tegra20_slink.o
+COBJS-$(CONFIG_TEGRA114_SPI) += tegra114_spi.o
+COBJS-$(CONFIG_TI_QSPI) += ti_qspi.o
 COBJS-$(CONFIG_XILINX_SPI) += xilinx_spi.o
+COBJS-$(CONFIG_ZYNQ_SPI) += zynq_spi.o
+COBJS-$(CONFIG_FSL_QSPI) += fsl_qspi.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/spi/altera_spi.c b/drivers/spi/altera_spi.c
index 138d6f4..5accbb5 100644
--- a/drivers/spi/altera_spi.c
+++ b/drivers/spi/altera_spi.c
@@ -5,7 +5,7 @@
  * Copyright (c) 2005-2008 Analog Devices Inc.
  * Copyright (C) 2010 Thomas Chou <thomas@wytron.com.tw>
  *
- * Licensed under the GPL-2 or later.
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
 #include <asm/io.h>
@@ -83,12 +83,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	altspi = malloc(sizeof(*altspi));
+	altspi = spi_alloc_slave(struct altera_spi_slave, bus, cs);
 	if (!altspi)
 		return NULL;
 
-	altspi->slave.bus = bus;
-	altspi->slave.cs = cs;
 	altspi->base = altera_spi_base_list[bus];
 	debug("%s: bus:%i cs:%i base:%lx\n", __func__,
 		bus, cs, altspi->base);
diff --git a/drivers/spi/andes_spi.c b/drivers/spi/andes_spi.c
index fdde139..82aed75 100644
--- a/drivers/spi/andes_spi.c
+++ b/drivers/spi/andes_spi.c
@@ -4,23 +4,7 @@
  * (C) Copyright 2011 Andes Technology
  * Macpaul Lin <macpaul@andestech.com>
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -53,12 +37,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	ds = malloc(sizeof(*ds));
+	ds = spi_alloc_slave(struct andes_spi_slave, bus, cs);
 	if (!ds)
 		return NULL;
 
-	ds->slave.bus = bus;
-	ds->slave.cs = cs;
 	ds->regs = (struct andes_spi_regs *)CONFIG_SYS_SPI_BASE;
 
 	/*
diff --git a/drivers/spi/andes_spi.h b/drivers/spi/andes_spi.h
index 844bdba..b7d2945 100644
--- a/drivers/spi/andes_spi.h
+++ b/drivers/spi/andes_spi.h
@@ -4,20 +4,7 @@
  * (C) Copyright 2011 Andes Technology
  * Macpaul Lin <macpaul@andestech.com>
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #ifndef __ANDES_SPI_H
diff --git a/drivers/spi/armada100_spi.c b/drivers/spi/armada100_spi.c
index 7384c9c..53aaf95 100644
--- a/drivers/spi/armada100_spi.c
+++ b/drivers/spi/armada100_spi.c
@@ -8,23 +8,7 @@
  * Based on SSP driver
  * Written-by: Lei Wen <leiwen@marvell.com>
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 
@@ -120,12 +104,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 {
 	struct armd_spi_slave *pss;
 
-	pss = malloc(sizeof(*pss));
+	pss = spi_alloc_slave(struct armd_spi_slave, bus, cs);
 	if (!pss)
 		return NULL;
 
-	pss->slave.bus = bus;
-	pss->slave.cs = cs;
 	pss->spi_reg = (struct ssp_reg *)SSP_REG_BASE(CONFIG_SYS_SSP_PORT);
 
 	pss->cr0 = SSCR0_MOTO | SSCR0_DATASIZE(DEFAULT_WORD_LEN) | SSCR0_SSE;
@@ -184,15 +166,8 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 		goto done;
 	}
 
-	if (dout)
-		pss->tx = dout;
-	else
-		pss->tx = NULL;
-
-	if (din)
-		pss->rx = din;
-	else
-		pss->rx = NULL;
+	pss->tx = dout;
+	pss->rx = din;
 
 	if (flags & SPI_XFER_BEGIN) {
 		spi_cs_activate(slave);
diff --git a/drivers/spi/atmel_dataflash_spi.c b/drivers/spi/atmel_dataflash_spi.c
index 363e07a..a2e9c00 100644
--- a/drivers/spi/atmel_dataflash_spi.c
+++ b/drivers/spi/atmel_dataflash_spi.c
@@ -2,21 +2,7 @@
  * Driver for ATMEL DataFlash support
  * Author : Hamid Ikdoumi (Atmel)
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- *
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 /*
@@ -116,33 +102,26 @@ void AT91F_SpiEnable(int cs)
 {
 	unsigned long mode;
 
+	mode = readl(ATMEL_BASE_SPI0 + AT91_SPI_MR);
+	mode &= ~AT91_SPI_PCS;
+
 	switch (cs) {
-	case 0:	/* Configure SPI CS0 for Serial DataFlash AT45DBxx */
-		mode = readl(ATMEL_BASE_SPI0 + AT91_SPI_MR);
-		mode &= 0xFFF0FFFF;
-		writel(mode | ((AT91_SPI_PCS0_DATAFLASH_CARD<<16) & AT91_SPI_PCS),
-		       ATMEL_BASE_SPI0 + AT91_SPI_MR);
+	case 0:
+		mode |= AT91_SPI_PCS0_DATAFLASH_CARD << 16;
 		break;
-	case 1:	/* Configure SPI CS1 for Serial DataFlash AT45DBxx */
-		mode = readl(ATMEL_BASE_SPI0 + AT91_SPI_MR);
-		mode &= 0xFFF0FFFF;
-		writel(mode | ((AT91_SPI_PCS1_DATAFLASH_CARD<<16) & AT91_SPI_PCS),
-		       ATMEL_BASE_SPI0 + AT91_SPI_MR);
+	case 1:
+		mode |= AT91_SPI_PCS1_DATAFLASH_CARD << 16;
 		break;
-	case 2:	/* Configure SPI CS2 for Serial DataFlash AT45DBxx */
-		mode = readl(ATMEL_BASE_SPI0 + AT91_SPI_MR);
-		mode &= 0xFFF0FFFF;
-		writel(mode | ((AT91_SPI_PCS2_DATAFLASH_CARD<<16) & AT91_SPI_PCS),
-		       ATMEL_BASE_SPI0 + AT91_SPI_MR);
+	case 2:
+		mode |= AT91_SPI_PCS2_DATAFLASH_CARD << 16;
 		break;
 	case 3:
-		mode = readl(ATMEL_BASE_SPI0 + AT91_SPI_MR);
-		mode &= 0xFFF0FFFF;
-		writel(mode | ((AT91_SPI_PCS3_DATAFLASH_CARD<<16) & AT91_SPI_PCS),
-		       ATMEL_BASE_SPI0 + AT91_SPI_MR);
+		mode |= AT91_SPI_PCS3_DATAFLASH_CARD << 16;
 		break;
 	}
 
+	writel(mode, ATMEL_BASE_SPI0 + AT91_SPI_MR);
+
 	/* SPI_Enable */
 	writel(AT91_SPI_SPIEN, ATMEL_BASE_SPI0 + AT91_SPI_CR);
 }
diff --git a/drivers/spi/atmel_spi.c b/drivers/spi/atmel_spi.c
index ce7d460..ed6278b 100644
--- a/drivers/spi/atmel_spi.c
+++ b/drivers/spi/atmel_spi.c
@@ -1,23 +1,7 @@
 /*
  * Copyright (C) 2007 Atmel Corporation
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
 #include <spi.h>
@@ -30,6 +14,15 @@
 
 #include "atmel_spi.h"
 
+static int spi_has_wdrbt(struct atmel_spi_slave *slave)
+{
+	unsigned int ver;
+
+	ver = spi_readl(slave, VERSION);
+
+	return (ATMEL_SPI_VERSION_REV(ver) >= 0x210);
+}
+
 void spi_init()
 {
 
@@ -84,18 +77,16 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (mode & SPI_CPOL)
 		csrx |= ATMEL_SPI_CSRx_CPOL;
 
-	as = malloc(sizeof(struct atmel_spi_slave));
+	as = spi_alloc_slave(struct atmel_spi_slave, bus, cs);
 	if (!as)
 		return NULL;
 
-	as->slave.bus = bus;
-	as->slave.cs = cs;
 	as->regs = regs;
 	as->mr = ATMEL_SPI_MR_MSTR | ATMEL_SPI_MR_MODFDIS
-#if defined(CONFIG_AT91SAM9X5) || defined(CONFIG_AT91SAM9M10G45)
-			| ATMEL_SPI_MR_WDRBT
-#endif
 			| ATMEL_SPI_MR_PCS(~(1 << cs) & 0xf);
+	if (spi_has_wdrbt(as))
+		as->mr |= ATMEL_SPI_MR_WDRBT;
+
 	spi_writel(as, CSR(cs), csrx);
 
 	return &as->slave;
diff --git a/drivers/spi/atmel_spi.h b/drivers/spi/atmel_spi.h
index 057de9a..d240945 100644
--- a/drivers/spi/atmel_spi.h
+++ b/drivers/spi/atmel_spi.h
@@ -64,7 +64,7 @@
 #define ATMEL_SPI_CSRx_DLYBCT(x)	((x) << 24)
 
 /* Bits in VERSION */
-#define ATMEL_SPI_VERSION_REV(x)	((x) << 0)
+#define ATMEL_SPI_VERSION_REV(x)	((x) & 0xfff)
 #define ATMEL_SPI_VERSION_MFN(x)	((x) << 16)
 
 /* Constants for CSRx:BITS */
diff --git a/drivers/spi/bfin_spi.c b/drivers/spi/bfin_spi.c
index e080bec..71a31d0 100644
--- a/drivers/spi/bfin_spi.c
+++ b/drivers/spi/bfin_spi.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2005-2010 Analog Devices Inc.
  *
- * Licensed under the GPL-2 or later.
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 /*#define DEBUG*/
@@ -13,7 +13,7 @@
 #include <spi.h>
 
 #include <asm/blackfin.h>
-#include <asm/dma.h>
+#include <asm/clock.h>
 #include <asm/gpio.h>
 #include <asm/portmux.h>
 #include <asm/mach-common/bits/spi.h>
@@ -141,14 +141,12 @@ static const unsigned short cs_pins[][7] = {
 void spi_set_speed(struct spi_slave *slave, uint hz)
 {
 	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
-	ulong sclk;
+	ulong clk;
 	u32 baud;
 
-	sclk = get_sclk();
-	baud = sclk / (2 * hz);
+	clk = get_spi_clk();
 	/* baud should be rounded up */
-	if (sclk % (2 * hz))
-		baud += 1;
+	baud = DIV_ROUND_UP(clk, 2 * hz);
 	if (baud < 2)
 		baud = 2;
 	else if (baud > (u16)-1)
@@ -165,29 +163,28 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	if (bus >= ARRAY_SIZE(pins) || pins[bus] == NULL) {
-		debug("%s: invalid bus %u\n", __func__, bus);
-		return NULL;
-	}
 	switch (bus) {
 #ifdef SPI0_CTL
-		case 0: mmr_base = SPI0_CTL; break;
+	case 0:
+		mmr_base = SPI0_CTL; break;
 #endif
 #ifdef SPI1_CTL
-		case 1: mmr_base = SPI1_CTL; break;
+	case 1:
+		mmr_base = SPI1_CTL; break;
 #endif
 #ifdef SPI2_CTL
-		case 2: mmr_base = SPI2_CTL; break;
+	case 2:
+		mmr_base = SPI2_CTL; break;
 #endif
-		default: return NULL;
+	default:
+		debug("%s: invalid bus %u\n", __func__, bus);
+		return NULL;
 	}
 
-	bss = malloc(sizeof(*bss));
+	bss = spi_alloc_slave(struct bfin_spi_slave, bus, cs);
 	if (!bss)
 		return NULL;
 
-	bss->slave.bus = bus;
-	bss->slave.cs = cs;
 	bss->mmr_base = (void *)mmr_base;
 	bss->ctl = SPE | MSTR | TDBR_CORE;
 	if (mode & SPI_CPHA) bss->ctl |= CPHA;
@@ -244,109 +241,15 @@ void spi_release_bus(struct spi_slave *slave)
 	SSYNC();
 }
 
-#ifdef __ADSPBF54x__
-# define SPI_DMA_BASE DMA4_NEXT_DESC_PTR
-#elif defined(__ADSPBF533__) || defined(__ADSPBF532__) || defined(__ADSPBF531__) || \
-      defined(__ADSPBF538__) || defined(__ADSPBF539__)
-# define SPI_DMA_BASE DMA5_NEXT_DESC_PTR
-#elif defined(__ADSPBF561__)
-# define SPI_DMA_BASE DMA2_4_NEXT_DESC_PTR
-#elif defined(__ADSPBF537__) || defined(__ADSPBF536__) || defined(__ADSPBF534__) || \
-      defined(__ADSPBF52x__) || defined(__ADSPBF51x__)
-# define SPI_DMA_BASE DMA7_NEXT_DESC_PTR
-# elif defined(__ADSPBF50x__)
-# define SPI_DMA_BASE DMA6_NEXT_DESC_PTR
-#else
-# error "Please provide SPI DMA channel defines"
-#endif
-static volatile struct dma_register *dma = (void *)SPI_DMA_BASE;
-
 #ifndef CONFIG_BFIN_SPI_IDLE_VAL
 # define CONFIG_BFIN_SPI_IDLE_VAL 0xff
 #endif
 
-#ifdef CONFIG_BFIN_SPI_NO_DMA
-# define SPI_DMA 0
-#else
-# define SPI_DMA 1
-#endif
-
-static int spi_dma_xfer(struct bfin_spi_slave *bss, const u8 *tx, u8 *rx,
-			uint bytes)
-{
-	int ret = -1;
-	u16 ndsize, spi_config, dma_config;
-	struct dmasg dmasg[2];
-	const u8 *buf;
-
-	if (tx) {
-		debug("%s: doing half duplex TX\n", __func__);
-		buf = tx;
-		spi_config = TDBR_DMA;
-		dma_config = 0;
-	} else {
-		debug("%s: doing half duplex RX\n", __func__);
-		buf = rx;
-		spi_config = RDBR_DMA;
-		dma_config = WNR;
-	}
-
-	dmasg[0].start_addr = (unsigned long)buf;
-	dmasg[0].x_modify = 1;
-	dma_config |= WDSIZE_8 | DMAEN;
-	if (bytes <= 65536) {
-		blackfin_dcache_flush_invalidate_range(buf, buf + bytes);
-		ndsize = NDSIZE_5;
-		dmasg[0].cfg = NDSIZE_0 | dma_config | FLOW_STOP | DI_EN;
-		dmasg[0].x_count = bytes;
-	} else {
-		blackfin_dcache_flush_invalidate_range(buf, buf + 65536 - 1);
-		ndsize = NDSIZE_7;
-		dmasg[0].cfg = NDSIZE_5 | dma_config | FLOW_ARRAY | DMA2D;
-		dmasg[0].x_count = 0;	/* 2^16 */
-		dmasg[0].y_count = bytes >> 16;	/* count / 2^16 */
-		dmasg[0].y_modify = 1;
-		dmasg[1].start_addr = (unsigned long)(buf + (bytes & ~0xFFFF));
-		dmasg[1].cfg = NDSIZE_0 | dma_config | FLOW_STOP | DI_EN;
-		dmasg[1].x_count = bytes & 0xFFFF; /* count % 2^16 */
-		dmasg[1].x_modify = 1;
-	}
-
-	dma->cfg = 0;
-	dma->irq_status = DMA_DONE | DMA_ERR;
-	dma->curr_desc_ptr = dmasg;
-	write_SPI_CTL(bss, (bss->ctl & ~TDBR_CORE));
-	write_SPI_STAT(bss, -1);
-	SSYNC();
-
-	write_SPI_TDBR(bss, CONFIG_BFIN_SPI_IDLE_VAL);
-	dma->cfg = ndsize | FLOW_ARRAY | DMAEN;
-	write_SPI_CTL(bss, (bss->ctl & ~TDBR_CORE) | spi_config);
-	SSYNC();
-
-	/*
-	 * We already invalidated the first 64k,
-	 * now while we just wait invalidate the remaining part.
-	 * Its not likely that the DMA is going to overtake
-	 */
-	if (bytes > 65536)
-		blackfin_dcache_flush_invalidate_range(buf + 65536, buf + bytes);
-
-	while (!(dma->irq_status & DMA_DONE))
-		if (ctrlc())
-			goto done;
-
-	dma->cfg = 0;
-
-	ret = 0;
- done:
-	write_SPI_CTL(bss, bss->ctl);
-	return ret;
-}
-
 static int spi_pio_xfer(struct bfin_spi_slave *bss, const u8 *tx, u8 *rx,
 			uint bytes)
 {
+	/* discard invalid data and clear RXS */
+	read_SPI_RDBR(bss);
 	/* todo: take advantage of hardware fifos  */
 	while (bytes--) {
 		u8 value = (tx ? *tx++ : CONFIG_BFIN_SPI_IDLE_VAL);
@@ -395,11 +298,7 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	if (flags & SPI_XFER_BEGIN)
 		spi_cs_activate(slave);
 
-	/* TX DMA doesn't work quite right */
-	if (SPI_DMA && bytes > 6 && (!tx /*|| !rx*/))
-		ret = spi_dma_xfer(bss, tx, rx, bytes);
-	else
-		ret = spi_pio_xfer(bss, tx, rx, bytes);
+	ret = spi_pio_xfer(bss, tx, rx, bytes);
 
  done:
 	if (flags & SPI_XFER_END)
diff --git a/drivers/spi/bfin_spi6xx.c b/drivers/spi/bfin_spi6xx.c
new file mode 100644
index 0000000..eba01d1
--- /dev/null
+++ b/drivers/spi/bfin_spi6xx.c
@@ -0,0 +1,304 @@
+/*
+ * Analog Devices SPI3 controller driver
+ *
+ * Copyright (c) 2011 Analog Devices Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+
+#include <asm/blackfin.h>
+#include <asm/clock.h>
+#include <asm/gpio.h>
+#include <asm/portmux.h>
+#include <asm/mach-common/bits/spi6xx.h>
+
+struct bfin_spi_slave {
+	struct spi_slave slave;
+	u32 control, clock;
+	struct bfin_spi_regs *regs;
+	int cs_pol;
+};
+
+#define to_bfin_spi_slave(s) container_of(s, struct bfin_spi_slave, slave)
+
+#define gpio_cs(cs) ((cs) - MAX_CTRL_CS)
+#ifdef CONFIG_BFIN_SPI_GPIO_CS
+# define is_gpio_cs(cs) ((cs) > MAX_CTRL_CS)
+#else
+# define is_gpio_cs(cs) 0
+#endif
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (is_gpio_cs(cs))
+		return gpio_is_valid(gpio_cs(cs));
+	else
+		return (cs >= 1 && cs <= MAX_CTRL_CS);
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+
+	if (is_gpio_cs(slave->cs)) {
+		unsigned int cs = gpio_cs(slave->cs);
+		gpio_set_value(cs, bss->cs_pol);
+	} else {
+		u32 ssel;
+		ssel = bfin_read32(&bss->regs->ssel);
+		ssel |= 1 << slave->cs;
+		if (bss->cs_pol)
+			ssel |= (1 << 8) << slave->cs;
+		else
+			ssel &= ~((1 << 8) << slave->cs);
+		bfin_write32(&bss->regs->ssel, ssel);
+	}
+
+	SSYNC();
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+
+	if (is_gpio_cs(slave->cs)) {
+		unsigned int cs = gpio_cs(slave->cs);
+		gpio_set_value(cs, !bss->cs_pol);
+	} else {
+		u32 ssel;
+		ssel = bfin_read32(&bss->regs->ssel);
+		if (bss->cs_pol)
+			ssel &= ~((1 << 8) << slave->cs);
+		else
+			ssel |= (1 << 8) << slave->cs;
+		/* deassert cs */
+		bfin_write32(&bss->regs->ssel, ssel);
+		SSYNC();
+		/* disable cs */
+		ssel &= ~(1 << slave->cs);
+		bfin_write32(&bss->regs->ssel, ssel);
+	}
+
+	SSYNC();
+}
+
+void spi_init()
+{
+}
+
+#define SPI_PINS(n) \
+	{ 0, P_SPI##n##_SCK, P_SPI##n##_MISO, P_SPI##n##_MOSI, 0 }
+static unsigned short pins[][5] = {
+#ifdef SPI0_REGBASE
+	[0] = SPI_PINS(0),
+#endif
+#ifdef SPI1_REGBASE
+	[1] = SPI_PINS(1),
+#endif
+#ifdef SPI2_REGBASE
+	[2] = SPI_PINS(2),
+#endif
+};
+
+#define SPI_CS_PINS(n) \
+	{ \
+		P_SPI##n##_SSEL1, P_SPI##n##_SSEL2, P_SPI##n##_SSEL3, \
+		P_SPI##n##_SSEL4, P_SPI##n##_SSEL5, P_SPI##n##_SSEL6, \
+		P_SPI##n##_SSEL7, \
+	}
+static const unsigned short cs_pins[][7] = {
+#ifdef SPI0_REGBASE
+	[0] = SPI_CS_PINS(0),
+#endif
+#ifdef SPI1_REGBASE
+	[1] = SPI_CS_PINS(1),
+#endif
+#ifdef SPI2_REGBASE
+	[2] = SPI_CS_PINS(2),
+#endif
+};
+
+void spi_set_speed(struct spi_slave *slave, uint hz)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+	ulong clk;
+	u32 clock;
+
+	clk = get_spi_clk();
+	clock = clk / hz;
+	if (clock)
+		clock--;
+	bss->clock = clock;
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct bfin_spi_slave *bss;
+	u32 reg_base;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	switch (bus) {
+#ifdef SPI0_REGBASE
+	case 0:
+		reg_base = SPI0_REGBASE;
+		break;
+#endif
+#ifdef SPI1_REGBASE
+	case 1:
+		reg_base = SPI1_REGBASE;
+		break;
+#endif
+#ifdef SPI2_REGBASE
+	case 2:
+		reg_base = SPI2_REGBASE;
+		break;
+#endif
+	default:
+		debug("%s: invalid bus %u\n", __func__, bus);
+		return NULL;
+	}
+
+	bss = spi_alloc_slave(struct bfin_spi_slave, bus, cs);
+	if (!bss)
+		return NULL;
+
+	bss->regs = (struct bfin_spi_regs *)reg_base;
+	bss->control = SPI_CTL_EN | SPI_CTL_MSTR;
+	if (mode & SPI_CPHA)
+		bss->control |= SPI_CTL_CPHA;
+	if (mode & SPI_CPOL)
+		bss->control |= SPI_CTL_CPOL;
+	if (mode & SPI_LSB_FIRST)
+		bss->control |= SPI_CTL_LSBF;
+	bss->control &= ~SPI_CTL_ASSEL;
+	bss->cs_pol = mode & SPI_CS_HIGH ? 1 : 0;
+	spi_set_speed(&bss->slave, max_hz);
+
+	return &bss->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+	free(bss);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+
+	debug("%s: bus:%i cs:%i\n", __func__, slave->bus, slave->cs);
+
+	if (is_gpio_cs(slave->cs)) {
+		unsigned int cs = gpio_cs(slave->cs);
+		gpio_request(cs, "bfin-spi");
+		gpio_direction_output(cs, !bss->cs_pol);
+		pins[slave->bus][0] = P_DONTCARE;
+	} else
+		pins[slave->bus][0] = cs_pins[slave->bus][slave->cs - 1];
+	peripheral_request_list(pins[slave->bus], "bfin-spi");
+
+	bfin_write32(&bss->regs->control, bss->control);
+	bfin_write32(&bss->regs->clock, bss->clock);
+	bfin_write32(&bss->regs->delay, 0x0);
+	bfin_write32(&bss->regs->rx_control, SPI_RXCTL_REN);
+	bfin_write32(&bss->regs->tx_control, SPI_TXCTL_TEN | SPI_TXCTL_TTI);
+	SSYNC();
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+
+	debug("%s: bus:%i cs:%i\n", __func__, slave->bus, slave->cs);
+
+	peripheral_free_list(pins[slave->bus]);
+	if (is_gpio_cs(slave->cs))
+		gpio_free(gpio_cs(slave->cs));
+
+	bfin_write32(&bss->regs->rx_control, 0x0);
+	bfin_write32(&bss->regs->tx_control, 0x0);
+	bfin_write32(&bss->regs->control, 0x0);
+	SSYNC();
+}
+
+#ifndef CONFIG_BFIN_SPI_IDLE_VAL
+# define CONFIG_BFIN_SPI_IDLE_VAL 0xff
+#endif
+
+static int spi_pio_xfer(struct bfin_spi_slave *bss, const u8 *tx, u8 *rx,
+			uint bytes)
+{
+	/* discard invalid rx data and empty rfifo */
+	while (!(bfin_read32(&bss->regs->status) & SPI_STAT_RFE))
+		bfin_read32(&bss->regs->rfifo);
+
+	while (bytes--) {
+		u8 value = (tx ? *tx++ : CONFIG_BFIN_SPI_IDLE_VAL);
+		debug("%s: tx:%x ", __func__, value);
+		bfin_write32(&bss->regs->tfifo, value);
+		SSYNC();
+		while (bfin_read32(&bss->regs->status) & SPI_STAT_RFE)
+			if (ctrlc())
+				return -1;
+		value = bfin_read32(&bss->regs->rfifo);
+		if (rx)
+			*rx++ = value;
+		debug("rx:%x\n", value);
+	}
+
+	return 0;
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+	const u8 *tx = dout;
+	u8 *rx = din;
+	uint bytes = bitlen / 8;
+	int ret = 0;
+
+	debug("%s: bus:%i cs:%i bitlen:%i bytes:%i flags:%lx\n", __func__,
+		slave->bus, slave->cs, bitlen, bytes, flags);
+
+	if (bitlen == 0)
+		goto done;
+
+	/* we can only do 8 bit transfers */
+	if (bitlen % 8) {
+		flags |= SPI_XFER_END;
+		goto done;
+	}
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	ret = spi_pio_xfer(bss, tx, rx, bytes);
+
+ done:
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return ret;
+}
diff --git a/drivers/spi/cf_qspi.c b/drivers/spi/cf_qspi.c
index 72dd1a5..6b85633 100644
--- a/drivers/spi/cf_qspi.c
+++ b/drivers/spi/cf_qspi.c
@@ -5,26 +5,10 @@
  * This driver is written to transfer 8 bit at-a-time and uses the dedicated
  * SPI slave select pins as bit-banged GPIO to work with spi_flash subsystem.
  *
- *
  * Copyright (C) 2011 Ruggedcom, Inc.
  * Richard Retanubun (richardretanubun@freescale.com)
  *
- * See file CREDITS for list of people who contributed to this project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -120,13 +104,11 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	dev = malloc(sizeof(struct cf_qspi_slave));
+	dev = spi_alloc_slave(struct cf_qspi_slave, bus, cs);
 	if (!dev)
 		return NULL;
 
 	/* Initialize to known value */
-	dev->slave.bus = bus;
-	dev->slave.cs  = cs;
 	dev->regs      = (qspi_t *)MMAP_QSPI;
 	dev->qmr       = 0;
 	dev->qwr       = 0;
@@ -173,7 +155,7 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	volatile qspi_t *qspi = dev->regs;
 	u8 *txbuf = (u8 *)dout;
 	u8 *rxbuf = (u8 *)din;
-	u32 count = ((bitlen / 8) + (bitlen % 8 ? 1 : 0));
+	u32 count = DIV_ROUND_UP(bitlen, 8);
 	u32 n, i = 0;
 
 	/* Sanitize arguments */
diff --git a/drivers/spi/cf_spi.c b/drivers/spi/cf_spi.c
index a883da9..879a809 100644
--- a/drivers/spi/cf_spi.c
+++ b/drivers/spi/cf_spi.c
@@ -6,23 +6,7 @@
  * Copyright (C) 2004-2009 Freescale Semiconductor, Inc.
  * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -330,12 +314,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	cfslave = malloc(sizeof(struct cf_spi_slave));
+	cfslave = spi_alloc_slave(struct cf_spi_slave, bus, cs);
 	if (!cfslave)
 		return NULL;
 
-	cfslave->slave.bus = bus;
-	cfslave->slave.cs = cs;
 	cfslave->baudrate = max_hz;
 
 	/* specific setup */
diff --git a/drivers/spi/davinci_spi.c b/drivers/spi/davinci_spi.c
index 13aca52..0ec5b9d 100644
--- a/drivers/spi/davinci_spi.c
+++ b/drivers/spi/davinci_spi.c
@@ -6,23 +6,7 @@
  *
  * Copyright (C) 2007 Atmel Corporation
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
 #include <spi.h>
@@ -44,13 +28,31 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	ds = malloc(sizeof(*ds));
+	ds = spi_alloc_slave(struct davinci_spi_slave, bus, cs);
 	if (!ds)
 		return NULL;
 
 	ds->slave.bus = bus;
 	ds->slave.cs = cs;
-	ds->regs = (struct davinci_spi_regs *)CONFIG_SYS_SPI_BASE;
+
+	switch (bus) {
+	case SPI0_BUS:
+		ds->regs = (struct davinci_spi_regs *)SPI0_BASE;
+		break;
+#ifdef CONFIG_SYS_SPI1
+	case SPI1_BUS:
+		ds->regs = (struct davinci_spi_regs *)SPI1_BASE;
+		break;
+#endif
+#ifdef CONFIG_SYS_SPI2
+	case SPI2_BUS:
+		ds->regs = (struct davinci_spi_regs *)SPI2_BASE;
+		break;
+#endif
+	default: /* Invalid bus number */
+		return NULL;
+	}
+
 	ds->freq = max_hz;
 
 	return &ds->slave;
@@ -77,7 +79,7 @@ int spi_claim_bus(struct spi_slave *slave)
 	writel(SPIGCR1_MASTER_MASK | SPIGCR1_CLKMOD_MASK, &ds->regs->gcr1);
 
 	/* CS, CLK, SIMO and SOMI are functional pins */
-	writel((SPIPC0_EN0FUN_MASK | SPIPC0_CLKFUN_MASK |
+	writel(((1 << slave->cs) | SPIPC0_CLKFUN_MASK |
 		SPIPC0_DOFUN_MASK | SPIPC0_DIFUN_MASK), &ds->regs->pc0);
 
 	/* setup format */
@@ -282,7 +284,30 @@ out:
 
 int spi_cs_is_valid(unsigned int bus, unsigned int cs)
 {
-	return bus == 0 && cs == 0;
+	int ret = 0;
+
+	switch (bus) {
+	case SPI0_BUS:
+		if (cs < SPI0_NUM_CS)
+			ret = 1;
+		break;
+#ifdef CONFIG_SYS_SPI1
+	case SPI1_BUS:
+		if (cs < SPI1_NUM_CS)
+			ret = 1;
+		break;
+#endif
+#ifdef CONFIG_SYS_SPI2
+	case SPI2_BUS:
+		if (cs < SPI2_NUM_CS)
+			ret = 1;
+		break;
+#endif
+	default:
+		/* Invalid bus number. Do nothing */
+		break;
+	}
+	return ret;
 }
 
 void spi_cs_activate(struct spi_slave *slave)
diff --git a/drivers/spi/davinci_spi.h b/drivers/spi/davinci_spi.h
index 8d36a42..d4612d3 100644
--- a/drivers/spi/davinci_spi.h
+++ b/drivers/spi/davinci_spi.h
@@ -3,20 +3,7 @@
  *
  * Register definitions for the DaVinci SPI Controller
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #ifndef _DAVINCI_SPI_H_
@@ -87,6 +74,39 @@ struct davinci_spi_regs {
 /* SPIDEF */
 #define SPIDEF_CSDEF0_MASK	BIT(0)
 
+#define SPI0_BUS		0
+#define SPI0_BASE		CONFIG_SYS_SPI_BASE
+/*
+ * Define default SPI0_NUM_CS as 1 for existing platforms that uses this
+ * driver. Platform can configure number of CS using CONFIG_SYS_SPI0_NUM_CS
+ * if more than one CS is supported and by defining CONFIG_SYS_SPI0.
+ */
+#ifndef CONFIG_SYS_SPI0
+#define SPI0_NUM_CS		1
+#else
+#define SPI0_NUM_CS		CONFIG_SYS_SPI0_NUM_CS
+#endif
+
+/*
+ * define CONFIG_SYS_SPI1 when platform has spi-1 device (bus #1) and
+ * CONFIG_SYS_SPI1_NUM_CS defines number of CS on this bus
+ */
+#ifdef CONFIG_SYS_SPI1
+#define SPI1_BUS		1
+#define SPI1_NUM_CS		CONFIG_SYS_SPI1_NUM_CS
+#define SPI1_BASE		CONFIG_SYS_SPI1_BASE
+#endif
+
+/*
+ * define CONFIG_SYS_SPI2 when platform has spi-2 device (bus #2) and
+ * CONFIG_SYS_SPI2_NUM_CS defines number of CS on this bus
+ */
+#ifdef CONFIG_SYS_SPI2
+#define SPI2_BUS		2
+#define SPI2_NUM_CS		CONFIG_SYS_SPI2_NUM_CS
+#define SPI2_BASE		CONFIG_SYS_SPI2_BASE
+#endif
+
 struct davinci_spi_slave {
 	struct spi_slave slave;
 	struct davinci_spi_regs *regs;
diff --git a/drivers/spi/ep93xx_spi.c b/drivers/spi/ep93xx_spi.c
new file mode 100644
index 0000000..235557e
--- /dev/null
+++ b/drivers/spi/ep93xx_spi.c
@@ -0,0 +1,274 @@
+/*
+ * SPI Driver for EP93xx
+ *
+ * Copyright (C) 2013 Sergey Kostanabev <sergey.kostanbaev <at> fairwaves.ru>
+ *
+ * Inspired form linux kernel driver and atmel uboot driver
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <malloc.h>
+
+#include <asm/io.h>
+
+#include <asm/arch/ep93xx.h>
+
+
+#define BIT(x)			(1<<(x))
+#define SSPBASE			SPI_BASE
+
+#define SSPCR0			0x0000
+#define SSPCR0_MODE_SHIFT	6
+#define SSPCR0_SCR_SHIFT	8
+#define SSPCR0_SPH		BIT(7)
+#define SSPCR0_SPO		BIT(6)
+#define SSPCR0_FRF_SPI		0
+#define SSPCR0_DSS_8BIT		7
+
+#define SSPCR1			0x0004
+#define SSPCR1_RIE		BIT(0)
+#define SSPCR1_TIE		BIT(1)
+#define SSPCR1_RORIE		BIT(2)
+#define SSPCR1_LBM		BIT(3)
+#define SSPCR1_SSE		BIT(4)
+#define SSPCR1_MS		BIT(5)
+#define SSPCR1_SOD		BIT(6)
+
+#define SSPDR			0x0008
+
+#define SSPSR			0x000c
+#define SSPSR_TFE		BIT(0)
+#define SSPSR_TNF		BIT(1)
+#define SSPSR_RNE		BIT(2)
+#define SSPSR_RFF		BIT(3)
+#define SSPSR_BSY		BIT(4)
+#define SSPCPSR			0x0010
+
+#define SSPIIR			0x0014
+#define SSPIIR_RIS		BIT(0)
+#define SSPIIR_TIS		BIT(1)
+#define SSPIIR_RORIS		BIT(2)
+#define SSPICR			SSPIIR
+
+#define SSPCLOCK		14745600
+#define SSP_MAX_RATE		(SSPCLOCK / 2)
+#define SSP_MIN_RATE		(SSPCLOCK / (254 * 256))
+
+/* timeout in milliseconds */
+#define SPI_TIMEOUT		5
+/* maximum depth of RX/TX FIFO */
+#define SPI_FIFO_SIZE		8
+
+struct ep93xx_spi_slave {
+	struct spi_slave slave;
+
+	unsigned sspcr0;
+	unsigned sspcpsr;
+};
+
+static inline struct ep93xx_spi_slave *to_ep93xx_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct ep93xx_spi_slave, slave);
+}
+
+void spi_init()
+{
+}
+
+static inline void ep93xx_spi_write_u8(u16 reg, u8 value)
+{
+	writel(value, (unsigned int *)(SSPBASE + reg));
+}
+
+static inline u8 ep93xx_spi_read_u8(u16 reg)
+{
+	return readl((unsigned int *)(SSPBASE + reg));
+}
+
+static inline void ep93xx_spi_write_u16(u16 reg, u16 value)
+{
+	writel(value, (unsigned int *)(SSPBASE + reg));
+}
+
+static inline u16 ep93xx_spi_read_u16(u16 reg)
+{
+	return (u16)readl((unsigned int *)(SSPBASE + reg));
+}
+
+static int ep93xx_spi_init_hw(unsigned int rate, unsigned int mode,
+				struct ep93xx_spi_slave *slave)
+{
+	unsigned cpsr, scr;
+
+	if (rate > SSP_MAX_RATE)
+		rate = SSP_MAX_RATE;
+
+	if (rate < SSP_MIN_RATE)
+		return -1;
+
+	/* Calculate divisors so that we can get speed according the
+	 * following formula:
+	 *	rate = spi_clock_rate / (cpsr * (1 + scr))
+	 *
+	 * cpsr must be even number and starts from 2, scr can be any number
+	 * between 0 and 255.
+	 */
+	for (cpsr = 2; cpsr <= 254; cpsr += 2) {
+		for (scr = 0; scr <= 255; scr++) {
+			if ((SSPCLOCK / (cpsr * (scr + 1))) <= rate) {
+				/* Set CHPA and CPOL, SPI format and 8bit */
+				unsigned sspcr0 = (scr << SSPCR0_SCR_SHIFT) |
+					SSPCR0_FRF_SPI | SSPCR0_DSS_8BIT;
+				if (mode & SPI_CPHA)
+					sspcr0 |= SSPCR0_SPH;
+				if (mode & SPI_CPOL)
+					sspcr0 |= SSPCR0_SPO;
+
+				slave->sspcr0 = sspcr0;
+				slave->sspcpsr = cpsr;
+				return 0;
+			}
+		}
+	}
+
+	return -1;
+}
+
+void spi_set_speed(struct spi_slave *slave, unsigned int hz)
+{
+	struct ep93xx_spi_slave *as = to_ep93xx_spi(slave);
+
+	unsigned int mode = 0;
+	if (as->sspcr0 & SSPCR0_SPH)
+		mode |= SPI_CPHA;
+	if (as->sspcr0 & SSPCR0_SPO)
+		mode |= SPI_CPOL;
+
+	ep93xx_spi_init_hw(hz, mode, as);
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+			unsigned int max_hz, unsigned int mode)
+{
+	struct ep93xx_spi_slave	*as;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	as = spi_alloc_slave(struct ep93xx_spi_slave, bus, cs);
+	if (!as)
+		return NULL;
+
+	if (ep93xx_spi_init_hw(max_hz, mode, as)) {
+		free(as);
+		return NULL;
+	}
+
+	return &as->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct ep93xx_spi_slave *as = to_ep93xx_spi(slave);
+
+	free(as);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct ep93xx_spi_slave *as = to_ep93xx_spi(slave);
+
+	/* Enable the SPI hardware */
+	ep93xx_spi_write_u8(SSPCR1, SSPCR1_SSE);
+
+
+	ep93xx_spi_write_u8(SSPCPSR, as->sspcpsr);
+	ep93xx_spi_write_u16(SSPCR0, as->sspcr0);
+
+	debug("Select CS:%d SSPCPSR=%02x SSPCR0=%04x\n",
+	      slave->cs, as->sspcpsr, as->sspcr0);
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	/* Disable the SPI hardware */
+	ep93xx_spi_write_u8(SSPCR1, 0);
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+		const void *dout, void *din, unsigned long flags)
+{
+	unsigned int	len_tx;
+	unsigned int	len_rx;
+	unsigned int	len;
+	u32		status;
+	const u8	*txp = dout;
+	u8		*rxp = din;
+	u8		value;
+
+	debug("spi_xfer: slave %u:%u dout %p din %p bitlen %u\n",
+	      slave->bus, slave->cs, (uint *)dout, (uint *)din, bitlen);
+
+
+	if (bitlen == 0)
+		/* Finish any previously submitted transfers */
+		goto out;
+
+	if (bitlen % 8) {
+		/* Errors always terminate an ongoing transfer */
+		flags |= SPI_XFER_END;
+		goto out;
+	}
+
+	len = bitlen / 8;
+
+
+	if (flags & SPI_XFER_BEGIN) {
+		/* Empty RX FIFO */
+		while ((ep93xx_spi_read_u8(SSPSR) & SSPSR_RNE))
+			ep93xx_spi_read_u8(SSPDR);
+
+		spi_cs_activate(slave);
+	}
+
+	for (len_tx = 0, len_rx = 0; len_rx < len; ) {
+		status = ep93xx_spi_read_u8(SSPSR);
+
+		if ((len_tx < len) && (status & SSPSR_TNF)) {
+			if (txp)
+				value = *txp++;
+			else
+				value = 0xff;
+
+			ep93xx_spi_write_u8(SSPDR, value);
+			len_tx++;
+		}
+
+		if (status & SSPSR_RNE) {
+			value = ep93xx_spi_read_u8(SSPDR);
+
+			if (rxp)
+				*rxp++ = value;
+			len_rx++;
+		}
+	}
+
+out:
+	if (flags & SPI_XFER_END) {
+		/*
+		 * Wait until the transfer is completely done before
+		 * we deactivate CS.
+		 */
+		do {
+			status = ep93xx_spi_read_u8(SSPSR);
+		} while (status & SSPSR_BSY);
+
+		spi_cs_deactivate(slave);
+	}
+
+	return 0;
+}
diff --git a/drivers/spi/exynos_spi.c b/drivers/spi/exynos_spi.c
index be60ada..2969184 100644
--- a/drivers/spi/exynos_spi.c
+++ b/drivers/spi/exynos_spi.c
@@ -2,19 +2,7 @@
  * (C) Copyright 2012 SAMSUNG Electronics
  * Padmavathi Venna <padma.v@samsung.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -38,6 +26,7 @@ struct spi_bus {
 	struct exynos_spi *regs;
 	int inited;		/* 1 if this bus is ready for use */
 	int node;
+	uint deactivate_delay_us;	/* Delay to wait after deactivate */
 };
 
 /* A list of spi buses that we know about */
@@ -51,6 +40,9 @@ struct exynos_spi_slave {
 	unsigned int mode;
 	enum periph_id periph_id;	/* Peripheral ID for this device */
 	unsigned int fifo_size;
+	int skip_preamble;
+	struct spi_bus *bus;		/* Pointer to our SPI bus info */
+	ulong last_transaction_us;	/* Time of last transaction end */
 };
 
 static struct spi_bus *spi_get_bus(unsigned dev_index)
@@ -89,15 +81,14 @@ struct spi_slave *spi_setup_slave(unsigned int busnum, unsigned int cs,
 		return NULL;
 	}
 
-	spi_slave = malloc(sizeof(*spi_slave));
+	spi_slave = spi_alloc_slave(struct exynos_spi_slave, busnum, cs);
 	if (!spi_slave) {
 		debug("%s: Could not allocate spi_slave\n", __func__);
 		return NULL;
 	}
 
 	bus = &spi_bus[busnum];
-	spi_slave->slave.bus = busnum;
-	spi_slave->slave.cs = cs;
+	spi_slave->bus = bus;
 	spi_slave->regs = bus->regs;
 	spi_slave->mode = mode;
 	spi_slave->periph_id = bus->periph_id;
@@ -107,6 +98,9 @@ struct spi_slave *spi_setup_slave(unsigned int busnum, unsigned int cs,
 	else
 		spi_slave->fifo_size = 256;
 
+	spi_slave->skip_preamble = 0;
+	spi_slave->last_transaction_us = timer_get_us();
+
 	spi_slave->freq = bus->frequency;
 	if (max_hz)
 		spi_slave->freq = min(max_hz, spi_slave->freq);
@@ -210,55 +204,139 @@ static void spi_get_fifo_levels(struct exynos_spi *regs,
  *
  * @param regs	SPI peripheral registers
  * @param count	Number of bytes to transfer
+ * @param step	Number of bytes to transfer in each packet (1 or 4)
  */
-static void spi_request_bytes(struct exynos_spi *regs, int count)
+static void spi_request_bytes(struct exynos_spi *regs, int count, int step)
 {
+	/* For word address we need to swap bytes */
+	if (step == 4) {
+		setbits_le32(&regs->mode_cfg,
+			     SPI_MODE_CH_WIDTH_WORD | SPI_MODE_BUS_WIDTH_WORD);
+		count /= 4;
+		setbits_le32(&regs->swap_cfg, SPI_TX_SWAP_EN | SPI_RX_SWAP_EN |
+			SPI_TX_BYTE_SWAP | SPI_RX_BYTE_SWAP |
+			SPI_TX_HWORD_SWAP | SPI_RX_HWORD_SWAP);
+	} else {
+		/* Select byte access and clear the swap configuration */
+		clrbits_le32(&regs->mode_cfg,
+			     SPI_MODE_CH_WIDTH_WORD | SPI_MODE_BUS_WIDTH_WORD);
+		writel(0, &regs->swap_cfg);
+	}
+
 	assert(count && count < (1 << 16));
 	setbits_le32(&regs->ch_cfg, SPI_CH_RST);
 	clrbits_le32(&regs->ch_cfg, SPI_CH_RST);
+
 	writel(count | SPI_PACKET_CNT_EN, &regs->pkt_cnt);
 }
 
-static void spi_rx_tx(struct exynos_spi_slave *spi_slave, int todo,
-			void **dinp, void const **doutp)
+static int spi_rx_tx(struct exynos_spi_slave *spi_slave, int todo,
+			void **dinp, void const **doutp, unsigned long flags)
 {
 	struct exynos_spi *regs = spi_slave->regs;
 	uchar *rxp = *dinp;
 	const uchar *txp = *doutp;
 	int rx_lvl, tx_lvl;
 	uint out_bytes, in_bytes;
+	int toread;
+	unsigned start = get_timer(0);
+	int stopping;
+	int step;
 
 	out_bytes = in_bytes = todo;
 
+	stopping = spi_slave->skip_preamble && (flags & SPI_XFER_END) &&
+					!(spi_slave->mode & SPI_SLAVE);
+
+	/*
+	 * Try to transfer words if we can. This helps read performance at
+	 * SPI clock speeds above about 20MHz.
+	 */
+	step = 1;
+	if (!((todo | (uintptr_t)rxp | (uintptr_t)txp) & 3) &&
+	    !spi_slave->skip_preamble)
+		step = 4;
+
 	/*
 	 * If there's something to send, do a software reset and set a
 	 * transaction size.
 	 */
-	spi_request_bytes(regs, todo);
+	spi_request_bytes(regs, todo, step);
 
 	/*
 	 * Bytes are transmitted/received in pairs. Wait to receive all the
 	 * data because then transmission will be done as well.
 	 */
+	toread = in_bytes;
+
 	while (in_bytes) {
 		int temp;
 
 		/* Keep the fifos full/empty. */
 		spi_get_fifo_levels(regs, &rx_lvl, &tx_lvl);
-		if (tx_lvl < spi_slave->fifo_size && out_bytes) {
-			temp = txp ? *txp++ : 0xff;
+
+		/*
+		 * Don't completely fill the txfifo, since we don't want our
+		 * rxfifo to overflow, and it may already contain data.
+		 */
+		while (tx_lvl < spi_slave->fifo_size/2 && out_bytes) {
+			if (!txp)
+				temp = -1;
+			else if (step == 4)
+				temp = *(uint32_t *)txp;
+			else
+				temp = *txp;
 			writel(temp, &regs->tx_data);
-			out_bytes--;
+			out_bytes -= step;
+			if (txp)
+				txp += step;
+			tx_lvl += step;
 		}
-		if (rx_lvl > 0 && in_bytes) {
-			temp = readl(&regs->rx_data);
-			if (rxp)
-				*rxp++ = temp;
-			in_bytes--;
+		if (rx_lvl >= step) {
+			while (rx_lvl >= step) {
+				temp = readl(&regs->rx_data);
+				if (spi_slave->skip_preamble) {
+					if (temp == SPI_PREAMBLE_END_BYTE) {
+						spi_slave->skip_preamble = 0;
+						stopping = 0;
+					}
+				} else {
+					if (rxp || stopping) {
+						if (step == 4)
+							*(uint32_t *)rxp = temp;
+						else
+							*rxp = temp;
+						rxp += step;
+					}
+					in_bytes -= step;
+				}
+				toread -= step;
+				rx_lvl -= step;
+			}
+		} else if (!toread) {
+			/*
+			 * We have run out of input data, but haven't read
+			 * enough bytes after the preamble yet. Read some more,
+			 * and make sure that we transmit dummy bytes too, to
+			 * keep things going.
+			 */
+			assert(!out_bytes);
+			out_bytes = in_bytes;
+			toread = in_bytes;
+			txp = NULL;
+			spi_request_bytes(regs, toread, step);
+		}
+		if (spi_slave->skip_preamble && get_timer(start) > 100) {
+			printf("SPI timeout: in_bytes=%d, out_bytes=%d, ",
+			       in_bytes, out_bytes);
+			return -1;
 		}
 	}
+
 	*dinp = rxp;
 	*doutp = txp;
+
+	return 0;
 }
 
 /**
@@ -278,6 +356,7 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	struct exynos_spi_slave *spi_slave = to_exynos_spi(slave);
 	int upto, todo;
 	int bytelen;
+	int ret = 0;
 
 	/* spi core configured to do 8 bit transfers */
 	if (bitlen % 8) {
@@ -289,18 +368,30 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	if ((flags & SPI_XFER_BEGIN))
 		spi_cs_activate(slave);
 
-	/* Exynos SPI limits each transfer to 65535 bytes */
+	/*
+	 * Exynos SPI limits each transfer to 65535 transfers. To keep
+	 * things simple, allow a maximum of 65532 bytes. We could allow
+	 * more in word mode, but the performance difference is small.
+	 */
 	bytelen =  bitlen / 8;
-	for (upto = 0; upto < bytelen; upto += todo) {
-		todo = min(bytelen - upto, (1 << 16) - 1);
-		spi_rx_tx(spi_slave, todo, &din, &dout);
+	for (upto = 0; !ret && upto < bytelen; upto += todo) {
+		todo = min(bytelen - upto, (1 << 16) - 4);
+		ret = spi_rx_tx(spi_slave, todo, &din, &dout, flags);
+		if (ret)
+			break;
 	}
 
 	/* Stop the transaction, if necessary. */
-	if ((flags & SPI_XFER_END))
+	if ((flags & SPI_XFER_END) && !(spi_slave->mode & SPI_SLAVE)) {
 		spi_cs_deactivate(slave);
+		if (spi_slave->skip_preamble) {
+			assert(!spi_slave->skip_preamble);
+			debug("Failed to complete premable transaction\n");
+			ret = -1;
+		}
+	}
 
-	return 0;
+	return ret;
 }
 
 /**
@@ -325,8 +416,18 @@ void spi_cs_activate(struct spi_slave *slave)
 {
 	struct exynos_spi_slave *spi_slave = to_exynos_spi(slave);
 
+	/* If it's too soon to do another transaction, wait */
+	if (spi_slave->bus->deactivate_delay_us &&
+	    spi_slave->last_transaction_us) {
+		ulong delay_us;		/* The delay completed so far */
+		delay_us = timer_get_us() - spi_slave->last_transaction_us;
+		if (delay_us < spi_slave->bus->deactivate_delay_us)
+			udelay(spi_slave->bus->deactivate_delay_us - delay_us);
+	}
+
 	clrbits_le32(&spi_slave->regs->cs_reg, SPI_SLAVE_SIG_INACT);
 	debug("Activate CS, bus %d\n", spi_slave->slave.bus);
+	spi_slave->skip_preamble = spi_slave->mode & SPI_PREAMBLE;
 }
 
 /**
@@ -340,6 +441,11 @@ void spi_cs_deactivate(struct spi_slave *slave)
 	struct exynos_spi_slave *spi_slave = to_exynos_spi(slave);
 
 	setbits_le32(&spi_slave->regs->cs_reg, SPI_SLAVE_SIG_INACT);
+
+	/* Remember time of this transaction so we can honour the bus delay */
+	if (spi_slave->bus->deactivate_delay_us)
+		spi_slave->last_transaction_us = timer_get_us();
+
 	debug("Deactivate CS, bus %d\n", spi_slave->slave.bus);
 }
 
@@ -360,6 +466,7 @@ static inline struct exynos_spi *get_spi_base(int dev_index)
  * @param bus   SPI bus structure to fill with information
  * @return 0 if ok, or -FDT_ERR_NOTFOUND if something was missing
  */
+#ifdef CONFIG_OF_CONTROL
 static int spi_get_config(const void *blob, int node, struct spi_bus *bus)
 {
 	bus->node = node;
@@ -375,6 +482,8 @@ static int spi_get_config(const void *blob, int node, struct spi_bus *bus)
 	/* Use 500KHz as a suitable default */
 	bus->frequency = fdtdec_get_int(blob, node, "spi-max-frequency",
 					500000);
+	bus->deactivate_delay_us = fdtdec_get_int(blob, node,
+					"spi-deactivate-delay", 0);
 
 	return 0;
 }
@@ -415,6 +524,29 @@ static int process_nodes(const void *blob, int node_list[], int count)
 
 	return 0;
 }
+#endif
+
+/**
+ * Set up a new SPI slave for an fdt node
+ *
+ * @param blob		Device tree blob
+ * @param node		SPI peripheral node to use
+ * @return 0 if ok, -1 on error
+ */
+struct spi_slave *spi_setup_slave_fdt(const void *blob, int slave_node,
+				      int spi_node)
+{
+	struct spi_bus *bus;
+	unsigned int i;
+
+	for (i = 0, bus = spi_bus; i < bus_count; i++, bus++) {
+		if (bus->node == spi_node)
+			return spi_base_setup_slave_fdt(blob, i, slave_node);
+	}
+
+	debug("%s: Failed to find bus node %d\n", __func__, spi_node);
+	return NULL;
+}
 
 /* Sadly there is no error return from this function */
 void spi_init(void)
diff --git a/drivers/spi/fdt_spi.c b/drivers/spi/fdt_spi.c
new file mode 100644
index 0000000..58f139a
--- /dev/null
+++ b/drivers/spi/fdt_spi.c
@@ -0,0 +1,186 @@
+/*
+ * Common fdt based SPI driver front end
+ *
+ * Copyright (c) 2013 NVIDIA Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch-tegra/clk_rst.h>
+#include <asm/arch-tegra20/tegra20_sflash.h>
+#include <asm/arch-tegra20/tegra20_slink.h>
+#include <asm/arch-tegra114/tegra114_spi.h>
+#include <spi.h>
+#include <fdtdec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct fdt_spi_driver {
+	int compat;
+	int max_ctrls;
+	int (*init)(int *node_list, int count);
+	int (*claim_bus)(struct spi_slave *slave);
+	int (*release_bus)(struct spi_slave *slave);
+	int (*cs_is_valid)(unsigned int bus, unsigned int cs);
+	struct spi_slave *(*setup_slave)(unsigned int bus, unsigned int cs,
+					unsigned int max_hz, unsigned int mode);
+	void (*free_slave)(struct spi_slave *slave);
+	void (*cs_activate)(struct spi_slave *slave);
+	void (*cs_deactivate)(struct spi_slave *slave);
+	int (*xfer)(struct spi_slave *slave, unsigned int bitlen,
+		    const void *data_out, void *data_in, unsigned long flags);
+};
+
+static struct fdt_spi_driver fdt_spi_drivers[] = {
+#ifdef CONFIG_TEGRA20_SFLASH
+	{
+		.compat		= COMPAT_NVIDIA_TEGRA20_SFLASH,
+		.max_ctrls	= 1,
+		.init		= tegra20_spi_init,
+		.claim_bus	= tegra20_spi_claim_bus,
+		.cs_is_valid	= tegra20_spi_cs_is_valid,
+		.setup_slave	= tegra20_spi_setup_slave,
+		.free_slave	= tegra20_spi_free_slave,
+		.cs_activate	= tegra20_spi_cs_activate,
+		.cs_deactivate	= tegra20_spi_cs_deactivate,
+		.xfer		= tegra20_spi_xfer,
+	},
+#endif
+#ifdef CONFIG_TEGRA20_SLINK
+	{
+		.compat		= COMPAT_NVIDIA_TEGRA20_SLINK,
+		.max_ctrls	= CONFIG_TEGRA_SLINK_CTRLS,
+		.init		= tegra30_spi_init,
+		.claim_bus	= tegra30_spi_claim_bus,
+		.cs_is_valid	= tegra30_spi_cs_is_valid,
+		.setup_slave	= tegra30_spi_setup_slave,
+		.free_slave	= tegra30_spi_free_slave,
+		.cs_activate	= tegra30_spi_cs_activate,
+		.cs_deactivate	= tegra30_spi_cs_deactivate,
+		.xfer		= tegra30_spi_xfer,
+	},
+#endif
+#ifdef CONFIG_TEGRA114_SPI
+	{
+		.compat		= COMPAT_NVIDIA_TEGRA114_SPI,
+		.max_ctrls	= CONFIG_TEGRA114_SPI_CTRLS,
+		.init		= tegra114_spi_init,
+		.claim_bus	= tegra114_spi_claim_bus,
+		.cs_is_valid	= tegra114_spi_cs_is_valid,
+		.setup_slave	= tegra114_spi_setup_slave,
+		.free_slave	= tegra114_spi_free_slave,
+		.cs_activate	= tegra114_spi_cs_activate,
+		.cs_deactivate	= tegra114_spi_cs_deactivate,
+		.xfer		= tegra114_spi_xfer,
+	},
+#endif
+};
+
+static struct fdt_spi_driver *driver;
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (!driver)
+		return 0;
+	else if (!driver->cs_is_valid)
+		return 1;
+	else
+		return driver->cs_is_valid(bus, cs);
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	if (!driver || !driver->setup_slave)
+		return NULL;
+
+	return driver->setup_slave(bus, cs, max_hz, mode);
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	if (driver && driver->free_slave)
+		return driver->free_slave(slave);
+}
+
+static int spi_init_driver(struct fdt_spi_driver *driver)
+{
+	int count;
+	int node_list[driver->max_ctrls];
+
+	count = fdtdec_find_aliases_for_id(gd->fdt_blob, "spi",
+					   driver->compat,
+					   node_list,
+					   driver->max_ctrls);
+	return driver->init(node_list, count);
+}
+
+void spi_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fdt_spi_drivers); i++) {
+		driver = &fdt_spi_drivers[i];
+		if (!spi_init_driver(driver))
+			break;
+	}
+	if (i == ARRAY_SIZE(fdt_spi_drivers))
+		driver = NULL;
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	if (!driver)
+		return 1;
+	if (!driver->claim_bus)
+		return 0;
+
+	return driver->claim_bus(slave);
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	if (driver && driver->release_bus)
+		driver->release_bus(slave);
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	if (driver && driver->cs_activate)
+		driver->cs_activate(slave);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	if (driver && driver->cs_deactivate)
+		driver->cs_deactivate(slave);
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+	     const void *data_out, void *data_in, unsigned long flags)
+{
+	if (!driver || !driver->xfer)
+		return -1;
+
+	return driver->xfer(slave, bitlen, data_out, data_in, flags);
+}
diff --git a/drivers/spi/fsl_espi.c b/drivers/spi/fsl_espi.c
index eb99e90..da51a82 100644
--- a/drivers/spi/fsl_espi.c
+++ b/drivers/spi/fsl_espi.c
@@ -4,20 +4,7 @@
  * Copyright 2010-2011 Freescale Semiconductor, Inc.
  * Author: Mingkai Hu (Mingkai.hu@freescale.com)
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -28,8 +15,10 @@
 
 struct fsl_spi_slave {
 	struct spi_slave slave;
+	ccsr_espi_t	*espi;
 	unsigned int	div16;
 	unsigned int	pm;
+	int		tx_timeout;
 	unsigned int	mode;
 	size_t		cmd_len;
 	u8		cmd_buf[16];
@@ -38,11 +27,17 @@ struct fsl_spi_slave {
 };
 
 #define to_fsl_spi_slave(s) container_of(s, struct fsl_spi_slave, slave)
+#define US_PER_SECOND		1000000UL
 
 #define ESPI_MAX_CS_NUM		4
+#define ESPI_FIFO_WIDTH_BIT	32
 
 #define ESPI_EV_RNE		(1 << 9)
 #define ESPI_EV_TNF		(1 << 8)
+#define ESPI_EV_DON		(1 << 14)
+#define ESPI_EV_TXE		(1 << 15)
+#define ESPI_EV_RFCNT_SHIFT	24
+#define ESPI_EV_RFCNT_MASK	(0x3f << ESPI_EV_RFCNT_SHIFT)
 
 #define ESPI_MODE_EN		(1 << 31)	/* Enable interface */
 #define ESPI_MODE_TXTHR(x)	((x) << 8)	/* Tx FIFO threshold */
@@ -74,23 +69,24 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	struct fsl_spi_slave *fsl;
 	sys_info_t sysinfo;
 	unsigned long spibrg = 0;
+	unsigned long spi_freq = 0;
 	unsigned char pm = 0;
 
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	fsl = malloc(sizeof(struct fsl_spi_slave));
+	fsl = spi_alloc_slave(struct fsl_spi_slave, bus, cs);
 	if (!fsl)
 		return NULL;
 
-	fsl->slave.bus = bus;
-	fsl->slave.cs = cs;
+	fsl->espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
 	fsl->mode = mode;
 	fsl->max_transfer_length = ESPI_MAX_DATA_TRANSFER_LEN;
 
 	/* Set eSPI BRG clock source */
 	get_sys_info(&sysinfo);
 	spibrg = sysinfo.freqSystemBus / 2;
+
 	fsl->div16 = 0;
 	if ((spibrg / max_hz) > 32) {
 		fsl->div16 = ESPI_CSMODE_DIV16;
@@ -102,10 +98,21 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 		}
 	} else
 		pm = spibrg / (max_hz * 2);
+
 	if (pm)
 		pm--;
+
 	fsl->pm = pm;
 
+	if (fsl->div16)
+		spi_freq = spibrg / ((pm + 1) * 2 * 16);
+	else
+		spi_freq = spibrg / ((pm + 1) * 2);
+
+	/* set tx_timeout to 10 times of one espi FIFO entry go out */
+	fsl->tx_timeout = DIV_ROUND_UP((US_PER_SECOND * ESPI_FIFO_WIDTH_BIT
+				* 10), spi_freq);
+
 	return &fsl->slave;
 }
 
@@ -117,13 +124,12 @@ void spi_free_slave(struct spi_slave *slave)
 
 void spi_init(void)
 {
-
 }
 
 int spi_claim_bus(struct spi_slave *slave)
 {
 	struct fsl_spi_slave *fsl = to_fsl_spi_slave(slave);
-	ccsr_espi_t *espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
+	ccsr_espi_t *espi = fsl->espi;
 	unsigned char pm = fsl->pm;
 	unsigned int cs = slave->cs;
 	unsigned int mode =  fsl->mode;
@@ -176,24 +182,86 @@ void spi_release_bus(struct spi_slave *slave)
 
 }
 
+static void fsl_espi_tx(struct fsl_spi_slave *fsl, const void *dout)
+{
+	ccsr_espi_t *espi = fsl->espi;
+	unsigned int tmpdout, event;
+	int tmp_tx_timeout;
+
+	if (dout)
+		tmpdout = *(u32 *)dout;
+	else
+		tmpdout = 0;
+
+	out_be32(&espi->tx, tmpdout);
+	out_be32(&espi->event, ESPI_EV_TNF);
+	debug("***spi_xfer:...%08x written\n", tmpdout);
+
+	tmp_tx_timeout = fsl->tx_timeout;
+	/* Wait for eSPI transmit to go out */
+	while (tmp_tx_timeout--) {
+		event = in_be32(&espi->event);
+		if (event & ESPI_EV_DON || event & ESPI_EV_TXE) {
+			out_be32(&espi->event, ESPI_EV_TXE);
+			break;
+		}
+		udelay(1);
+	}
+
+	if (tmp_tx_timeout < 0)
+		debug("***spi_xfer:...Tx timeout! event = %08x\n", event);
+}
+
+static int fsl_espi_rx(struct fsl_spi_slave *fsl, void *din, unsigned int bytes)
+{
+	ccsr_espi_t *espi = fsl->espi;
+	unsigned int tmpdin, rx_times;
+	unsigned char *buf, *p_cursor;
+
+	if (bytes <= 0)
+		return 0;
+
+	rx_times = DIV_ROUND_UP(bytes, 4);
+	buf = (unsigned char *)malloc(4 * rx_times);
+	if (!buf) {
+		debug("SF: Failed to malloc memory.\n");
+		return -1;
+	}
+	p_cursor = buf;
+	while (rx_times--) {
+		tmpdin = in_be32(&espi->rx);
+		debug("***spi_xfer:...%08x readed\n", tmpdin);
+		*(u32 *)p_cursor = tmpdin;
+		p_cursor += 4;
+	}
+
+	if (din)
+		memcpy(din, buf, bytes);
+
+	free(buf);
+	out_be32(&espi->event, ESPI_EV_RNE);
+
+	return bytes;
+}
+
 int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *data_out,
 		void *data_in, unsigned long flags)
 {
 	struct fsl_spi_slave *fsl = to_fsl_spi_slave(slave);
-	ccsr_espi_t *espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
-	unsigned int tmpdout, tmpdin, event;
+	ccsr_espi_t *espi = fsl->espi;
+	unsigned int event, rx_bytes;
 	const void *dout = NULL;
 	void *din = NULL;
 	int len = 0;
 	int num_blks, num_chunks, max_tran_len, tran_len;
 	int num_bytes;
-	unsigned char *ch;
 	unsigned char *buffer = NULL;
 	size_t buf_len;
 	u8 *cmd_buf = fsl->cmd_buf;
 	size_t cmd_len = fsl->cmd_len;
 	size_t data_len = bitlen / 8;
 	size_t rx_offset = 0;
+	int rf_cnt;
 
 	max_tran_len = fsl->max_transfer_length;
 	switch (flags) {
@@ -232,19 +300,16 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *data_out,
 		break;
 	}
 
-	debug("spi_xfer: slave %u:%u dout %08X(%p) din %08X(%p) len %u\n",
-	      slave->bus, slave->cs, *(uint *) dout,
-	      dout, *(uint *) din, din, len);
+	debug("spi_xfer: data_out %08X(%p) data_in %08X(%p) len %u\n",
+	      *(uint *)data_out, data_out, *(uint *)data_in, data_in, len);
 
-	num_chunks = data_len / max_tran_len +
-		(data_len % max_tran_len ? 1 : 0);
+	num_chunks = DIV_ROUND_UP(data_len, max_tran_len);
 	while (num_chunks--) {
 		if (data_in)
 			din = buffer + rx_offset;
 		dout = buffer;
 		tran_len = min(data_len , max_tran_len);
-		num_blks = (tran_len + cmd_len) / 4 +
-			((tran_len + cmd_len) % 4 ? 1 : 0);
+		num_blks = DIV_ROUND_UP(tran_len + cmd_len, 4);
 		num_bytes = (tran_len + cmd_len) % 4;
 		fsl->data_len = tran_len + cmd_len;
 		spi_cs_activate(slave);
@@ -252,41 +317,34 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *data_out,
 		/* Clear all eSPI events */
 		out_be32(&espi->event , 0xffffffff);
 		/* handle data in 32-bit chunks */
-		while (num_blks--) {
-
+		while (num_blks) {
 			event = in_be32(&espi->event);
 			if (event & ESPI_EV_TNF) {
-				tmpdout = *(u32 *)dout;
-
+				fsl_espi_tx(fsl, dout);
 				/* Set up the next iteration */
 				if (len > 4) {
 					len -= 4;
 					dout += 4;
 				}
-
-				out_be32(&espi->tx, tmpdout);
-				out_be32(&espi->event, ESPI_EV_TNF);
-				debug("***spi_xfer:...%08x written\n", tmpdout);
 			}
 
-			/* Wait for eSPI transmit to get out */
-			udelay(80);
-
 			event = in_be32(&espi->event);
 			if (event & ESPI_EV_RNE) {
-				tmpdin = in_be32(&espi->rx);
-				if (num_blks == 0 && num_bytes != 0) {
-					ch = (unsigned char *)&tmpdin;
-					while (num_bytes--)
-						*(unsigned char *)din++ = *ch++;
-				} else {
-					*(u32 *) din = tmpdin;
-					din += 4;
+				rf_cnt = ((event & ESPI_EV_RFCNT_MASK)
+						>> ESPI_EV_RFCNT_SHIFT);
+				if (rf_cnt >= 4)
+					rx_bytes = 4;
+				else if (num_blks == 1 && rf_cnt == num_bytes)
+					rx_bytes = num_bytes;
+				else
+					continue;
+				if (fsl_espi_rx(fsl, din, rx_bytes)
+						== rx_bytes) {
+					num_blks--;
+					if (din)
+						din = (unsigned char *)din
+							+ rx_bytes;
 				}
-
-				out_be32(&espi->event, in_be32(&espi->event)
-						| ESPI_EV_RNE);
-				debug("***spi_xfer:...%08x readed\n", tmpdin);
 			}
 		}
 		if (data_in) {
@@ -312,7 +370,7 @@ int spi_cs_is_valid(unsigned int bus, unsigned int cs)
 void spi_cs_activate(struct spi_slave *slave)
 {
 	struct fsl_spi_slave *fsl = to_fsl_spi_slave(slave);
-	ccsr_espi_t *espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
+	ccsr_espi_t *espi = fsl->espi;
 	unsigned int com = 0;
 	size_t data_len = fsl->data_len;
 
@@ -324,7 +382,8 @@ void spi_cs_activate(struct spi_slave *slave)
 
 void spi_cs_deactivate(struct spi_slave *slave)
 {
-	ccsr_espi_t *espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
+	struct fsl_spi_slave *fsl = to_fsl_spi_slave(slave);
+	ccsr_espi_t *espi = fsl->espi;
 
 	/* clear the RXCNT and TXCNT */
 	out_be32(&espi->mode, in_be32(&espi->mode) & (~ESPI_MODE_EN));
diff --git a/drivers/spi/fsl_qspi.c b/drivers/spi/fsl_qspi.c
new file mode 100644
index 0000000..ba20bef
--- /dev/null
+++ b/drivers/spi/fsl_qspi.c
@@ -0,0 +1,482 @@
+/*
+ * Copyright 2013-2014 Freescale Semiconductor, Inc.
+ *
+ * Freescale Quad Serial Peripheral Interface (QSPI) driver
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include "fsl_qspi.h"
+
+#define RX_BUFFER_SIZE		0x80
+#define TX_BUFFER_SIZE		0x40
+
+#define OFFSET_BITS_MASK	0x00ffffff
+
+#define FLASH_STATUS_WEL	0x02
+
+/* SEQID */
+#define SEQID_WREN		1
+#define SEQID_FAST_READ		2
+#define SEQID_RDSR		3
+#define SEQID_SE		4
+#define SEQID_CHIP_ERASE	5
+#define SEQID_PP		6
+#define SEQID_RDID		7
+
+/* Flash opcodes */
+#define OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define OPCODE_RDSR		0x05	/* Read status register */
+#define OPCODE_WREN		0x06	/* Write enable */
+#define OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define OPCODE_RDID		0x9f	/* Read JEDEC ID */
+
+/* 4-byte address opcodes - used on Spansion and some Macronix flashes */
+#define OPCODE_FAST_READ_4B	0x0c    /* Read data bytes (high frequency) */
+#define OPCODE_PP_4B		0x12    /* Page program (up to 256 bytes) */
+#define OPCODE_SE_4B		0xdc    /* Sector erase (usually 64KiB) */
+
+#ifdef CONFIG_SYS_FSL_QSPI_LE
+#define qspi_read32		in_le32
+#define qspi_write32		out_le32
+#elif defined(CONFIG_SYS_FSL_QSPI_BE)
+#define qspi_read32		in_be32
+#define qspi_write32		out_be32
+#endif
+
+static unsigned long spi_bases[] = {
+	QSPI0_BASE_ADDR,
+};
+
+static unsigned long amba_bases[] = {
+	QSPI0_AMBA_BASE,
+};
+
+struct fsl_qspi {
+	struct spi_slave slave;
+	unsigned long reg_base;
+	unsigned long amba_base;
+	u32 sf_addr;
+	u8 cur_seqid;
+};
+
+/* QSPI support swapping the flash read/write data
+ * in hardware for LS102xA, but not for VF610 */
+static inline u32 qspi_endian_xchg(u32 data)
+{
+#ifdef CONFIG_VF610
+	return swab32(data);
+#else
+	return data;
+#endif
+}
+
+static inline struct fsl_qspi *to_qspi_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct fsl_qspi, slave);
+}
+
+static void qspi_set_lut(struct fsl_qspi *qspi)
+{
+	struct fsl_qspi_regs *regs = (struct fsl_qspi_regs *)qspi->reg_base;
+	u32 lut_base;
+
+	/* Unlock the LUT */
+	qspi_write32(&regs->lutkey, LUT_KEY_VALUE);
+	qspi_write32(&regs->lckcr, QSPI_LCKCR_UNLOCK);
+
+	/* Write Enable */
+	lut_base = SEQID_WREN * 4;
+	qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_WREN) |
+		PAD0(LUT_PAD1) | INSTR0(LUT_CMD));
+	qspi_write32(&regs->lut[lut_base + 1], 0);
+	qspi_write32(&regs->lut[lut_base + 2], 0);
+	qspi_write32(&regs->lut[lut_base + 3], 0);
+
+	/* Fast Read */
+	lut_base = SEQID_FAST_READ * 4;
+	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
+		qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_FAST_READ) |
+			PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
+			PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
+	else
+		qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_FAST_READ_4B) |
+			PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR32BIT) |
+			PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
+	qspi_write32(&regs->lut[lut_base + 1], OPRND0(8) | PAD0(LUT_PAD1) |
+		INSTR0(LUT_DUMMY) | OPRND1(RX_BUFFER_SIZE) | PAD1(LUT_PAD1) |
+		INSTR1(LUT_READ));
+	qspi_write32(&regs->lut[lut_base + 2], 0);
+	qspi_write32(&regs->lut[lut_base + 3], 0);
+
+	/* Read Status */
+	lut_base = SEQID_RDSR * 4;
+	qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_RDSR) |
+		PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
+		PAD1(LUT_PAD1) | INSTR1(LUT_READ));
+	qspi_write32(&regs->lut[lut_base + 1], 0);
+	qspi_write32(&regs->lut[lut_base + 2], 0);
+	qspi_write32(&regs->lut[lut_base + 3], 0);
+
+	/* Erase a sector */
+	lut_base = SEQID_SE * 4;
+	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
+		qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_SE) |
+			PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
+			PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
+	else
+		qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_SE_4B) |
+			PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR32BIT) |
+			PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
+	qspi_write32(&regs->lut[lut_base + 1], 0);
+	qspi_write32(&regs->lut[lut_base + 2], 0);
+	qspi_write32(&regs->lut[lut_base + 3], 0);
+
+	/* Erase the whole chip */
+	lut_base = SEQID_CHIP_ERASE * 4;
+	qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_CHIP_ERASE) |
+		PAD0(LUT_PAD1) | INSTR0(LUT_CMD));
+	qspi_write32(&regs->lut[lut_base + 1], 0);
+	qspi_write32(&regs->lut[lut_base + 2], 0);
+	qspi_write32(&regs->lut[lut_base + 3], 0);
+
+	/* Page Program */
+	lut_base = SEQID_PP * 4;
+	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
+		qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_PP) |
+			PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
+			PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
+	else
+		qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_PP_4B) |
+			PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR32BIT) |
+			PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
+	qspi_write32(&regs->lut[lut_base + 1], OPRND0(TX_BUFFER_SIZE) |
+		PAD0(LUT_PAD1) | INSTR0(LUT_WRITE));
+	qspi_write32(&regs->lut[lut_base + 2], 0);
+	qspi_write32(&regs->lut[lut_base + 3], 0);
+
+	/* READ ID */
+	lut_base = SEQID_RDID * 4;
+	qspi_write32(&regs->lut[lut_base], OPRND0(OPCODE_RDID) |
+		PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(8) |
+		PAD1(LUT_PAD1) | INSTR1(LUT_READ));
+	qspi_write32(&regs->lut[lut_base + 1], 0);
+	qspi_write32(&regs->lut[lut_base + 2], 0);
+	qspi_write32(&regs->lut[lut_base + 3], 0);
+
+	/* Lock the LUT */
+	qspi_write32(&regs->lutkey, LUT_KEY_VALUE);
+	qspi_write32(&regs->lckcr, QSPI_LCKCR_LOCK);
+}
+
+void spi_init()
+{
+	/* do nothing */
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct fsl_qspi *qspi;
+	struct fsl_qspi_regs *regs;
+	u32 reg_val, smpr_val;
+	u32 total_size, seq_id;
+
+	if (bus >= ARRAY_SIZE(spi_bases))
+		return NULL;
+
+	qspi = spi_alloc_slave(struct fsl_qspi, bus, cs);
+	if (!qspi)
+		return NULL;
+
+	qspi->reg_base = spi_bases[bus];
+	qspi->amba_base = amba_bases[bus];
+
+	qspi->slave.max_write_size = TX_BUFFER_SIZE;
+
+	regs = (struct fsl_qspi_regs *)qspi->reg_base;
+	qspi_write32(&regs->mcr, QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK);
+
+	smpr_val = qspi_read32(&regs->smpr);
+	qspi_write32(&regs->smpr, smpr_val & ~(QSPI_SMPR_FSDLY_MASK |
+		QSPI_SMPR_FSPHS_MASK | QSPI_SMPR_HSENA_MASK));
+	qspi_write32(&regs->mcr, QSPI_MCR_RESERVED_MASK);
+
+	total_size = FSL_QSPI_FLASH_SIZE * FSL_QSPI_FLASH_NUM;
+	qspi_write32(&regs->sfa1ad, FSL_QSPI_FLASH_SIZE | qspi->amba_base);
+	qspi_write32(&regs->sfa2ad, FSL_QSPI_FLASH_SIZE | qspi->amba_base);
+	qspi_write32(&regs->sfb1ad, total_size | qspi->amba_base);
+	qspi_write32(&regs->sfb2ad, total_size | qspi->amba_base);
+
+	qspi_set_lut(qspi);
+
+	smpr_val = qspi_read32(&regs->smpr);
+	smpr_val &= ~QSPI_SMPR_DDRSMP_MASK;
+	qspi_write32(&regs->smpr, smpr_val);
+	qspi_write32(&regs->mcr, QSPI_MCR_RESERVED_MASK);
+
+	seq_id = 0;
+	reg_val = qspi_read32(&regs->bfgencr);
+	reg_val &= ~QSPI_BFGENCR_SEQID_MASK;
+	reg_val |= (seq_id << QSPI_BFGENCR_SEQID_SHIFT);
+	reg_val &= ~QSPI_BFGENCR_PAR_EN_MASK;
+	qspi_write32(&regs->bfgencr, reg_val);
+
+	return &qspi->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct fsl_qspi *qspi = to_qspi_spi(slave);
+
+	free(qspi);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	return 0;
+}
+
+static void qspi_op_rdid(struct fsl_qspi *qspi, u32 *rxbuf, u32 len)
+{
+	struct fsl_qspi_regs *regs = (struct fsl_qspi_regs *)qspi->reg_base;
+	u32 mcr_reg, rbsr_reg, data;
+	int i, size;
+
+	mcr_reg = qspi_read32(&regs->mcr);
+	qspi_write32(&regs->mcr, QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+		QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
+	qspi_write32(&regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
+
+	qspi_write32(&regs->sfar, qspi->amba_base);
+
+	qspi_write32(&regs->ipcr, (SEQID_RDID << QSPI_IPCR_SEQID_SHIFT) | 0);
+	while (qspi_read32(&regs->sr) & QSPI_SR_BUSY_MASK)
+		;
+
+	i = 0;
+	size = len;
+	while ((RX_BUFFER_SIZE >= size) && (size > 0)) {
+		rbsr_reg = qspi_read32(&regs->rbsr);
+		if (rbsr_reg & QSPI_RBSR_RDBFL_MASK) {
+			data = qspi_read32(&regs->rbdr[i]);
+			data = qspi_endian_xchg(data);
+			memcpy(rxbuf, &data, 4);
+			rxbuf++;
+			size -= 4;
+			i++;
+		}
+	}
+
+	qspi_write32(&regs->mcr, mcr_reg);
+}
+
+static void qspi_op_read(struct fsl_qspi *qspi, u32 *rxbuf, u32 len)
+{
+	struct fsl_qspi_regs *regs = (struct fsl_qspi_regs *)qspi->reg_base;
+	u32 mcr_reg, data;
+	int i, size;
+	u32 to_or_from;
+
+	mcr_reg = qspi_read32(&regs->mcr);
+	qspi_write32(&regs->mcr, QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+		QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
+	qspi_write32(&regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
+
+	to_or_from = qspi->sf_addr + qspi->amba_base;
+
+	while (len > 0) {
+		qspi_write32(&regs->sfar, to_or_from);
+
+		size = (len > RX_BUFFER_SIZE) ?
+			RX_BUFFER_SIZE : len;
+
+		qspi_write32(&regs->ipcr,
+			(SEQID_FAST_READ << QSPI_IPCR_SEQID_SHIFT) | size);
+		while (qspi_read32(&regs->sr) & QSPI_SR_BUSY_MASK)
+			;
+
+		to_or_from += size;
+		len -= size;
+
+		i = 0;
+		while ((RX_BUFFER_SIZE >= size) && (size > 0)) {
+			data = qspi_read32(&regs->rbdr[i]);
+			data = qspi_endian_xchg(data);
+			memcpy(rxbuf, &data, 4);
+			rxbuf++;
+			size -= 4;
+			i++;
+		}
+		qspi_write32(&regs->mcr, qspi_read32(&regs->mcr) |
+			QSPI_MCR_CLR_RXF_MASK);
+	}
+
+	qspi_write32(&regs->mcr, mcr_reg);
+}
+
+static void qspi_op_pp(struct fsl_qspi *qspi, u32 *txbuf, u32 len)
+{
+	struct fsl_qspi_regs *regs = (struct fsl_qspi_regs *)qspi->reg_base;
+	u32 mcr_reg, data, reg, status_reg;
+	int i, size, tx_size;
+	u32 to_or_from = 0;
+
+	mcr_reg = qspi_read32(&regs->mcr);
+	qspi_write32(&regs->mcr, QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+		QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
+	qspi_write32(&regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
+
+	status_reg = 0;
+	while ((status_reg & FLASH_STATUS_WEL) != FLASH_STATUS_WEL) {
+		qspi_write32(&regs->ipcr,
+			(SEQID_WREN << QSPI_IPCR_SEQID_SHIFT) | 0);
+		while (qspi_read32(&regs->sr) & QSPI_SR_BUSY_MASK)
+			;
+
+		qspi_write32(&regs->ipcr,
+			(SEQID_RDSR << QSPI_IPCR_SEQID_SHIFT) | 1);
+		while (qspi_read32(&regs->sr) & QSPI_SR_BUSY_MASK)
+			;
+
+		reg = qspi_read32(&regs->rbsr);
+		if (reg & QSPI_RBSR_RDBFL_MASK) {
+			status_reg = qspi_read32(&regs->rbdr[0]);
+			status_reg = qspi_endian_xchg(status_reg);
+		}
+		qspi_write32(&regs->mcr,
+			qspi_read32(&regs->mcr) | QSPI_MCR_CLR_RXF_MASK);
+	}
+
+	to_or_from = qspi->sf_addr + qspi->amba_base;
+	qspi_write32(&regs->sfar, to_or_from);
+
+	tx_size = (len > TX_BUFFER_SIZE) ?
+		TX_BUFFER_SIZE : len;
+
+	size = (tx_size + 3) / 4;
+
+	for (i = 0; i < size; i++) {
+		data = qspi_endian_xchg(*txbuf);
+		qspi_write32(&regs->tbdr, data);
+		txbuf++;
+	}
+
+	qspi_write32(&regs->ipcr,
+		(SEQID_PP << QSPI_IPCR_SEQID_SHIFT) | tx_size);
+	while (qspi_read32(&regs->sr) & QSPI_SR_BUSY_MASK)
+		;
+
+	qspi_write32(&regs->mcr, mcr_reg);
+}
+
+static void qspi_op_rdsr(struct fsl_qspi *qspi, u32 *rxbuf)
+{
+	struct fsl_qspi_regs *regs = (struct fsl_qspi_regs *)qspi->reg_base;
+	u32 mcr_reg, reg, data;
+
+	mcr_reg = qspi_read32(&regs->mcr);
+	qspi_write32(&regs->mcr, QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+		QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
+	qspi_write32(&regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
+
+	qspi_write32(&regs->sfar, qspi->amba_base);
+
+	qspi_write32(&regs->ipcr,
+		(SEQID_RDSR << QSPI_IPCR_SEQID_SHIFT) | 0);
+	while (qspi_read32(&regs->sr) & QSPI_SR_BUSY_MASK)
+		;
+
+	while (1) {
+		reg = qspi_read32(&regs->rbsr);
+		if (reg & QSPI_RBSR_RDBFL_MASK) {
+			data = qspi_read32(&regs->rbdr[0]);
+			data = qspi_endian_xchg(data);
+			memcpy(rxbuf, &data, 4);
+			qspi_write32(&regs->mcr, qspi_read32(&regs->mcr) |
+				QSPI_MCR_CLR_RXF_MASK);
+			break;
+		}
+	}
+
+	qspi_write32(&regs->mcr, mcr_reg);
+}
+
+static void qspi_op_se(struct fsl_qspi *qspi)
+{
+	struct fsl_qspi_regs *regs = (struct fsl_qspi_regs *)qspi->reg_base;
+	u32 mcr_reg;
+	u32 to_or_from = 0;
+
+	mcr_reg = qspi_read32(&regs->mcr);
+	qspi_write32(&regs->mcr, QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+		QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
+	qspi_write32(&regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
+
+	to_or_from = qspi->sf_addr + qspi->amba_base;
+	qspi_write32(&regs->sfar, to_or_from);
+
+	qspi_write32(&regs->ipcr,
+		(SEQID_WREN << QSPI_IPCR_SEQID_SHIFT) | 0);
+	while (qspi_read32(&regs->sr) & QSPI_SR_BUSY_MASK)
+		;
+
+	qspi_write32(&regs->ipcr,
+		(SEQID_SE << QSPI_IPCR_SEQID_SHIFT) | 0);
+	while (qspi_read32(&regs->sr) & QSPI_SR_BUSY_MASK)
+		;
+
+	qspi_write32(&regs->mcr, mcr_reg);
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+		const void *dout, void *din, unsigned long flags)
+{
+	struct fsl_qspi *qspi = to_qspi_spi(slave);
+	u32 bytes = DIV_ROUND_UP(bitlen, 8);
+	static u32 pp_sfaddr;
+	u32 txbuf;
+
+	if (dout) {
+		memcpy(&txbuf, dout, 4);
+		qspi->cur_seqid = *(u8 *)dout;
+
+		if (flags == SPI_XFER_END) {
+			qspi->sf_addr = pp_sfaddr;
+			qspi_op_pp(qspi, (u32 *)dout, bytes);
+			return 0;
+		}
+
+		if (qspi->cur_seqid == OPCODE_FAST_READ) {
+			qspi->sf_addr = swab32(txbuf) & OFFSET_BITS_MASK;
+		} else if (qspi->cur_seqid == OPCODE_SE) {
+			qspi->sf_addr = swab32(txbuf) & OFFSET_BITS_MASK;
+			qspi_op_se(qspi);
+		} else if (qspi->cur_seqid == OPCODE_PP) {
+			pp_sfaddr = swab32(txbuf) & OFFSET_BITS_MASK;
+		}
+	}
+
+	if (din) {
+		if (qspi->cur_seqid == OPCODE_FAST_READ)
+			qspi_op_read(qspi, din, bytes);
+		else if (qspi->cur_seqid == OPCODE_RDID)
+			qspi_op_rdid(qspi, din, bytes);
+		else if (qspi->cur_seqid == OPCODE_RDSR)
+			qspi_op_rdsr(qspi, din);
+	}
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	/* Nothing to do */
+}
diff --git a/drivers/spi/fsl_qspi.h b/drivers/spi/fsl_qspi.h
new file mode 100644
index 0000000..db400e6
--- /dev/null
+++ b/drivers/spi/fsl_qspi.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2013-2014 Freescale Semiconductor, Inc.
+ *
+ * Register definitions for Freescale QSPI
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _FSL_QSPI_H_
+#define _FSL_QSPI_H_
+
+struct fsl_qspi_regs {
+	u32 mcr;
+	u32 rsvd0[1];
+	u32 ipcr;
+	u32 flshcr;
+	u32 buf0cr;
+	u32 buf1cr;
+	u32 buf2cr;
+	u32 buf3cr;
+	u32 bfgencr;
+	u32 soccr;
+	u32 rsvd1[2];
+	u32 buf0ind;
+	u32 buf1ind;
+	u32 buf2ind;
+	u32 rsvd2[49];
+	u32 sfar;
+	u32 rsvd3[1];
+	u32 smpr;
+	u32 rbsr;
+	u32 rbct;
+	u32 rsvd4[15];
+	u32 tbsr;
+	u32 tbdr;
+	u32 rsvd5[1];
+	u32 sr;
+	u32 fr;
+	u32 rser;
+	u32 spndst;
+	u32 sptrclr;
+	u32 rsvd6[4];
+	u32 sfa1ad;
+	u32 sfa2ad;
+	u32 sfb1ad;
+	u32 sfb2ad;
+	u32 rsvd7[28];
+	u32 rbdr[32];
+	u32 rsvd8[32];
+	u32 lutkey;
+	u32 lckcr;
+	u32 rsvd9[2];
+	u32 lut[64];
+};
+
+#define QSPI_IPCR_SEQID_SHIFT		24
+#define QSPI_IPCR_SEQID_MASK		(0xf << QSPI_IPCR_SEQID_SHIFT)
+
+#define QSPI_MCR_END_CFD_SHIFT		2
+#define QSPI_MCR_END_CFD_MASK		(3 << QSPI_MCR_END_CFD_SHIFT)
+#define QSPI_MCR_END_CFD_LE		(1 << QSPI_MCR_END_CFD_SHIFT)
+#define QSPI_MCR_DDR_EN_SHIFT		7
+#define QSPI_MCR_DDR_EN_MASK		(1 << QSPI_MCR_DDR_EN_SHIFT)
+#define QSPI_MCR_CLR_RXF_SHIFT		10
+#define QSPI_MCR_CLR_RXF_MASK		(1 << QSPI_MCR_CLR_RXF_SHIFT)
+#define QSPI_MCR_CLR_TXF_SHIFT		11
+#define QSPI_MCR_CLR_TXF_MASK		(1 << QSPI_MCR_CLR_TXF_SHIFT)
+#define QSPI_MCR_MDIS_SHIFT		14
+#define QSPI_MCR_MDIS_MASK		(1 << QSPI_MCR_MDIS_SHIFT)
+#define QSPI_MCR_RESERVED_SHIFT		16
+#define QSPI_MCR_RESERVED_MASK		(0xf << QSPI_MCR_RESERVED_SHIFT)
+
+#define QSPI_SMPR_HSENA_SHIFT		0
+#define QSPI_SMPR_HSENA_MASK		(1 << QSPI_SMPR_HSENA_SHIFT)
+#define QSPI_SMPR_FSPHS_SHIFT		5
+#define QSPI_SMPR_FSPHS_MASK		(1 << QSPI_SMPR_FSPHS_SHIFT)
+#define QSPI_SMPR_FSDLY_SHIFT		6
+#define QSPI_SMPR_FSDLY_MASK		(1 << QSPI_SMPR_FSDLY_SHIFT)
+#define QSPI_SMPR_DDRSMP_SHIFT		16
+#define QSPI_SMPR_DDRSMP_MASK		(7 << QSPI_SMPR_DDRSMP_SHIFT)
+
+#define QSPI_BFGENCR_SEQID_SHIFT	12
+#define QSPI_BFGENCR_SEQID_MASK		(0xf << QSPI_BFGENCR_SEQID_SHIFT)
+#define QSPI_BFGENCR_PAR_EN_SHIFT	16
+#define QSPI_BFGENCR_PAR_EN_MASK	(1 << QSPI_BFGENCR_PAR_EN_SHIFT)
+
+#define QSPI_RBSR_RDBFL_SHIFT		8
+#define QSPI_RBSR_RDBFL_MASK		(0x3f << QSPI_RBSR_RDBFL_SHIFT)
+
+#define QSPI_RBCT_RXBRD_SHIFT		8
+#define QSPI_RBCT_RXBRD_USEIPS		(1 << QSPI_RBCT_RXBRD_SHIFT)
+
+#define QSPI_SR_BUSY_SHIFT		0
+#define QSPI_SR_BUSY_MASK		(1 << QSPI_SR_BUSY_SHIFT)
+
+#define QSPI_LCKCR_LOCK			0x1
+#define QSPI_LCKCR_UNLOCK		0x2
+
+#define LUT_KEY_VALUE			0x5af05af0
+
+#define OPRND0_SHIFT			0
+#define OPRND0(x)			((x) << OPRND0_SHIFT)
+#define PAD0_SHIFT			8
+#define PAD0(x)				((x) << PAD0_SHIFT)
+#define INSTR0_SHIFT			10
+#define INSTR0(x)			((x) << INSTR0_SHIFT)
+#define OPRND1_SHIFT			16
+#define OPRND1(x)			((x) << OPRND1_SHIFT)
+#define PAD1_SHIFT			24
+#define PAD1(x)				((x) << PAD1_SHIFT)
+#define INSTR1_SHIFT			26
+#define INSTR1(x)			((x) << INSTR1_SHIFT)
+
+#define LUT_CMD				1
+#define LUT_ADDR			2
+#define LUT_DUMMY			3
+#define LUT_READ			7
+#define LUT_WRITE			8
+
+#define LUT_PAD1			0
+#define LUT_PAD2			1
+#define LUT_PAD4			2
+
+#define ADDR24BIT			0x18
+#define ADDR32BIT			0x20
+
+#endif /* _FSL_QSPI_H_ */
diff --git a/drivers/spi/ftssp010_spi.c b/drivers/spi/ftssp010_spi.c
new file mode 100644
index 0000000..aa3b5a0
--- /dev/null
+++ b/drivers/spi/ftssp010_spi.c
@@ -0,0 +1,508 @@
+/*
+ * (C) Copyright 2013
+ * Faraday Technology Corporation. <http://www.faraday-tech.com/tw/>
+ * Kuo-Jung Su <dantesu@gmail.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <linux/compat.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <spi.h>
+
+#ifndef CONFIG_FTSSP010_BASE_LIST
+#define CONFIG_FTSSP010_BASE_LIST   { CONFIG_FTSSP010_BASE }
+#endif
+
+#ifndef CONFIG_FTSSP010_GPIO_BASE
+#define CONFIG_FTSSP010_GPIO_BASE   0
+#endif
+
+#ifndef CONFIG_FTSSP010_GPIO_LIST
+#define CONFIG_FTSSP010_GPIO_LIST   { CONFIG_FTSSP010_GPIO_BASE }
+#endif
+
+#ifndef CONFIG_FTSSP010_CLOCK
+#define CONFIG_FTSSP010_CLOCK       clk_get_rate("SSP");
+#endif
+
+#ifndef CONFIG_FTSSP010_TIMEOUT
+#define CONFIG_FTSSP010_TIMEOUT     100
+#endif
+
+/* FTSSP010 chip registers */
+struct ftssp010_regs {
+	uint32_t cr[3];/* control register */
+	uint32_t sr;   /* status register */
+	uint32_t icr;  /* interrupt control register */
+	uint32_t isr;  /* interrupt status register */
+	uint32_t dr;   /* data register */
+	uint32_t rsvd[17];
+	uint32_t revr; /* revision register */
+	uint32_t fear; /* feature register */
+};
+
+/* Control Register 0  */
+#define CR0_FFMT_MASK       (7 << 12)
+#define CR0_FFMT_SSP        (0 << 12)
+#define CR0_FFMT_SPI        (1 << 12)
+#define CR0_FFMT_MICROWIRE  (2 << 12)
+#define CR0_FFMT_I2S        (3 << 12)
+#define CR0_FFMT_AC97       (4 << 12)
+#define CR0_FLASH           (1 << 11)
+#define CR0_FSDIST(x)       (((x) & 0x03) << 8)
+#define CR0_LOOP            (1 << 7)  /* loopback mode */
+#define CR0_LSB             (1 << 6)  /* LSB */
+#define CR0_FSPO            (1 << 5)  /* fs atcive low (I2S only) */
+#define CR0_FSJUSTIFY       (1 << 4)
+#define CR0_OPM_SLAVE       (0 << 2)
+#define CR0_OPM_MASTER      (3 << 2)
+#define CR0_OPM_I2S_MSST    (3 << 2)  /* master stereo mode */
+#define CR0_OPM_I2S_MSMO    (2 << 2)  /* master mono mode */
+#define CR0_OPM_I2S_SLST    (1 << 2)  /* slave stereo mode */
+#define CR0_OPM_I2S_SLMO    (0 << 2)  /* slave mono mode */
+#define CR0_SCLKPO          (1 << 1)  /* clock polarity */
+#define CR0_SCLKPH          (1 << 0)  /* clock phase */
+
+/* Control Register 1 */
+#define CR1_PDL(x)   (((x) & 0xff) << 24) /* padding length */
+#define CR1_SDL(x)   ((((x) - 1) & 0x1f) << 16) /* data length */
+#define CR1_DIV(x)   (((x) - 1) & 0xffff) /* clock divider */
+
+/* Control Register 2 */
+#define CR2_CS(x)    (((x) & 3) << 10) /* CS/FS select */
+#define CR2_FS       (1 << 9) /* CS/FS signal level */
+#define CR2_TXEN     (1 << 8) /* tx enable */
+#define CR2_RXEN     (1 << 7) /* rx enable */
+#define CR2_RESET    (1 << 6) /* chip reset */
+#define CR2_TXFC     (1 << 3) /* tx fifo Clear */
+#define CR2_RXFC     (1 << 2) /* rx fifo Clear */
+#define CR2_TXDOE    (1 << 1) /* tx data output enable */
+#define CR2_EN       (1 << 0) /* chip enable */
+
+/* Status Register */
+#define SR_RFF       (1 << 0) /* rx fifo full */
+#define SR_TFNF      (1 << 1) /* tx fifo not full */
+#define SR_BUSY      (1 << 2) /* chip busy */
+#define SR_RFVE(reg) (((reg) >> 4) & 0x1f)  /* rx fifo valid entries */
+#define SR_TFVE(reg) (((reg) >> 12) & 0x1f) /* tx fifo valid entries */
+
+/* Feature Register */
+#define FEAR_BITS(reg)   ((((reg) >>  0) & 0xff) + 1) /* data width */
+#define FEAR_RFSZ(reg)   ((((reg) >>  8) & 0xff) + 1) /* rx fifo size */
+#define FEAR_TFSZ(reg)   ((((reg) >> 16) & 0xff) + 1) /* tx fifo size */
+#define FEAR_AC97        (1 << 24)
+#define FEAR_I2S         (1 << 25)
+#define FEAR_SPI_MWR     (1 << 26)
+#define FEAR_SSP         (1 << 27)
+#define FEAR_SPDIF       (1 << 28)
+
+/* FTGPIO010 chip registers */
+struct ftgpio010_regs {
+	uint32_t out;     /* 0x00: Data Output */
+	uint32_t in;      /* 0x04: Data Input */
+	uint32_t dir;     /* 0x08: Direction */
+	uint32_t bypass;  /* 0x0c: Bypass */
+	uint32_t set;     /* 0x10: Data Set */
+	uint32_t clr;     /* 0x14: Data Clear */
+	uint32_t pull_up; /* 0x18: Pull-Up Enabled */
+	uint32_t pull_st; /* 0x1c: Pull State (0=pull-down, 1=pull-up) */
+};
+
+struct ftssp010_gpio {
+	struct ftgpio010_regs *regs;
+	uint32_t pin;
+};
+
+struct ftssp010_spi {
+	struct spi_slave slave;
+	struct ftssp010_gpio gpio;
+	struct ftssp010_regs *regs;
+	uint32_t fifo;
+	uint32_t mode;
+	uint32_t div;
+	uint32_t clk;
+	uint32_t speed;
+	uint32_t revision;
+};
+
+static inline struct ftssp010_spi *to_ftssp010_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct ftssp010_spi, slave);
+}
+
+static int get_spi_chip(int bus, struct ftssp010_spi *chip)
+{
+	uint32_t fear, base[] = CONFIG_FTSSP010_BASE_LIST;
+
+	if (bus >= ARRAY_SIZE(base) || !base[bus])
+		return -1;
+
+	chip->regs = (struct ftssp010_regs *)base[bus];
+
+	chip->revision = readl(&chip->regs->revr);
+
+	fear = readl(&chip->regs->fear);
+	chip->fifo = min_t(uint32_t, FEAR_TFSZ(fear), FEAR_RFSZ(fear));
+
+	return 0;
+}
+
+static int get_spi_gpio(int bus, struct ftssp010_gpio *chip)
+{
+	uint32_t base[] = CONFIG_FTSSP010_GPIO_LIST;
+
+	if (bus >= ARRAY_SIZE(base) || !base[bus])
+		return -1;
+
+	chip->regs = (struct ftgpio010_regs *)(base[bus] & 0xfff00000);
+	chip->pin = base[bus] & 0x1f;
+
+	/* make it an output pin */
+	setbits_le32(&chip->regs->dir, 1 << chip->pin);
+
+	return 0;
+}
+
+static int ftssp010_wait(struct ftssp010_spi *chip)
+{
+	struct ftssp010_regs *regs = chip->regs;
+	int ret = -1;
+	ulong t;
+
+	/* wait until device idle */
+	for (t = get_timer(0); get_timer(t) < CONFIG_FTSSP010_TIMEOUT; ) {
+		if (readl(&regs->sr) & SR_BUSY)
+			continue;
+		ret = 0;
+		break;
+	}
+
+	if (ret)
+		puts("ftspi010: busy timeout\n");
+
+	return ret;
+}
+
+static int ftssp010_wait_tx(struct ftssp010_spi *chip)
+{
+	struct ftssp010_regs *regs = chip->regs;
+	int ret = -1;
+	ulong t;
+
+	/* wait until tx fifo not full */
+	for (t = get_timer(0); get_timer(t) < CONFIG_FTSSP010_TIMEOUT; ) {
+		if (!(readl(&regs->sr) & SR_TFNF))
+			continue;
+		ret = 0;
+		break;
+	}
+
+	if (ret)
+		puts("ftssp010: tx timeout\n");
+
+	return ret;
+}
+
+static int ftssp010_wait_rx(struct ftssp010_spi *chip)
+{
+	struct ftssp010_regs *regs = chip->regs;
+	int ret = -1;
+	ulong t;
+
+	/* wait until rx fifo not empty */
+	for (t = get_timer(0); get_timer(t) < CONFIG_FTSSP010_TIMEOUT; ) {
+		if (!SR_RFVE(readl(&regs->sr)))
+			continue;
+		ret = 0;
+		break;
+	}
+
+	if (ret)
+		puts("ftssp010: rx timeout\n");
+
+	return ret;
+}
+
+static int ftssp010_spi_work_transfer_v2(struct ftssp010_spi *chip,
+	const void *tx_buf, void *rx_buf, int len, uint flags)
+{
+	struct ftssp010_regs *regs = chip->regs;
+	const uint8_t *txb = tx_buf;
+	uint8_t       *rxb = rx_buf;
+
+	while (len > 0) {
+		int i, depth = min(chip->fifo >> 2, len);
+		uint32_t xmsk = 0;
+
+		if (tx_buf) {
+			for (i = 0; i < depth; ++i) {
+				ftssp010_wait_tx(chip);
+				writel(*txb++, &regs->dr);
+			}
+			xmsk |= CR2_TXEN | CR2_TXDOE;
+			if ((readl(&regs->cr[2]) & xmsk) != xmsk)
+				setbits_le32(&regs->cr[2], xmsk);
+		}
+		if (rx_buf) {
+			xmsk |= CR2_RXEN;
+			if ((readl(&regs->cr[2]) & xmsk) != xmsk)
+				setbits_le32(&regs->cr[2], xmsk);
+			for (i = 0; i < depth; ++i) {
+				ftssp010_wait_rx(chip);
+				*rxb++ = (uint8_t)readl(&regs->dr);
+			}
+		}
+
+		len -= depth;
+	}
+
+	return 0;
+}
+
+static int ftssp010_spi_work_transfer_v1(struct ftssp010_spi *chip,
+	const void *tx_buf, void *rx_buf, int len, uint flags)
+{
+	struct ftssp010_regs *regs = chip->regs;
+	const uint8_t *txb = tx_buf;
+	uint8_t       *rxb = rx_buf;
+
+	while (len > 0) {
+		int i, depth = min(chip->fifo >> 2, len);
+		uint32_t tmp;
+
+		for (i = 0; i < depth; ++i) {
+			ftssp010_wait_tx(chip);
+			writel(txb ? (*txb++) : 0, &regs->dr);
+		}
+		for (i = 0; i < depth; ++i) {
+			ftssp010_wait_rx(chip);
+			tmp = readl(&regs->dr);
+			if (rxb)
+				*rxb++ = (uint8_t)tmp;
+		}
+
+		len -= depth;
+	}
+
+	return 0;
+}
+
+static void ftssp010_cs_set(struct ftssp010_spi *chip, int high)
+{
+	struct ftssp010_regs *regs = chip->regs;
+	struct ftssp010_gpio *gpio = &chip->gpio;
+	uint32_t mask;
+
+	/* cs pull high/low */
+	if (chip->revision >= 0x11900) {
+		mask = CR2_CS(chip->slave.cs) | (high ? CR2_FS : 0);
+		writel(mask, &regs->cr[2]);
+	} else if (gpio->regs) {
+		mask = 1 << gpio->pin;
+		if (high)
+			writel(mask, &gpio->regs->set);
+		else
+			writel(mask, &gpio->regs->clr);
+	}
+
+	/* extra delay for signal propagation */
+	udelay_masked(1);
+}
+
+/*
+ * Determine if a SPI chipselect is valid.
+ * This function is provided by the board if the low-level SPI driver
+ * needs it to determine if a given chipselect is actually valid.
+ *
+ * Returns: 1 if bus:cs identifies a valid chip on this board, 0
+ * otherwise.
+ */
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	struct ftssp010_spi chip;
+
+	if (get_spi_chip(bus, &chip))
+		return 0;
+
+	if (!cs)
+		return 1;
+	else if ((cs < 4) && (chip.revision >= 0x11900))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * Activate a SPI chipselect.
+ * This function is provided by the board code when using a driver
+ * that can't control its chipselects automatically (e.g.
+ * common/soft_spi.c). When called, it should activate the chip select
+ * to the device identified by "slave".
+ */
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct ftssp010_spi *chip = to_ftssp010_spi(slave);
+	struct ftssp010_regs *regs = chip->regs;
+
+	/* cs pull */
+	if (chip->mode & SPI_CS_HIGH)
+		ftssp010_cs_set(chip, 1);
+	else
+		ftssp010_cs_set(chip, 0);
+
+	/* chip enable + fifo clear */
+	setbits_le32(&regs->cr[2], CR2_EN | CR2_TXFC | CR2_RXFC);
+}
+
+/*
+ * Deactivate a SPI chipselect.
+ * This function is provided by the board code when using a driver
+ * that can't control its chipselects automatically (e.g.
+ * common/soft_spi.c). When called, it should deactivate the chip
+ * select to the device identified by "slave".
+ */
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct ftssp010_spi *chip = to_ftssp010_spi(slave);
+
+	/* wait until chip idle */
+	ftssp010_wait(chip);
+
+	/* cs pull */
+	if (chip->mode & SPI_CS_HIGH)
+		ftssp010_cs_set(chip, 0);
+	else
+		ftssp010_cs_set(chip, 1);
+}
+
+void spi_init(void)
+{
+	/* nothing to do */
+}
+
+struct spi_slave *spi_setup_slave(uint bus, uint cs, uint max_hz, uint mode)
+{
+	struct ftssp010_spi *chip;
+
+	if (mode & SPI_3WIRE) {
+		puts("ftssp010: can't do 3-wire\n");
+		return NULL;
+	}
+
+	if (mode & SPI_SLAVE) {
+		puts("ftssp010: can't do slave mode\n");
+		return NULL;
+	}
+
+	if (mode & SPI_PREAMBLE) {
+		puts("ftssp010: can't skip preamble bytes\n");
+		return NULL;
+	}
+
+	if (!spi_cs_is_valid(bus, cs)) {
+		puts("ftssp010: invalid (bus, cs)\n");
+		return NULL;
+	}
+
+	chip = spi_alloc_slave(struct ftssp010_spi, bus, cs);
+	if (!chip)
+		return NULL;
+
+	if (get_spi_chip(bus, chip))
+		goto free_out;
+
+	if (chip->revision < 0x11900 && get_spi_gpio(bus, &chip->gpio)) {
+		puts("ftssp010: Before revision 1.19.0, its clock & cs are\n"
+		"controlled by tx engine which is not synced with rx engine,\n"
+		"so the clock & cs might be shutdown before rx engine\n"
+		"finishs its jobs.\n"
+		"If possible, please add a dedicated gpio for it.\n");
+	}
+
+	chip->mode = mode;
+	chip->clk = CONFIG_FTSSP010_CLOCK;
+	chip->div = 2;
+	if (max_hz) {
+		while (chip->div < 0xffff) {
+			if ((chip->clk / (2 * chip->div)) <= max_hz)
+				break;
+			chip->div += 1;
+		}
+	}
+	chip->speed = chip->clk / (2 * chip->div);
+
+	return &chip->slave;
+
+free_out:
+	free(chip);
+	return NULL;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	free(slave);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct ftssp010_spi *chip = to_ftssp010_spi(slave);
+	struct ftssp010_regs *regs = chip->regs;
+
+	writel(CR1_SDL(8) | CR1_DIV(chip->div), &regs->cr[1]);
+
+	if (chip->revision >= 0x11900) {
+		writel(CR0_OPM_MASTER | CR0_FFMT_SPI | CR0_FSPO | CR0_FLASH,
+		       &regs->cr[0]);
+		writel(CR2_TXFC | CR2_RXFC,
+		       &regs->cr[2]);
+	} else {
+		writel(CR0_OPM_MASTER | CR0_FFMT_SPI | CR0_FSPO,
+		       &regs->cr[0]);
+		writel(CR2_TXFC | CR2_RXFC | CR2_EN | CR2_TXDOE,
+		       &regs->cr[2]);
+	}
+
+	if (chip->mode & SPI_LOOP)
+		setbits_le32(&regs->cr[0], CR0_LOOP);
+
+	if (chip->mode & SPI_CPOL)
+		setbits_le32(&regs->cr[0], CR0_SCLKPO);
+
+	if (chip->mode & SPI_CPHA)
+		setbits_le32(&regs->cr[0], CR0_SCLKPH);
+
+	spi_cs_deactivate(slave);
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	struct ftssp010_spi *chip = to_ftssp010_spi(slave);
+	struct ftssp010_regs *regs = chip->regs;
+
+	writel(0, &regs->cr[2]);
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+			 const void *dout, void *din, unsigned long flags)
+{
+	struct ftssp010_spi *chip = to_ftssp010_spi(slave);
+	uint32_t len = bitlen >> 3;
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	if (chip->revision >= 0x11900)
+		ftssp010_spi_work_transfer_v2(chip, dout, din, len, flags);
+	else
+		ftssp010_spi_work_transfer_v1(chip, dout, din, len, flags);
+
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return 0;
+}
diff --git a/drivers/spi/ich.c b/drivers/spi/ich.c
new file mode 100644
index 0000000..f5c6f3e
--- /dev/null
+++ b/drivers/spi/ich.c
@@ -0,0 +1,741 @@
+/*
+ * Copyright (c) 2011-12 The Chromium OS Authors.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * This file is derived from the flashrom project.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <pci.h>
+#include <pci_ids.h>
+#include <asm/io.h>
+
+#include "ich.h"
+
+#define SPI_OPCODE_WREN      0x06
+#define SPI_OPCODE_FAST_READ 0x0b
+
+struct ich_ctlr {
+	pci_dev_t dev;		/* PCI device number */
+	int ich_version;	/* Controller version, 7 or 9 */
+	int ichspi_lock;
+	int locked;
+	uint8_t *opmenu;
+	int menubytes;
+	void *base;		/* Base of register set */
+	uint16_t *preop;
+	uint16_t *optype;
+	uint32_t *addr;
+	uint8_t *data;
+	unsigned databytes;
+	uint8_t *status;
+	uint16_t *control;
+	uint32_t *bbar;
+	uint32_t *pr;		/* only for ich9 */
+	uint8_t *speed;		/* pointer to speed control */
+	ulong max_speed;	/* Maximum bus speed in MHz */
+};
+
+struct ich_ctlr ctlr;
+
+static inline struct ich_spi_slave *to_ich_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct ich_spi_slave, slave);
+}
+
+static unsigned int ich_reg(const void *addr)
+{
+	return (unsigned)(addr - ctlr.base) & 0xffff;
+}
+
+static u8 ich_readb(const void *addr)
+{
+	u8 value = readb(addr);
+
+	debug("read %2.2x from %4.4x\n", value, ich_reg(addr));
+
+	return value;
+}
+
+static u16 ich_readw(const void *addr)
+{
+	u16 value = readw(addr);
+
+	debug("read %4.4x from %4.4x\n", value, ich_reg(addr));
+
+	return value;
+}
+
+static u32 ich_readl(const void *addr)
+{
+	u32 value = readl(addr);
+
+	debug("read %8.8x from %4.4x\n", value, ich_reg(addr));
+
+	return value;
+}
+
+static void ich_writeb(u8 value, void *addr)
+{
+	writeb(value, addr);
+	debug("wrote %2.2x to %4.4x\n", value, ich_reg(addr));
+}
+
+static void ich_writew(u16 value, void *addr)
+{
+	writew(value, addr);
+	debug("wrote %4.4x to %4.4x\n", value, ich_reg(addr));
+}
+
+static void ich_writel(u32 value, void *addr)
+{
+	writel(value, addr);
+	debug("wrote %8.8x to %4.4x\n", value, ich_reg(addr));
+}
+
+static void write_reg(const void *value, void *dest, uint32_t size)
+{
+	memcpy_toio(dest, value, size);
+}
+
+static void read_reg(const void *src, void *value, uint32_t size)
+{
+	memcpy_fromio(value, src, size);
+}
+
+static void ich_set_bbar(struct ich_ctlr *ctlr, uint32_t minaddr)
+{
+	const uint32_t bbar_mask = 0x00ffff00;
+	uint32_t ichspi_bbar;
+
+	minaddr &= bbar_mask;
+	ichspi_bbar = ich_readl(ctlr->bbar) & ~bbar_mask;
+	ichspi_bbar |= minaddr;
+	ich_writel(ichspi_bbar, ctlr->bbar);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	puts("spi_cs_is_valid used but not implemented\n");
+	return 0;
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct ich_spi_slave *ich;
+
+	ich = spi_alloc_slave(struct ich_spi_slave, bus, cs);
+	if (!ich) {
+		puts("ICH SPI: Out of memory\n");
+		return NULL;
+	}
+
+	/*
+	 * Yes this controller can only write a small number of bytes at
+	 * once! The limit is typically 64 bytes.
+	 */
+	ich->slave.max_write_size = ctlr.databytes;
+	ich->speed = max_hz;
+
+	return &ich->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct ich_spi_slave *ich = to_ich_spi(slave);
+
+	free(ich);
+}
+
+/*
+ * Check if this device ID matches one of supported Intel PCH devices.
+ *
+ * Return the ICH version if there is a match, or zero otherwise.
+ */
+static int get_ich_version(uint16_t device_id)
+{
+	if (device_id == PCI_DEVICE_ID_INTEL_TGP_LPC)
+		return 7;
+
+	if ((device_id >= PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MIN &&
+	     device_id <= PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MAX) ||
+	    (device_id >= PCI_DEVICE_ID_INTEL_PANTHERPOINT_LPC_MIN &&
+	     device_id <= PCI_DEVICE_ID_INTEL_PANTHERPOINT_LPC_MAX))
+		return 9;
+
+	return 0;
+}
+
+/* @return 1 if the SPI flash supports the 33MHz speed */
+static int ich9_can_do_33mhz(pci_dev_t dev)
+{
+	u32 fdod, speed;
+
+	/* Observe SPI Descriptor Component Section 0 */
+	pci_write_config_dword(dev, 0xb0, 0x1000);
+
+	/* Extract the Write/Erase SPI Frequency from descriptor */
+	pci_read_config_dword(dev, 0xb4, &fdod);
+
+	/* Bits 23:21 have the fast read clock frequency, 0=20MHz, 1=33MHz */
+	speed = (fdod >> 21) & 7;
+
+	return speed == 1;
+}
+
+static int ich_find_spi_controller(pci_dev_t *devp, int *ich_versionp)
+{
+	int last_bus = pci_last_busno();
+	int bus;
+
+	if (last_bus == -1) {
+		debug("No PCI busses?\n");
+		return -1;
+	}
+
+	for (bus = 0; bus <= last_bus; bus++) {
+		uint16_t vendor_id, device_id;
+		uint32_t ids;
+		pci_dev_t dev;
+
+		dev = PCI_BDF(bus, 31, 0);
+		pci_read_config_dword(dev, 0, &ids);
+		vendor_id = ids;
+		device_id = ids >> 16;
+
+		if (vendor_id == PCI_VENDOR_ID_INTEL) {
+			*devp = dev;
+			*ich_versionp = get_ich_version(device_id);
+			return 0;
+		}
+	}
+
+	debug("ICH SPI: No ICH found.\n");
+	return -1;
+}
+
+static int ich_init_controller(struct ich_ctlr *ctlr)
+{
+	uint8_t *rcrb; /* Root Complex Register Block */
+	uint32_t rcba; /* Root Complex Base Address */
+
+	pci_read_config_dword(ctlr->dev, 0xf0, &rcba);
+	/* Bits 31-14 are the base address, 13-1 are reserved, 0 is enable. */
+	rcrb = (uint8_t *)(rcba & 0xffffc000);
+	if (ctlr->ich_version == 7) {
+		struct ich7_spi_regs *ich7_spi;
+
+		ich7_spi = (struct ich7_spi_regs *)(rcrb + 0x3020);
+		ctlr->ichspi_lock = ich_readw(&ich7_spi->spis) & SPIS_LOCK;
+		ctlr->opmenu = ich7_spi->opmenu;
+		ctlr->menubytes = sizeof(ich7_spi->opmenu);
+		ctlr->optype = &ich7_spi->optype;
+		ctlr->addr = &ich7_spi->spia;
+		ctlr->data = (uint8_t *)ich7_spi->spid;
+		ctlr->databytes = sizeof(ich7_spi->spid);
+		ctlr->status = (uint8_t *)&ich7_spi->spis;
+		ctlr->control = &ich7_spi->spic;
+		ctlr->bbar = &ich7_spi->bbar;
+		ctlr->preop = &ich7_spi->preop;
+		ctlr->base = ich7_spi;
+	} else if (ctlr->ich_version == 9) {
+		struct ich9_spi_regs *ich9_spi;
+
+		ich9_spi = (struct ich9_spi_regs *)(rcrb + 0x3800);
+		ctlr->ichspi_lock = ich_readw(&ich9_spi->hsfs) & HSFS_FLOCKDN;
+		ctlr->opmenu = ich9_spi->opmenu;
+		ctlr->menubytes = sizeof(ich9_spi->opmenu);
+		ctlr->optype = &ich9_spi->optype;
+		ctlr->addr = &ich9_spi->faddr;
+		ctlr->data = (uint8_t *)ich9_spi->fdata;
+		ctlr->databytes = sizeof(ich9_spi->fdata);
+		ctlr->status = &ich9_spi->ssfs;
+		ctlr->control = (uint16_t *)ich9_spi->ssfc;
+		ctlr->speed = ich9_spi->ssfc + 2;
+		ctlr->bbar = &ich9_spi->bbar;
+		ctlr->preop = &ich9_spi->preop;
+		ctlr->pr = &ich9_spi->pr[0];
+		ctlr->base = ich9_spi;
+	} else {
+		debug("ICH SPI: Unrecognized ICH version %d.\n",
+		      ctlr->ich_version);
+		return -1;
+	}
+	debug("ICH SPI: Version %d detected\n", ctlr->ich_version);
+
+	/* Work out the maximum speed we can support */
+	ctlr->max_speed = 20000000;
+	if (ctlr->ich_version == 9 && ich9_can_do_33mhz(ctlr->dev))
+		ctlr->max_speed = 33000000;
+
+	ich_set_bbar(ctlr, 0);
+
+	return 0;
+}
+
+void spi_init(void)
+{
+	uint8_t bios_cntl;
+
+	if (ich_find_spi_controller(&ctlr.dev, &ctlr.ich_version)) {
+		printf("ICH SPI: Cannot find device\n");
+		return;
+	}
+
+	if (ich_init_controller(&ctlr)) {
+		printf("ICH SPI: Cannot setup controller\n");
+		return;
+	}
+
+	/*
+	 * Disable the BIOS write protect so write commands are allowed.  On
+	 * v9, deassert SMM BIOS Write Protect Disable.
+	 */
+	pci_read_config_byte(ctlr.dev, 0xdc, &bios_cntl);
+	if (ctlr.ich_version == 9)
+		bios_cntl &= ~(1 << 5);
+	pci_write_config_byte(ctlr.dev, 0xdc, bios_cntl | 0x1);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	/* Handled by ICH automatically. */
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	/* Handled by ICH automatically. */
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	/* Handled by ICH automatically. */
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	/* Handled by ICH automatically. */
+}
+
+static inline void spi_use_out(struct spi_trans *trans, unsigned bytes)
+{
+	trans->out += bytes;
+	trans->bytesout -= bytes;
+}
+
+static inline void spi_use_in(struct spi_trans *trans, unsigned bytes)
+{
+	trans->in += bytes;
+	trans->bytesin -= bytes;
+}
+
+static void spi_setup_type(struct spi_trans *trans, int data_bytes)
+{
+	trans->type = 0xFF;
+
+	/* Try to guess spi type from read/write sizes. */
+	if (trans->bytesin == 0) {
+		if (trans->bytesout + data_bytes > 4)
+			/*
+			 * If bytesin = 0 and bytesout > 4, we presume this is
+			 * a write data operation, which is accompanied by an
+			 * address.
+			 */
+			trans->type = SPI_OPCODE_TYPE_WRITE_WITH_ADDRESS;
+		else
+			trans->type = SPI_OPCODE_TYPE_WRITE_NO_ADDRESS;
+		return;
+	}
+
+	if (trans->bytesout == 1) {	/* and bytesin is > 0 */
+		trans->type = SPI_OPCODE_TYPE_READ_NO_ADDRESS;
+		return;
+	}
+
+	if (trans->bytesout == 4)	/* and bytesin is > 0 */
+		trans->type = SPI_OPCODE_TYPE_READ_WITH_ADDRESS;
+
+	/* Fast read command is called with 5 bytes instead of 4 */
+	if (trans->out[0] == SPI_OPCODE_FAST_READ && trans->bytesout == 5) {
+		trans->type = SPI_OPCODE_TYPE_READ_WITH_ADDRESS;
+		--trans->bytesout;
+	}
+}
+
+static int spi_setup_opcode(struct spi_trans *trans)
+{
+	uint16_t optypes;
+	uint8_t opmenu[ctlr.menubytes];
+
+	trans->opcode = trans->out[0];
+	spi_use_out(trans, 1);
+	if (!ctlr.ichspi_lock) {
+		/* The lock is off, so just use index 0. */
+		ich_writeb(trans->opcode, ctlr.opmenu);
+		optypes = ich_readw(ctlr.optype);
+		optypes = (optypes & 0xfffc) | (trans->type & 0x3);
+		ich_writew(optypes, ctlr.optype);
+		return 0;
+	} else {
+		/* The lock is on. See if what we need is on the menu. */
+		uint8_t optype;
+		uint16_t opcode_index;
+
+		/* Write Enable is handled as atomic prefix */
+		if (trans->opcode == SPI_OPCODE_WREN)
+			return 0;
+
+		read_reg(ctlr.opmenu, opmenu, sizeof(opmenu));
+		for (opcode_index = 0; opcode_index < ctlr.menubytes;
+				opcode_index++) {
+			if (opmenu[opcode_index] == trans->opcode)
+				break;
+		}
+
+		if (opcode_index == ctlr.menubytes) {
+			printf("ICH SPI: Opcode %x not found\n",
+			       trans->opcode);
+			return -1;
+		}
+
+		optypes = ich_readw(ctlr.optype);
+		optype = (optypes >> (opcode_index * 2)) & 0x3;
+		if (trans->type == SPI_OPCODE_TYPE_WRITE_NO_ADDRESS &&
+		    optype == SPI_OPCODE_TYPE_WRITE_WITH_ADDRESS &&
+		    trans->bytesout >= 3) {
+			/* We guessed wrong earlier. Fix it up. */
+			trans->type = optype;
+		}
+		if (optype != trans->type) {
+			printf("ICH SPI: Transaction doesn't fit type %d\n",
+			       optype);
+			return -1;
+		}
+		return opcode_index;
+	}
+}
+
+static int spi_setup_offset(struct spi_trans *trans)
+{
+	/* Separate the SPI address and data. */
+	switch (trans->type) {
+	case SPI_OPCODE_TYPE_READ_NO_ADDRESS:
+	case SPI_OPCODE_TYPE_WRITE_NO_ADDRESS:
+		return 0;
+	case SPI_OPCODE_TYPE_READ_WITH_ADDRESS:
+	case SPI_OPCODE_TYPE_WRITE_WITH_ADDRESS:
+		trans->offset = ((uint32_t)trans->out[0] << 16) |
+				((uint32_t)trans->out[1] << 8) |
+				((uint32_t)trans->out[2] << 0);
+		spi_use_out(trans, 3);
+		return 1;
+	default:
+		printf("Unrecognized SPI transaction type %#x\n", trans->type);
+		return -1;
+	}
+}
+
+/*
+ * Wait for up to 6s til status register bit(s) turn 1 (in case wait_til_set
+ * below is true) or 0. In case the wait was for the bit(s) to set - write
+ * those bits back, which would cause resetting them.
+ *
+ * Return the last read status value on success or -1 on failure.
+ */
+static int ich_status_poll(u16 bitmask, int wait_til_set)
+{
+	int timeout = 600000; /* This will result in 6s */
+	u16 status = 0;
+
+	while (timeout--) {
+		status = ich_readw(ctlr.status);
+		if (wait_til_set ^ ((status & bitmask) == 0)) {
+			if (wait_til_set)
+				ich_writew((status & bitmask), ctlr.status);
+			return status;
+		}
+		udelay(10);
+	}
+
+	printf("ICH SPI: SCIP timeout, read %x, expected %x\n",
+	       status, bitmask);
+	return -1;
+}
+
+/*
+int spi_xfer(struct spi_slave *slave, const void *dout,
+		unsigned int bitsout, void *din, unsigned int bitsin)
+*/
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct ich_spi_slave *ich = to_ich_spi(slave);
+	uint16_t control;
+	int16_t opcode_index;
+	int with_address;
+	int status;
+	int bytes = bitlen / 8;
+	struct spi_trans *trans = &ich->trans;
+	unsigned type = flags & (SPI_XFER_BEGIN | SPI_XFER_END);
+	int using_cmd = 0;
+	/* Align read transactions to 64-byte boundaries */
+	char buff[ctlr.databytes];
+
+	/* Ee don't support writing partial bytes. */
+	if (bitlen % 8) {
+		debug("ICH SPI: Accessing partial bytes not supported\n");
+		return -1;
+	}
+
+	/* An empty end transaction can be ignored */
+	if (type == SPI_XFER_END && !dout && !din)
+		return 0;
+
+	if (type & SPI_XFER_BEGIN)
+		memset(trans, '\0', sizeof(*trans));
+
+	/* Dp we need to come back later to finish it? */
+	if (dout && type == SPI_XFER_BEGIN) {
+		if (bytes > ICH_MAX_CMD_LEN) {
+			debug("ICH SPI: Command length limit exceeded\n");
+			return -1;
+		}
+		memcpy(trans->cmd, dout, bytes);
+		trans->cmd_len = bytes;
+		debug("ICH SPI: Saved %d bytes\n", bytes);
+		return 0;
+	}
+
+	/*
+	 * We process a 'middle' spi_xfer() call, which has no
+	 * SPI_XFER_BEGIN/END, as an independent transaction as if it had
+	 * an end. We therefore repeat the command. This is because ICH
+	 * seems to have no support for this, or because interest (in digging
+	 * out the details and creating a special case in the code) is low.
+	 */
+	if (trans->cmd_len) {
+		trans->out = trans->cmd;
+		trans->bytesout = trans->cmd_len;
+		using_cmd = 1;
+		debug("ICH SPI: Using %d bytes\n", trans->cmd_len);
+	} else {
+		trans->out = dout;
+		trans->bytesout = dout ? bytes : 0;
+	}
+
+	trans->in = din;
+	trans->bytesin = din ? bytes : 0;
+
+	/* There has to always at least be an opcode. */
+	if (!trans->bytesout) {
+		debug("ICH SPI: No opcode for transfer\n");
+		return -1;
+	}
+
+	if (ich_status_poll(SPIS_SCIP, 0) == -1)
+		return -1;
+
+	ich_writew(SPIS_CDS | SPIS_FCERR, ctlr.status);
+
+	spi_setup_type(trans, using_cmd ? bytes : 0);
+	opcode_index = spi_setup_opcode(trans);
+	if (opcode_index < 0)
+		return -1;
+	with_address = spi_setup_offset(trans);
+	if (with_address < 0)
+		return -1;
+
+	if (trans->opcode == SPI_OPCODE_WREN) {
+		/*
+		 * Treat Write Enable as Atomic Pre-Op if possible
+		 * in order to prevent the Management Engine from
+		 * issuing a transaction between WREN and DATA.
+		 */
+		if (!ctlr.ichspi_lock)
+			ich_writew(trans->opcode, ctlr.preop);
+		return 0;
+	}
+
+	if (ctlr.speed && ctlr.max_speed >= 33000000) {
+		int byte;
+
+		byte = ich_readb(ctlr.speed);
+		if (ich->speed >= 33000000)
+			byte |= SSFC_SCF_33MHZ;
+		else
+			byte &= ~SSFC_SCF_33MHZ;
+		ich_writeb(byte, ctlr.speed);
+	}
+
+	/* See if we have used up the command data */
+	if (using_cmd && dout && bytes) {
+		trans->out = dout;
+		trans->bytesout = bytes;
+		debug("ICH SPI: Moving to data, %d bytes\n", bytes);
+	}
+
+	/* Preset control fields */
+	control = ich_readw(ctlr.control);
+	control &= ~SSFC_RESERVED;
+	control = SPIC_SCGO | ((opcode_index & 0x07) << 4);
+
+	/* Issue atomic preop cycle if needed */
+	if (ich_readw(ctlr.preop))
+		control |= SPIC_ACS;
+
+	if (!trans->bytesout && !trans->bytesin) {
+		/* SPI addresses are 24 bit only */
+		if (with_address)
+			ich_writel(trans->offset & 0x00FFFFFF, ctlr.addr);
+
+		/*
+		 * This is a 'no data' command (like Write Enable), its
+		 * bitesout size was 1, decremented to zero while executing
+		 * spi_setup_opcode() above. Tell the chip to send the
+		 * command.
+		 */
+		ich_writew(control, ctlr.control);
+
+		/* wait for the result */
+		status = ich_status_poll(SPIS_CDS | SPIS_FCERR, 1);
+		if (status == -1)
+			return -1;
+
+		if (status & SPIS_FCERR) {
+			debug("ICH SPI: Command transaction error\n");
+			return -1;
+		}
+
+		return 0;
+	}
+
+	/*
+	 * Check if this is a write command atempting to transfer more bytes
+	 * than the controller can handle. Iterations for writes are not
+	 * supported here because each SPI write command needs to be preceded
+	 * and followed by other SPI commands, and this sequence is controlled
+	 * by the SPI chip driver.
+	 */
+	if (trans->bytesout > ctlr.databytes) {
+		debug("ICH SPI: Too much to write. This should be prevented by the driver's max_write_size?\n");
+		return -1;
+	}
+
+	/*
+	 * Read or write up to databytes bytes at a time until everything has
+	 * been sent.
+	 */
+	while (trans->bytesout || trans->bytesin) {
+		uint32_t data_length;
+		uint32_t aligned_offset;
+		uint32_t diff;
+
+		aligned_offset = trans->offset & ~(ctlr.databytes - 1);
+		diff = trans->offset - aligned_offset;
+
+		/* SPI addresses are 24 bit only */
+		ich_writel(aligned_offset & 0x00FFFFFF, ctlr.addr);
+
+		if (trans->bytesout)
+			data_length = min(trans->bytesout, ctlr.databytes);
+		else
+			data_length = min(trans->bytesin, ctlr.databytes);
+
+		/* Program data into FDATA0 to N */
+		if (trans->bytesout) {
+			write_reg(trans->out, ctlr.data, data_length);
+			spi_use_out(trans, data_length);
+			if (with_address)
+				trans->offset += data_length;
+		}
+
+		/* Add proper control fields' values */
+		control &= ~((ctlr.databytes - 1) << 8);
+		control |= SPIC_DS;
+		control |= (data_length - 1) << 8;
+
+		/* write it */
+		ich_writew(control, ctlr.control);
+
+		/* Wait for Cycle Done Status or Flash Cycle Error. */
+		status = ich_status_poll(SPIS_CDS | SPIS_FCERR, 1);
+		if (status == -1)
+			return -1;
+
+		if (status & SPIS_FCERR) {
+			debug("ICH SPI: Data transaction error\n");
+			return -1;
+		}
+
+		if (trans->bytesin) {
+			if (diff) {
+				data_length -= diff;
+				read_reg(ctlr.data, buff, ctlr.databytes);
+				memcpy(trans->in, buff + diff, data_length);
+			} else {
+				read_reg(ctlr.data, trans->in, data_length);
+			}
+			spi_use_in(trans, data_length);
+			if (with_address)
+				trans->offset += data_length;
+		}
+	}
+
+	/* Clear atomic preop now that xfer is done */
+	ich_writew(0, ctlr.preop);
+
+	return 0;
+}
+
+
+/*
+ * This uses the SPI controller from the Intel Cougar Point and Panther Point
+ * PCH to write-protect portions of the SPI flash until reboot. The changes
+ * don't actually take effect until the HSFS[FLOCKDN] bit is set, but that's
+ * done elsewhere.
+ */
+int spi_write_protect_region(uint32_t lower_limit, uint32_t length, int hint)
+{
+	uint32_t tmplong;
+	uint32_t upper_limit;
+
+	if (!ctlr.pr) {
+		printf("%s: operation not supported on this chipset\n",
+		       __func__);
+		return -1;
+	}
+
+	if (length == 0 ||
+	    lower_limit > (0xFFFFFFFFUL - length) + 1 ||
+	    hint < 0 || hint > 4) {
+		printf("%s(0x%x, 0x%x, %d): invalid args\n", __func__,
+		       lower_limit, length, hint);
+		return -1;
+	}
+
+	upper_limit = lower_limit + length - 1;
+
+	/*
+	 * Determine bits to write, as follows:
+	 *  31     Write-protection enable (includes erase operation)
+	 *  30:29  reserved
+	 *  28:16  Upper Limit (FLA address bits 24:12, with 11:0 == 0xfff)
+	 *  15     Read-protection enable
+	 *  14:13  reserved
+	 *  12:0   Lower Limit (FLA address bits 24:12, with 11:0 == 0x000)
+	 */
+	tmplong = 0x80000000 |
+		((upper_limit & 0x01fff000) << 4) |
+		((lower_limit & 0x01fff000) >> 12);
+
+	printf("%s: writing 0x%08x to %p\n", __func__, tmplong,
+	       &ctlr.pr[hint]);
+	ctlr.pr[hint] = tmplong;
+
+	return 0;
+}
diff --git a/drivers/spi/ich.h b/drivers/spi/ich.h
new file mode 100644
index 0000000..d2e4b85
--- /dev/null
+++ b/drivers/spi/ich.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2011 The Chromium OS Authors.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * This file is derived from the flashrom project.
+ */
+
+struct ich7_spi_regs {
+	uint16_t spis;
+	uint16_t spic;
+	uint32_t spia;
+	uint64_t spid[8];
+	uint64_t _pad;
+	uint32_t bbar;
+	uint16_t preop;
+	uint16_t optype;
+	uint8_t opmenu[8];
+} __packed;
+
+struct ich9_spi_regs {
+	uint32_t bfpr;			/* 0x00 */
+	uint16_t hsfs;
+	uint16_t hsfc;
+	uint32_t faddr;
+	uint32_t _reserved0;
+	uint32_t fdata[16];		/* 0x10 */
+	uint32_t frap;			/* 0x50 */
+	uint32_t freg[5];
+	uint32_t _reserved1[3];
+	uint32_t pr[5];			/* 0x74 */
+	uint32_t _reserved2[2];
+	uint8_t ssfs;			/* 0x90 */
+	uint8_t ssfc[3];
+	uint16_t preop;			/* 0x94 */
+	uint16_t optype;
+	uint8_t opmenu[8];		/* 0x98 */
+	uint32_t bbar;
+	uint8_t _reserved3[12];
+	uint32_t fdoc;
+	uint32_t fdod;
+	uint8_t _reserved4[8];
+	uint32_t afc;
+	uint32_t lvscc;
+	uint32_t uvscc;
+	uint8_t _reserved5[4];
+	uint32_t fpb;
+	uint8_t _reserved6[28];
+	uint32_t srdl;
+	uint32_t srdc;
+	uint32_t srd;
+} __packed;
+
+enum {
+	SPIS_SCIP =		0x0001,
+	SPIS_GRANT =		0x0002,
+	SPIS_CDS =		0x0004,
+	SPIS_FCERR =		0x0008,
+	SSFS_AEL =		0x0010,
+	SPIS_LOCK =		0x8000,
+	SPIS_RESERVED_MASK =	0x7ff0,
+	SSFS_RESERVED_MASK =	0x7fe2
+};
+
+enum {
+	SPIC_SCGO =		0x000002,
+	SPIC_ACS =		0x000004,
+	SPIC_SPOP =		0x000008,
+	SPIC_DBC =		0x003f00,
+	SPIC_DS =		0x004000,
+	SPIC_SME =		0x008000,
+	SSFC_SCF_MASK =		0x070000,
+	SSFC_RESERVED =		0xf80000,
+
+	/* Mask for speed byte, biuts 23:16 of SSFC */
+	SSFC_SCF_33MHZ	=	0x01,
+};
+
+enum {
+	HSFS_FDONE =		0x0001,
+	HSFS_FCERR =		0x0002,
+	HSFS_AEL =		0x0004,
+	HSFS_BERASE_MASK =	0x0018,
+	HSFS_BERASE_SHIFT =	3,
+	HSFS_SCIP =		0x0020,
+	HSFS_FDOPSS =		0x2000,
+	HSFS_FDV =		0x4000,
+	HSFS_FLOCKDN =		0x8000
+};
+
+enum {
+	HSFC_FGO =		0x0001,
+	HSFC_FCYCLE_MASK =	0x0006,
+	HSFC_FCYCLE_SHIFT =	1,
+	HSFC_FDBC_MASK =	0x3f00,
+	HSFC_FDBC_SHIFT =	8,
+	HSFC_FSMIE =		0x8000
+};
+
+enum {
+	SPI_OPCODE_TYPE_READ_NO_ADDRESS =	0,
+	SPI_OPCODE_TYPE_WRITE_NO_ADDRESS =	1,
+	SPI_OPCODE_TYPE_READ_WITH_ADDRESS =	2,
+	SPI_OPCODE_TYPE_WRITE_WITH_ADDRESS =	3
+};
+
+enum {
+	ICH_MAX_CMD_LEN		= 5,
+};
+
+struct spi_trans {
+	uint8_t cmd[ICH_MAX_CMD_LEN];
+	int cmd_len;
+	const uint8_t *out;
+	uint32_t bytesout;
+	uint8_t *in;
+	uint32_t bytesin;
+	uint8_t type;
+	uint8_t opcode;
+	uint32_t offset;
+};
+
+struct ich_spi_slave {
+	struct spi_slave slave;
+	struct spi_trans trans;	/* current transaction in progress */
+	int speed;		/* SPI speed in Hz */
+};
diff --git a/drivers/spi/kirkwood_spi.c b/drivers/spi/kirkwood_spi.c
index de81064..942a208 100644
--- a/drivers/spi/kirkwood_spi.c
+++ b/drivers/spi/kirkwood_spi.c
@@ -5,23 +5,7 @@
  *
  * Derived from drivers/spi/mpc8xxx_spi.c
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -49,13 +33,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	slave = malloc(sizeof(struct spi_slave));
+	slave = spi_alloc_slave_base(bus, cs);
 	if (!slave)
 		return NULL;
 
-	slave->bus = bus;
-	slave->cs = cs;
-
 	writel(~KWSPI_CSN_ACT | KWSPI_SMEMRDY, &spireg->ctrl);
 
 	/* calculate spi clock prescaller using max_hz */
diff --git a/drivers/spi/mpc52xx_spi.c b/drivers/spi/mpc52xx_spi.c
index 3e96b3f..4613bec 100644
--- a/drivers/spi/mpc52xx_spi.c
+++ b/drivers/spi/mpc52xx_spi.c
@@ -3,23 +3,7 @@
  * Frank Bodammer <frank.bodammer@gcd-solutions.de>
  * (C) Copyright 2009 Semihalf, Grzegorz Bernacki
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -48,13 +32,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 {
 	struct spi_slave *slave;
 
-	slave = malloc(sizeof(struct spi_slave));
+	slave = spi_alloc_slave_base(bus, cs);
 	if (!slave)
 		return NULL;
 
-	slave->bus = bus;
-	slave->cs = cs;
-
 	return slave;
 }
 
diff --git a/drivers/spi/mpc8xxx_spi.c b/drivers/spi/mpc8xxx_spi.c
index 4e46041..0d59c36 100644
--- a/drivers/spi/mpc8xxx_spi.c
+++ b/drivers/spi/mpc8xxx_spi.c
@@ -2,23 +2,7 @@
  * Copyright (c) 2006 Ben Warren, Qstreams Networks Inc.
  * With help from the common/soft_spi and arch/powerpc/cpu/mpc8260 drivers
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -45,13 +29,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	slave = malloc(sizeof(struct spi_slave));
+	slave = spi_alloc_slave_base(bus, cs);
 	if (!slave)
 		return NULL;
 
-	slave->bus = bus;
-	slave->cs = cs;
-
 	/*
 	 * TODO: Some of the code in spi_init() should probably move
 	 * here, or into spi_claim_bus() below.
@@ -96,7 +77,7 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 {
 	volatile spi8xxx_t *spi = &((immap_t *) (CONFIG_SYS_IMMR))->spi;
 	unsigned int tmpdout, tmpdin, event;
-	int numBlks = bitlen / 32 + (bitlen % 32 ? 1 : 0);
+	int numBlks = DIV_ROUND_UP(bitlen, 32);
 	int tm, isRead = 0;
 	unsigned char charSize = 32;
 
@@ -129,10 +110,10 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 		if (bitlen <= 16) {
 			if (bitlen <= 4)
 				spi->mode = (spi->mode & 0xff0fffff) |
-				            (3 << 20);
+					    (3 << 20);
 			else
 				spi->mode = (spi->mode & 0xff0fffff) |
-				            ((bitlen - 1) << 20);
+					    ((bitlen - 1) << 20);
 		} else {
 			spi->mode = (spi->mode & 0xff0fffff);
 			/* Set up the next iteration if sending > 32 bits */
diff --git a/drivers/spi/mxc_spi.c b/drivers/spi/mxc_spi.c
index 859c43f..2d5f385 100644
--- a/drivers/spi/mxc_spi.c
+++ b/drivers/spi/mxc_spi.c
@@ -1,21 +1,7 @@
 /*
  * Copyright (C) 2008, Guennadi Liakhovetski <lg@denx.de>
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- *
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -44,6 +30,10 @@ static unsigned long spi_bases[] = {
 #define reg_read readl
 #define reg_write(a, v) writel(v, a)
 
+#if !defined(CONFIG_SYS_SPI_MXC_WAIT)
+#define CONFIG_SYS_SPI_MXC_WAIT		(CONFIG_SYS_HZ/100)	/* 10 ms */
+#endif
+
 struct mxc_spi_slave {
 	struct spi_slave slave;
 	unsigned long	base;
@@ -128,8 +118,9 @@ static s32 spi_cfg_mxc(struct mxc_spi_slave *mxcs, unsigned int cs,
 		unsigned int max_hz, unsigned int mode)
 {
 	u32 clk_src = mxc_get_clock(MXC_CSPI_CLK);
-	s32 pre_div = 0, post_div = 0, i, reg_ctrl, reg_config;
-	u32 ss_pol = 0, sclkpol = 0, sclkpha = 0;
+	s32 reg_ctrl, reg_config;
+	u32 ss_pol = 0, sclkpol = 0, sclkpha = 0, sclkctl = 0;
+	u32 pre_div = 0, post_div = 0;
 	struct cspi_regs *regs = (struct cspi_regs *)mxcs->base;
 
 	if (max_hz == 0) {
@@ -137,32 +128,30 @@ static s32 spi_cfg_mxc(struct mxc_spi_slave *mxcs, unsigned int cs,
 		return -1;
 	}
 
-	reg_ctrl = reg_read(&regs->ctrl);
-
-	/* Reset spi */
-	reg_write(&regs->ctrl, (reg_ctrl & ~MXC_CSPICTRL_EN));
-	reg_write(&regs->ctrl, (reg_ctrl | MXC_CSPICTRL_EN));
-
 	/*
-	 * The following computation is taken directly from Freescale's code.
+	 * Reset SPI and set all CSs to master mode, if toggling
+	 * between slave and master mode we might see a glitch
+	 * on the clock line
 	 */
+	reg_ctrl = MXC_CSPICTRL_MODE_MASK;
+	reg_write(&regs->ctrl, reg_ctrl);
+	reg_ctrl |=  MXC_CSPICTRL_EN;
+	reg_write(&regs->ctrl, reg_ctrl);
+
 	if (clk_src > max_hz) {
-		pre_div = DIV_ROUND_UP(clk_src, max_hz);
-		if (pre_div > 16) {
-			post_div = pre_div / 16;
-			pre_div = 15;
-		}
-		if (post_div != 0) {
-			for (i = 0; i < 16; i++) {
-				if ((1 << i) >= post_div)
-					break;
-			}
-			if (i == 16) {
+		pre_div = (clk_src - 1) / max_hz;
+		/* fls(1) = 1, fls(0x80000000) = 32, fls(16) = 5 */
+		post_div = fls(pre_div);
+		if (post_div > 4) {
+			post_div -= 4;
+			if (post_div >= 16) {
 				printf("Error: no divider for the freq: %d\n",
 					max_hz);
 				return -1;
 			}
-			post_div = i;
+			pre_div >>= post_div;
+		} else {
+			post_div = 0;
 		}
 	}
 
@@ -174,17 +163,16 @@ static s32 spi_cfg_mxc(struct mxc_spi_slave *mxcs, unsigned int cs,
 	reg_ctrl = (reg_ctrl & ~MXC_CSPICTRL_POSTDIV(0x0F)) |
 		MXC_CSPICTRL_POSTDIV(post_div);
 
-	/* always set to master mode */
-	reg_ctrl |= 1 << (cs + 4);
-
 	/* We need to disable SPI before changing registers */
 	reg_ctrl &= ~MXC_CSPICTRL_EN;
 
 	if (mode & SPI_CS_HIGH)
 		ss_pol = 1;
 
-	if (mode & SPI_CPOL)
+	if (mode & SPI_CPOL) {
 		sclkpol = 1;
+		sclkctl = 1;
+	}
 
 	if (mode & SPI_CPHA)
 		sclkpha = 1;
@@ -199,6 +187,8 @@ static s32 spi_cfg_mxc(struct mxc_spi_slave *mxcs, unsigned int cs,
 		(ss_pol << (cs + MXC_CSPICON_SSPOL));
 	reg_config = (reg_config & ~(1 << (cs + MXC_CSPICON_POL))) |
 		(sclkpol << (cs + MXC_CSPICON_POL));
+	reg_config = (reg_config & ~(1 << (cs + MXC_CSPICON_CTL))) |
+		(sclkctl << (cs + MXC_CSPICON_CTL));
 	reg_config = (reg_config & ~(1 << (cs + MXC_CSPICON_PHA))) |
 		(sclkpha << (cs + MXC_CSPICON_PHA));
 
@@ -223,9 +213,11 @@ int spi_xchg_single(struct spi_slave *slave, unsigned int bitlen,
 	const u8 *dout, u8 *din, unsigned long flags)
 {
 	struct mxc_spi_slave *mxcs = to_mxc_spi_slave(slave);
-	int nbytes = (bitlen + 7) / 8;
+	int nbytes = DIV_ROUND_UP(bitlen, 8);
 	u32 data, cnt, i;
 	struct cspi_regs *regs = (struct cspi_regs *)mxcs->base;
+	u32 ts;
+	int status;
 
 	debug("%s: bitlen %d dout 0x%x din 0x%x\n",
 		__func__, bitlen, (u32)dout, (u32)din);
@@ -274,8 +266,8 @@ int spi_xchg_single(struct spi_slave *slave, unsigned int bitlen,
 			} else {
 				data = *(u32 *)dout;
 				data = cpu_to_be32(data);
+				dout += 4;
 			}
-			dout += 4;
 		}
 		debug("Sending SPI 0x%x\n", data);
 		reg_write(&regs->txdata, data);
@@ -286,14 +278,21 @@ int spi_xchg_single(struct spi_slave *slave, unsigned int bitlen,
 	reg_write(&regs->ctrl, mxcs->ctrl_reg |
 		MXC_CSPICTRL_EN | MXC_CSPICTRL_XCH);
 
+	ts = get_timer(0);
+	status = reg_read(&regs->stat);
 	/* Wait until the TC (Transfer completed) bit is set */
-	while ((reg_read(&regs->stat) & MXC_CSPICTRL_TC) == 0)
-		;
+	while ((status & MXC_CSPICTRL_TC) == 0) {
+		if (get_timer(ts) > CONFIG_SYS_SPI_MXC_WAIT) {
+			printf("spi_xchg_single: Timeout!\n");
+			return -1;
+		}
+		status = reg_read(&regs->stat);
+	}
 
 	/* Transfer completed, clear any pending request */
 	reg_write(&regs->stat, MXC_CSPICTRL_TC | MXC_CSPICTRL_RXOVF);
 
-	nbytes = (bitlen + 7) / 8;
+	nbytes = DIV_ROUND_UP(bitlen, 8);
 
 	cnt = nbytes % 32;
 
@@ -329,7 +328,7 @@ int spi_xchg_single(struct spi_slave *slave, unsigned int bitlen,
 int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 		void *din, unsigned long flags)
 {
-	int n_bytes = (bitlen + 7) / 8;
+	int n_bytes = DIV_ROUND_UP(bitlen, 8);
 	int n_bits;
 	int ret;
 	u32 blk_size;
@@ -408,7 +407,7 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (bus >= ARRAY_SIZE(spi_bases))
 		return NULL;
 
-	mxcs = calloc(sizeof(struct mxc_spi_slave), 1);
+	mxcs = spi_alloc_slave(struct mxc_spi_slave, bus, cs);
 	if (!mxcs) {
 		puts("mxc_spi: SPI Slave not allocated !\n");
 		return NULL;
@@ -424,8 +423,6 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 
 	cs = ret;
 
-	mxcs->slave.bus = bus;
-	mxcs->slave.cs = cs;
 	mxcs->base = spi_bases[bus];
 
 	ret = spi_cfg_mxc(mxcs, cs, max_hz, mode);
diff --git a/drivers/spi/mxs_spi.c b/drivers/spi/mxs_spi.c
index 42e4c99..2b9f395 100644
--- a/drivers/spi/mxs_spi.c
+++ b/drivers/spi/mxs_spi.c
@@ -4,20 +4,7 @@
  * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
  * on behalf of DENX Software Engineering GmbH
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  *
  * NOTE: This driver only supports the SPI-controller chipselects,
  *       GPIO driven chipselects are not supported.
@@ -31,7 +18,7 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/sys_proto.h>
-#include <asm/arch/dma.h>
+#include <asm/imx-common/dma.h>
 
 #define	MXS_SPI_MAX_TIMEOUT	1000000
 #define	MXS_SPI_PORT_OFFSET	0x2000
@@ -40,17 +27,6 @@
 
 #define MXSSSP_SMALL_TRANSFER	512
 
-/*
- * CONFIG_MXS_SPI_DMA_ENABLE: Experimental mixed PIO/DMA support for MXS SPI
- *                            host. Use with utmost caution!
- *
- *                            Enabling this is not yet recommended since this
- *                            still doesn't support transfers to/from unaligned
- *                            addresses. Therefore this driver will not work
- *                            for example with saving environment. This is
- *                            caused by DMA alignment constraints on MXS.
- */
-
 struct mxs_spi_slave {
 	struct spi_slave	slave;
 	uint32_t		max_khz;
@@ -70,7 +46,7 @@ void spi_init(void)
 int spi_cs_is_valid(unsigned int bus, unsigned int cs)
 {
 	/* MXS SPI: 4 ports and 3 chip selects maximum */
-	if (bus > 3 || cs > 2)
+	if (!mxs_ssp_bus_id_valid(bus) || cs > 2)
 		return 0;
 	else
 		return 1;
@@ -80,36 +56,23 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 				  unsigned int max_hz, unsigned int mode)
 {
 	struct mxs_spi_slave *mxs_slave;
-	uint32_t addr;
-	struct mxs_ssp_regs *ssp_regs;
-	int reg;
 
 	if (!spi_cs_is_valid(bus, cs)) {
 		printf("mxs_spi: invalid bus %d / chip select %d\n", bus, cs);
 		return NULL;
 	}
 
-	mxs_slave = calloc(sizeof(struct mxs_spi_slave), 1);
+	mxs_slave = spi_alloc_slave(struct mxs_spi_slave, bus, cs);
 	if (!mxs_slave)
 		return NULL;
 
-	if (mxs_dma_init_channel(bus))
+	if (mxs_dma_init_channel(MXS_DMA_CHANNEL_AHB_APBH_SSP0 + bus))
 		goto err_init;
 
-	addr = MXS_SSP0_BASE + (bus * MXS_SPI_PORT_OFFSET);
-
-	mxs_slave->slave.bus = bus;
-	mxs_slave->slave.cs = cs;
 	mxs_slave->max_khz = max_hz / 1000;
 	mxs_slave->mode = mode;
-	mxs_slave->regs = (struct mxs_ssp_regs *)addr;
-	ssp_regs = mxs_slave->regs;
+	mxs_slave->regs = mxs_ssp_regs_by_bus(bus);
 
-	reg = readl(&ssp_regs->hw_ssp_ctrl0);
-	reg &= ~(MXS_SSP_CHIPSELECT_MASK);
-	reg |= cs << MXS_SSP_CHIPSELECT_SHIFT;
-
-	writel(reg, &ssp_regs->hw_ssp_ctrl0);
 	return &mxs_slave->slave;
 
 err_init:
@@ -131,7 +94,9 @@ int spi_claim_bus(struct spi_slave *slave)
 
 	mxs_reset_block(&ssp_regs->hw_ssp_ctrl0_reg);
 
-	writel(SSP_CTRL0_BUS_WIDTH_ONE_BIT, &ssp_regs->hw_ssp_ctrl0);
+	writel((slave->cs << MXS_SSP_CHIPSELECT_SHIFT) |
+	       SSP_CTRL0_BUS_WIDTH_ONE_BIT,
+	       &ssp_regs->hw_ssp_ctrl0);
 
 	reg = SSP_CTRL1_SSP_MODE_SPI | SSP_CTRL1_WORD_LENGTH_EIGHT_BITS;
 	reg |= (mxs_slave->mode & SPI_CPOL) ? SSP_CTRL1_POLARITY : 0;
@@ -140,7 +105,7 @@ int spi_claim_bus(struct spi_slave *slave)
 
 	writel(0, &ssp_regs->hw_ssp_cmd0);
 
-	mx28_set_ssp_busclock(slave->bus, mxs_slave->max_khz);
+	mxs_set_ssp_busclock(slave->bus, mxs_slave->max_khz);
 
 	return 0;
 }
@@ -171,7 +136,12 @@ static int mxs_spi_xfer_pio(struct mxs_spi_slave *slave,
 
 	while (length--) {
 		/* We transfer 1 byte */
+#if defined(CONFIG_MX23)
+		writel(SSP_CTRL0_XFER_COUNT_MASK, &ssp_regs->hw_ssp_ctrl0_clr);
+		writel(1, &ssp_regs->hw_ssp_ctrl0_set);
+#elif defined(CONFIG_MX28)
 		writel(1, &ssp_regs->hw_ssp_xfer_size);
+#endif
 
 		if ((flags & SPI_XFER_END) && !length)
 			mxs_spi_end_xfer(ssp_regs);
@@ -229,6 +199,12 @@ static int mxs_spi_xfer_dma(struct mxs_spi_slave *slave,
 	int tl;
 	int ret = 0;
 
+#if defined(CONFIG_MX23)
+	const int mxs_spi_pio_words = 1;
+#elif defined(CONFIG_MX28)
+	const int mxs_spi_pio_words = 4;
+#endif
+
 	ALLOC_CACHE_ALIGN_BUFFER(struct mxs_dma_desc, desc, desc_count);
 
 	memset(desc, 0, sizeof(struct mxs_dma_desc) * desc_count);
@@ -284,7 +260,7 @@ static int mxs_spi_xfer_dma(struct mxs_spi_slave *slave,
 
 		dp->cmd.data |=
 			((tl & 0xffff) << MXS_DMA_DESC_BYTES_OFFSET) |
-			(4 << MXS_DMA_DESC_PIO_WORDS_OFFSET) |
+			(mxs_spi_pio_words << MXS_DMA_DESC_PIO_WORDS_OFFSET) |
 			MXS_DMA_DESC_HALT_ON_TERMINATE |
 			MXS_DMA_DESC_TERMINATE_FLUSH;
 
@@ -301,15 +277,19 @@ static int mxs_spi_xfer_dma(struct mxs_spi_slave *slave,
 		}
 
 		/*
-		 * Write CTRL0, CMD0, CMD1, XFER_SIZE registers. It is
+		 * Write CTRL0, CMD0, CMD1 and XFER_SIZE registers in
+		 * case of MX28, write only CTRL0 in case of MX23 due
+		 * to the difference in register layout. It is utterly
 		 * essential that the XFER_SIZE register is written on
 		 * a per-descriptor basis with the same size as is the
 		 * descriptor!
 		 */
 		dp->cmd.pio_words[0] = ctrl0;
+#ifdef CONFIG_MX28
 		dp->cmd.pio_words[1] = 0;
 		dp->cmd.pio_words[2] = 0;
 		dp->cmd.pio_words[3] = tl;
+#endif
 
 		mxs_dma_desc_append(dmach, dp);
 
@@ -335,12 +315,7 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 	char dummy;
 	int write = 0;
 	char *data = NULL;
-
-#ifdef CONFIG_MXS_SPI_DMA_ENABLE
 	int dma = 1;
-#else
-	int dma = 0;
-#endif
 
 	if (bitlen == 0) {
 		if (flags & SPI_XFER_END) {
diff --git a/drivers/spi/oc_tiny_spi.c b/drivers/spi/oc_tiny_spi.c
index fc01fb8..4de5d00 100644
--- a/drivers/spi/oc_tiny_spi.c
+++ b/drivers/spi/oc_tiny_spi.c
@@ -7,7 +7,7 @@
  * Copyright (c) 2005-2008 Analog Devices Inc.
  * Copyright (C) 2010 Thomas Chou <thomas@wytron.com.tw>
  *
- * Licensed under the GPL-2 or later.
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -90,13 +90,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs) || gpio_request(cs, "tiny_spi"))
 		return NULL;
 
-	tiny_spi = malloc(sizeof(*tiny_spi));
+	tiny_spi = spi_alloc_slave(struct tiny_spi_slave, bus, cs);
 	if (!tiny_spi)
 		return NULL;
-	memset(tiny_spi, 0, sizeof(*tiny_spi));
 
-	tiny_spi->slave.bus = bus;
-	tiny_spi->slave.cs = cs;
 	tiny_spi->host = &tiny_spi_host_list[bus];
 	tiny_spi->mode = mode & (SPI_CPOL | SPI_CPHA);
 	tiny_spi->flg = mode & SPI_CS_HIGH ? 1 : 0;
diff --git a/drivers/spi/omap3_spi.c b/drivers/spi/omap3_spi.c
index 344d5b8..651e46e 100644
--- a/drivers/spi/omap3_spi.c
+++ b/drivers/spi/omap3_spi.c
@@ -11,24 +11,7 @@
  *
  * Modified by Ruslan Araslanov <ruslan.araslanov@vitecmm.com>
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- *
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -37,8 +20,7 @@
 #include <asm/io.h>
 #include "omap3_spi.h"
 
-#define WORD_LEN	8
-#define SPI_WAIT_TIMEOUT 3000000;
+#define SPI_WAIT_TIMEOUT 3000000
 
 static void spi_reset(struct omap3_spi_slave *ds)
 {
@@ -67,7 +49,7 @@ static void omap3_spi_write_chconf(struct omap3_spi_slave *ds, int val)
 static void omap3_spi_set_enable(struct omap3_spi_slave *ds, int enable)
 {
 	writel(enable, &ds->regs->channel[ds->slave.cs].chctrl);
-        /* Flash post writes to make immediate effect */
+	/* Flash post writes to make immediate effect */
 	readl(&ds->regs->channel[ds->slave.cs].chctrl);
 }
 
@@ -80,12 +62,7 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 				  unsigned int max_hz, unsigned int mode)
 {
 	struct omap3_spi_slave	*ds;
-
-	ds = malloc(sizeof(struct omap3_spi_slave));
-	if (!ds) {
-		printf("SPI error: malloc of SPI structure failed\n");
-		return NULL;
-	}
+	struct mcspi *regs;
 
 	/*
 	 * OMAP3 McSPI (MultiChannel SPI) has 4 busses (modules)
@@ -98,21 +75,21 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 
 	switch (bus) {
 	case 0:
-		ds->regs = (struct mcspi *)OMAP3_MCSPI1_BASE;
+		regs = (struct mcspi *)OMAP3_MCSPI1_BASE;
 		break;
 #ifdef OMAP3_MCSPI2_BASE
 	case 1:
-		ds->regs = (struct mcspi *)OMAP3_MCSPI2_BASE;
+		regs = (struct mcspi *)OMAP3_MCSPI2_BASE;
 		break;
 #endif
-#ifdef OMAP3_MCSPI3_BASE 
+#ifdef OMAP3_MCSPI3_BASE
 	case 2:
-		ds->regs = (struct mcspi *)OMAP3_MCSPI3_BASE;
+		regs = (struct mcspi *)OMAP3_MCSPI3_BASE;
 		break;
 #endif
 #ifdef OMAP3_MCSPI4_BASE
 	case 3:
-		ds->regs = (struct mcspi *)OMAP3_MCSPI4_BASE;
+		regs = (struct mcspi *)OMAP3_MCSPI4_BASE;
 		break;
 #endif
 	default:
@@ -120,7 +97,6 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 			Supported busses 0 - 3\n", bus);
 		return NULL;
 	}
-	ds->slave.bus = bus;
 
 	if (((bus == 0) && (cs > 3)) ||
 			((bus == 1) && (cs > 1)) ||
@@ -130,19 +106,26 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 			on bus %i\n", cs, bus);
 		return NULL;
 	}
-	ds->slave.cs = cs;
 
 	if (max_hz > OMAP3_MCSPI_MAX_FREQ) {
 		printf("SPI error: unsupported frequency %i Hz. \
 			Max frequency is 48 Mhz\n", max_hz);
 		return NULL;
 	}
-	ds->freq = max_hz;
 
 	if (mode > SPI_MODE_3) {
 		printf("SPI error: unsupported SPI mode %i\n", mode);
 		return NULL;
 	}
+
+	ds = spi_alloc_slave(struct omap3_spi_slave, bus, cs);
+	if (!ds) {
+		printf("SPI error: malloc of SPI structure failed\n");
+		return NULL;
+	}
+
+	ds->regs = regs;
+	ds->freq = max_hz;
 	ds->mode = mode;
 
 	return &ds->slave;
@@ -201,7 +184,7 @@ int spi_claim_bus(struct spi_slave *slave)
 
 	/* wordlength */
 	conf &= ~OMAP3_MCSPI_CHCONF_WL_MASK;
-	conf |= (WORD_LEN - 1) << 7;
+	conf |= (ds->slave.wordlen - 1) << 7;
 
 	/* set chipselect polarity; manage with FORCE */
 	if (!(ds->mode & SPI_CS_HIGH))
@@ -239,7 +222,7 @@ void spi_release_bus(struct spi_slave *slave)
 	spi_reset(ds);
 }
 
-int omap3_spi_write(struct spi_slave *slave, unsigned int len, const u8 *txp,
+int omap3_spi_write(struct spi_slave *slave, unsigned int len, const void *txp,
 		    unsigned long flags)
 {
 	struct omap3_spi_slave *ds = to_omap3_spi(slave);
@@ -250,7 +233,8 @@ int omap3_spi_write(struct spi_slave *slave, unsigned int len, const u8 *txp,
 	/* Enable the channel */
 	omap3_spi_set_enable(ds,OMAP3_MCSPI_CHCTRL_EN);
 
-	chconf &= ~OMAP3_MCSPI_CHCONF_TRM_MASK;
+	chconf &= ~(OMAP3_MCSPI_CHCONF_TRM_MASK | OMAP3_MCSPI_CHCONF_WL_MASK);
+	chconf |= (ds->slave.wordlen - 1) << 7;
 	chconf |= OMAP3_MCSPI_CHCONF_TRM_TX_ONLY;
 	chconf |= OMAP3_MCSPI_CHCONF_FORCE;
 	omap3_spi_write_chconf(ds,chconf);
@@ -266,12 +250,19 @@ int omap3_spi_write(struct spi_slave *slave, unsigned int len, const u8 *txp,
 			}
 		}
 		/* Write the data */
-		writel(txp[i], &ds->regs->channel[ds->slave.cs].tx);
+		unsigned int *tx = &ds->regs->channel[ds->slave.cs].tx;
+		if (ds->slave.wordlen > 16)
+			writel(((u32 *)txp)[i], tx);
+		else if (ds->slave.wordlen > 8)
+			writel(((u16 *)txp)[i], tx);
+		else
+			writel(((u8 *)txp)[i], tx);
 	}
 
-        /* wait to finish of transfer */
-        while (!(readl(&ds->regs->channel[ds->slave.cs].chstat) &
-                         OMAP3_MCSPI_CHSTAT_EOT));
+	/* wait to finish of transfer */
+	while ((readl(&ds->regs->channel[ds->slave.cs].chstat) &
+			 (OMAP3_MCSPI_CHSTAT_EOT | OMAP3_MCSPI_CHSTAT_TXS)) !=
+			 (OMAP3_MCSPI_CHSTAT_EOT | OMAP3_MCSPI_CHSTAT_TXS));
 
 	/* Disable the channel otherwise the next immediate RX will get affected */
 	omap3_spi_set_enable(ds,OMAP3_MCSPI_CHCTRL_DIS);
@@ -284,7 +275,7 @@ int omap3_spi_write(struct spi_slave *slave, unsigned int len, const u8 *txp,
 	return 0;
 }
 
-int omap3_spi_read(struct spi_slave *slave, unsigned int len, u8 *rxp,
+int omap3_spi_read(struct spi_slave *slave, unsigned int len, void *rxp,
 		   unsigned long flags)
 {
 	struct omap3_spi_slave *ds = to_omap3_spi(slave);
@@ -295,7 +286,8 @@ int omap3_spi_read(struct spi_slave *slave, unsigned int len, u8 *rxp,
 	/* Enable the channel */
 	omap3_spi_set_enable(ds,OMAP3_MCSPI_CHCTRL_EN);
 
-	chconf &= ~OMAP3_MCSPI_CHCONF_TRM_MASK;
+	chconf &= ~(OMAP3_MCSPI_CHCONF_TRM_MASK | OMAP3_MCSPI_CHCONF_WL_MASK);
+	chconf |= (ds->slave.wordlen - 1) << 7;
 	chconf |= OMAP3_MCSPI_CHCONF_TRM_RX_ONLY;
 	chconf |= OMAP3_MCSPI_CHCONF_FORCE;
 	omap3_spi_write_chconf(ds,chconf);
@@ -318,7 +310,13 @@ int omap3_spi_read(struct spi_slave *slave, unsigned int len, u8 *rxp,
 			omap3_spi_set_enable(ds,OMAP3_MCSPI_CHCTRL_DIS);
 
 		/* Read the data */
-		rxp[i] = readl(&ds->regs->channel[ds->slave.cs].rx);
+		unsigned int *rx = &ds->regs->channel[ds->slave.cs].rx;
+		if (ds->slave.wordlen > 16)
+			((u32 *)rxp)[i] = readl(rx);
+		else if (ds->slave.wordlen > 8)
+			((u16 *)rxp)[i] = (u16)readl(rx);
+		else
+			((u8 *)rxp)[i] = (u8)readl(rx);
 	}
 
 	if (flags & SPI_XFER_END) {
@@ -330,8 +328,8 @@ int omap3_spi_read(struct spi_slave *slave, unsigned int len, u8 *rxp,
 }
 
 /*McSPI Transmit Receive Mode*/
-int omap3_spi_txrx(struct spi_slave *slave,
-		unsigned int len, const u8 *txp, u8 *rxp, unsigned long flags)
+int omap3_spi_txrx(struct spi_slave *slave, unsigned int len,
+		   const void *txp, void *rxp, unsigned long flags)
 {
 	struct omap3_spi_slave *ds = to_omap3_spi(slave);
 	int timeout = SPI_WAIT_TIMEOUT;
@@ -343,7 +341,8 @@ int omap3_spi_txrx(struct spi_slave *slave,
 	omap3_spi_set_enable(ds,OMAP3_MCSPI_CHCTRL_EN);
 
 	/*set TRANSMIT-RECEIVE Mode*/
-	chconf &= ~OMAP3_MCSPI_CHCONF_TRM_MASK;
+	chconf &= ~(OMAP3_MCSPI_CHCONF_TRM_MASK | OMAP3_MCSPI_CHCONF_WL_MASK);
+	chconf |= (ds->slave.wordlen - 1) << 7;
 	chconf |= OMAP3_MCSPI_CHCONF_FORCE;
 	omap3_spi_write_chconf(ds,chconf);
 
@@ -360,7 +359,13 @@ int omap3_spi_txrx(struct spi_slave *slave,
 			}
 		}
 		/* Write the data */
-		writel(txp[i], &ds->regs->channel[ds->slave.cs].tx);
+		unsigned int *tx = &ds->regs->channel[ds->slave.cs].tx;
+		if (ds->slave.wordlen > 16)
+			writel(((u32 *)txp)[i], tx);
+		else if (ds->slave.wordlen > 8)
+			writel(((u16 *)txp)[i], tx);
+		else
+			writel(((u8 *)txp)[i], tx);
 
 		/*Read: wait for RX containing data (RXS == 1)*/
 		while (!(readl(&ds->regs->channel[ds->slave.cs].chstat) &
@@ -372,10 +377,16 @@ int omap3_spi_txrx(struct spi_slave *slave,
 			}
 		}
 		/* Read the data */
-		rxp[i] = readl(&ds->regs->channel[ds->slave.cs].rx);
+		unsigned int *rx = &ds->regs->channel[ds->slave.cs].rx;
+		if (ds->slave.wordlen > 16)
+			((u32 *)rxp)[i] = readl(rx);
+		else if (ds->slave.wordlen > 8)
+			((u16 *)rxp)[i] = (u16)readl(rx);
+		else
+			((u8 *)rxp)[i] = (u8)readl(rx);
 	}
 	/* Disable the channel */
-        omap3_spi_set_enable(ds,OMAP3_MCSPI_CHCTRL_DIS);
+	omap3_spi_set_enable(ds,OMAP3_MCSPI_CHCTRL_DIS);
 
 	/*if transfer must be terminated disable the channel*/
 	if (flags & SPI_XFER_END) {
@@ -391,14 +402,17 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 {
 	struct omap3_spi_slave *ds = to_omap3_spi(slave);
 	unsigned int	len;
-	const u8	*txp = dout;
-	u8		*rxp = din;
 	int ret = -1;
 
-	if (bitlen % 8)
+	if (ds->slave.wordlen < 4 || ds->slave.wordlen > 32) {
+		printf("omap3_spi: invalid wordlen %d\n", ds->slave.wordlen);
+		return -1;
+	}
+
+	if (bitlen % ds->slave.wordlen)
 		return -1;
 
-	len = bitlen / 8;
+	len = bitlen / ds->slave.wordlen;
 
 	if (bitlen == 0) {	 /* only change CS */
 		int chconf = readl(&ds->regs->channel[ds->slave.cs].chconf);
@@ -416,11 +430,11 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 		ret = 0;
 	} else {
 		if (dout != NULL && din != NULL)
-			ret = omap3_spi_txrx(slave, len, txp, rxp, flags);
+			ret = omap3_spi_txrx(slave, len, dout, din, flags);
 		else if (dout != NULL)
-			ret = omap3_spi_write(slave, len, txp, flags);
+			ret = omap3_spi_write(slave, len, dout, flags);
 		else if (din != NULL)
-			ret = omap3_spi_read(slave, len, rxp, flags);
+			ret = omap3_spi_read(slave, len, din, flags);
 	}
 	return ret;
 }
diff --git a/drivers/spi/omap3_spi.h b/drivers/spi/omap3_spi.h
index 5e00208..ab7cd84 100644
--- a/drivers/spi/omap3_spi.h
+++ b/drivers/spi/omap3_spi.h
@@ -8,23 +8,7 @@
  *
  * Modified by Ruslan Araslanov <ruslan.araslanov@vitecmm.com>
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #ifndef _OMAP3_SPI_H_
@@ -115,11 +99,11 @@ static inline struct omap3_spi_slave *to_omap3_spi(struct spi_slave *slave)
 	return container_of(slave, struct omap3_spi_slave, slave);
 }
 
-int omap3_spi_txrx(struct spi_slave *slave, unsigned int len, const u8 *txp,
-			u8 *rxp, unsigned long flags);
-int omap3_spi_write(struct spi_slave *slave, unsigned int len, const u8 *txp,
+int omap3_spi_txrx(struct spi_slave *slave, unsigned int len, const void *txp,
+			void *rxp, unsigned long flags);
+int omap3_spi_write(struct spi_slave *slave, unsigned int len, const void *txp,
 		    unsigned long flags);
-int omap3_spi_read(struct spi_slave *slave, unsigned int len, u8 *rxp,
+int omap3_spi_read(struct spi_slave *slave, unsigned int len, void *rxp,
 		   unsigned long flags);
 
 #endif /* _OMAP3_SPI_H_ */
diff --git a/drivers/spi/sandbox_spi.c b/drivers/spi/sandbox_spi.c
new file mode 100644
index 0000000..12e9bda
--- /dev/null
+++ b/drivers/spi/sandbox_spi.c
@@ -0,0 +1,217 @@
+/*
+ * Simulate a SPI port
+ *
+ * Copyright (c) 2011-2013 The Chromium OS Authors.
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <os.h>
+
+#include <asm/errno.h>
+#include <asm/spi.h>
+#include <asm/state.h>
+
+#ifndef CONFIG_SPI_IDLE_VAL
+# define CONFIG_SPI_IDLE_VAL 0xFF
+#endif
+
+struct sandbox_spi_slave {
+	struct spi_slave slave;
+	const struct sandbox_spi_emu_ops *ops;
+	void *priv;
+};
+
+#define to_sandbox_spi_slave(s) container_of(s, struct sandbox_spi_slave, slave)
+
+const char *sandbox_spi_parse_spec(const char *arg, unsigned long *bus,
+				   unsigned long *cs)
+{
+	char *endp;
+
+	*bus = simple_strtoul(arg, &endp, 0);
+	if (*endp != ':' || *bus >= CONFIG_SANDBOX_SPI_MAX_BUS)
+		return NULL;
+
+	*cs = simple_strtoul(endp + 1, &endp, 0);
+	if (*endp != ':' || *cs >= CONFIG_SANDBOX_SPI_MAX_CS)
+		return NULL;
+
+	return endp + 1;
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return bus < CONFIG_SANDBOX_SPI_MAX_BUS &&
+		cs < CONFIG_SANDBOX_SPI_MAX_CS;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct sandbox_spi_slave *sss = to_sandbox_spi_slave(slave);
+
+	debug("sandbox_spi: activating CS\n");
+	if (sss->ops->cs_activate)
+		sss->ops->cs_activate(sss->priv);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct sandbox_spi_slave *sss = to_sandbox_spi_slave(slave);
+
+	debug("sandbox_spi: deactivating CS\n");
+	if (sss->ops->cs_deactivate)
+		sss->ops->cs_deactivate(sss->priv);
+}
+
+void spi_init(void)
+{
+}
+
+void spi_set_speed(struct spi_slave *slave, uint hz)
+{
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct sandbox_spi_slave *sss;
+	struct sandbox_state *state = state_get_current();
+	const char *spec;
+
+	if (!spi_cs_is_valid(bus, cs)) {
+		debug("sandbox_spi: Invalid SPI bus/cs\n");
+		return NULL;
+	}
+
+	sss = spi_alloc_slave(struct sandbox_spi_slave, bus, cs);
+	if (!sss) {
+		debug("sandbox_spi: Out of memory\n");
+		return NULL;
+	}
+
+	spec = state->spi[bus][cs].spec;
+	sss->ops = state->spi[bus][cs].ops;
+	if (!spec || !sss->ops || sss->ops->setup(&sss->priv, spec)) {
+		free(sss);
+		printf("sandbox_spi: unable to locate a slave client\n");
+		return NULL;
+	}
+
+	return &sss->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct sandbox_spi_slave *sss = to_sandbox_spi_slave(slave);
+
+	debug("sandbox_spi: releasing slave\n");
+
+	if (sss->ops->free)
+		sss->ops->free(sss->priv);
+
+	free(sss);
+}
+
+static int spi_bus_claim_cnt[CONFIG_SANDBOX_SPI_MAX_BUS];
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	if (spi_bus_claim_cnt[slave->bus]++) {
+		printf("sandbox_spi: error: bus already claimed: %d!\n",
+		       spi_bus_claim_cnt[slave->bus]);
+	}
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	if (--spi_bus_claim_cnt[slave->bus]) {
+		printf("sandbox_spi: error: bus freed too often: %d!\n",
+		       spi_bus_claim_cnt[slave->bus]);
+	}
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct sandbox_spi_slave *sss = to_sandbox_spi_slave(slave);
+	uint bytes = bitlen / 8, i;
+	int ret = 0;
+	u8 *tx = (void *)dout, *rx = din;
+
+	if (bitlen == 0)
+		goto done;
+
+	/* we can only do 8 bit transfers */
+	if (bitlen % 8) {
+		printf("sandbox_spi: xfer: invalid bitlen size %u; needs to be 8bit\n",
+		       bitlen);
+		flags |= SPI_XFER_END;
+		goto done;
+	}
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	/* make sure rx/tx buffers are full so clients can assume */
+	if (!tx) {
+		debug("sandbox_spi: xfer: auto-allocating tx scratch buffer\n");
+		tx = malloc(bytes);
+		if (!tx) {
+			debug("sandbox_spi: Out of memory\n");
+			return -ENOMEM;
+		}
+	}
+	if (!rx) {
+		debug("sandbox_spi: xfer: auto-allocating rx scratch buffer\n");
+		rx = malloc(bytes);
+		if (!rx) {
+			debug("sandbox_spi: Out of memory\n");
+			return -ENOMEM;
+		}
+	}
+
+	debug("sandbox_spi: xfer: bytes = %u\n tx:", bytes);
+	for (i = 0; i < bytes; ++i)
+		debug(" %u:%02x", i, tx[i]);
+	debug("\n");
+
+	ret = sss->ops->xfer(sss->priv, tx, rx, bytes);
+
+	debug("sandbox_spi: xfer: got back %i (that's %s)\n rx:",
+	      ret, ret ? "bad" : "good");
+	for (i = 0; i < bytes; ++i)
+		debug(" %u:%02x", i, rx[i]);
+	debug("\n");
+
+	if (tx != dout)
+		free(tx);
+	if (rx != din)
+		free(rx);
+
+ done:
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return ret;
+}
+
+/**
+ * Set up a new SPI slave for an fdt node
+ *
+ * @param blob		Device tree blob
+ * @param node		SPI peripheral node to use
+ * @return 0 if ok, -1 on error
+ */
+struct spi_slave *spi_setup_slave_fdt(const void *blob, int slave_node,
+				      int spi_node)
+{
+	return NULL;
+}
diff --git a/drivers/spi/sh_qspi.c b/drivers/spi/sh_qspi.c
new file mode 100644
index 0000000..77ede6b
--- /dev/null
+++ b/drivers/spi/sh_qspi.c
@@ -0,0 +1,278 @@
+/*
+ * SH QSPI (Quad SPI) driver
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ * Copyright (C) 2013 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <asm/arch/rmobile.h>
+#include <asm/io.h>
+
+/* SH QSPI register bit masks <REG>_<BIT> */
+#define SPCR_MSTR	0x08
+#define SPCR_SPE	0x40
+#define SPSR_SPRFF	0x80
+#define SPSR_SPTEF	0x20
+#define SPPCR_IO3FV	0x04
+#define SPPCR_IO2FV	0x02
+#define SPPCR_IO1FV	0x01
+#define SPBDCR_RXBC0	(1 << 0)
+#define SPCMD_SCKDEN	(1 << 15)
+#define SPCMD_SLNDEN	(1 << 14)
+#define SPCMD_SPNDEN	(1 << 13)
+#define SPCMD_SSLKP	(1 << 7)
+#define SPCMD_BRDV0	(1 << 2)
+#define SPCMD_INIT1	SPCMD_SCKDEN | SPCMD_SLNDEN | \
+			SPCMD_SPNDEN | SPCMD_SSLKP | \
+			SPCMD_BRDV0
+#define SPCMD_INIT2	SPCMD_SPNDEN | SPCMD_SSLKP | \
+			SPCMD_BRDV0
+#define SPBFCR_TXRST	(1 << 7)
+#define SPBFCR_RXRST	(1 << 6)
+
+/* SH QSPI register set */
+struct sh_qspi_regs {
+	unsigned char spcr;
+	unsigned char sslp;
+	unsigned char sppcr;
+	unsigned char spsr;
+	unsigned long spdr;
+	unsigned char spscr;
+	unsigned char spssr;
+	unsigned char spbr;
+	unsigned char spdcr;
+	unsigned char spckd;
+	unsigned char sslnd;
+	unsigned char spnd;
+	unsigned char dummy0;
+	unsigned short spcmd0;
+	unsigned short spcmd1;
+	unsigned short spcmd2;
+	unsigned short spcmd3;
+	unsigned char spbfcr;
+	unsigned char dummy1;
+	unsigned short spbdcr;
+	unsigned long spbmul0;
+	unsigned long spbmul1;
+	unsigned long spbmul2;
+	unsigned long spbmul3;
+};
+
+struct sh_qspi_slave {
+	struct spi_slave	slave;
+	struct sh_qspi_regs	*regs;
+};
+
+static inline struct sh_qspi_slave *to_sh_qspi(struct spi_slave *slave)
+{
+	return container_of(slave, struct sh_qspi_slave, slave);
+}
+
+static void sh_qspi_init(struct sh_qspi_slave *ss)
+{
+	/* QSPI initialize */
+	/* Set master mode only */
+	writeb(SPCR_MSTR, &ss->regs->spcr);
+
+	/* Set SSL signal level */
+	writeb(0x00, &ss->regs->sslp);
+
+	/* Set MOSI signal value when transfer is in idle state */
+	writeb(SPPCR_IO3FV|SPPCR_IO2FV, &ss->regs->sppcr);
+
+	/* Set bit rate. See 58.3.8 Quad Serial Peripheral Interface */
+	writeb(0x01, &ss->regs->spbr);
+
+	/* Disable Dummy Data Transmission */
+	writeb(0x00, &ss->regs->spdcr);
+
+	/* Set clock delay value */
+	writeb(0x00, &ss->regs->spckd);
+
+	/* Set SSL negation delay value */
+	writeb(0x00, &ss->regs->sslnd);
+
+	/* Set next-access delay value */
+	writeb(0x00, &ss->regs->spnd);
+
+	/* Set equence command */
+	writew(SPCMD_INIT2, &ss->regs->spcmd0);
+
+	/* Reset transfer and receive Buffer */
+	setbits_8(&ss->regs->spbfcr, SPBFCR_TXRST|SPBFCR_RXRST);
+
+	/* Clear transfer and receive Buffer control bit */
+	clrbits_8(&ss->regs->spbfcr, SPBFCR_TXRST|SPBFCR_RXRST);
+
+	/* Set equence control method. Use equence0 only */
+	writeb(0x00, &ss->regs->spscr);
+
+	/* Enable SPI function */
+	setbits_8(&ss->regs->spcr, SPCR_SPE);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return 1;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct sh_qspi_slave *ss = to_sh_qspi(slave);
+
+	/* Set master mode only */
+	writeb(SPCR_MSTR, &ss->regs->spcr);
+
+	/* Set command */
+	writew(SPCMD_INIT1, &ss->regs->spcmd0);
+
+	/* Reset transfer and receive Buffer */
+	setbits_8(&ss->regs->spbfcr, SPBFCR_TXRST|SPBFCR_RXRST);
+
+	/* Clear transfer and receive Buffer control bit */
+	clrbits_8(&ss->regs->spbfcr, SPBFCR_TXRST|SPBFCR_RXRST);
+
+	/* Set equence control method. Use equence0 only */
+	writeb(0x00, &ss->regs->spscr);
+
+	/* Enable SPI function */
+	setbits_8(&ss->regs->spcr, SPCR_SPE);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct sh_qspi_slave *ss = to_sh_qspi(slave);
+
+	/* Disable SPI Function */
+	clrbits_8(&ss->regs->spcr, SPCR_SPE);
+}
+
+void spi_init(void)
+{
+	/* nothing to do */
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct sh_qspi_slave *ss;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	ss = spi_alloc_slave(struct sh_qspi_slave, bus, cs);
+	if (!ss) {
+		printf("SPI_error: Fail to allocate sh_qspi_slave\n");
+		return NULL;
+	}
+
+	ss->regs = (struct sh_qspi_regs *)SH_QSPI_BASE;
+
+	/* Init SH QSPI */
+	sh_qspi_init(ss);
+
+	return &ss->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct sh_qspi_slave *spi = to_sh_qspi(slave);
+
+	free(spi);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+	     void *din, unsigned long flags)
+{
+	struct sh_qspi_slave *ss = to_sh_qspi(slave);
+	unsigned long nbyte;
+	int ret = 0;
+	unsigned char dtdata = 0, drdata;
+	unsigned char *tdata = &dtdata, *rdata = &drdata;
+	unsigned long *spbmul0 = &ss->regs->spbmul0;
+
+	if (dout == NULL && din == NULL) {
+		if (flags & SPI_XFER_END)
+			spi_cs_deactivate(slave);
+		return 0;
+	}
+
+	if (bitlen % 8) {
+		printf("%s: bitlen is not 8bit alined %d", __func__, bitlen);
+		return 1;
+	}
+
+	nbyte = bitlen / 8;
+
+	if (flags & SPI_XFER_BEGIN) {
+		spi_cs_activate(slave);
+
+		/* Set 1048576 byte */
+		writel(0x100000, spbmul0);
+	}
+
+	if (flags & SPI_XFER_END)
+		writel(nbyte, spbmul0);
+
+	if (dout != NULL)
+		tdata = (unsigned char *)dout;
+
+	if (din != NULL)
+		rdata = din;
+
+	while (nbyte > 0) {
+		while (!(readb(&ss->regs->spsr) & SPSR_SPTEF)) {
+			if (ctrlc()) {
+				puts("abort\n");
+				return 1;
+			}
+			udelay(10);
+		}
+
+		writeb(*tdata, (unsigned char *)(&ss->regs->spdr));
+
+		while ((readw(&ss->regs->spbdcr) != SPBDCR_RXBC0)) {
+			if (ctrlc()) {
+				puts("abort\n");
+				return 1;
+			}
+			udelay(1);
+		}
+
+		while (!(readb(&ss->regs->spsr) & SPSR_SPRFF)) {
+			if (ctrlc()) {
+				puts("abort\n");
+				return 1;
+			}
+			udelay(10);
+		}
+
+		*rdata = readb((unsigned char *)(&ss->regs->spdr));
+
+		if (dout != NULL)
+			tdata++;
+		if (din != NULL)
+			rdata++;
+
+		nbyte--;
+	}
+
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return ret;
+}
diff --git a/drivers/spi/sh_spi.c b/drivers/spi/sh_spi.c
index e944b23..7ca5e36 100644
--- a/drivers/spi/sh_spi.c
+++ b/drivers/spi/sh_spi.c
@@ -103,12 +103,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	ss = malloc(sizeof(struct spi_slave));
+	ss = spi_alloc_slave(struct sh_spi, bus, cs);
 	if (!ss)
 		return NULL;
 
-	ss->slave.bus = bus;
-	ss->slave.cs = cs;
 	ss->regs = (struct sh_spi_regs *)CONFIG_SH_SPI_BASE;
 
 	/* SPI sycle stop */
@@ -153,7 +151,6 @@ static int sh_spi_send(struct sh_spi *ss, const unsigned char *tx_data,
 {
 	int i, cur_len, ret = 0;
 	int remain = (int)len;
-	unsigned long tmp;
 
 	if (len >= SH_SPI_FIFO_SIZE)
 		sh_spi_set_bit(SH_SPI_SSA, &ss->regs->cr1);
@@ -185,9 +182,7 @@ static int sh_spi_send(struct sh_spi *ss, const unsigned char *tx_data,
 	}
 
 	if (flags & SPI_XFER_END) {
-		tmp = sh_spi_read(&ss->regs->cr1);
-		tmp = tmp & ~(SH_SPI_SSD | SH_SPI_SSDB);
-		sh_spi_write(tmp, &ss->regs->cr1);
+		sh_spi_clear_bit(SH_SPI_SSD | SH_SPI_SSDB, &ss->regs->cr1);
 		sh_spi_set_bit(SH_SPI_SSA, &ss->regs->cr1);
 		udelay(100);
 		write_fifo_empty_wait(ss);
@@ -200,16 +195,13 @@ static int sh_spi_receive(struct sh_spi *ss, unsigned char *rx_data,
 			  unsigned int len, unsigned long flags)
 {
 	int i;
-	unsigned long tmp;
 
 	if (len > SH_SPI_MAX_BYTE)
 		sh_spi_write(SH_SPI_MAX_BYTE, &ss->regs->cr3);
 	else
 		sh_spi_write(len, &ss->regs->cr3);
 
-	tmp = sh_spi_read(&ss->regs->cr1);
-	tmp = tmp & ~(SH_SPI_SSD | SH_SPI_SSDB);
-	sh_spi_write(tmp, &ss->regs->cr1);
+	sh_spi_clear_bit(SH_SPI_SSD | SH_SPI_SSDB, &ss->regs->cr1);
 	sh_spi_set_bit(SH_SPI_SSA, &ss->regs->cr1);
 
 	for (i = 0; i < len; i++) {
diff --git a/drivers/spi/soft_spi.c b/drivers/spi/soft_spi.c
index 13df8cb..c969be3 100644
--- a/drivers/spi/soft_spi.c
+++ b/drivers/spi/soft_spi.c
@@ -5,23 +5,7 @@
  * Influenced by code from:
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -73,12 +57,10 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	if (!spi_cs_is_valid(bus, cs))
 		return NULL;
 
-	ss = malloc(sizeof(struct soft_spi_slave));
+	ss = spi_alloc_slave(struct soft_spi_slave, bus, cs);
 	if (!ss)
 		return NULL;
 
-	ss->slave.bus = bus;
-	ss->slave.cs = cs;
 	ss->mode = mode;
 
 	/* TODO: Use max_hz to limit the SCK rate */
@@ -154,10 +136,14 @@ int  spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 		/*
 		 * Check if it is time to work on a new byte.
 		 */
-		if((j % 8) == 0) {
-			tmpdout = *txd++;
+		if ((j % 8) == 0) {
+			if (txd)
+				tmpdout = *txd++;
+			else
+				tmpdout = 0;
 			if(j != 0) {
-				*rxd++ = tmpdin;
+				if (rxd)
+					*rxd++ = tmpdin;
 			}
 			tmpdin  = 0;
 		}
@@ -182,9 +168,11 @@ int  spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 	 * bits over to left-justify them.  Then store the last byte
 	 * read in.
 	 */
-	if((bitlen % 8) != 0)
-		tmpdin <<= 8 - (bitlen % 8);
-	*rxd++ = tmpdin;
+	if (rxd) {
+		if ((bitlen % 8) != 0)
+			tmpdin <<= 8 - (bitlen % 8);
+		*rxd++ = tmpdin;
+	}
 
 	if (flags & SPI_XFER_END)
 		spi_cs_deactivate(slave);
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
new file mode 100644
index 0000000..7d81fbd
--- /dev/null
+++ b/drivers/spi/spi.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2011 The Chromium OS Authors.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fdtdec.h>
+#include <malloc.h>
+#include <spi.h>
+
+int spi_set_wordlen(struct spi_slave *slave, unsigned int wordlen)
+{
+	if (wordlen == 0 || wordlen > 32) {
+		printf("spi: invalid wordlen %d\n", wordlen);
+		return -1;
+	}
+
+	slave->wordlen = wordlen;
+
+	return 0;
+}
+
+void *spi_do_alloc_slave(int offset, int size, unsigned int bus,
+			 unsigned int cs)
+{
+	struct spi_slave *slave;
+	void *ptr;
+
+	ptr = malloc(size);
+	if (ptr) {
+		memset(ptr, '\0', size);
+		slave = (struct spi_slave *)(ptr + offset);
+		slave->bus = bus;
+		slave->cs = cs;
+		slave->wordlen = SPI_DEFAULT_WORDLEN;
+	}
+
+	return ptr;
+}
+
+#ifdef CONFIG_OF_SPI
+struct spi_slave *spi_base_setup_slave_fdt(const void *blob, int busnum,
+					   int node)
+{
+	int cs, max_hz, mode = 0;
+
+	cs = fdtdec_get_int(blob, node, "reg", -1);
+	max_hz = fdtdec_get_int(blob, node, "spi-max-frequency", 100000);
+	if (fdtdec_get_bool(blob, node, "spi-cpol"))
+		mode |= SPI_CPOL;
+	if (fdtdec_get_bool(blob, node, "spi-cpha"))
+		mode |= SPI_CPHA;
+	if (fdtdec_get_bool(blob, node, "spi-cs-high"))
+		mode |= SPI_CS_HIGH;
+	if (fdtdec_get_bool(blob, node, "spi-half-duplex"))
+		mode |= SPI_PREAMBLE;
+	return spi_setup_slave(busnum, cs, max_hz, mode);
+}
+#endif
diff --git a/drivers/spi/tegra114_spi.c b/drivers/spi/tegra114_spi.c
new file mode 100644
index 0000000..810fa47
--- /dev/null
+++ b/drivers/spi/tegra114_spi.c
@@ -0,0 +1,398 @@
+/*
+ * NVIDIA Tegra SPI controller (T114 and later)
+ *
+ * Copyright (c) 2010-2013 NVIDIA Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch-tegra/clk_rst.h>
+#include <asm/arch-tegra114/tegra114_spi.h>
+#include <spi.h>
+#include <fdtdec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* COMMAND1 */
+#define SPI_CMD1_GO			(1 << 31)
+#define SPI_CMD1_M_S			(1 << 30)
+#define SPI_CMD1_MODE_MASK		0x3
+#define SPI_CMD1_MODE_SHIFT		28
+#define SPI_CMD1_CS_SEL_MASK		0x3
+#define SPI_CMD1_CS_SEL_SHIFT		26
+#define SPI_CMD1_CS_POL_INACTIVE3	(1 << 25)
+#define SPI_CMD1_CS_POL_INACTIVE2	(1 << 24)
+#define SPI_CMD1_CS_POL_INACTIVE1	(1 << 23)
+#define SPI_CMD1_CS_POL_INACTIVE0	(1 << 22)
+#define SPI_CMD1_CS_SW_HW		(1 << 21)
+#define SPI_CMD1_CS_SW_VAL		(1 << 20)
+#define SPI_CMD1_IDLE_SDA_MASK		0x3
+#define SPI_CMD1_IDLE_SDA_SHIFT		18
+#define SPI_CMD1_BIDIR			(1 << 17)
+#define SPI_CMD1_LSBI_FE		(1 << 16)
+#define SPI_CMD1_LSBY_FE		(1 << 15)
+#define SPI_CMD1_BOTH_EN_BIT		(1 << 14)
+#define SPI_CMD1_BOTH_EN_BYTE		(1 << 13)
+#define SPI_CMD1_RX_EN			(1 << 12)
+#define SPI_CMD1_TX_EN			(1 << 11)
+#define SPI_CMD1_PACKED			(1 << 5)
+#define SPI_CMD1_BIT_LEN_MASK		0x1F
+#define SPI_CMD1_BIT_LEN_SHIFT		0
+
+/* COMMAND2 */
+#define SPI_CMD2_TX_CLK_TAP_DELAY	(1 << 6)
+#define SPI_CMD2_TX_CLK_TAP_DELAY_MASK	(0x3F << 6)
+#define SPI_CMD2_RX_CLK_TAP_DELAY	(1 << 0)
+#define SPI_CMD2_RX_CLK_TAP_DELAY_MASK	(0x3F << 0)
+
+/* TRANSFER STATUS */
+#define SPI_XFER_STS_RDY		(1 << 30)
+
+/* FIFO STATUS */
+#define SPI_FIFO_STS_CS_INACTIVE	(1 << 31)
+#define SPI_FIFO_STS_FRAME_END		(1 << 30)
+#define SPI_FIFO_STS_RX_FIFO_FLUSH	(1 << 15)
+#define SPI_FIFO_STS_TX_FIFO_FLUSH	(1 << 14)
+#define SPI_FIFO_STS_ERR		(1 << 8)
+#define SPI_FIFO_STS_TX_FIFO_OVF	(1 << 7)
+#define SPI_FIFO_STS_TX_FIFO_UNR	(1 << 6)
+#define SPI_FIFO_STS_RX_FIFO_OVF	(1 << 5)
+#define SPI_FIFO_STS_RX_FIFO_UNR	(1 << 4)
+#define SPI_FIFO_STS_TX_FIFO_FULL	(1 << 3)
+#define SPI_FIFO_STS_TX_FIFO_EMPTY	(1 << 2)
+#define SPI_FIFO_STS_RX_FIFO_FULL	(1 << 1)
+#define SPI_FIFO_STS_RX_FIFO_EMPTY	(1 << 0)
+
+#define SPI_TIMEOUT		1000
+#define TEGRA_SPI_MAX_FREQ	52000000
+
+struct spi_regs {
+	u32 command1;	/* 000:SPI_COMMAND1 register */
+	u32 command2;	/* 004:SPI_COMMAND2 register */
+	u32 timing1;	/* 008:SPI_CS_TIM1 register */
+	u32 timing2;	/* 00c:SPI_CS_TIM2 register */
+	u32 xfer_status;/* 010:SPI_TRANS_STATUS register */
+	u32 fifo_status;/* 014:SPI_FIFO_STATUS register */
+	u32 tx_data;	/* 018:SPI_TX_DATA register */
+	u32 rx_data;	/* 01c:SPI_RX_DATA register */
+	u32 dma_ctl;	/* 020:SPI_DMA_CTL register */
+	u32 dma_blk;	/* 024:SPI_DMA_BLK register */
+	u32 rsvd[56];	/* 028-107 reserved */
+	u32 tx_fifo;	/* 108:SPI_FIFO1 register */
+	u32 rsvd2[31];	/* 10c-187 reserved */
+	u32 rx_fifo;	/* 188:SPI_FIFO2 register */
+	u32 spare_ctl;	/* 18c:SPI_SPARE_CTRL register */
+};
+
+struct tegra_spi_ctrl {
+	struct spi_regs *regs;
+	unsigned int freq;
+	unsigned int mode;
+	int periph_id;
+	int valid;
+};
+
+struct tegra_spi_slave {
+	struct spi_slave slave;
+	struct tegra_spi_ctrl *ctrl;
+};
+
+static struct tegra_spi_ctrl spi_ctrls[CONFIG_TEGRA114_SPI_CTRLS];
+
+static inline struct tegra_spi_slave *to_tegra_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct tegra_spi_slave, slave);
+}
+
+int tegra114_spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus >= CONFIG_TEGRA114_SPI_CTRLS || cs > 3 || !spi_ctrls[bus].valid)
+		return 0;
+	else
+		return 1;
+}
+
+struct spi_slave *tegra114_spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct tegra_spi_slave *spi;
+
+	debug("%s: bus: %u, cs: %u, max_hz: %u, mode: %u\n", __func__,
+		bus, cs, max_hz, mode);
+
+	if (!spi_cs_is_valid(bus, cs)) {
+		printf("SPI error: unsupported bus %d / chip select %d\n",
+		       bus, cs);
+		return NULL;
+	}
+
+	if (max_hz > TEGRA_SPI_MAX_FREQ) {
+		printf("SPI error: unsupported frequency %d Hz. Max frequency"
+			" is %d Hz\n", max_hz, TEGRA_SPI_MAX_FREQ);
+		return NULL;
+	}
+
+	spi = spi_alloc_slave(struct tegra_spi_slave, bus, cs);
+	if (!spi) {
+		printf("SPI error: malloc of SPI structure failed\n");
+		return NULL;
+	}
+	spi->ctrl = &spi_ctrls[bus];
+	if (!spi->ctrl) {
+		printf("SPI error: could not find controller for bus %d\n",
+		       bus);
+		return NULL;
+	}
+
+	if (max_hz < spi->ctrl->freq) {
+		debug("%s: limiting frequency from %u to %u\n", __func__,
+		      spi->ctrl->freq, max_hz);
+		spi->ctrl->freq = max_hz;
+	}
+	spi->ctrl->mode = mode;
+
+	return &spi->slave;
+}
+
+void tegra114_spi_free_slave(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+
+	free(spi);
+}
+
+int tegra114_spi_init(int *node_list, int count)
+{
+	struct tegra_spi_ctrl *ctrl;
+	int i;
+	int node = 0;
+	int found = 0;
+
+	for (i = 0; i < count; i++) {
+		ctrl = &spi_ctrls[i];
+		node = node_list[i];
+
+		ctrl->regs = (struct spi_regs *)fdtdec_get_addr(gd->fdt_blob,
+								 node, "reg");
+		if ((fdt_addr_t)ctrl->regs == FDT_ADDR_T_NONE) {
+			debug("%s: no spi register found\n", __func__);
+			continue;
+		}
+		ctrl->freq = fdtdec_get_int(gd->fdt_blob, node,
+					    "spi-max-frequency", 0);
+		if (!ctrl->freq) {
+			debug("%s: no spi max frequency found\n", __func__);
+			continue;
+		}
+
+		ctrl->periph_id = clock_decode_periph_id(gd->fdt_blob, node);
+		if (ctrl->periph_id == PERIPH_ID_NONE) {
+			debug("%s: could not decode periph id\n", __func__);
+			continue;
+		}
+		ctrl->valid = 1;
+		found = 1;
+
+		debug("%s: found controller at %p, freq = %u, periph_id = %d\n",
+		      __func__, ctrl->regs, ctrl->freq, ctrl->periph_id);
+	}
+
+	return !found;
+}
+
+int tegra114_spi_claim_bus(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+
+	/* Change SPI clock to correct frequency, PLLP_OUT0 source */
+	clock_start_periph_pll(spi->ctrl->periph_id, CLOCK_ID_PERIPH,
+			       spi->ctrl->freq);
+
+	/* Clear stale status here */
+	setbits_le32(&regs->fifo_status,
+		     SPI_FIFO_STS_ERR		|
+		     SPI_FIFO_STS_TX_FIFO_OVF	|
+		     SPI_FIFO_STS_TX_FIFO_UNR	|
+		     SPI_FIFO_STS_RX_FIFO_OVF	|
+		     SPI_FIFO_STS_RX_FIFO_UNR	|
+		     SPI_FIFO_STS_TX_FIFO_FULL	|
+		     SPI_FIFO_STS_TX_FIFO_EMPTY	|
+		     SPI_FIFO_STS_RX_FIFO_FULL	|
+		     SPI_FIFO_STS_RX_FIFO_EMPTY);
+	debug("%s: FIFO STATUS = %08x\n", __func__, readl(&regs->fifo_status));
+
+	/* Set master mode and sw controlled CS */
+	setbits_le32(&regs->command1, SPI_CMD1_M_S | SPI_CMD1_CS_SW_HW |
+		     (spi->ctrl->mode << SPI_CMD1_MODE_SHIFT));
+	debug("%s: COMMAND1 = %08x\n", __func__, readl(&regs->command1));
+
+	return 0;
+}
+
+void tegra114_spi_cs_activate(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+
+	clrbits_le32(&regs->command1, SPI_CMD1_CS_SW_VAL);
+}
+
+void tegra114_spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+
+	setbits_le32(&regs->command1, SPI_CMD1_CS_SW_VAL);
+}
+
+int tegra114_spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+		const void *data_out, void *data_in, unsigned long flags)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+	u32 reg, tmpdout, tmpdin = 0;
+	const u8 *dout = data_out;
+	u8 *din = data_in;
+	int num_bytes;
+	int ret;
+
+	debug("%s: slave %u:%u dout %p din %p bitlen %u\n",
+	      __func__, slave->bus, slave->cs, dout, din, bitlen);
+	if (bitlen % 8)
+		return -1;
+	num_bytes = bitlen / 8;
+
+	ret = 0;
+
+	/* clear all error status bits */
+	reg = readl(&regs->fifo_status);
+	writel(reg, &regs->fifo_status);
+
+	clrsetbits_le32(&regs->command1, SPI_CMD1_CS_SW_VAL,
+			SPI_CMD1_RX_EN | SPI_CMD1_TX_EN | SPI_CMD1_LSBY_FE |
+			(slave->cs << SPI_CMD1_CS_SEL_SHIFT));
+
+	/* set xfer size to 1 block (32 bits) */
+	writel(0, &regs->dma_blk);
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	/* handle data in 32-bit chunks */
+	while (num_bytes > 0) {
+		int bytes;
+		int tm, i;
+
+		tmpdout = 0;
+		bytes = (num_bytes > 4) ?  4 : num_bytes;
+
+		if (dout != NULL) {
+			for (i = 0; i < bytes; ++i)
+				tmpdout = (tmpdout << 8) | dout[i];
+			dout += bytes;
+		}
+
+		num_bytes -= bytes;
+
+		/* clear ready bit */
+		setbits_le32(&regs->xfer_status, SPI_XFER_STS_RDY);
+
+		clrsetbits_le32(&regs->command1,
+				SPI_CMD1_BIT_LEN_MASK << SPI_CMD1_BIT_LEN_SHIFT,
+				(bytes * 8 - 1) << SPI_CMD1_BIT_LEN_SHIFT);
+		writel(tmpdout, &regs->tx_fifo);
+		setbits_le32(&regs->command1, SPI_CMD1_GO);
+
+		/*
+		 * Wait for SPI transmit FIFO to empty, or to time out.
+		 * The RX FIFO status will be read and cleared last
+		 */
+		for (tm = 0; tm < SPI_TIMEOUT; ++tm) {
+			u32 fifo_status, xfer_status;
+
+			xfer_status = readl(&regs->xfer_status);
+			if (!(xfer_status & SPI_XFER_STS_RDY))
+				continue;
+
+			fifo_status = readl(&regs->fifo_status);
+			if (fifo_status & SPI_FIFO_STS_ERR) {
+				debug("%s: got a fifo error: ", __func__);
+				if (fifo_status & SPI_FIFO_STS_TX_FIFO_OVF)
+					debug("tx FIFO overflow ");
+				if (fifo_status & SPI_FIFO_STS_TX_FIFO_UNR)
+					debug("tx FIFO underrun ");
+				if (fifo_status & SPI_FIFO_STS_RX_FIFO_OVF)
+					debug("rx FIFO overflow ");
+				if (fifo_status & SPI_FIFO_STS_RX_FIFO_UNR)
+					debug("rx FIFO underrun ");
+				if (fifo_status & SPI_FIFO_STS_TX_FIFO_FULL)
+					debug("tx FIFO full ");
+				if (fifo_status & SPI_FIFO_STS_TX_FIFO_EMPTY)
+					debug("tx FIFO empty ");
+				if (fifo_status & SPI_FIFO_STS_RX_FIFO_FULL)
+					debug("rx FIFO full ");
+				if (fifo_status & SPI_FIFO_STS_RX_FIFO_EMPTY)
+					debug("rx FIFO empty ");
+				debug("\n");
+				break;
+			}
+
+			if (!(fifo_status & SPI_FIFO_STS_RX_FIFO_EMPTY)) {
+				tmpdin = readl(&regs->rx_fifo);
+
+				/* swap bytes read in */
+				if (din != NULL) {
+					for (i = bytes - 1; i >= 0; --i) {
+						din[i] = tmpdin & 0xff;
+						tmpdin >>= 8;
+					}
+					din += bytes;
+				}
+
+				/* We can exit when we've had both RX and TX */
+				break;
+			}
+		}
+
+		if (tm >= SPI_TIMEOUT)
+			ret = tm;
+
+		/* clear ACK RDY, etc. bits */
+		writel(readl(&regs->fifo_status), &regs->fifo_status);
+	}
+
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	debug("%s: transfer ended. Value=%08x, fifo_status = %08x\n",
+	      __func__, tmpdin, readl(&regs->fifo_status));
+
+	if (ret) {
+		printf("%s: timeout during SPI transfer, tm %d\n",
+		       __func__, ret);
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/spi/tegra20_sflash.c b/drivers/spi/tegra20_sflash.c
new file mode 100644
index 0000000..b5d561b
--- /dev/null
+++ b/drivers/spi/tegra20_sflash.c
@@ -0,0 +1,341 @@
+/*
+ * Copyright (c) 2010-2013 NVIDIA Corporation
+ * With help from the mpc8xxx SPI driver
+ * With more help from omap3_spi SPI driver
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/pinmux.h>
+#include <asm/arch-tegra/clk_rst.h>
+#include <asm/arch-tegra20/tegra20_sflash.h>
+#include <spi.h>
+#include <fdtdec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define SPI_CMD_GO			(1 << 30)
+#define SPI_CMD_ACTIVE_SCLK_SHIFT	26
+#define SPI_CMD_ACTIVE_SCLK_MASK	(3 << SPI_CMD_ACTIVE_SCLK_SHIFT)
+#define SPI_CMD_CK_SDA			(1 << 21)
+#define SPI_CMD_ACTIVE_SDA_SHIFT	18
+#define SPI_CMD_ACTIVE_SDA_MASK		(3 << SPI_CMD_ACTIVE_SDA_SHIFT)
+#define SPI_CMD_CS_POL			(1 << 16)
+#define SPI_CMD_TXEN			(1 << 15)
+#define SPI_CMD_RXEN			(1 << 14)
+#define SPI_CMD_CS_VAL			(1 << 13)
+#define SPI_CMD_CS_SOFT			(1 << 12)
+#define SPI_CMD_CS_DELAY		(1 << 9)
+#define SPI_CMD_CS3_EN			(1 << 8)
+#define SPI_CMD_CS2_EN			(1 << 7)
+#define SPI_CMD_CS1_EN			(1 << 6)
+#define SPI_CMD_CS0_EN			(1 << 5)
+#define SPI_CMD_BIT_LENGTH		(1 << 4)
+#define SPI_CMD_BIT_LENGTH_MASK		0x0000001F
+
+#define SPI_STAT_BSY			(1 << 31)
+#define SPI_STAT_RDY			(1 << 30)
+#define SPI_STAT_RXF_FLUSH		(1 << 29)
+#define SPI_STAT_TXF_FLUSH		(1 << 28)
+#define SPI_STAT_RXF_UNR		(1 << 27)
+#define SPI_STAT_TXF_OVF		(1 << 26)
+#define SPI_STAT_RXF_EMPTY		(1 << 25)
+#define SPI_STAT_RXF_FULL		(1 << 24)
+#define SPI_STAT_TXF_EMPTY		(1 << 23)
+#define SPI_STAT_TXF_FULL		(1 << 22)
+#define SPI_STAT_SEL_TXRX_N		(1 << 16)
+#define SPI_STAT_CUR_BLKCNT		(1 << 15)
+
+#define SPI_TIMEOUT		1000
+#define TEGRA_SPI_MAX_FREQ	52000000
+
+struct spi_regs {
+	u32 command;	/* SPI_COMMAND_0 register  */
+	u32 status;	/* SPI_STATUS_0 register */
+	u32 rx_cmp;	/* SPI_RX_CMP_0 register  */
+	u32 dma_ctl;	/* SPI_DMA_CTL_0 register */
+	u32 tx_fifo;	/* SPI_TX_FIFO_0 register */
+	u32 rsvd[3];	/* offsets 0x14 to 0x1F reserved */
+	u32 rx_fifo;	/* SPI_RX_FIFO_0 register */
+};
+
+struct tegra_spi_ctrl {
+	struct spi_regs *regs;
+	unsigned int freq;
+	unsigned int mode;
+	int periph_id;
+	int valid;
+};
+
+struct tegra_spi_slave {
+	struct spi_slave slave;
+	struct tegra_spi_ctrl *ctrl;
+};
+
+/* tegra20 only supports one SFLASH controller */
+static struct tegra_spi_ctrl spi_ctrls[1];
+
+static inline struct tegra_spi_slave *to_tegra_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct tegra_spi_slave, slave);
+}
+
+int tegra20_spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	/* Tegra20 SPI-Flash - only 1 device ('bus/cs') */
+	if (bus != 0 || cs != 0)
+		return 0;
+	else
+		return 1;
+}
+
+struct spi_slave *tegra20_spi_setup_slave(unsigned int bus, unsigned int cs,
+				  unsigned int max_hz, unsigned int mode)
+{
+	struct tegra_spi_slave *spi;
+
+	if (!spi_cs_is_valid(bus, cs)) {
+		printf("SPI error: unsupported bus %d / chip select %d\n",
+		       bus, cs);
+		return NULL;
+	}
+
+	if (max_hz > TEGRA_SPI_MAX_FREQ) {
+		printf("SPI error: unsupported frequency %d Hz. Max frequency"
+			" is %d Hz\n", max_hz, TEGRA_SPI_MAX_FREQ);
+		return NULL;
+	}
+
+	spi = spi_alloc_slave(struct tegra_spi_slave, bus, cs);
+	if (!spi) {
+		printf("SPI error: malloc of SPI structure failed\n");
+		return NULL;
+	}
+	spi->ctrl = &spi_ctrls[bus];
+	if (!spi->ctrl) {
+		printf("SPI error: could not find controller for bus %d\n",
+		       bus);
+		return NULL;
+	}
+
+	if (max_hz < spi->ctrl->freq) {
+		debug("%s: limiting frequency from %u to %u\n", __func__,
+		      spi->ctrl->freq, max_hz);
+		spi->ctrl->freq = max_hz;
+	}
+	spi->ctrl->mode = mode;
+
+	return &spi->slave;
+}
+
+void tegra20_spi_free_slave(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+
+	free(spi);
+}
+
+int tegra20_spi_init(int *node_list, int count)
+{
+	struct tegra_spi_ctrl *ctrl;
+	int i;
+	int node = 0;
+	int found = 0;
+
+	for (i = 0; i < count; i++) {
+		ctrl = &spi_ctrls[i];
+		node = node_list[i];
+
+		ctrl->regs = (struct spi_regs *)fdtdec_get_addr(gd->fdt_blob,
+								node, "reg");
+		if ((fdt_addr_t)ctrl->regs == FDT_ADDR_T_NONE) {
+			debug("%s: no slink register found\n", __func__);
+			continue;
+		}
+		ctrl->freq = fdtdec_get_int(gd->fdt_blob, node,
+					    "spi-max-frequency", 0);
+		if (!ctrl->freq) {
+			debug("%s: no slink max frequency found\n", __func__);
+			continue;
+		}
+
+		ctrl->periph_id = clock_decode_periph_id(gd->fdt_blob, node);
+		if (ctrl->periph_id == PERIPH_ID_NONE) {
+			debug("%s: could not decode periph id\n", __func__);
+			continue;
+		}
+		ctrl->valid = 1;
+		found = 1;
+
+		debug("%s: found controller at %p, freq = %u, periph_id = %d\n",
+		      __func__, ctrl->regs, ctrl->freq, ctrl->periph_id);
+	}
+	return !found;
+}
+
+int tegra20_spi_claim_bus(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+	u32 reg;
+
+	/* Change SPI clock to correct frequency, PLLP_OUT0 source */
+	clock_start_periph_pll(spi->ctrl->periph_id, CLOCK_ID_PERIPH,
+			       spi->ctrl->freq);
+
+	/* Clear stale status here */
+	reg = SPI_STAT_RDY | SPI_STAT_RXF_FLUSH | SPI_STAT_TXF_FLUSH | \
+		SPI_STAT_RXF_UNR | SPI_STAT_TXF_OVF;
+	writel(reg, &regs->status);
+	debug("%s: STATUS = %08x\n", __func__, readl(&regs->status));
+
+	/*
+	 * Use sw-controlled CS, so we can clock in data after ReadID, etc.
+	 */
+	reg = (spi->ctrl->mode & 1) << SPI_CMD_ACTIVE_SDA_SHIFT;
+	if (spi->ctrl->mode & 2)
+		reg |= 1 << SPI_CMD_ACTIVE_SCLK_SHIFT;
+	clrsetbits_le32(&regs->command, SPI_CMD_ACTIVE_SCLK_MASK |
+		SPI_CMD_ACTIVE_SDA_MASK, SPI_CMD_CS_SOFT | reg);
+	debug("%s: COMMAND = %08x\n", __func__, readl(&regs->command));
+
+	/*
+	 * SPI pins on Tegra20 are muxed - change pinmux later due to UART
+	 * issue.
+	 */
+	pinmux_set_func(PMUX_PINGRP_GMD, PMUX_FUNC_SFLASH);
+	pinmux_tristate_disable(PMUX_PINGRP_LSPI);
+	pinmux_set_func(PMUX_PINGRP_GMC, PMUX_FUNC_SFLASH);
+
+	return 0;
+}
+
+void tegra20_spi_cs_activate(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+
+	/* CS is negated on Tegra, so drive a 1 to get a 0 */
+	setbits_le32(&regs->command, SPI_CMD_CS_VAL);
+}
+
+void tegra20_spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+
+	/* CS is negated on Tegra, so drive a 0 to get a 1 */
+	clrbits_le32(&regs->command, SPI_CMD_CS_VAL);
+}
+
+int tegra20_spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+		const void *data_out, void *data_in, unsigned long flags)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+	u32 reg, tmpdout, tmpdin = 0;
+	const u8 *dout = data_out;
+	u8 *din = data_in;
+	int num_bytes;
+	int ret;
+
+	debug("spi_xfer: slave %u:%u dout %08X din %08X bitlen %u\n",
+	      slave->bus, slave->cs, *(u8 *)dout, *(u8 *)din, bitlen);
+	if (bitlen % 8)
+		return -1;
+	num_bytes = bitlen / 8;
+
+	ret = 0;
+
+	reg = readl(&regs->status);
+	writel(reg, &regs->status);	/* Clear all SPI events via R/W */
+	debug("spi_xfer entry: STATUS = %08x\n", reg);
+
+	reg = readl(&regs->command);
+	reg |= SPI_CMD_TXEN | SPI_CMD_RXEN;
+	writel(reg, &regs->command);
+	debug("spi_xfer: COMMAND = %08x\n", readl(&regs->command));
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	/* handle data in 32-bit chunks */
+	while (num_bytes > 0) {
+		int bytes;
+		int is_read = 0;
+		int tm, i;
+
+		tmpdout = 0;
+		bytes = (num_bytes > 4) ?  4 : num_bytes;
+
+		if (dout != NULL) {
+			for (i = 0; i < bytes; ++i)
+				tmpdout = (tmpdout << 8) | dout[i];
+		}
+
+		num_bytes -= bytes;
+		if (dout)
+			dout += bytes;
+
+		clrsetbits_le32(&regs->command, SPI_CMD_BIT_LENGTH_MASK,
+				bytes * 8 - 1);
+		writel(tmpdout, &regs->tx_fifo);
+		setbits_le32(&regs->command, SPI_CMD_GO);
+
+		/*
+		 * Wait for SPI transmit FIFO to empty, or to time out.
+		 * The RX FIFO status will be read and cleared last
+		 */
+		for (tm = 0, is_read = 0; tm < SPI_TIMEOUT; ++tm) {
+			u32 status;
+
+			status = readl(&regs->status);
+
+			/* We can exit when we've had both RX and TX activity */
+			if (is_read && (status & SPI_STAT_TXF_EMPTY))
+				break;
+
+			if ((status & (SPI_STAT_BSY | SPI_STAT_RDY)) !=
+					SPI_STAT_RDY)
+				tm++;
+
+			else if (!(status & SPI_STAT_RXF_EMPTY)) {
+				tmpdin = readl(&regs->rx_fifo);
+				is_read = 1;
+
+				/* swap bytes read in */
+				if (din != NULL) {
+					for (i = bytes - 1; i >= 0; --i) {
+						din[i] = tmpdin & 0xff;
+						tmpdin >>= 8;
+					}
+					din += bytes;
+				}
+			}
+		}
+
+		if (tm >= SPI_TIMEOUT)
+			ret = tm;
+
+		/* clear ACK RDY, etc. bits */
+		writel(readl(&regs->status), &regs->status);
+	}
+
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	debug("spi_xfer: transfer ended. Value=%08x, status = %08x\n",
+		tmpdin, readl(&regs->status));
+
+	if (ret) {
+		printf("spi_xfer: timeout during SPI transfer, tm %d\n", ret);
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/spi/tegra20_slink.c b/drivers/spi/tegra20_slink.c
new file mode 100644
index 0000000..664de6e
--- /dev/null
+++ b/drivers/spi/tegra20_slink.c
@@ -0,0 +1,359 @@
+/*
+ * NVIDIA Tegra SPI-SLINK controller
+ *
+ * Copyright (c) 2010-2013 NVIDIA Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch-tegra/clk_rst.h>
+#include <asm/arch-tegra20/tegra20_slink.h>
+#include <spi.h>
+#include <fdtdec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* COMMAND */
+#define SLINK_CMD_ENB			(1 << 31)
+#define SLINK_CMD_GO			(1 << 30)
+#define SLINK_CMD_M_S			(1 << 28)
+#define SLINK_CMD_CK_SDA		(1 << 21)
+#define SLINK_CMD_CS_POL		(1 << 13)
+#define SLINK_CMD_CS_VAL		(1 << 12)
+#define SLINK_CMD_CS_SOFT		(1 << 11)
+#define SLINK_CMD_BIT_LENGTH		(1 << 4)
+#define SLINK_CMD_BIT_LENGTH_MASK	0x0000001F
+/* COMMAND2 */
+#define SLINK_CMD2_TXEN			(1 << 30)
+#define SLINK_CMD2_RXEN			(1 << 31)
+#define SLINK_CMD2_SS_EN		(1 << 18)
+#define SLINK_CMD2_SS_EN_SHIFT		18
+#define SLINK_CMD2_SS_EN_MASK		0x000C0000
+#define SLINK_CMD2_CS_ACTIVE_BETWEEN	(1 << 17)
+/* STATUS */
+#define SLINK_STAT_BSY			(1 << 31)
+#define SLINK_STAT_RDY			(1 << 30)
+#define SLINK_STAT_ERR			(1 << 29)
+#define SLINK_STAT_RXF_FLUSH		(1 << 27)
+#define SLINK_STAT_TXF_FLUSH		(1 << 26)
+#define SLINK_STAT_RXF_OVF		(1 << 25)
+#define SLINK_STAT_TXF_UNR		(1 << 24)
+#define SLINK_STAT_RXF_EMPTY		(1 << 23)
+#define SLINK_STAT_RXF_FULL		(1 << 22)
+#define SLINK_STAT_TXF_EMPTY		(1 << 21)
+#define SLINK_STAT_TXF_FULL		(1 << 20)
+#define SLINK_STAT_TXF_OVF		(1 << 19)
+#define SLINK_STAT_RXF_UNR		(1 << 18)
+#define SLINK_STAT_CUR_BLKCNT		(1 << 15)
+/* STATUS2 */
+#define SLINK_STAT2_RXF_FULL_CNT	(1 << 16)
+#define SLINK_STAT2_TXF_FULL_CNT	(1 << 0)
+
+#define SPI_TIMEOUT		1000
+#define TEGRA_SPI_MAX_FREQ	52000000
+
+struct spi_regs {
+	u32 command;	/* SLINK_COMMAND_0 register  */
+	u32 command2;	/* SLINK_COMMAND2_0 reg */
+	u32 status;	/* SLINK_STATUS_0 register */
+	u32 reserved;	/* Reserved offset 0C */
+	u32 mas_data;	/* SLINK_MAS_DATA_0 reg */
+	u32 slav_data;	/* SLINK_SLAVE_DATA_0 reg */
+	u32 dma_ctl;	/* SLINK_DMA_CTL_0 register */
+	u32 status2;	/* SLINK_STATUS2_0 reg */
+	u32 rsvd[56];	/* 0x20 to 0xFF reserved */
+	u32 tx_fifo;	/* SLINK_TX_FIFO_0 reg off 100h */
+	u32 rsvd2[31];	/* 0x104 to 0x17F reserved */
+	u32 rx_fifo;	/* SLINK_RX_FIFO_0 reg off 180h */
+};
+
+struct tegra_spi_ctrl {
+	struct spi_regs *regs;
+	unsigned int freq;
+	unsigned int mode;
+	int periph_id;
+	int valid;
+};
+
+struct tegra_spi_slave {
+	struct spi_slave slave;
+	struct tegra_spi_ctrl *ctrl;
+};
+
+static struct tegra_spi_ctrl spi_ctrls[CONFIG_TEGRA_SLINK_CTRLS];
+
+static inline struct tegra_spi_slave *to_tegra_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct tegra_spi_slave, slave);
+}
+
+int tegra30_spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus >= CONFIG_TEGRA_SLINK_CTRLS || cs > 3 || !spi_ctrls[bus].valid)
+		return 0;
+	else
+		return 1;
+}
+
+struct spi_slave *tegra30_spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct tegra_spi_slave *spi;
+
+	debug("%s: bus: %u, cs: %u, max_hz: %u, mode: %u\n", __func__,
+		bus, cs, max_hz, mode);
+
+	if (!spi_cs_is_valid(bus, cs)) {
+		printf("SPI error: unsupported bus %d / chip select %d\n",
+		       bus, cs);
+		return NULL;
+	}
+
+	if (max_hz > TEGRA_SPI_MAX_FREQ) {
+		printf("SPI error: unsupported frequency %d Hz. Max frequency"
+			" is %d Hz\n", max_hz, TEGRA_SPI_MAX_FREQ);
+		return NULL;
+	}
+
+	spi = spi_alloc_slave(struct tegra_spi_slave, bus, cs);
+	if (!spi) {
+		printf("SPI error: malloc of SPI structure failed\n");
+		return NULL;
+	}
+	spi->ctrl = &spi_ctrls[bus];
+	if (!spi->ctrl) {
+		printf("SPI error: could not find controller for bus %d\n",
+		       bus);
+		return NULL;
+	}
+
+	if (max_hz < spi->ctrl->freq) {
+		debug("%s: limiting frequency from %u to %u\n", __func__,
+		      spi->ctrl->freq, max_hz);
+		spi->ctrl->freq = max_hz;
+	}
+	spi->ctrl->mode = mode;
+
+	return &spi->slave;
+}
+
+void tegra30_spi_free_slave(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+
+	free(spi);
+}
+
+int tegra30_spi_init(int *node_list, int count)
+{
+	struct tegra_spi_ctrl *ctrl;
+	int i;
+	int node = 0;
+	int found = 0;
+
+	for (i = 0; i < count; i++) {
+		ctrl = &spi_ctrls[i];
+		node = node_list[i];
+
+		ctrl->regs = (struct spi_regs *)fdtdec_get_addr(gd->fdt_blob,
+								node, "reg");
+		if ((fdt_addr_t)ctrl->regs == FDT_ADDR_T_NONE) {
+			debug("%s: no slink register found\n", __func__);
+			continue;
+		}
+		ctrl->freq = fdtdec_get_int(gd->fdt_blob, node,
+					    "spi-max-frequency", 0);
+		if (!ctrl->freq) {
+			debug("%s: no slink max frequency found\n", __func__);
+			continue;
+		}
+
+		ctrl->periph_id = clock_decode_periph_id(gd->fdt_blob, node);
+		if (ctrl->periph_id == PERIPH_ID_NONE) {
+			debug("%s: could not decode periph id\n", __func__);
+			continue;
+		}
+		ctrl->valid = 1;
+		found = 1;
+
+		debug("%s: found controller at %p, freq = %u, periph_id = %d\n",
+		      __func__, ctrl->regs, ctrl->freq, ctrl->periph_id);
+	}
+	return !found;
+}
+
+int tegra30_spi_claim_bus(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+	u32 reg;
+
+	/* Change SPI clock to correct frequency, PLLP_OUT0 source */
+	clock_start_periph_pll(spi->ctrl->periph_id, CLOCK_ID_PERIPH,
+			       spi->ctrl->freq);
+
+	/* Clear stale status here */
+	reg = SLINK_STAT_RDY | SLINK_STAT_RXF_FLUSH | SLINK_STAT_TXF_FLUSH | \
+		SLINK_STAT_RXF_UNR | SLINK_STAT_TXF_OVF;
+	writel(reg, &regs->status);
+	debug("%s: STATUS = %08x\n", __func__, readl(&regs->status));
+
+	/* Set master mode and sw controlled CS */
+	reg = readl(&regs->command);
+	reg |= SLINK_CMD_M_S | SLINK_CMD_CS_SOFT;
+	writel(reg, &regs->command);
+	debug("%s: COMMAND = %08x\n", __func__, readl(&regs->command));
+
+	return 0;
+}
+
+void tegra30_spi_cs_activate(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+
+	/* CS is negated on Tegra, so drive a 1 to get a 0 */
+	setbits_le32(&regs->command, SLINK_CMD_CS_VAL);
+}
+
+void tegra30_spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+
+	/* CS is negated on Tegra, so drive a 0 to get a 1 */
+	clrbits_le32(&regs->command, SLINK_CMD_CS_VAL);
+}
+
+int tegra30_spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+		const void *data_out, void *data_in, unsigned long flags)
+{
+	struct tegra_spi_slave *spi = to_tegra_spi(slave);
+	struct spi_regs *regs = spi->ctrl->regs;
+	u32 reg, tmpdout, tmpdin = 0;
+	const u8 *dout = data_out;
+	u8 *din = data_in;
+	int num_bytes;
+	int ret;
+
+	debug("%s: slave %u:%u dout %p din %p bitlen %u\n",
+	      __func__, slave->bus, slave->cs, dout, din, bitlen);
+	if (bitlen % 8)
+		return -1;
+	num_bytes = bitlen / 8;
+
+	ret = 0;
+
+	reg = readl(&regs->status);
+	writel(reg, &regs->status);	/* Clear all SPI events via R/W */
+	debug("%s entry: STATUS = %08x\n", __func__, reg);
+
+	reg = readl(&regs->status2);
+	writel(reg, &regs->status2);	/* Clear all STATUS2 events via R/W */
+	debug("%s entry: STATUS2 = %08x\n", __func__, reg);
+
+	debug("%s entry: COMMAND = %08x\n", __func__, readl(&regs->command));
+
+	clrsetbits_le32(&regs->command2, SLINK_CMD2_SS_EN_MASK,
+			SLINK_CMD2_TXEN | SLINK_CMD2_RXEN |
+			(slave->cs << SLINK_CMD2_SS_EN_SHIFT));
+	debug("%s entry: COMMAND2 = %08x\n", __func__, readl(&regs->command2));
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	/* handle data in 32-bit chunks */
+	while (num_bytes > 0) {
+		int bytes;
+		int is_read = 0;
+		int tm, i;
+
+		tmpdout = 0;
+		bytes = (num_bytes > 4) ?  4 : num_bytes;
+
+		if (dout != NULL) {
+			for (i = 0; i < bytes; ++i)
+				tmpdout = (tmpdout << 8) | dout[i];
+			dout += bytes;
+		}
+
+		num_bytes -= bytes;
+
+		clrsetbits_le32(&regs->command, SLINK_CMD_BIT_LENGTH_MASK,
+				bytes * 8 - 1);
+		writel(tmpdout, &regs->tx_fifo);
+		setbits_le32(&regs->command, SLINK_CMD_GO);
+
+		/*
+		 * Wait for SPI transmit FIFO to empty, or to time out.
+		 * The RX FIFO status will be read and cleared last
+		 */
+		for (tm = 0, is_read = 0; tm < SPI_TIMEOUT; ++tm) {
+			u32 status;
+
+			status = readl(&regs->status);
+
+			/* We can exit when we've had both RX and TX activity */
+			if (is_read && (status & SLINK_STAT_TXF_EMPTY))
+				break;
+
+			if ((status & (SLINK_STAT_BSY | SLINK_STAT_RDY)) !=
+					SLINK_STAT_RDY)
+				tm++;
+
+			else if (!(status & SLINK_STAT_RXF_EMPTY)) {
+				tmpdin = readl(&regs->rx_fifo);
+				is_read = 1;
+
+				/* swap bytes read in */
+				if (din != NULL) {
+					for (i = bytes - 1; i >= 0; --i) {
+						din[i] = tmpdin & 0xff;
+						tmpdin >>= 8;
+					}
+					din += bytes;
+				}
+			}
+		}
+
+		if (tm >= SPI_TIMEOUT)
+			ret = tm;
+
+		/* clear ACK RDY, etc. bits */
+		writel(readl(&regs->status), &regs->status);
+	}
+
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	debug("%s: transfer ended. Value=%08x, status = %08x\n",
+	      __func__, tmpdin, readl(&regs->status));
+
+	if (ret) {
+		printf("%s: timeout during SPI transfer, tm %d\n",
+		       __func__, ret);
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/spi/tegra_spi.c b/drivers/spi/tegra_spi.c
deleted file mode 100644
index 9bb34e2..0000000
--- a/drivers/spi/tegra_spi.c
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- * Copyright (c) 2010-2012 NVIDIA Corporation
- * With help from the mpc8xxx SPI driver
- * With more help from omap3_spi SPI driver
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/pinmux.h>
-#include <asm/arch/uart-spi-switch.h>
-#include <asm/arch-tegra/clk_rst.h>
-#include <asm/arch-tegra/tegra_spi.h>
-#include <spi.h>
-
-#if defined(CONFIG_SPI_CORRUPTS_UART)
- #define corrupt_delay()	udelay(CONFIG_SPI_CORRUPTS_UART_DLY);
-#else
- #define corrupt_delay()
-#endif
-
-struct tegra_spi_slave {
-	struct spi_slave slave;
-	struct spi_tegra *regs;
-	unsigned int freq;
-	unsigned int mode;
-};
-
-static inline struct tegra_spi_slave *to_tegra_spi(struct spi_slave *slave)
-{
-	return container_of(slave, struct tegra_spi_slave, slave);
-}
-
-int spi_cs_is_valid(unsigned int bus, unsigned int cs)
-{
-	/* Tegra20 SPI-Flash - only 1 device ('bus/cs') */
-	if (bus != 0 || cs != 0)
-		return 0;
-	else
-		return 1;
-}
-
-struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
-		unsigned int max_hz, unsigned int mode)
-{
-	struct tegra_spi_slave *spi;
-
-	if (!spi_cs_is_valid(bus, cs)) {
-		printf("SPI error: unsupported bus %d / chip select %d\n",
-		       bus, cs);
-		return NULL;
-	}
-
-	if (max_hz > TEGRA_SPI_MAX_FREQ) {
-		printf("SPI error: unsupported frequency %d Hz. Max frequency"
-			" is %d Hz\n", max_hz, TEGRA_SPI_MAX_FREQ);
-		return NULL;
-	}
-
-	spi = malloc(sizeof(struct tegra_spi_slave));
-	if (!spi) {
-		printf("SPI error: malloc of SPI structure failed\n");
-		return NULL;
-	}
-	spi->slave.bus = bus;
-	spi->slave.cs = cs;
-	spi->freq = max_hz;
-	spi->regs = (struct spi_tegra *)NV_PA_SPI_BASE;
-	spi->mode = mode;
-
-	return &spi->slave;
-}
-
-void spi_free_slave(struct spi_slave *slave)
-{
-	struct tegra_spi_slave *spi = to_tegra_spi(slave);
-
-	free(spi);
-}
-
-void spi_init(void)
-{
-	/* do nothing */
-}
-
-int spi_claim_bus(struct spi_slave *slave)
-{
-	struct tegra_spi_slave *spi = to_tegra_spi(slave);
-	struct spi_tegra *regs = spi->regs;
-	u32 reg;
-
-	/* Change SPI clock to correct frequency, PLLP_OUT0 source */
-	clock_start_periph_pll(PERIPH_ID_SPI1, CLOCK_ID_PERIPH, spi->freq);
-
-	/* Clear stale status here */
-	reg = SPI_STAT_RDY | SPI_STAT_RXF_FLUSH | SPI_STAT_TXF_FLUSH | \
-		SPI_STAT_RXF_UNR | SPI_STAT_TXF_OVF;
-	writel(reg, &regs->status);
-	debug("spi_init: STATUS = %08x\n", readl(&regs->status));
-
-	/*
-	 * Use sw-controlled CS, so we can clock in data after ReadID, etc.
-	 */
-	reg = (spi->mode & 1) << SPI_CMD_ACTIVE_SDA_SHIFT;
-	if (spi->mode & 2)
-		reg |= 1 << SPI_CMD_ACTIVE_SCLK_SHIFT;
-	clrsetbits_le32(&regs->command, SPI_CMD_ACTIVE_SCLK_MASK |
-		SPI_CMD_ACTIVE_SDA_MASK, SPI_CMD_CS_SOFT | reg);
-	debug("spi_init: COMMAND = %08x\n", readl(&regs->command));
-
-	/*
-	 * SPI pins on Tegra20 are muxed - change pinmux later due to UART
-	 * issue.
-	 */
-	pinmux_set_func(PINGRP_GMD, PMUX_FUNC_SFLASH);
-	pinmux_tristate_disable(PINGRP_LSPI);
-
-#ifndef CONFIG_SPI_UART_SWITCH
-	/*
-	 * NOTE:
-	 * Only set PinMux bits 3:2 to SPI here on boards that don't have the
-	 * SPI UART switch or subsequent UART data won't go out!  See
-	 * spi_uart_switch().
-	 */
-	/* TODO: pinmux_set_func(PINGRP_GMC, PMUX_FUNC_SFLASH); */
-#endif
-	return 0;
-}
-
-void spi_release_bus(struct spi_slave *slave)
-{
-	/*
-	 * We can't release UART_DISABLE and set pinmux to UART4 here since
-	 * some code (e,g, spi_flash_probe) uses printf() while the SPI
-	 * bus is held. That is arguably bad, but it has the advantage of
-	 * already being in the source tree.
-	 */
-}
-
-void spi_cs_activate(struct spi_slave *slave)
-{
-	struct tegra_spi_slave *spi = to_tegra_spi(slave);
-
-	pinmux_select_spi();
-
-	/* CS is negated on Tegra, so drive a 1 to get a 0 */
-	setbits_le32(&spi->regs->command, SPI_CMD_CS_VAL);
-
-	corrupt_delay();		/* Let UART settle */
-}
-
-void spi_cs_deactivate(struct spi_slave *slave)
-{
-	struct tegra_spi_slave *spi = to_tegra_spi(slave);
-
-	pinmux_select_uart();
-
-	/* CS is negated on Tegra, so drive a 0 to get a 1 */
-	clrbits_le32(&spi->regs->command, SPI_CMD_CS_VAL);
-
-	corrupt_delay();		/* Let SPI settle */
-}
-
-int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
-		const void *data_out, void *data_in, unsigned long flags)
-{
-	struct tegra_spi_slave *spi = to_tegra_spi(slave);
-	struct spi_tegra *regs = spi->regs;
-	u32 reg, tmpdout, tmpdin = 0;
-	const u8 *dout = data_out;
-	u8 *din = data_in;
-	int num_bytes;
-	int ret;
-
-	debug("spi_xfer: slave %u:%u dout %08X din %08X bitlen %u\n",
-	      slave->bus, slave->cs, *(u8 *)dout, *(u8 *)din, bitlen);
-	if (bitlen % 8)
-		return -1;
-	num_bytes = bitlen / 8;
-
-	ret = 0;
-
-	reg = readl(&regs->status);
-	writel(reg, &regs->status);	/* Clear all SPI events via R/W */
-	debug("spi_xfer entry: STATUS = %08x\n", reg);
-
-	reg = readl(&regs->command);
-	reg |= SPI_CMD_TXEN | SPI_CMD_RXEN;
-	writel(reg, &regs->command);
-	debug("spi_xfer: COMMAND = %08x\n", readl(&regs->command));
-
-	if (flags & SPI_XFER_BEGIN)
-		spi_cs_activate(slave);
-
-	/* handle data in 32-bit chunks */
-	while (num_bytes > 0) {
-		int bytes;
-		int is_read = 0;
-		int tm, i;
-
-		tmpdout = 0;
-		bytes = (num_bytes > 4) ?  4 : num_bytes;
-
-		if (dout != NULL) {
-			for (i = 0; i < bytes; ++i)
-				tmpdout = (tmpdout << 8) | dout[i];
-		}
-
-		num_bytes -= bytes;
-		if (dout)
-			dout += bytes;
-
-		clrsetbits_le32(&regs->command, SPI_CMD_BIT_LENGTH_MASK,
-				bytes * 8 - 1);
-		writel(tmpdout, &regs->tx_fifo);
-		setbits_le32(&regs->command, SPI_CMD_GO);
-
-		/*
-		 * Wait for SPI transmit FIFO to empty, or to time out.
-		 * The RX FIFO status will be read and cleared last
-		 */
-		for (tm = 0, is_read = 0; tm < SPI_TIMEOUT; ++tm) {
-			u32 status;
-
-			status = readl(&regs->status);
-
-			/* We can exit when we've had both RX and TX activity */
-			if (is_read && (status & SPI_STAT_TXF_EMPTY))
-				break;
-
-			if ((status & (SPI_STAT_BSY | SPI_STAT_RDY)) !=
-					SPI_STAT_RDY)
-				tm++;
-
-			else if (!(status & SPI_STAT_RXF_EMPTY)) {
-				tmpdin = readl(&regs->rx_fifo);
-				is_read = 1;
-
-				/* swap bytes read in */
-				if (din != NULL) {
-					for (i = bytes - 1; i >= 0; --i) {
-						din[i] = tmpdin & 0xff;
-						tmpdin >>= 8;
-					}
-					din += bytes;
-				}
-			}
-		}
-
-		if (tm >= SPI_TIMEOUT)
-			ret = tm;
-
-		/* clear ACK RDY, etc. bits */
-		writel(readl(&regs->status), &regs->status);
-	}
-
-	if (flags & SPI_XFER_END)
-		spi_cs_deactivate(slave);
-
-	debug("spi_xfer: transfer ended. Value=%08x, status = %08x\n",
-		tmpdin, readl(&regs->status));
-
-	if (ret) {
-		printf("spi_xfer: timeout during SPI transfer, tm %d\n", ret);
-		return -1;
-	}
-
-	return 0;
-}
diff --git a/drivers/spi/ti_qspi.c b/drivers/spi/ti_qspi.c
new file mode 100644
index 0000000..fd7fea8
--- /dev/null
+++ b/drivers/spi/ti_qspi.c
@@ -0,0 +1,342 @@
+/*
+ * TI QSPI driver
+ *
+ * Copyright (C) 2013, Texas Instruments, Incorporated
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/omap.h>
+#include <malloc.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/omap_gpio.h>
+
+/* ti qpsi register bit masks */
+#define QSPI_TIMEOUT                    2000000
+#define QSPI_FCLK                       192000000
+/* clock control */
+#define QSPI_CLK_EN                     (1 << 31)
+#define QSPI_CLK_DIV_MAX                0xffff
+/* command */
+#define QSPI_EN_CS(n)                   (n << 28)
+#define QSPI_WLEN(n)                    ((n-1) << 19)
+#define QSPI_3_PIN                      (1 << 18)
+#define QSPI_RD_SNGL                    (1 << 16)
+#define QSPI_WR_SNGL                    (2 << 16)
+#define QSPI_INVAL                      (4 << 16)
+#define QSPI_RD_QUAD                    (7 << 16)
+/* device control */
+#define QSPI_DD(m, n)                   (m << (3 + n*8))
+#define QSPI_CKPHA(n)                   (1 << (2 + n*8))
+#define QSPI_CSPOL(n)                   (1 << (1 + n*8))
+#define QSPI_CKPOL(n)                   (1 << (n*8))
+/* status */
+#define QSPI_WC                         (1 << 1)
+#define QSPI_BUSY                       (1 << 0)
+#define QSPI_WC_BUSY                    (QSPI_WC | QSPI_BUSY)
+#define QSPI_XFER_DONE                  QSPI_WC
+#define MM_SWITCH                       0x01
+#define MEM_CS                          0x100
+#define MEM_CS_UNSELECT                 0xfffff0ff
+#define MMAP_START_ADDR_DRA		0x5c000000
+#define MMAP_START_ADDR_AM43x		0x30000000
+#define CORE_CTRL_IO                    0x4a002558
+
+#define QSPI_CMD_READ                   (0x3 << 0)
+#define QSPI_CMD_READ_QUAD              (0x6b << 0)
+#define QSPI_CMD_READ_FAST              (0x0b << 0)
+#define QSPI_SETUP0_NUM_A_BYTES         (0x2 << 8)
+#define QSPI_SETUP0_NUM_D_BYTES_NO_BITS (0x0 << 10)
+#define QSPI_SETUP0_NUM_D_BYTES_8_BITS  (0x1 << 10)
+#define QSPI_SETUP0_READ_NORMAL         (0x0 << 12)
+#define QSPI_SETUP0_READ_QUAD           (0x3 << 12)
+#define QSPI_CMD_WRITE                  (0x2 << 16)
+#define QSPI_NUM_DUMMY_BITS             (0x0 << 24)
+
+/* ti qspi register set */
+struct ti_qspi_regs {
+	u32 pid;
+	u32 pad0[3];
+	u32 sysconfig;
+	u32 pad1[3];
+	u32 int_stat_raw;
+	u32 int_stat_en;
+	u32 int_en_set;
+	u32 int_en_ctlr;
+	u32 intc_eoi;
+	u32 pad2[3];
+	u32 clk_ctrl;
+	u32 dc;
+	u32 cmd;
+	u32 status;
+	u32 data;
+	u32 setup0;
+	u32 setup1;
+	u32 setup2;
+	u32 setup3;
+	u32 memswitch;
+	u32 data1;
+	u32 data2;
+	u32 data3;
+};
+
+/* ti qspi slave */
+struct ti_qspi_slave {
+	struct spi_slave slave;
+	struct ti_qspi_regs *base;
+	unsigned int mode;
+	u32 cmd;
+	u32 dc;
+};
+
+static inline struct ti_qspi_slave *to_ti_qspi_slave(struct spi_slave *slave)
+{
+	return container_of(slave, struct ti_qspi_slave, slave);
+}
+
+static void ti_spi_setup_spi_register(struct ti_qspi_slave *qslave)
+{
+	struct spi_slave *slave = &qslave->slave;
+	u32 memval = 0;
+
+#ifdef CONFIG_DRA7XX
+	slave->memory_map = (void *)MMAP_START_ADDR_DRA;
+#else
+	slave->memory_map = (void *)MMAP_START_ADDR_AM43x;
+	slave->op_mode_rx = 8;
+#endif
+
+	memval |= QSPI_CMD_READ | QSPI_SETUP0_NUM_A_BYTES |
+			QSPI_SETUP0_NUM_D_BYTES_NO_BITS |
+			QSPI_SETUP0_READ_NORMAL | QSPI_CMD_WRITE |
+			QSPI_NUM_DUMMY_BITS;
+
+	writel(memval, &qslave->base->setup0);
+}
+
+static void ti_spi_set_speed(struct spi_slave *slave, uint hz)
+{
+	struct ti_qspi_slave *qslave = to_ti_qspi_slave(slave);
+	uint clk_div;
+
+	debug("ti_spi_set_speed: hz: %d, clock divider %d\n", hz, clk_div);
+
+	if (!hz)
+		clk_div = 0;
+	else
+		clk_div = (QSPI_FCLK / hz) - 1;
+
+	/* disable SCLK */
+	writel(readl(&qslave->base->clk_ctrl) & ~QSPI_CLK_EN,
+	       &qslave->base->clk_ctrl);
+
+	/* assign clk_div values */
+	if (clk_div < 0)
+		clk_div = 0;
+	else if (clk_div > QSPI_CLK_DIV_MAX)
+		clk_div = QSPI_CLK_DIV_MAX;
+
+	/* enable SCLK */
+	writel(QSPI_CLK_EN | clk_div, &qslave->base->clk_ctrl);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return 1;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	/* CS handled in xfer */
+	return;
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct ti_qspi_slave *qslave = to_ti_qspi_slave(slave);
+
+	debug("spi_cs_deactivate: 0x%08x\n", (u32)slave);
+
+	writel(qslave->cmd | QSPI_INVAL, &qslave->base->cmd);
+}
+
+void spi_init(void)
+{
+	/* nothing to do */
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+				  unsigned int max_hz, unsigned int mode)
+{
+	struct ti_qspi_slave *qslave;
+
+#ifdef CONFIG_AM43XX
+	gpio_request(CONFIG_QSPI_SEL_GPIO, "qspi_gpio");
+	gpio_direction_output(CONFIG_QSPI_SEL_GPIO, 1);
+#endif
+
+	qslave = spi_alloc_slave(struct ti_qspi_slave, bus, cs);
+	if (!qslave) {
+		printf("SPI_error: Fail to allocate ti_qspi_slave\n");
+		return NULL;
+	}
+
+	qslave->base = (struct ti_qspi_regs *)QSPI_BASE;
+	qslave->mode = mode;
+
+	ti_spi_set_speed(&qslave->slave, max_hz);
+
+#ifdef CONFIG_TI_SPI_MMAP
+	ti_spi_setup_spi_register(qslave);
+#endif
+
+	return &qslave->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct ti_qspi_slave *qslave = to_ti_qspi_slave(slave);
+	free(qslave);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct ti_qspi_slave *qslave = to_ti_qspi_slave(slave);
+
+	debug("spi_claim_bus: bus:%i cs:%i\n", slave->bus, slave->cs);
+
+	qslave->dc = 0;
+	if (qslave->mode & SPI_CPHA)
+		qslave->dc |= QSPI_CKPHA(slave->cs);
+	if (qslave->mode & SPI_CPOL)
+		qslave->dc |= QSPI_CKPOL(slave->cs);
+	if (qslave->mode & SPI_CS_HIGH)
+		qslave->dc |= QSPI_CSPOL(slave->cs);
+
+	writel(qslave->dc, &qslave->base->dc);
+	writel(0, &qslave->base->cmd);
+	writel(0, &qslave->base->data);
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	struct ti_qspi_slave *qslave = to_ti_qspi_slave(slave);
+
+	debug("spi_release_bus: bus:%i cs:%i\n", slave->bus, slave->cs);
+
+	writel(0, &qslave->base->dc);
+	writel(0, &qslave->base->cmd);
+	writel(0, &qslave->base->data);
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+	     void *din, unsigned long flags)
+{
+	struct ti_qspi_slave *qslave = to_ti_qspi_slave(slave);
+	uint words = bitlen >> 3; /* fixed 8-bit word length */
+	const uchar *txp = dout;
+	uchar *rxp = din;
+	uint status;
+	int timeout;
+
+#ifdef CONFIG_DRA7XX
+	int val;
+#endif
+
+	debug("spi_xfer: bus:%i cs:%i bitlen:%i words:%i flags:%lx\n",
+	      slave->bus, slave->cs, bitlen, words, flags);
+
+	/* Setup mmap flags */
+	if (flags & SPI_XFER_MMAP) {
+		writel(MM_SWITCH, &qslave->base->memswitch);
+#ifdef CONFIG_DRA7XX
+		val = readl(CORE_CTRL_IO);
+		val |= MEM_CS;
+		writel(val, CORE_CTRL_IO);
+#endif
+		return 0;
+	} else if (flags & SPI_XFER_MMAP_END) {
+		writel(~MM_SWITCH, &qslave->base->memswitch);
+#ifdef CONFIG_DRA7XX
+		val = readl(CORE_CTRL_IO);
+		val &= MEM_CS_UNSELECT;
+		writel(val, CORE_CTRL_IO);
+#endif
+		return 0;
+	}
+
+	if (bitlen == 0)
+		return -1;
+
+	if (bitlen % 8) {
+		debug("spi_xfer: Non byte aligned SPI transfer\n");
+		return -1;
+	}
+
+	/* Setup command reg */
+	qslave->cmd = 0;
+	qslave->cmd |= QSPI_WLEN(8);
+	qslave->cmd |= QSPI_EN_CS(slave->cs);
+	if (flags & SPI_3WIRE)
+		qslave->cmd |= QSPI_3_PIN;
+	qslave->cmd |= 0xfff;
+
+/* FIXME: This delay is required for successfull
+ * completion of read/write/erase. Once its root
+ * caused, it will be remove from the driver.
+ */
+#ifdef CONFIG_AM43XX
+	udelay(100);
+#endif
+	while (words--) {
+		if (txp) {
+			debug("tx cmd %08x dc %08x data %02x\n",
+			      qslave->cmd | QSPI_WR_SNGL, qslave->dc, *txp);
+			writel(*txp++, &qslave->base->data);
+			writel(qslave->cmd | QSPI_WR_SNGL,
+			       &qslave->base->cmd);
+			status = readl(&qslave->base->status);
+			timeout = QSPI_TIMEOUT;
+			while ((status & QSPI_WC_BUSY) != QSPI_XFER_DONE) {
+				if (--timeout < 0) {
+					printf("spi_xfer: TX timeout!\n");
+					return -1;
+				}
+				status = readl(&qslave->base->status);
+			}
+			debug("tx done, status %08x\n", status);
+		}
+		if (rxp) {
+			qslave->cmd |= QSPI_RD_SNGL;
+			debug("rx cmd %08x dc %08x\n",
+			      qslave->cmd, qslave->dc);
+			#ifdef CONFIG_DRA7XX
+				udelay(500);
+			#endif
+			writel(qslave->cmd, &qslave->base->cmd);
+			status = readl(&qslave->base->status);
+			timeout = QSPI_TIMEOUT;
+			while ((status & QSPI_WC_BUSY) != QSPI_XFER_DONE) {
+				if (--timeout < 0) {
+					printf("spi_xfer: RX timeout!\n");
+					return -1;
+				}
+				status = readl(&qslave->base->status);
+			}
+			*rxp++ = readl(&qslave->base->data);
+			debug("rx done, status %08x, read %02x\n",
+			      status, *(rxp-1));
+		}
+	}
+
+	/* Terminate frame */
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return 0;
+}
diff --git a/drivers/spi/xilinx_spi.c b/drivers/spi/xilinx_spi.c
index 52a4134..56d99d1 100644
--- a/drivers/spi/xilinx_spi.c
+++ b/drivers/spi/xilinx_spi.c
@@ -9,7 +9,7 @@
  * Copyright (c) 2010 Graeme Smecher <graeme.smecher@mail.mcgill.ca>
  * Copyright (c) 2012 Stephan Linz <linz@li-pro.net>
  *
- * Licensed under the GPL-2 or later.
+ * SPDX-License-Identifier:	GPL-2.0+
  *
  * [0]: http://www.xilinx.com/support/documentation
  *
@@ -85,20 +85,20 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 		return NULL;
 	}
 
-	xilspi = malloc(sizeof(*xilspi));
+	xilspi = spi_alloc_slave(struct xilinx_spi_slave, bus, cs);
 	if (!xilspi) {
 		printf("XILSPI error: %s: malloc of SPI structure failed\n",
 				__func__);
 		return NULL;
 	}
-	xilspi->slave.bus = bus;
-	xilspi->slave.cs = cs;
 	xilspi->regs = (struct xilinx_spi_reg *)xilinx_spi_base_list[bus];
 	xilspi->freq = max_hz;
 	xilspi->mode = mode;
 	debug("%s: bus:%i cs:%i base:%p mode:%x max_hz:%d\n", __func__,
 		bus, cs, xilspi->regs, xilspi->mode, xilspi->freq);
 
+	writel(SPISSR_RESET_VALUE, &xilspi->regs->srr);
+
 	return &xilspi->slave;
 }
 
@@ -149,6 +149,7 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	const unsigned char *txp = dout;
 	unsigned char *rxp = din;
 	unsigned rxecount = 17;	/* max. 16 elements in FIFO, leftover 1 */
+	unsigned global_timeout;
 
 	debug("%s: bus:%i cs:%i bitlen:%i bytes:%i flags:%lx\n", __func__,
 		slave->bus, slave->cs, bitlen, bytes, flags);
@@ -176,11 +177,12 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	if (flags & SPI_XFER_BEGIN)
 		spi_cs_activate(slave);
 
-	while (bytes--) {
-		unsigned timeout = /* at least 1usec or greater, leftover 1 */
-			xilspi->freq > XILSPI_MAX_XFER_BITS * 1000000 ? 2 :
+	/* at least 1usec or greater, leftover 1 */
+	global_timeout = xilspi->freq > XILSPI_MAX_XFER_BITS * 1000000 ? 2 :
 			(XILSPI_MAX_XFER_BITS * 1000000 / xilspi->freq) + 1;
 
+	while (bytes--) {
+		unsigned timeout = global_timeout;
 		/* get Tx element from data out buffer and count up */
 		unsigned char d = txp ? *txp++ : CONFIG_XILINX_SPI_IDLE_VAL;
 		debug("%s: tx:%x ", __func__, d);
diff --git a/drivers/spi/xilinx_spi.h b/drivers/spi/xilinx_spi.h
index 32610d2..ce7d82c 100644
--- a/drivers/spi/xilinx_spi.h
+++ b/drivers/spi/xilinx_spi.h
@@ -9,7 +9,7 @@
  * Copyright (c) 2010 Graeme Smecher <graeme.smecher@mail.mcgill.ca>
  * Copyright (c) 2012 Stephan Linz <linz@li-pro.net>
  *
- * Licensed under the GPL-2 or later.
+ * SPDX-License-Identifier:	GPL-2.0+
  *
  * [0]: http://www.xilinx.com/support/documentation
  *
@@ -119,6 +119,9 @@ struct xilinx_spi_reg {
 #define SPIRFOR_OCYVAL_POS	0
 #define SPIRFOR_OCYVAL_MASK	(0xf << SPIRFOR_OCYVAL_POS)
 
+/* SPI Software Reset Register (ssr) */
+#define SPISSR_RESET_VALUE	0x0a
+
 struct xilinx_spi_slave {
 	struct spi_slave slave;
 	struct xilinx_spi_reg *regs;
diff --git a/drivers/spi/zynq_spi.c b/drivers/spi/zynq_spi.c
new file mode 100644
index 0000000..5da8759
--- /dev/null
+++ b/drivers/spi/zynq_spi.c
@@ -0,0 +1,280 @@
+/*
+ * (C) Copyright 2013 Inc.
+ *
+ * Xilinx Zynq PS SPI controller driver (master mode only)
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+
+/* zynq spi register bit masks ZYNQ_SPI_<REG>_<BIT>_MASK */
+#define ZYNQ_SPI_CR_MSA_MASK		(1 << 15)	/* Manual start enb */
+#define ZYNQ_SPI_CR_MCS_MASK		(1 << 14)	/* Manual chip select */
+#define ZYNQ_SPI_CR_CS_MASK		(0xF << 10)	/* Chip select */
+#define ZYNQ_SPI_CR_BRD_MASK		(0x7 << 3)	/* Baud rate div */
+#define ZYNQ_SPI_CR_CPHA_MASK		(1 << 2)	/* Clock phase */
+#define ZYNQ_SPI_CR_CPOL_MASK		(1 << 1)	/* Clock polarity */
+#define ZYNQ_SPI_CR_MSTREN_MASK		(1 << 0)	/* Mode select */
+#define ZYNQ_SPI_IXR_RXNEMPTY_MASK	(1 << 4)	/* RX_FIFO_not_empty */
+#define ZYNQ_SPI_IXR_TXOW_MASK		(1 << 2)	/* TX_FIFO_not_full */
+#define ZYNQ_SPI_IXR_ALL_MASK		0x7F		/* All IXR bits */
+#define ZYNQ_SPI_ENR_SPI_EN_MASK	(1 << 0)	/* SPI Enable */
+
+#define ZYNQ_SPI_FIFO_DEPTH		128
+#ifndef CONFIG_SYS_ZYNQ_SPI_WAIT
+#define CONFIG_SYS_ZYNQ_SPI_WAIT	(CONFIG_SYS_HZ/100)	/* 10 ms */
+#endif
+
+/* zynq spi register set */
+struct zynq_spi_regs {
+	u32 cr;		/* 0x00 */
+	u32 isr;	/* 0x04 */
+	u32 ier;	/* 0x08 */
+	u32 idr;	/* 0x0C */
+	u32 imr;	/* 0x10 */
+	u32 enr;	/* 0x14 */
+	u32 dr;		/* 0x18 */
+	u32 txdr;	/* 0x1C */
+	u32 rxdr;	/* 0x20 */
+};
+
+/* zynq spi slave */
+struct zynq_spi_slave {
+	struct spi_slave slave;
+	struct zynq_spi_regs *base;
+	u8 mode;
+	u8 fifo_depth;
+	u32 speed_hz;
+	u32 input_hz;
+	u32 req_hz;
+};
+
+static inline struct zynq_spi_slave *to_zynq_spi_slave(struct spi_slave *slave)
+{
+	return container_of(slave, struct zynq_spi_slave, slave);
+}
+
+static inline struct zynq_spi_regs *get_zynq_spi_base(int dev)
+{
+	if (dev)
+		return (struct zynq_spi_regs *)ZYNQ_SPI_BASEADDR1;
+	else
+		return (struct zynq_spi_regs *)ZYNQ_SPI_BASEADDR0;
+}
+
+static void zynq_spi_init_hw(struct zynq_spi_slave *zslave)
+{
+	u32 confr;
+
+	/* Disable SPI */
+	writel(~ZYNQ_SPI_ENR_SPI_EN_MASK, &zslave->base->enr);
+
+	/* Disable Interrupts */
+	writel(ZYNQ_SPI_IXR_ALL_MASK, &zslave->base->idr);
+
+	/* Clear RX FIFO */
+	while (readl(&zslave->base->isr) &
+			ZYNQ_SPI_IXR_RXNEMPTY_MASK)
+		readl(&zslave->base->rxdr);
+
+	/* Clear Interrupts */
+	writel(ZYNQ_SPI_IXR_ALL_MASK, &zslave->base->isr);
+
+	/* Manual slave select and Auto start */
+	confr = ZYNQ_SPI_CR_MCS_MASK | ZYNQ_SPI_CR_CS_MASK |
+		ZYNQ_SPI_CR_MSTREN_MASK;
+	confr &= ~ZYNQ_SPI_CR_MSA_MASK;
+	writel(confr, &zslave->base->cr);
+
+	/* Enable SPI */
+	writel(ZYNQ_SPI_ENR_SPI_EN_MASK, &zslave->base->enr);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	/* 2 bus with 3 chipselect */
+	return bus < 2 && cs < 3;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct zynq_spi_slave *zslave = to_zynq_spi_slave(slave);
+	u32 cr;
+
+	debug("spi_cs_activate: 0x%08x\n", (u32)slave);
+
+	clrbits_le32(&zslave->base->cr, ZYNQ_SPI_CR_CS_MASK);
+	cr = readl(&zslave->base->cr);
+	/*
+	 * CS cal logic: CS[13:10]
+	 * xxx0	- cs0
+	 * xx01	- cs1
+	 * x011 - cs2
+	 */
+	cr |= (~(0x1 << slave->cs) << 10) & ZYNQ_SPI_CR_CS_MASK;
+	writel(cr, &zslave->base->cr);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct zynq_spi_slave *zslave = to_zynq_spi_slave(slave);
+
+	debug("spi_cs_deactivate: 0x%08x\n", (u32)slave);
+
+	setbits_le32(&zslave->base->cr, ZYNQ_SPI_CR_CS_MASK);
+}
+
+void spi_init()
+{
+	/* nothing to do */
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct zynq_spi_slave *zslave;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	zslave = spi_alloc_slave(struct zynq_spi_slave, bus, cs);
+	if (!zslave) {
+		printf("SPI_error: Fail to allocate zynq_spi_slave\n");
+		return NULL;
+	}
+
+	zslave->base = get_zynq_spi_base(bus);
+	zslave->mode = mode;
+	zslave->fifo_depth = ZYNQ_SPI_FIFO_DEPTH;
+	zslave->input_hz = 166666700;
+	zslave->speed_hz = zslave->input_hz / 2;
+	zslave->req_hz = max_hz;
+
+	/* init the zynq spi hw */
+	zynq_spi_init_hw(zslave);
+
+	return &zslave->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct zynq_spi_slave *zslave = to_zynq_spi_slave(slave);
+
+	debug("spi_free_slave: 0x%08x\n", (u32)slave);
+	free(zslave);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct zynq_spi_slave *zslave = to_zynq_spi_slave(slave);
+	u32 confr = 0;
+	u8 baud_rate_val = 0;
+
+	writel(~ZYNQ_SPI_ENR_SPI_EN_MASK, &zslave->base->enr);
+
+	/* Set the SPI Clock phase and polarities */
+	confr = readl(&zslave->base->cr);
+	confr &= ~(ZYNQ_SPI_CR_CPHA_MASK | ZYNQ_SPI_CR_CPOL_MASK);
+	if (zslave->mode & SPI_CPHA)
+		confr |= ZYNQ_SPI_CR_CPHA_MASK;
+	if (zslave->mode & SPI_CPOL)
+		confr |= ZYNQ_SPI_CR_CPOL_MASK;
+
+	/* Set the clock frequency */
+	if (zslave->req_hz == 0) {
+		/* Set baudrate x8, if the req_hz is 0 */
+		baud_rate_val = 0x2;
+	} else if (zslave->speed_hz != zslave->req_hz) {
+		while ((baud_rate_val < 8) &&
+				((zslave->input_hz /
+				(2 << baud_rate_val)) > zslave->req_hz))
+			baud_rate_val++;
+		zslave->speed_hz = zslave->req_hz / (2 << baud_rate_val);
+	}
+	confr &= ~ZYNQ_SPI_CR_BRD_MASK;
+	confr |= (baud_rate_val << 3);
+	writel(confr, &zslave->base->cr);
+
+	writel(ZYNQ_SPI_ENR_SPI_EN_MASK, &zslave->base->enr);
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	struct zynq_spi_slave *zslave = to_zynq_spi_slave(slave);
+
+	debug("spi_release_bus: 0x%08x\n", (u32)slave);
+	writel(~ZYNQ_SPI_ENR_SPI_EN_MASK, &zslave->base->enr);
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct zynq_spi_slave *zslave = to_zynq_spi_slave(slave);
+	u32 len = bitlen / 8;
+	u32 tx_len = len, rx_len = len, tx_tvl;
+	const u8 *tx_buf = dout;
+	u8 *rx_buf = din, buf;
+	u32 ts, status;
+
+	debug("spi_xfer: bus:%i cs:%i bitlen:%i len:%i flags:%lx\n",
+	      slave->bus, slave->cs, bitlen, len, flags);
+
+	if (bitlen == 0)
+		return -1;
+
+	if (bitlen % 8) {
+		debug("spi_xfer: Non byte aligned SPI transfer\n");
+		return -1;
+	}
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	while (rx_len > 0) {
+		/* Write the data into TX FIFO - tx threshold is fifo_depth */
+		tx_tvl = 0;
+		while ((tx_tvl < zslave->fifo_depth) && tx_len) {
+			if (tx_buf)
+				buf = *tx_buf++;
+			else
+				buf = 0;
+			writel(buf, &zslave->base->txdr);
+			tx_len--;
+			tx_tvl++;
+		}
+
+		/* Check TX FIFO completion */
+		ts = get_timer(0);
+		status = readl(&zslave->base->isr);
+		while (!(status & ZYNQ_SPI_IXR_TXOW_MASK)) {
+			if (get_timer(ts) > CONFIG_SYS_ZYNQ_SPI_WAIT) {
+				printf("spi_xfer: Timeout! TX FIFO not full\n");
+				return -1;
+			}
+			status = readl(&zslave->base->isr);
+		}
+
+		/* Read the data from RX FIFO */
+		status = readl(&zslave->base->isr);
+		while (status & ZYNQ_SPI_IXR_RXNEMPTY_MASK) {
+			buf = readl(&zslave->base->rxdr);
+			if (rx_buf)
+				*rx_buf++ = buf;
+			status = readl(&zslave->base->isr);
+			rx_len--;
+		}
+	}
+
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return 0;
+}
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index f54b408..826a09a 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -30,6 +30,8 @@
 
 #include "ehci.h"
 
+static bool has_erratum_a005275(void);
+
 /* Check USB PHY clock valid */
 static int usb_phy_clk_valid(struct usb_ehci *ehci)
 {
@@ -50,6 +52,8 @@ static int usb_phy_clk_valid(struct usb_ehci *ehci)
  */
 int ehci_hcd_init(int index, struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 {
+	struct ehci_ctrl *ehci_ctrl = container_of(hccr,
+					struct ehci_ctrl, hccr);
 	struct usb_ehci *ehci;
 	const char *phy_type = NULL;
 	size_t len;
@@ -59,7 +63,23 @@ int ehci_hcd_init(int index, struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 	usb_phy[0] = '\0';
 #endif
 
-	ehci = (struct usb_ehci *)CONFIG_SYS_FSL_USB_ADDR;
+    uint32_t offset = 0;
+
+    switch(index)
+    {
+        case 0:
+            offset = 0x0;
+        break;
+
+        case 1:
+            offset = 0x1000;
+        break;
+
+        default:
+        break;
+    }
+
+	ehci = (struct usb_ehci *)(CONFIG_SYS_FSL_USB_ADDR + offset);
 	*hccr = (struct ehci_hccr *)((uint32_t)&ehci->caplength);
 	*hcor = (struct ehci_hcor *)((uint32_t) *hccr +
 			HC_LENGTH(ehci_readl(&(*hccr)->cr_capbase)));
@@ -87,13 +107,13 @@ int ehci_hcd_init(int index, struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 #endif
 	}
 
-	if (!strcmp(phy_type, "utmi")) {
+	if (!strncmp(phy_type, "utmi", 4)) {
 #if defined(CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY)
 		setbits_be32(&ehci->control, PHY_CLK_SEL_UTMI);
 		setbits_be32(&ehci->control, UTMI_PHY_EN);
 		udelay(1000); /* delay required for PHY Clk to appear */
 #endif
-		out_le32(&(*hcor)->or_portsc[0], PORT_PTS_UTMI);
+		out_le32(&(*hcor)->or_portsc[index], PORT_PTS_UTMI);
 		setbits_be32(&ehci->control, USB_EN);
 	} else {
 		setbits_be32(&ehci->control, PHY_CLK_SEL_ULPI);
@@ -101,7 +121,7 @@ int ehci_hcd_init(int index, struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 		udelay(1000); /* delay required for PHY Clk to appear */
 		if (!usb_phy_clk_valid(ehci))
 			return -EINVAL;
-		out_le32(&(*hcor)->or_portsc[0], PORT_PTS_ULPI);
+		out_le32(&(*hcor)->or_portsc[index], PORT_PTS_ULPI);
 	}
 
 	out_be32(&ehci->prictrl, 0x0000000c);
@@ -110,6 +130,17 @@ int ehci_hcd_init(int index, struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 
 	in_le32(&ehci->usbmode);
 
+	/* enable/disable USB Erratum USB A-005275 workaround;
+	* workaround can be disabled by mentioning "no_usb_hs_errata"
+	* in hwconfig string
+	*/
+	if (!hwconfig("no_erratum_a005275")) {
+		if (has_erratum_a005275())
+			ehci_ctrl->has_fsl_erratum_a005275 = 1;
+	} else {
+		ehci_ctrl->has_fsl_erratum_a005275 = 0;
+	}
+
 	return 0;
 }
 
@@ -121,3 +152,30 @@ int ehci_hcd_stop(int index)
 {
 	return 0;
 }
+
+/* Deal with USB Erratum USB A-005275
+ *	* Packet corruption in HS mode, default to
+ *	* FS mode for the following
+ *	* P3041 and P2041 rev 1.0 and 1.1
+ *	* P5020 and P5010 rev 1.0 and 2.0
+ *	* P5040 and P1010 rev 1.0
+ */
+static bool has_erratum_a005275(void)
+{
+	u32 svr = get_svr();
+	u32 soc = SVR_SOC_VER(svr);
+
+	switch (soc) {
+	case SVR_P3041:
+	case SVR_P2041:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1);
+	case SVR_P5020:
+	case SVR_P5010:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
+	case SVR_P5040:
+	case SVR_P1010:
+		return IS_SVR_REV(svr, 1, 0);
+	}
+
+	return false;
+}
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7f98a63..6b25290 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -31,16 +31,10 @@
 #include "ehci.h"
 
 #ifndef CONFIG_USB_MAX_CONTROLLER_COUNT
-#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
 #endif
 
-static struct ehci_ctrl {
-	struct ehci_hccr *hccr;	/* R/O registers, not need for volatile */
-	struct ehci_hcor *hcor;
-	int rootdev;
-	uint16_t portreset;
-	struct QH qh_list __attribute__((aligned(USB_DMA_MINALIGN)));
-} ehcic[CONFIG_USB_MAX_CONTROLLER_COUNT];
+static struct ehci_ctrl ehcic[CONFIG_USB_MAX_CONTROLLER_COUNT];
 
 #define ALIGN_END_ADDR(type, ptr, size)			\
 	((uint32_t)(ptr) + roundup((size) * sizeof(type), USB_DMA_MINALIGN))
@@ -335,9 +329,15 @@ ehci_submit_async(struct usb_device *dev, unsigned long pipe, void *buffer,
 	endpt = QH_ENDPT1_RL(8) | QH_ENDPT1_C(c) |
 		QH_ENDPT1_MAXPKTLEN(maxpacket) | QH_ENDPT1_H(0) |
 		QH_ENDPT1_DTC(QH_ENDPT1_DTC_DT_FROM_QTD) |
-		QH_ENDPT1_EPS(ehci_encode_speed(dev->speed)) |
 		QH_ENDPT1_ENDPT(usb_pipeendpoint(pipe)) | QH_ENDPT1_I(0) |
 		QH_ENDPT1_DEVADDR(usb_pipedevice(pipe));
+
+	/* Force FS for fsl HS quirk */
+	if (!ctrl->has_fsl_erratum_a005275)
+		endpt |= QH_ENDPT1_EPS(ehci_encode_speed(dev->speed));
+	else
+		endpt |= QH_ENDPT1_EPS(ehci_encode_speed(QH_FULL_SPEED));
+
 	qh->qh_endpt1 = cpu_to_hc32(endpt);
 	endpt = QH_ENDPT2_MULT(1) | QH_ENDPT2_PORTNUM(dev->portnr) |
 		QH_ENDPT2_HUBADDR(dev->parent->devnum) |
@@ -760,6 +760,10 @@ ehci_submit_root(struct usb_device *dev, unsigned long pipe, void *buffer,
 			} else {
 				int ret;
 
+				/* Disable chirp for HS erratum */
+				if (ctrl->has_fsl_erratum_a005275)
+					reg |= PORTSC_FSL_PFSC;
+
 				reg |= EHCI_PS_PR;
 				reg &= ~EHCI_PS_PE;
 				ehci_writel(status_reg, reg);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 1e3cd79..4dd7179 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -22,6 +22,8 @@
 #ifndef USB_EHCI_H
 #define USB_EHCI_H
 
+#include <stdbool.h>
+
 #if !defined(CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS)
 #define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS	2
 #endif
@@ -248,6 +250,20 @@ struct QH {
 	uint8_t fill[16];
 };
 
+#define	PORTSC_FSL_PFSC	(1 << 24)	/* PFSC bit to disable HS chirping */
+
+struct ehci_ctrl {
+	struct ehci_hccr *hccr;	/* R/O registers, not need for volatile */
+	struct ehci_hcor *hcor;
+	int rootdev;
+	uint16_t portreset;
+	struct QH qh_list __aligned(USB_DMA_MINALIGN);
+	struct QH periodic_queue __aligned(USB_DMA_MINALIGN);
+	uint32_t *periodic_list;
+	int ntds;
+	bool has_fsl_erratum_a005275;	/* Freescale HS silicon quirk */
+};
+
 /* Low level init functions */
 int ehci_hcd_init(int index, struct ehci_hccr **hccr, struct ehci_hcor **hcor);
 int ehci_hcd_stop(int index);
diff --git a/fs/fat/fat.c b/fs/fat/fat.c
index 25d3318..393c378 100644
--- a/fs/fat/fat.c
+++ b/fs/fat/fat.c
@@ -569,9 +569,9 @@ static __u8 mkcksum(const char name[8], const char ext[3])
 
 	__u8 ret = 0;
 
-	for (i = 0; i < 8; i++)
+	for (i = 0; i < sizeof(name); i++)
 		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + name[i];
-	for (i = 0; i < 3; i++)
+	for (i = 0; i < sizeof(ext); i++)
 		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + ext[i];
 
 	return ret;
diff --git a/include/broadcom_phy.h b/include/broadcom_phy.h
index 2607c5c..54673ae 100644
--- a/include/broadcom_phy.h
+++ b/include/broadcom_phy.h
@@ -43,4 +43,4 @@
 #define MIIM_BCM54XX_EXP_SEL_SSD    0x0e00  /* Secondary SerDes select */
 #define MIIM_BCM54XX_EXP_SEL_ER     0x0f00  /* Expansion register select */
 
-#endif	/* BROADCOM_PHY_H__ */
+#endif	/* BROADCOM_PHY_H__ */
\ No newline at end of file
diff --git a/include/common.h b/include/common.h
index a29f6a6..f26a80d 100644
--- a/include/common.h
+++ b/include/common.h
@@ -307,7 +307,7 @@ int	checkflash    (void);
 int	checkdram     (void);
 int	last_stage_init(void);
 extern ulong monitor_flash_len;
-int mac_read_from_eeprom(void);
+int onie_mac_read_from_eeprom(void);
 int populate_serial_number(void);
 extern u8 _binary_dt_dtb_start[];	/* embedded device tree blob */
 int set_cpu_clk_info(void);
diff --git a/include/configs/ACCTON_AS6700_32X-R0.h b/include/configs/ACCTON_AS6700_32X-R0.h
new file mode 100644
index 0000000..709a680
--- /dev/null
+++ b/include/configs/ACCTON_AS6700_32X-R0.h
@@ -0,0 +1,850 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * P2041 RDB board configuration file
+ * Also supports P2040 RDB
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define ACCTON_AS6700_32X
+#define CONFIG_BOARDNAME "Accton AS6700_32X"
+#define CONFIG_LAST_STAGE_INIT
+
+#define CONFIG_SYNC_VERSION_VARIABLE_TO_FLASH
+
+#define CONFIG_P2041RDB
+#define CONFIG_PHYS_64BIT
+#define CONFIG_PPC_P2041
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_RAMBOOT_TEXT_BASE	CONFIG_SYS_TEXT_BASE
+#define CONFIG_RESET_VECTOR_ADDRESS	0xfffffffc
+#define CONFIG_PBLPBI_CONFIG $(SRCTREE)/board/freescale/as6700_32x/pbi.cfg
+#define CONFIG_PBLRCW_CONFIG $(SRCTREE)/board/freescale/as6700_32x/rcw.cfg
+#endif
+
+#if 0
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+/* Set 1M boot space */
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR (CONFIG_SYS_TEXT_BASE & 0xfff00000)
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR)
+#define CONFIG_RESET_VECTOR_ADDRESS 0xfffffffc
+#define CONFIG_SYS_NO_FLASH
+#endif
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_E500MC			/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
+#define CONFIG_MPC85xx			/* MPC85xx/PQ3 platform */
+#define CONFIG_MP			/* support multiple processors */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#define CONFIG_SYS_FSL_CPC		/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC		CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_ELBC			/* Has Enhanced localbus controller */
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#define CONFIG_PCIE1			/* PCIE controler 1 */
+#define CONFIG_PCIE2			/* PCIE controler 2 */
+#define CONFIG_PCIE3			/* PCIE controler 3 */
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+
+#if 0
+#define CONFIG_SYS_SRIO
+#define CONFIG_SRIO1			/* SRIO port 1 */
+#define CONFIG_SRIO2			/* SRIO port 2 */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+#define CONFIG_SYS_DPAA_RMAN		/* RMan */
+#endif
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_SYS_NO_FLASH
+
+#ifdef CONFIG_SYS_NO_FLASH
+#if !defined(CONFIG_RAMBOOT_PBL) && !defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+#define CONFIG_ENV_IS_NOWHERE
+#endif
+#else
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_SPI_FLASH_BAR
+
+#if defined(CONFIG_SPIFLASH)
+	#define CONFIG_SYS_EXTRA_ENV_RELOC
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+	#define CONFIG_ENV_SPI_BUS              0
+	#define CONFIG_ENV_SPI_CS               0
+	#define CONFIG_ENV_SPI_MAX_HZ           10000000
+	#define CONFIG_ENV_SPI_MODE             0
+	#define CONFIG_ENV_SIZE                 0x2000          /* 8KB */
+	#define CONFIG_ENV_OFFSET               0x100000        /* 1MB */
+	#define CONFIG_ENV_SECT_SIZE            0x10000
+#elif defined(CONFIG_SDCARD)
+	#define CONFIG_SYS_EXTRA_ENV_RELOC
+	#define CONFIG_ENV_IS_IN_MMC
+	#define CONFIG_FSL_FIXED_MMC_LOCATION
+	#define CONFIG_SYS_MMC_ENV_DEV          0
+	#define CONFIG_ENV_SIZE			0x2000
+	#define CONFIG_ENV_OFFSET		(512 * 1105)
+#else
+	#error No supported storage type was defined.
+#endif
+
+/*#define CONFIG_BOOTARGS     "root=/dev/ram rw console=ttyS0,115200 mem=3968M quiet"*/
+/*#define CONFIG_ETHADDR      00:E0:0C:00:00:FD*/
+/*#define CONFIG_ETH2ADDR     00:00:00:00:00:02*/
+/*#define CONFIG_ETH3ADDR     00:00:00:00:00:03*/
+#define CONFIG_IPADDR       192.168.3.10
+#define CONFIG_SERVERIP     192.168.3.14
+#define CONFIG_GATEWAYIP    192.168.3.14
+#define CONFIG_NETMASK      255.255.255.0
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(unsigned long dummy);
+#endif
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk(0)
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BACKSIDE_L2_CACHE
+#define CONFIG_SYS_INIT_L2CSR0		L2CSR0_L2E
+#define CONFIG_BTB			/* toggle branch predition */
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP
+#define CONFIG_SYS_NUM_ADDR_MAP		64	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_POST CONFIG_SYS_POST_MEMORY	/* test POST memory test */
+#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+/*
+ *  Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		CONFIG_RAMBOOT_TEXT_BASE
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_L3_ADDR_PHYS	(0xf00000000ull | \
+		CONFIG_RAMBOOT_TEXT_BASE)
+#else
+#define CONFIG_SYS_INIT_L3_ADDR_PHYS	CONFIG_SYS_INIT_L3_ADDR
+#endif
+#define CONFIG_SYS_L3_SIZE		(1024 << 10)
+#define CONFIG_SYS_INIT_L3_END (CONFIG_SYS_INIT_L3_ADDR + CONFIG_SYS_L3_SIZE)
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_DCSRBAR		0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS		0xf00000000ull
+#endif
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL    (1 * CONFIG_DIMM_SLOTS_PER_CTLR)
+
+#define CONFIG_DDR_SPD
+#define CONFIG_FSL_DDR3
+
+#define CONFIG_DDR_ECC
+#define CONFIG_MEM_INIT_VALUE 0xdeadbeef
+/*#define CONFIG_SYS_DRAM_TEST*/
+
+#define CONFIG_SYS_SPD_BUS_NUM	0
+
+#define SPD_EEPROM_ADDRESS 0x50
+#define CONFIG_SYS_SDRAM_SIZE 2048  /* for fixed parameter use */
+
+/*
+ * Local Bus Definitions
+ */
+
+/* Set the local bus clock 1/8 of platform clock */
+#define CONFIG_SYS_LBC_LCRR     LCRR_CLKDIV_32
+
+/*
+ * This board doesn't have a promjet connector.
+ * However, it uses commone corenet board LAW and TLB.
+ * It is necessary to use the same start address with proper offset.
+ */
+#define CONFIG_SYS_FLASH_BASE       0xec000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS  0xfec000000ull
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+/*#define CONFIG_SYS_FLASH_BR_PRELIM \
+		(BR_PHYS_ADDR((CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000)) | \
+		BR_PS_16 | BR_V)*/
+#define CONFIG_SYS_FLASH_BR_PRELIM \
+        (BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_16 | BR_V)
+/*#define CONFIG_SYS_FLASH_OR_PRELIM \
+		((0xf8000ff7 & ~OR_GPCM_SCY & ~OR_GPCM_EHTR) \
+		 | OR_GPCM_SCY_8 | OR_GPCM_EHTR_CLEAR)*/
+#define CONFIG_SYS_FLASH_OR_PRELIM \
+        ((0xfc000ff7 & ~OR_GPCM_SCY & ~OR_GPCM_EHTR) \
+         | OR_GPCM_SCY_8 | OR_GPCM_EHTR_CLEAR)
+
+#define CONFIG_FSL_CPLD
+#define CPLD_BASE		0xffdf0000	/* CPLD registers */
+#ifdef CONFIG_PHYS_64BIT
+#define CPLD_BASE_PHYS		0xfffdf0000ull
+#else
+#define CPLD_BASE_PHYS		CPLD_BASE
+#endif
+
+#define CONFIG_SYS_BR3_PRELIM	(BR_PHYS_ADDR(CPLD_BASE_PHYS) | BR_PS_8 | BR_V)
+#define CONFIG_SYS_OR3_PRELIM	0xffffeff7	/* 32KB but only 4k mapped */
+
+#define PIXIS_LBMAP_SWITCH	7
+#define PIXIS_LBMAP_MASK	0xf0
+#define PIXIS_LBMAP_SHIFT	4
+#define PIXIS_LBMAP_ALTBANK	0x40
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1		/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024		/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000		/* Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500		/* Write Timeout (ms) */
+
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+/*#define CONFIG_NAND_FSL_ELBC*/
+/* Nand Flash */
+#ifdef CONFIG_NAND_FSL_ELBC
+#define CONFIG_SYS_NAND_BASE		0xffa00000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfffa00000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+
+#define CONFIG_SYS_NAND_BASE_LIST     {CONFIG_SYS_NAND_BASE}
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_NAND_BLOCK_SIZE    (128 * 1024)
+
+/* NAND flash config */
+#define CONFIG_SYS_NAND_BR_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+			       | (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
+			       | BR_PS_8	       /* Port Size = 8 bit */ \
+			       | BR_MS_FCM	       /* MSEL = FCM */ \
+			       | BR_V)		       /* valid */
+#define CONFIG_SYS_NAND_OR_PRELIM  (0xFFFC0000	      /* length 256K */ \
+			       | OR_FCM_PGS	       /* Large Page*/ \
+			       | OR_FCM_CSCT \
+			       | OR_FCM_CST \
+			       | OR_FCM_CHT \
+			       | OR_FCM_SCY_1 \
+			       | OR_FCM_TRLX \
+			       | OR_FCM_EHTR)
+
+#ifdef CONFIG_NAND
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_SYS_NAND_BR_PRELIM /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_SYS_FLASH_BR_PRELIM /* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_SYS_FLASH_OR_PRELIM /* NOR Options */
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_SYS_FLASH_BR_PRELIM /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_SYS_FLASH_OR_PRELIM /* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_SYS_NAND_BR_PRELIM /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+#endif
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_SYS_FLASH_BR_PRELIM /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_SYS_FLASH_OR_PRELIM /* NOR Options */
+#endif /* CONFIG_NAND_FSL_ELBC */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_AMD_CHECK_DQ7
+/*#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000}*/
+#define CONFIG_SYS_FLASH_BANKS_LIST {CONFIG_SYS_FLASH_BASE_PHYS}
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* Initial L1 address */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#else
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	CONFIG_SYS_INIT_RAM_ADDR
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+#endif
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+					GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)
+
+/* Serial Port - controlled on board with jumper J8
+ * open - index 2
+ * shorted - index 1
+ */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3	(CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4	(CONFIG_SYS_CCSRBAR+0x11D600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+
+/* new uImage format support */
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x118000
+#define CONFIG_SYS_I2C2_OFFSET		0x118100
+#define CONFIG_SYS_I2C3_OFFSET      0x119000
+#define CONFIG_SYS_I2C4_OFFSET      0x119100
+
+
+#if 0
+/*
+ * RapidIO
+ */
+#define CONFIG_SYS_SRIO1_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_SRIO1_MEM_SIZE	0x10000000	/* 256M */
+
+#define CONFIG_SYS_SRIO2_MEM_VIRT	0xb0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xc30000000ull
+#else
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xb0000000
+#endif
+#define CONFIG_SYS_SRIO2_MEM_SIZE	0x10000000	/* 256M */
+
+/*
+ * for slave u-boot IMAGE instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef080000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff80000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE 0x80000	/* 512K */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff80000ull
+/*
+ * for slave UCODE and ENV instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef040000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS 0x3ffe00000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE 0x40000	/* 256K */
+
+/* slave core release by master*/
+#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET 0xe00e4
+#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK 0x00000001 /* release core 0 */
+
+/*
+ * SRIO_PCIE_BOOT - SLAVE
+ */
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
+#endif
+
+#endif
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+/*#define CONFIG_SPI_FLASH_SPANSION*/
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED         10000000
+#define CONFIG_SF_DEFAULT_MODE          3
+
+/*PCIE default setting*/
+#if 0
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xf8000000
+#endif
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xff8010000ull
+#else
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xf8010000
+#endif
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xc0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc40000000ull
+#else
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc0000000
+#endif
+#define CONFIG_SYS_PCIE3_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xff8020000ull
+#else
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xf8020000
+#endif
+#define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT   0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS    0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS   0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE1_IO_VIRT    0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS    0xf8000000
+#define CONFIG_SYS_PCIE1_IO_SIZE    0x00010000  /* 64k */
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#define CONFIG_SYS_PCIE2_MEM_VIRT   0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_BUS    0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS   0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE2_IO_VIRT    0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS    0xf8010000
+#define CONFIG_SYS_PCIE2_IO_SIZE    0x00010000  /* 64k */
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#define CONFIG_SYS_PCIE3_MEM_VIRT   0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_BUS    0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS   0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE3_IO_VIRT    0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE3_IO_PHYS    0xf8020000
+#define CONFIG_SYS_PCIE3_IO_SIZE    0x00010000  /* 64k */
+
+/* Qman/Bman */
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#else
+#define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf4200000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff4200000ull
+#else
+#define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_SYS_DPAA_PME
+/* Default address of microcode for the Linux Fman driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0x110000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 545KB (1089 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 1089 + 16 = 1113, enlarge it to 1130.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(512 * 1130)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(6 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+/*
+ * Slave has no ucode locally, it can fetch this from remote. When implementing
+ * in two corenet boards, slave's ucode could be stored in master's memory
+ * space, the address can be mapped from slave TLB->slave LAW->
+ * slave SRIO or PCIE outbound window->master inbound window->
+ * master LAW->the ucode address in master's memory space.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0xFFE00000
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0xEFF40000
+#endif
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHYLIB_10G
+
+/*#define CONFIG_PHY_VITESSE*/
+#define CONFIG_PHY_BROADCOM
+
+#define CONFIG_PHY_TERANETICS
+#endif
+
+#ifdef CONFIG_PCI
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_E1000
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#endif	/* CONFIG_PCI */
+
+/* SATA */
+#define CONFIG_FSL_SATA_V2
+
+#ifdef CONFIG_FSL_SATA_V2
+#define CONFIG_FSL_SATA
+#define CONFIG_LIBATA
+
+#define CONFIG_SYS_SATA_MAX_DEVICE	2
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+#define CONFIG_SATA2
+#define CONFIG_SYS_SATA2		CONFIG_SYS_MPC85xx_SATA2_ADDR
+#define CONFIG_SYS_SATA2_FLAGS		FLAGS_DMA
+
+#define CONFIG_LBA48
+#define CONFIG_CMD_SATA
+#define CONFIG_CMD_EXT2
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_SYS_FM1_DTSEC1_PHY_ADDR	0x2
+#define CONFIG_SYS_FM1_DTSEC2_PHY_ADDR	0x3
+#define CONFIG_SYS_FM1_DTSEC3_PHY_ADDR	0x4
+#define CONFIG_SYS_FM1_DTSEC4_PHY_ADDR	0x1
+#define CONFIG_SYS_FM1_DTSEC5_PHY_ADDR	0x0
+
+#define CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR	0x1c
+#define CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR	0x1d
+#define CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR	0x1e
+#define CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR    0x01
+
+#define CONFIG_SYS_FM1_10GEC1_PHY_ADDR	0
+
+#define CONFIG_SYS_TBIPA_VALUE	8
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC1"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+/*
+ * Environment
+ */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+* USB
+*/
+#define CONFIG_HAS_FSL_DR_USB
+#define CONFIG_HAS_FSL_MPH_USB
+
+#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB)
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#endif
+
+#define CONFIG_CMD_EXT2
+
+#define CONFIG_MMC
+
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR       CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_SYS_FSL_ESDHC_BROKEN_TIMEOUT
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"LOADER=> "	/* Monitor Command Prompt */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial Memory for Linux */
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	u-boot.bin
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR     2000000
+
+#define __USB_PHY_TYPE	utmi
+
+/*ONIE redefined*/
+/*
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
+	"bank_intlv=cs0_cs1\0"					\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"			\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"		\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"usb_phy_type=" __stringify(__USB_PHY_TYPE) "\0"		\
+	"usb_dr_mode=host\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"ramdiskfile=p2041rdb/ramdisk.uboot\0"			\
+	"fdtaddr=c00000\0"					\
+	"fdtfile=p2041rdb/p2041rdb.dtb\0"			\
+	"bdev=sda3\0"						\
+	"c=ffe\0"
+*/
+#define CONFIG_HDBOOT					\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_NFSBOOTCOMMAND			\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND				\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $ramdiskaddr $ramdiskfile;"		\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+/*#define CONFIG_BOOTCOMMAND        CONFIG_HDBOOT*/ /*ONIE redefined*/
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+/* ICOS Fastpath app image file support */
+#define CONFIG_FASTPATH
+
+#ifdef CONFIG_FASTPATH
+#define CONFIG_FDT_INDEX        4
+#endif
+
+/* ONIE */
+#include "common_config.h"
+
+#undef CONFIG_CMD_JFFS2
+
+#define CONFIG_SYS_EEPROM_LOAD_ENV_MAC
+#define CONFIG_CMD_SYS_EEPROM
+#define CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS 2
+
+#define CONFIG_SYS_EEPROM_USE_COMMON_SPI_IO
+#define CONFIG_SYS_SPI_FLASH_HWINFO_ADDR        0x00120000
+#define CONFIG_SYS_SPI_FLASH_HWINFO_SECT_SIZE   0x00010000
+#define CONFIG_SYS_EEPROM_MAX_SIZE		CONFIG_SYS_SPI_FLASH_HWINFO_SECT_SIZE
+#define CONFIG_PLATFORM_ENV     \
+    "hwconfig=fsl_ddr:ctlr_intlv=cacheline," \
+    "bank_intlv=cs0_cs1\0"      \
+    "consoledev=ttyS0\0"        \
+    "boot_diag=if test -n $onie_boot_reason; then " \
+        "if test $onie_boot_reason = diag; then "   \
+        "run diag_bootcmd; fi; fi\0"                \
+    "diag_bootcmd=setenv bootargs root=/dev/ram rw console=ttyS0,$baudrate quiet $diagargs;"    \
+        "run fan_default_speed;"    \
+        "sf probe; sf read $loadaddr $diag_start ${diag_sz.b}; bootm $loadaddr\0"   \
+    "fan_speed_level=7\0"       \
+    "fan_default_speed=i2c dev 1; i2c mw 0x35 0x20 $fan_speed_level\0"  \
+    "diag_start=0x00930000\0"   \
+    "diag_sz.b=0x02000000\0"    \
+    "onie_start=0x00130000\0"   \
+    "onie_sz.b=0x500000\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    CONFIG_PLATFORM_ENV           \
+    CONFIG_ONIE_COMMON_UBOOT_ENV
+/* ONIE */
+
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ACCTON_AS6700_32X-R1.h b/include/configs/ACCTON_AS6700_32X-R1.h
new file mode 100644
index 0000000..6a6d65b
--- /dev/null
+++ b/include/configs/ACCTON_AS6700_32X-R1.h
@@ -0,0 +1,851 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * P2041 RDB board configuration file
+ * Also supports P2040 RDB
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define ACCTON_AS6700_32X
+#define CONFIG_BOARDNAME "Accton AS6700_32X"
+#define CONFIG_LAST_STAGE_INIT
+
+#define CONFIG_SYNC_VERSION_VARIABLE_TO_FLASH
+
+#define CONFIG_P2041RDB
+#define CONFIG_PHYS_64BIT
+#define CONFIG_PPC_P2041
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_RAMBOOT_TEXT_BASE	CONFIG_SYS_TEXT_BASE
+#define CONFIG_RESET_VECTOR_ADDRESS	0xfffffffc
+#define CONFIG_PBLPBI_CONFIG $(SRCTREE)/board/freescale/as6700_32x/pbi.cfg
+#define CONFIG_PBLRCW_CONFIG $(SRCTREE)/board/freescale/as6700_32x/rcw.cfg
+#endif
+
+#if 0
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+/* Set 1M boot space */
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR (CONFIG_SYS_TEXT_BASE & 0xfff00000)
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR)
+#define CONFIG_RESET_VECTOR_ADDRESS 0xfffffffc
+#define CONFIG_SYS_NO_FLASH
+#endif
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_E500MC			/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
+#define CONFIG_MPC85xx			/* MPC85xx/PQ3 platform */
+#define CONFIG_MP			/* support multiple processors */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#define CONFIG_SYS_FSL_CPC		/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC		CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_ELBC			/* Has Enhanced localbus controller */
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#define CONFIG_PCIE1			/* PCIE controler 1 */
+#define CONFIG_PCIE2			/* PCIE controler 2 */
+#define CONFIG_PCIE3			/* PCIE controler 3 */
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+
+#if 0
+#define CONFIG_SYS_SRIO
+#define CONFIG_SRIO1			/* SRIO port 1 */
+#define CONFIG_SRIO2			/* SRIO port 2 */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+#define CONFIG_SYS_DPAA_RMAN		/* RMan */
+#endif
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_SYS_NO_FLASH
+
+#ifdef CONFIG_SYS_NO_FLASH
+#if !defined(CONFIG_RAMBOOT_PBL) && !defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+#define CONFIG_ENV_IS_NOWHERE
+#endif
+#else
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_BAR
+
+#if defined(CONFIG_SPIFLASH)
+	#define CONFIG_SYS_EXTRA_ENV_RELOC
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+	#define CONFIG_ENV_SPI_BUS              0
+	#define CONFIG_ENV_SPI_CS               0
+	#define CONFIG_ENV_SPI_MAX_HZ           10000000
+	#define CONFIG_ENV_SPI_MODE             0
+	#define CONFIG_ENV_SIZE                 0x2000          /* 8KB */
+	#define CONFIG_ENV_OFFSET               0x100000        /* 1MB */
+	#define CONFIG_ENV_SECT_SIZE            0x40000
+#elif defined(CONFIG_SDCARD)
+	#define CONFIG_SYS_EXTRA_ENV_RELOC
+	#define CONFIG_ENV_IS_IN_MMC
+	#define CONFIG_FSL_FIXED_MMC_LOCATION
+	#define CONFIG_SYS_MMC_ENV_DEV          0
+	#define CONFIG_ENV_SIZE			0x2000
+	#define CONFIG_ENV_OFFSET		(512 * 1105)
+#else
+	#error No supported storage type was defined.
+#endif
+
+/*#define CONFIG_BOOTARGS     "root=/dev/ram rw console=ttyS0,115200 mem=3968M quiet"*/
+/*#define CONFIG_ETHADDR      00:E0:0C:00:00:FD*/
+/*#define CONFIG_ETH2ADDR     00:00:00:00:00:02*/
+/*#define CONFIG_ETH3ADDR     00:00:00:00:00:03*/
+#define CONFIG_IPADDR       192.168.3.10
+#define CONFIG_SERVERIP     192.168.3.14
+#define CONFIG_GATEWAYIP    192.168.3.14
+#define CONFIG_NETMASK      255.255.255.0
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(unsigned long dummy);
+#endif
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk(0)
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BACKSIDE_L2_CACHE
+#define CONFIG_SYS_INIT_L2CSR0		L2CSR0_L2E
+#define CONFIG_BTB			/* toggle branch predition */
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP
+#define CONFIG_SYS_NUM_ADDR_MAP		64	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_POST CONFIG_SYS_POST_MEMORY	/* test POST memory test */
+#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+/*
+ *  Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		CONFIG_RAMBOOT_TEXT_BASE
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_L3_ADDR_PHYS	(0xf00000000ull | \
+		CONFIG_RAMBOOT_TEXT_BASE)
+#else
+#define CONFIG_SYS_INIT_L3_ADDR_PHYS	CONFIG_SYS_INIT_L3_ADDR
+#endif
+#define CONFIG_SYS_L3_SIZE		(1024 << 10)
+#define CONFIG_SYS_INIT_L3_END (CONFIG_SYS_INIT_L3_ADDR + CONFIG_SYS_L3_SIZE)
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_DCSRBAR		0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS		0xf00000000ull
+#endif
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL    (1 * CONFIG_DIMM_SLOTS_PER_CTLR)
+
+#define CONFIG_DDR_SPD
+#define CONFIG_FSL_DDR3
+
+#define CONFIG_DDR_ECC
+#define CONFIG_MEM_INIT_VALUE 0xdeadbeef
+/*#define CONFIG_SYS_DRAM_TEST*/
+
+#define CONFIG_SYS_SPD_BUS_NUM	0
+
+#define SPD_EEPROM_ADDRESS 0x50
+#define CONFIG_SYS_SDRAM_SIZE 2048  /* for fixed parameter use */
+
+/*
+ * Local Bus Definitions
+ */
+
+/* Set the local bus clock 1/8 of platform clock */
+#define CONFIG_SYS_LBC_LCRR     LCRR_CLKDIV_32
+
+/*
+ * This board doesn't have a promjet connector.
+ * However, it uses commone corenet board LAW and TLB.
+ * It is necessary to use the same start address with proper offset.
+ */
+#define CONFIG_SYS_FLASH_BASE       0xec000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS  0xfec000000ull
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+/*#define CONFIG_SYS_FLASH_BR_PRELIM \
+		(BR_PHYS_ADDR((CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000)) | \
+		BR_PS_16 | BR_V)*/
+#define CONFIG_SYS_FLASH_BR_PRELIM \
+        (BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_16 | BR_V)
+/*#define CONFIG_SYS_FLASH_OR_PRELIM \
+		((0xf8000ff7 & ~OR_GPCM_SCY & ~OR_GPCM_EHTR) \
+		 | OR_GPCM_SCY_8 | OR_GPCM_EHTR_CLEAR)*/
+#define CONFIG_SYS_FLASH_OR_PRELIM \
+        ((0xfc000ff7 & ~OR_GPCM_SCY & ~OR_GPCM_EHTR) \
+         | OR_GPCM_SCY_8 | OR_GPCM_EHTR_CLEAR)
+
+#define CONFIG_FSL_CPLD
+#define CPLD_BASE		0xffdf0000	/* CPLD registers */
+#ifdef CONFIG_PHYS_64BIT
+#define CPLD_BASE_PHYS		0xfffdf0000ull
+#else
+#define CPLD_BASE_PHYS		CPLD_BASE
+#endif
+
+#define CONFIG_SYS_BR3_PRELIM	(BR_PHYS_ADDR(CPLD_BASE_PHYS) | BR_PS_8 | BR_V)
+#define CONFIG_SYS_OR3_PRELIM	0xffffeff7	/* 32KB but only 4k mapped */
+
+#define PIXIS_LBMAP_SWITCH	7
+#define PIXIS_LBMAP_MASK	0xf0
+#define PIXIS_LBMAP_SHIFT	4
+#define PIXIS_LBMAP_ALTBANK	0x40
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1		/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024		/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000		/* Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500		/* Write Timeout (ms) */
+
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+/*#define CONFIG_NAND_FSL_ELBC*/
+/* Nand Flash */
+#ifdef CONFIG_NAND_FSL_ELBC
+#define CONFIG_SYS_NAND_BASE		0xffa00000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfffa00000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+
+#define CONFIG_SYS_NAND_BASE_LIST     {CONFIG_SYS_NAND_BASE}
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_NAND_BLOCK_SIZE    (128 * 1024)
+
+/* NAND flash config */
+#define CONFIG_SYS_NAND_BR_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+			       | (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
+			       | BR_PS_8	       /* Port Size = 8 bit */ \
+			       | BR_MS_FCM	       /* MSEL = FCM */ \
+			       | BR_V)		       /* valid */
+#define CONFIG_SYS_NAND_OR_PRELIM  (0xFFFC0000	      /* length 256K */ \
+			       | OR_FCM_PGS	       /* Large Page*/ \
+			       | OR_FCM_CSCT \
+			       | OR_FCM_CST \
+			       | OR_FCM_CHT \
+			       | OR_FCM_SCY_1 \
+			       | OR_FCM_TRLX \
+			       | OR_FCM_EHTR)
+
+#ifdef CONFIG_NAND
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_SYS_NAND_BR_PRELIM /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_SYS_FLASH_BR_PRELIM /* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_SYS_FLASH_OR_PRELIM /* NOR Options */
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_SYS_FLASH_BR_PRELIM /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_SYS_FLASH_OR_PRELIM /* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_SYS_NAND_BR_PRELIM /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+#endif
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_SYS_FLASH_BR_PRELIM /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_SYS_FLASH_OR_PRELIM /* NOR Options */
+#endif /* CONFIG_NAND_FSL_ELBC */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_AMD_CHECK_DQ7
+/*#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000}*/
+#define CONFIG_SYS_FLASH_BANKS_LIST {CONFIG_SYS_FLASH_BASE_PHYS}
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* Initial L1 address */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#else
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	CONFIG_SYS_INIT_RAM_ADDR
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+#endif
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+					GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)
+
+/* Serial Port - controlled on board with jumper J8
+ * open - index 2
+ * shorted - index 1
+ */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3	(CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4	(CONFIG_SYS_CCSRBAR+0x11D600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+
+/* new uImage format support */
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x118000
+#define CONFIG_SYS_I2C2_OFFSET		0x118100
+#define CONFIG_SYS_I2C3_OFFSET      0x119000
+#define CONFIG_SYS_I2C4_OFFSET      0x119100
+
+
+#if 0
+/*
+ * RapidIO
+ */
+#define CONFIG_SYS_SRIO1_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_SRIO1_MEM_SIZE	0x10000000	/* 256M */
+
+#define CONFIG_SYS_SRIO2_MEM_VIRT	0xb0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xc30000000ull
+#else
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xb0000000
+#endif
+#define CONFIG_SYS_SRIO2_MEM_SIZE	0x10000000	/* 256M */
+
+/*
+ * for slave u-boot IMAGE instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef080000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff80000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE 0x80000	/* 512K */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff80000ull
+/*
+ * for slave UCODE and ENV instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef040000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS 0x3ffe00000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE 0x40000	/* 256K */
+
+/* slave core release by master*/
+#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET 0xe00e4
+#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK 0x00000001 /* release core 0 */
+
+/*
+ * SRIO_PCIE_BOOT - SLAVE
+ */
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
+#endif
+
+#endif
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+/*#define CONFIG_SPI_FLASH_SPANSION*/
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED         10000000
+#define CONFIG_SF_DEFAULT_MODE          3
+
+/*PCIE default setting*/
+#if 0
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xf8000000
+#endif
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xff8010000ull
+#else
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xf8010000
+#endif
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xc0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc40000000ull
+#else
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc0000000
+#endif
+#define CONFIG_SYS_PCIE3_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xff8020000ull
+#else
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xf8020000
+#endif
+#define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT   0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS    0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS   0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE1_IO_VIRT    0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS    0xf8000000
+#define CONFIG_SYS_PCIE1_IO_SIZE    0x00010000  /* 64k */
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#define CONFIG_SYS_PCIE2_MEM_VIRT   0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_BUS    0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS   0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE2_IO_VIRT    0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS    0xf8010000
+#define CONFIG_SYS_PCIE2_IO_SIZE    0x00010000  /* 64k */
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#define CONFIG_SYS_PCIE3_MEM_VIRT   0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_BUS    0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS   0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE3_IO_VIRT    0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE3_IO_PHYS    0xf8020000
+#define CONFIG_SYS_PCIE3_IO_SIZE    0x00010000  /* 64k */
+
+/* Qman/Bman */
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#else
+#define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf4200000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff4200000ull
+#else
+#define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_SYS_DPAA_PME
+/* Default address of microcode for the Linux Fman driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0x140000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 545KB (1089 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 1089 + 16 = 1113, enlarge it to 1130.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(512 * 1130)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(6 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+/*
+ * Slave has no ucode locally, it can fetch this from remote. When implementing
+ * in two corenet boards, slave's ucode could be stored in master's memory
+ * space, the address can be mapped from slave TLB->slave LAW->
+ * slave SRIO or PCIE outbound window->master inbound window->
+ * master LAW->the ucode address in master's memory space.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0xFFE00000
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0xEFF40000
+#endif
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHYLIB_10G
+
+/*#define CONFIG_PHY_VITESSE*/
+#define CONFIG_PHY_BROADCOM
+
+#define CONFIG_PHY_TERANETICS
+#endif
+
+#ifdef CONFIG_PCI
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_E1000
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#endif	/* CONFIG_PCI */
+
+/* SATA */
+#define CONFIG_FSL_SATA_V2
+
+#ifdef CONFIG_FSL_SATA_V2
+#define CONFIG_FSL_SATA
+#define CONFIG_LIBATA
+
+#define CONFIG_SYS_SATA_MAX_DEVICE	2
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+#define CONFIG_SATA2
+#define CONFIG_SYS_SATA2		CONFIG_SYS_MPC85xx_SATA2_ADDR
+#define CONFIG_SYS_SATA2_FLAGS		FLAGS_DMA
+
+#define CONFIG_LBA48
+#define CONFIG_CMD_SATA
+#define CONFIG_CMD_EXT2
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_SYS_FM1_DTSEC1_PHY_ADDR	0x2
+#define CONFIG_SYS_FM1_DTSEC2_PHY_ADDR	0x3
+#define CONFIG_SYS_FM1_DTSEC3_PHY_ADDR	0x4
+#define CONFIG_SYS_FM1_DTSEC4_PHY_ADDR	0x1
+#define CONFIG_SYS_FM1_DTSEC5_PHY_ADDR	0x0
+
+#define CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR	0x1c
+#define CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR	0x1d
+#define CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR	0x1e
+#define CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR    0x01
+
+#define CONFIG_SYS_FM1_10GEC1_PHY_ADDR	0
+
+#define CONFIG_SYS_TBIPA_VALUE	8
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC1"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+/*
+ * Environment
+ */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+* USB
+*/
+#define CONFIG_HAS_FSL_DR_USB
+#define CONFIG_HAS_FSL_MPH_USB
+
+#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB)
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#endif
+
+#define CONFIG_CMD_EXT2
+
+#define CONFIG_MMC
+
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR       CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_SYS_FSL_ESDHC_BROKEN_TIMEOUT
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"LOADER=> "	/* Monitor Command Prompt */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial Memory for Linux */
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	u-boot.bin
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR     2000000
+
+#define __USB_PHY_TYPE	utmi
+
+/*ONIE redefined*/
+/*
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
+	"bank_intlv=cs0_cs1\0"					\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"			\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"		\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"usb_phy_type=" __stringify(__USB_PHY_TYPE) "\0"		\
+	"usb_dr_mode=host\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"ramdiskfile=p2041rdb/ramdisk.uboot\0"			\
+	"fdtaddr=c00000\0"					\
+	"fdtfile=p2041rdb/p2041rdb.dtb\0"			\
+	"bdev=sda3\0"						\
+	"c=ffe\0"
+*/
+#define CONFIG_HDBOOT					\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_NFSBOOTCOMMAND			\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND				\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $ramdiskaddr $ramdiskfile;"		\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+/*#define CONFIG_BOOTCOMMAND        CONFIG_HDBOOT*/ /*ONIE redefined*/
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+/* ICOS Fastpath app image file support */
+#define CONFIG_FASTPATH
+
+#ifdef CONFIG_FASTPATH
+#define CONFIG_FDT_INDEX        4
+#endif
+
+/* ONIE */
+#include "common_config.h"
+
+#undef CONFIG_CMD_JFFS2
+
+#define CONFIG_SYS_EEPROM_LOAD_ENV_MAC
+#define CONFIG_CMD_SYS_EEPROM
+#define CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS 2
+
+#define CONFIG_SYS_EEPROM_USE_COMMON_SPI_IO
+#define CONFIG_SYS_SPI_FLASH_HWINFO_ADDR        0x00180000
+#define CONFIG_SYS_SPI_FLASH_HWINFO_SECT_SIZE   0x00040000
+#define CONFIG_SYS_EEPROM_MAX_SIZE		CONFIG_SYS_SPI_FLASH_HWINFO_SECT_SIZE
+#define CONFIG_PLATFORM_ENV     \
+    "hwconfig=fsl_ddr:ctlr_intlv=cacheline," \
+    "bank_intlv=cs0_cs1\0"      \
+    "consoledev=ttyS0\0"        \
+    "boot_diag=if test -n $onie_boot_reason; then " \
+        "if test $onie_boot_reason = diag; then "   \
+        "run diag_bootcmd; fi; fi\0"                \
+    "diag_bootcmd=setenv bootargs root=/dev/ram rw console=ttyS0,$baudrate quiet $diagargs;"    \
+        "run fan_default_speed;"    \
+        "sf probe; sf read $loadaddr $diag_start ${diag_sz.b}; bootm $loadaddr\0"   \
+    "fan_speed_level=7\0"       \
+    "fan_default_speed=i2c dev 1; i2c mw 0x35 0x20 $fan_speed_level\0"  \
+    "diag_start=0x009c0000\0"   \
+    "diag_sz.b=0x02000000\0"    \
+    "onie_start=0x001c0000\0"   \
+    "onie_sz.b=0x500000\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    CONFIG_PLATFORM_ENV           \
+    CONFIG_ONIE_COMMON_UBOOT_ENV
+/* ONIE */
+
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/B4860QDS.h b/include/configs/B4860QDS.h
new file mode 100644
index 0000000..7bc920c
--- /dev/null
+++ b/include/configs/B4860QDS.h
@@ -0,0 +1,867 @@
+/*
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * B4860 QDS board configuration file
+ */
+#define CONFIG_B4860QDS
+#define CONFIG_PHYS_64BIT
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_RAMBOOT_TEXT_BASE	CONFIG_SYS_TEXT_BASE
+#define CONFIG_RESET_VECTOR_ADDRESS	0xfffffffc
+#define CONFIG_PBLPBI_CONFIG $(SRCTREE)/board/freescale/b4860qds/b4_pbi.cfg
+#define CONFIG_PBLRCW_CONFIG $(SRCTREE)/board/freescale/b4860qds/b4_rcw.cfg
+#endif
+
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+/* Set 1M boot space */
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR (CONFIG_SYS_TEXT_BASE & 0xfff00000)
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR)
+#define CONFIG_RESET_VECTOR_ADDRESS 0xfffffffc
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_E500MC			/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
+#define CONFIG_MPC85xx			/* MPC85xx/PQ3 platform */
+#define CONFIG_MP			/* support multiple processors */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#define CONFIG_SYS_FSL_CPC		/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC		CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#define CONFIG_PCIE1			/* PCIE controler 1 */
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+
+#ifndef CONFIG_PPC_B4420
+#define CONFIG_SYS_SRIO
+#define CONFIG_SRIO1			/* SRIO port 1 */
+#define CONFIG_SRIO2			/* SRIO port 2 */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+#endif
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+
+/* I2C bus multiplexer */
+#define I2C_MUX_PCA_ADDR                0x77
+
+/* VSC Crossbar switches */
+#define CONFIG_VSC_CROSSBAR
+#define I2C_CH_DEFAULT                  0x8
+#define I2C_CH_VSC3316                  0xc
+#define I2C_CH_VSC3308                  0xd
+
+#define VSC3316_TX_ADDRESS              0x70
+#define VSC3316_RX_ADDRESS              0x71
+#define VSC3308_TX_ADDRESS              0x02
+#define VSC3308_RX_ADDRESS              0x03
+
+/* IDT clock synthesizers */
+#define CONFIG_IDT8T49N222A
+#define I2C_CH_IDT                     0x9
+
+#define IDT_SERDES1_ADDRESS            0x6E
+#define IDT_SERDES2_ADDRESS            0x6C
+
+#define CONFIG_ENV_OVERWRITE
+
+#ifdef CONFIG_SYS_NO_FLASH
+#if !defined(CONFIG_SRIO_PCIE_BOOT_SLAVE) && !defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_ENV_IS_NOWHERE
+#endif
+#else
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+#if defined(CONFIG_SPIFLASH)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SPI_BUS              0
+#define CONFIG_ENV_SPI_CS               0
+#define CONFIG_ENV_SPI_MAX_HZ           10000000
+#define CONFIG_ENV_SPI_MODE             0
+#define CONFIG_ENV_SIZE                 0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET               0x100000        /* 1MB */
+#define CONFIG_ENV_SECT_SIZE            0x10000
+#elif defined(CONFIG_SDCARD)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV          0
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(512 * 1097)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE			CONFIG_SYS_NAND_BLOCK_SIZE
+#define CONFIG_ENV_OFFSET		(5 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+#define CONFIG_ENV_IS_IN_REMOTE
+#define CONFIG_ENV_ADDR		0xffe20000
+#define CONFIG_ENV_SIZE		0x2000
+#elif defined(CONFIG_ENV_IS_NOWHERE)
+#define CONFIG_ENV_SIZE		0x2000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk() /* sysclk for MPC85xx */
+#define CONFIG_DDR_CLK_FREQ	get_board_ddr_clk()
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BTB			/* toggle branch predition */
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#endif
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP
+#define CONFIG_SYS_NUM_ADDR_MAP		64	/* number of TLB1 entries */
+#endif
+
+#if 0
+#define CONFIG_POST CONFIG_SYS_POST_MEMORY	/* test POST memory test */
+#endif
+#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+/*
+ *  Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		CONFIG_RAMBOOT_TEXT_BASE
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_DCSRBAR		0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS		0xf00000000ull
+#endif
+
+/* EEPROM */
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+/* CONFIG_NUM_DDR_CONTROLLERS is defined in include/asm/config_mpc85xx.h */
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(4 * CONFIG_DIMM_SLOTS_PER_CTLR)
+
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_DDR_RAW_TIMING
+#define CONFIG_FSL_DDR3
+#define CONFIG_FSL_DDR_INTERACTIVE
+
+#define CONFIG_SYS_SPD_BUS_NUM	0
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS2	0x53
+
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
+#define CONFIG_SYS_SDRAM_SIZE	2048	/* for fixed parameter use */
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE	0xe0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
+				+ 0x8000000) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR1_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR1_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(4)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x01) | \
+				FTIM0_NOR_TEADC(0x04) | \
+				FTIM0_NOR_TEAHC(0x20))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1A) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x01) | \
+				FTIM2_NOR_TCH(0x0E) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS \
+					+ 0x8000000, CONFIG_SYS_FLASH_BASE_PHYS}
+
+#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
+#define CONFIG_FSL_QIXIS_V2
+#define QIXIS_BASE		0xffdf0000
+#ifdef CONFIG_PHYS_64BIT
+#define QIXIS_BASE_PHYS		(0xf00000000ull | QIXIS_BASE)
+#else
+#define QIXIS_BASE_PHYS		QIXIS_BASE
+#endif
+#define QIXIS_LBMAP_SWITCH		0x01
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x02
+#define QIXIS_RST_CTL_RESET		0x31
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+
+#define CONFIG_SYS_CSPR3_EXT	(0xf)
+#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+#define CONFIG_SYS_AMASK3	IFC_AMASK(4*1024)
+#define CONFIG_SYS_CSOR3	0x0
+/* QIXIS Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0x0e) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+					FTIM2_GPCM_TCH(0x0) | \
+					FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+
+/* NAND Flash on IFC */
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_NAND_BASE)
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 2Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x07) | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0x0e)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
+					FTIM2_NAND_TREH(0x0a) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+#if defined(CONFIG_NAND)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_R
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xfdd00000	/* Initial L1 address */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH	0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW	0xfe0ec000
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#else
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	0xfe0ec000 /* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+#endif
+#define CONFIG_SYS_INIT_RAM_SIZE		0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+					GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(4 * 1024 * 1024)
+
+/* Serial Port - controlled on board with jumper J8
+ * open - index 2
+ * shorted - index 1
+ */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3	(CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4	(CONFIG_SYS_CCSRBAR+0x11D600)
+#define CONFIG_SERIAL_MULTI		/* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000	/* I2C speed in Hz */
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x118000
+#define CONFIG_SYS_I2C2_OFFSET		0x119000
+
+/*
+ * RTC configuration
+ */
+#define RTC
+#define CONFIG_RTC_DS3231               1
+#define CONFIG_SYS_I2C_RTC_ADDR         0x68
+
+/*
+ * RapidIO
+ */
+#ifdef CONFIG_SYS_SRIO
+#ifdef CONFIG_SRIO1
+#define CONFIG_SYS_SRIO1_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_SRIO1_MEM_SIZE	0x10000000	/* 256M */
+#endif
+
+#ifdef CONFIG_SRIO2
+#define CONFIG_SYS_SRIO2_MEM_VIRT	0xb0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xc30000000ull
+#else
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xb0000000
+#endif
+#define CONFIG_SYS_SRIO2_MEM_SIZE	0x10000000	/* 256M */
+#endif
+#endif
+
+/*
+ * for slave u-boot IMAGE instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef080000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff80000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE 0x80000	/* 512K */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff80000ull
+/*
+ * for slave UCODE and ENV instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef040000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS 0x3ffe00000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE 0x40000	/* 256K */
+
+/* slave core release by master*/
+#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET 0xe00e4
+#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK 0x00000001 /* release core 0 */
+
+/*
+ * SRIO_PCIE_BOOT - SLAVE
+ */
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
+#endif
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED         10000000
+#define CONFIG_SF_DEFAULT_MODE          0
+
+/*
+ * MAPLE
+ */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_MAPLE_MEM_PHYS      0xFA0000000ull
+#else
+#define CONFIG_SYS_MAPLE_MEM_PHYS      0xA0000000
+#endif
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xf8000000
+#endif
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+/* Qman/Bman */
+#ifndef CONFIG_NOBQFMAN
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#else
+#define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_NUM_PORTALS	25
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
+#else
+#define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+
+#define CONFIG_SYS_DPAA_FMAN
+
+#define CONFIG_SYS_DPAA_RMAN		/* RMan */
+
+/* Default address of microcode for the Linux Fman driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0x110000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 545KB (1089 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 1089 + 16 = 1113, enlarge it to 1130.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(512 * 1130)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(6 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+/*
+ * Slave has no ucode locally, it can fetch this from remote. When implementing
+ * in two corenet boards, slave's ucode could be stored in master's memory
+ * space, the address can be mapped from slave TLB->slave LAW->
+ * slave SRIO or PCIE outbound window->master inbound window->
+ * master LAW->the ucode address in master's memory space.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0xFFE00000
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_QE_FMAN_FW_ADDR		0xEFF40000
+#endif
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+#endif /* CONFIG_NOBQFMAN */
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHYLIB_10G
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_TERANETICS
+#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
+#define SGMII_CARD_PORT2_PHY_ADDR 0x10
+#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
+#define SGMII_CARD_PORT4_PHY_ADDR 0x11
+#endif
+
+#ifdef CONFIG_PCI
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_E1000
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif	/* CONFIG_PCI */
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR	0x10
+#define CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR	0x11
+
+/*B4860 QDS AMC2PEX-2S default PHY_ADDR */
+#define CONFIG_SYS_FM1_10GEC1_PHY_ADDR 0x7	 /*SLOT 1*/
+#define CONFIG_SYS_FM1_10GEC2_PHY_ADDR 0x6	 /*SLOT 2*/
+
+
+#define CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR    0x1c
+#define CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR    0x1d
+#define CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR    0x1e
+#define CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR    0x1f
+
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC1"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+#define CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+
+/*
+ * Environment
+ */
+#define CONFIG_LOADS_ECHO		/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+* USB
+*/
+#define CONFIG_HAS_FSL_DR_USB
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_CMD_EXT2
+#endif
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks*/
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	"u-boot.bin"	/* U-Boot image on TFTP server*/
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+
+#define CONFIG_BAUDRATE	115200
+
+#define __USB_PHY_TYPE	ulpi
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:ctlr_intlv=null,"		\
+	"bank_intlv=cs0_cs1;"					\
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"			\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"			\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"ramdiskfile=b4860qds/ramdisk.uboot\0"			\
+	"fdtaddr=c00000\0"					\
+	"fdtfile=b4860qds/b4860qds.dtb\0"				\
+	"bdev=sda3\0"						\
+	"c=ffe\0"
+
+/* For emulation this causes u-boot to jump to the start of the proof point
+   app code automatically */
+#define CONFIG_PROOF_POINTS			\
+ "setenv bootargs root=/dev/$bdev rw "		\
+ "console=$consoledev,$baudrate $othbootargs;"	\
+ "cpu 1 release 0x29000000 - - -;"		\
+ "cpu 2 release 0x29000000 - - -;"		\
+ "cpu 3 release 0x29000000 - - -;"		\
+ "cpu 4 release 0x29000000 - - -;"		\
+ "cpu 5 release 0x29000000 - - -;"		\
+ "cpu 6 release 0x29000000 - - -;"		\
+ "cpu 7 release 0x29000000 - - -;"		\
+ "go 0x29000000"
+
+#define CONFIG_HVBOOT	\
+ "setenv bootargs config-addr=0x60000000; "	\
+ "bootm 0x01000000 - 0x00f00000"
+
+#define CONFIG_ALU				\
+ "setenv bootargs root=/dev/$bdev rw "		\
+ "console=$consoledev,$baudrate $othbootargs;"	\
+ "cpu 1 release 0x01000000 - - -;"		\
+ "cpu 2 release 0x01000000 - - -;"		\
+ "cpu 3 release 0x01000000 - - -;"		\
+ "cpu 4 release 0x01000000 - - -;"		\
+ "cpu 5 release 0x01000000 - - -;"		\
+ "cpu 6 release 0x01000000 - - -;"		\
+ "cpu 7 release 0x01000000 - - -;"		\
+ "go 0x01000000"
+
+#define CONFIG_LINUX				\
+ "setenv bootargs root=/dev/ram rw "		\
+ "console=$consoledev,$baudrate $othbootargs;"	\
+ "setenv ramdiskaddr 0x02000000;"		\
+ "setenv fdtaddr 0x00c00000;"			\
+ "setenv loadaddr 0x1000000;"			\
+ "bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_HDBOOT					\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_NFSBOOTCOMMAND			\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND				\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $ramdiskaddr $ramdiskfile;"		\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND		CONFIG_LINUX
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/BSC9131RDB.h b/include/configs/BSC9131RDB.h
index fd076e0..b5911c6 100644
--- a/include/configs/BSC9131RDB.h
+++ b/include/configs/BSC9131RDB.h
@@ -40,10 +40,34 @@
 #define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
 #endif
 
-#ifndef CONFIG_SYS_MONITOR_BASE
-#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#ifdef CONFIG_NAND
+#define CONFIG_SPL
+#define CONFIG_SPL_INIT_MINIMAL
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_MINIMAL
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+
+#define CONFIG_SYS_TEXT_BASE		0x00201000
+#define CONFIG_SPL_TEXT_BASE		0xFFFFE000
+#define CONFIG_SPL_MAX_SIZE		8192
+#define CONFIG_SPL_RELOC_TEXT_BASE	0x00100000
+#define CONFIG_SPL_RELOC_STACK		0x00100000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	((512 << 10) - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(0x00200000 - CONFIG_SPL_MAX_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_START	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	0
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
 #endif
 
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+
 /* High Level Configuration Options */
 #define CONFIG_BOOKE			/* BOOKE */
 #define CONFIG_E500			/* BOOKE e500 family */
@@ -55,7 +79,11 @@
 #define CONFIG_ENV_OVERWRITE
 
 #define CONFIG_DDR_CLK_FREQ	66666666 /* DDRCLK on 9131 RDB */
+#if defined(CONFIG_SYS_CLK_100)
+#define CONFIG_SYS_CLK_FREQ    100000000 /* SYSCLK for 9131 RDB */
+#else
 #define CONFIG_SYS_CLK_FREQ	66666666 /* SYSCLK for 9131 RDB */
+#endif
 
 #define CONFIG_HWCONFIG
 /*
@@ -125,16 +153,21 @@ extern unsigned long get_sdram_size(void);
 
 #define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR	/* PQII uses */
 							/* CONFIG_SYS_IMMR */
+/* DSP CCSRBAR */
+#define CONFIG_SYS_FSL_DSP_CCSRBAR	CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT
+#define CONFIG_SYS_FSL_DSP_CCSRBAR_PHYS	CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT
 
 /*
  * Memory map
  *
  * 0x0000_0000	0x3FFF_FFFF	DDR			1G cacheable
  * 0x8800_0000	0x8810_0000	IFC internal SRAM		1M
+ * 0xB000_0000	0xB0FF_FFFF	DSP core M2 memory	16M
  * 0xC100_0000	0xC13F_FFFF	MAPLE-2F		4M
  * 0xC1F0_0000	0xC1F3_FFFF	PA L2 SRAM Region 0	256K
  * 0xC1F8_0000	0xC1F9_FFFF	PA L2 SRAM Region 1	128K
  * 0xFED0_0000	0xFED0_3FFF	SEC Secured RAM		16K
+ * 0xFF60_0000	0xFF6F_FFFF	DSP CCSR		1M
  * 0xFF70_0000	0xFF7F_FFFF	PA CCSR			1M
  * 0xFF80_0000	0xFFFF_FFFF	Boot Page & NAND flash buffer	8M
  *
@@ -214,6 +247,9 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_SYS_NS16550_SERIAL
 #define CONFIG_SYS_NS16550_REG_SIZE	1
 #define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_NS16550_MIN_FUNCTIONS
+#endif
 
 #define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
 
@@ -295,7 +331,6 @@ extern unsigned long get_sdram_size(void);
 /*
  * Environment
  */
-#if defined(CONFIG_SYS_RAMBOOT)
 #if defined(CONFIG_RAMBOOT_SPIFLASH)
 #define CONFIG_ENV_IS_IN_SPI_FLASH
 #define CONFIG_ENV_SPI_BUS	0
@@ -305,15 +340,16 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_ENV_OFFSET	0x100000	/* 1MB */
 #define CONFIG_ENV_SECT_SIZE	0x10000
 #define CONFIG_ENV_SIZE		0x2000
-#else
-#define CONFIG_ENV_IS_NOWHERE		/* Store ENV in memory only */
-#define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE - 0x1000)
-#define CONFIG_ENV_SIZE			0x2000
-#endif
-#else
-#define CONFIG_ENV_IS_NOWHERE	1	/* Store ENV in memory only */
+#elif defined(CONFIG_NAND)
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+#define CONFIG_ENV_OFFSET	((512 * 1024) + CONFIG_SYS_NAND_BLOCK_SIZE)
+#define CONFIG_ENV_RANGE	(3 * CONFIG_ENV_SIZE)
+#elif defined(CONFIG_SYS_RAMBOOT)
+#define CONFIG_ENV_IS_NOWHERE	/* Store ENV in memory only */
 #define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - 0x1000)
-#define CONFIG_ENV_SIZE		0x400
+#define CONFIG_ENV_SIZE		0x2000
 #endif
 
 #define CONFIG_LOADS_ECHO		/* echo on for serial download */
@@ -406,7 +442,9 @@ extern unsigned long get_sdram_size(void);
 	"fdtfile=bsc9131rdb.dtb\0"		\
 	"bdev=sda1\0"	\
 	"hwconfig=usb1:dr_mode=host,phy_type=ulpi\0"	\
-	"othbootargs=ramdisk_size=600000 \0" \
+	"bootm_size=0x37000000\0"	\
+	"othbootargs=ramdisk_size=600000 " \
+	"default_hugepagesz=256m hugepagesz=256m hugepages=1\0" \
 	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
 	"console=$consoledev,$baudrate $othbootargs; "	\
 	"usb start;"			\
diff --git a/include/configs/BSC9132QDS.h b/include/configs/BSC9132QDS.h
new file mode 100644
index 0000000..194efa2
--- /dev/null
+++ b/include/configs/BSC9132QDS.h
@@ -0,0 +1,734 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * BSC9132 QDS board configuration file
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef CONFIG_BSC9132QDS
+#define CONFIG_BSC9132
+#endif
+
+#define CONFIG_MISC_INIT_R
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RAMBOOT_SDCARD
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+#define CONFIG_SYS_FSL_ERRATUM_IFC_A002769	1
+#ifdef CONFIG_SPIFLASH
+#define CONFIG_RAMBOOT_SPIFLASH
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+#ifdef CONFIG_NAND_SECBOOT
+#define CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+
+#ifdef CONFIG_NAND
+#define CONFIG_SPL
+#define CONFIG_SPL_INIT_MINIMAL
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_MINIMAL
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+
+#define CONFIG_SYS_TEXT_BASE		0x00201000
+#define CONFIG_SPL_TEXT_BASE		0xFFFFE000
+#define CONFIG_SPL_MAX_SIZE		8192
+#define CONFIG_SPL_RELOC_TEXT_BASE	0x00100000
+#define CONFIG_SPL_RELOC_STACK		0x00100000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	((512 << 10) - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(0x00200000 - CONFIG_SPL_MAX_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_START	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	0
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE		0x8ff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0x8ffffffc
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE			/* BOOKE */
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_MPC85xx
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+#define CONFIG_SYS_HAS_SERDES		/* common SERDES init code */
+
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#if defined(CONFIG_PCI)
+#define CONFIG_PCIE1			/* PCIE controler 1 (slot 1) */
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET		/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PCI
+
+#define CONFIG_E1000			/*  E1000 pci Ethernet card*/
+
+/*
+ * PCI Windows
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+/* controller 1, Slot 1, tgtid 1, Base address a000 */
+#define CONFIG_SYS_PCIE1_NAME		"PCIe Slot"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x90000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x90000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x90000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xC0010000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xC0010000
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_TSEC_ENET /* ethernet */
+
+#if defined(CONFIG_SYS_CLK_100_DDR_100)
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	100000000
+#elif defined(CONFIG_SYS_CLK_100_DDR_133)
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	133000000
+#endif
+
+#define CONFIG_MP
+
+#define CONFIG_HWCONFIG
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* enable branch predition */
+
+#define CONFIG_SYS_MEMTEST_START	0x01000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x01ffffff
+
+/* DDR Setup */
+#define CONFIG_FSL_DDR3
+#define CONFIG_SYS_SPD_BUS_NUM		0
+#define SPD_EEPROM_ADDRESS1		0x54 /* I2C access */
+#define SPD_EEPROM_ADDRESS2		0x56 /* I2C access */
+#define CONFIG_FSL_DDR_INTERACTIVE
+
+#define CONFIG_MEM_INIT_VALUE		0xDeadBeef
+
+#define CONFIG_SYS_SDRAM_SIZE		(1024)
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+
+/* DDR3 Controller Settings */
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000003F
+#define CONFIG_SYS_DDR_CS0_CONFIG_1333	0x80004302
+#define CONFIG_SYS_DDR_CS0_CONFIG_800	0x80014302
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_DATA_INIT	0xdeadbeef
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+#define CONFIG_SYS_DDR1_CS0_BNDS       0x0040007F
+
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL_800		0x470C0000
+#define CONFIG_SYS_DDR_CONTROL_2_800	0x04401050
+#define CONFIG_SYS_DDR_TIMING_4_800		0x00220001
+#define CONFIG_SYS_DDR_TIMING_5_800		0x03402400
+
+#define CONFIG_SYS_DDR_CONTROL_1333		0x470C0008
+#define CONFIG_SYS_DDR_CONTROL_2_1333	0x24401010
+#define CONFIG_SYS_DDR_TIMING_4_1333		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5_1333		0x03401400
+
+#define CONFIG_SYS_DDR_TIMING_3_800		0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_800		0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_800		0x6f6B4846
+#define CONFIG_SYS_DDR_TIMING_2_800		0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_800		0x03000000
+#define CONFIG_SYS_DDR_MODE_1_800		0x40461520
+#define CONFIG_SYS_DDR_MODE_2_800		0x8000c000
+#define CONFIG_SYS_DDR_INTERVAL_800		0x0C300000
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_800	0x8655A608
+
+#define CONFIG_SYS_DDR_TIMING_3_1333		0x01061000
+#define CONFIG_SYS_DDR_TIMING_0_1333		0x00440104
+#define CONFIG_SYS_DDR_TIMING_1_1333		0x98913A45
+#define CONFIG_SYS_DDR_TIMING_2_1333		0x0FB8B114
+#define CONFIG_SYS_DDR_CLK_CTRL_1333		0x02800000
+#define CONFIG_SYS_DDR_MODE_1_1333		0x00061A50
+#define CONFIG_SYS_DDR_MODE_2_1333		0x00100000
+#define CONFIG_SYS_DDR_INTERVAL_1333		0x144E0513
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_1333	0x8655F607
+
+/*FIXME: the following params are constant w.r.t diff freq
+combinations. this should be removed later
+*/
+#if CONFIG_DDR_CLK_FREQ == 100000000
+#define CONFIG_SYS_DDR_CS0_CONFIG CONFIG_SYS_DDR_CS0_CONFIG_800
+#define CONFIG_SYS_DDR_CONTROL		CONFIG_SYS_DDR_CONTROL_800
+#define CONFIG_SYS_DDR_CONTROL_2 CONFIG_SYS_DDR_CONTROL_2_800
+#define CONFIG_SYS_DDR_TIMING_4	CONFIG_SYS_DDR_TIMING_4_800
+#define CONFIG_SYS_DDR_TIMING_5	CONFIG_SYS_DDR_TIMING_5_800
+#elif CONFIG_DDR_CLK_FREQ == 133000000
+#define CONFIG_SYS_DDR_CS0_CONFIG CONFIG_SYS_DDR_CS0_CONFIG_1333
+#define CONFIG_SYS_DDR_CONTROL		CONFIG_SYS_DDR_CONTROL_1333
+#define CONFIG_SYS_DDR_CONTROL_2	CONFIG_SYS_DDR_CONTROL_2_1333
+#define CONFIG_SYS_DDR_TIMING_4	CONFIG_SYS_DDR_TIMING_4_1333
+#define CONFIG_SYS_DDR_TIMING_5	CONFIG_SYS_DDR_TIMING_5_1333
+#else
+#define CONFIG_SYS_DDR_CS0_CONFIG CONFIG_SYS_DDR_CS0_CONFIG_800
+#define CONFIG_SYS_DDR_CONTROL		CONFIG_SYS_DDR_CONTROL_800
+#define CONFIG_SYS_DDR_CONTROL_2	CONFIG_SYS_DDR_CONTROL_2_800
+#define CONFIG_SYS_DDR_TIMING_4	CONFIG_SYS_DDR_TIMING_4_800
+#define CONFIG_SYS_DDR_TIMING_5	CONFIG_SYS_DDR_TIMING_5_800
+#endif
+
+
+/* relocated CCSRBAR */
+#define CONFIG_SYS_CCSRBAR	CONFIG_SYS_CCSRBAR_DEFAULT
+#define CONFIG_SYS_CCSRBAR_PHYS_LOW	CONFIG_SYS_CCSRBAR_DEFAULT
+
+#define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR
+
+/* DSP CCSRBAR */
+#define CONFIG_SYS_FSL_DSP_CCSRBAR	CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT
+#define CONFIG_SYS_FSL_DSP_CCSRBAR_PHYS	CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT
+
+/*
+ * IFC Definitions
+ */
+/* NOR Flash on IFC */
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_NO_FLASH
+#endif
+#define CONFIG_SYS_FLASH_BASE		0x88000000
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* Max number of sector: 32M */
+
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_SYS_NOR_CSPR	0x88000101
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(5)
+/* NOR Flash Timing Params */
+
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x01) \
+				| FTIM0_NOR_TEADC(0x03) \
+				| FTIM0_NOR_TAVDS(0x00) \
+				| FTIM0_NOR_TEAHC(0x0f))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x1d) \
+				| FTIM1_NOR_TRAD_NOR(0x09) \
+				| FTIM1_NOR_TSEQRAD_NOR(0x09))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x1) \
+				| FTIM2_NOR_TCH(0x4) \
+				| FTIM2_NOR_TWPH(0x7) \
+				| FTIM2_NOR_TWP(0x1e))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS}
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45	/* count down from 45/5: 9..1 */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+
+#undef CONFIG_SYS_FLASH_CHECKSUM
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+/* CFI for NOR Flash */
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+/* NAND Flash on IFC */
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_2	/* RAL = 2Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+/* NAND Flash Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x03) \
+					| FTIM0_NAND_TWP(0x05) \
+					| FTIM0_NAND_TWCHT(0x02) \
+					| FTIM0_NAND_TWH(0x04))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x1c) \
+					| FTIM1_NAND_TWBE(0x1e) \
+					| FTIM1_NAND_TRR(0x07) \
+					| FTIM1_NAND_TRP(0x05))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x08) \
+					| FTIM2_NAND_TREH(0x04) \
+					| FTIM2_NAND_TWHRE(0x11))
+#define CONFIG_SYS_NAND_FTIM3		FTIM3_NAND_TWW(0x04)
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+
+/* NAND */
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_FSL_QIXIS
+#endif
+#ifdef CONFIG_FSL_QIXIS
+#define CONFIG_SYS_FPGA_BASE	0xffb00000
+#define CONFIG_SYS_I2C_FPGA_ADDR	0x66
+#define QIXIS_BASE	CONFIG_SYS_FPGA_BASE
+#define QIXIS_LBMAP_SWITCH	9
+#define QIXIS_LBMAP_MASK	0x07
+#define QIXIS_LBMAP_SHIFT	0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+#define QIXIS_RST_CTL_RESET		0x83
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+
+#define CONFIG_SYS_FPGA_BASE_PHYS	CONFIG_SYS_FPGA_BASE
+
+#define CONFIG_SYS_CSPR2		(CSPR_PHYS_ADDR(CONFIG_SYS_FPGA_BASE) \
+					| CSPR_PORT_SIZE_8 \
+					| CSPR_MSEL_GPCM \
+					| CSPR_V)
+#define CONFIG_SYS_AMASK2		IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR2		0x0
+/* CPLD Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS2_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS2_FTIM1		(FTIM1_GPCM_TACO(0x0e) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_CS2_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+					FTIM2_GPCM_TCH(0x0) | \
+					FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS2_FTIM3		0x0
+#endif
+
+/* Set up IFC registers for boot location NOR/NAND */
+#if defined(CONFIG_NAND) || defined(CONFIG_NAND_SECBOOT)
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_F	/* Call board_pre_init */
+#define CONFIG_BOARD_EARLY_INIT_R
+
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* stack in RAM */
+#define CONFIG_SYS_INIT_RAM_END		0x00004000 /* End of used area in RAM */
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_END \
+						- GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon*/
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	/* Reserved for malloc*/
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX	1
+#undef	CONFIG_SERIAL_SOFTWARE_FIFO
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_NS16550_MIN_FUNCTIONS
+#endif
+
+#define CONFIG_SERIAL_MULTI	1 /* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR + 0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR + 0x4600)
+#define CONFIG_SYS_NS16550_COM3	(CONFIG_SYS_CCSRBAR + 0x4700)
+#define CONFIG_SYS_NS16550_COM4	(CONFIG_SYS_CCSRBAR + 0x4800)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER    /* hush parser */
+#ifdef	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+#define CONFIG_FSL_I2C			/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C			/* I2C with hardware support */
+#undef CONFIG_SOFT_I2C			/* I2C bit-banged */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400800 /* I2C speed and slave address*/
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/* I2C EEPROM */
+#define CONFIG_ID_EEPROM
+#ifdef CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#endif
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+
+/* enable read and write access to EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+/* I2C FPGA */
+#define CONFIG_I2C_FPGA
+#define CONFIG_SYS_I2C_FPGA_ADDR	0x66
+
+#define CONFIG_RTC_DS3231
+#define CONFIG_SYS_I2C_RTC_ADDR		0x68
+
+/*
+ * SPI interface will not be available in case of NAND boot SPI CS0 will be
+ * used for SLIC
+ */
+/* eSPI - Enhanced SPI */
+#define CONFIG_FSL_ESPI  /* SPI */
+#ifdef CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED		10000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#if defined(CONFIG_TSEC_ENET)
+
+#define CONFIG_MII			/* MII PHY management */
+#define CONFIG_MII_DEFAULT_TSEC	1	/* Allow unregistered phys */
+#define CONFIG_TSEC1	1
+#define CONFIG_TSEC1_NAME	"eTSEC1"
+#define CONFIG_TSEC2	1
+#define CONFIG_TSEC2_NAME	"eTSEC2"
+
+#define TSEC1_PHY_ADDR		0
+#define TSEC2_PHY_ADDR		1
+
+#define TSEC1_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC2_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+
+#define CONFIG_ETHPRIME		"eTSEC1"
+
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+
+/* TBI PHY configuration for SGMII mode */
+#define CONFIG_TSEC_TBICR_SETTINGS ( \
+		TBICR_PHY_RESET \
+		| TBICR_ANEG_ENABLE \
+		| TBICR_FULL_DUPLEX \
+		| TBICR_SPEED1_SET \
+		)
+
+#endif	/* CONFIG_TSEC_ENET */
+
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_FSL_ESDHC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#endif
+
+#define CONFIG_USB_EHCI  /* USB */
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_USB_STORAGE
+#define CONFIG_HAS_FSL_DR_USB
+#endif
+
+/*
+ * Environment
+ */
+#if defined(CONFIG_RAMBOOT_SDCARD)
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_FSL_FIXED_MMC_LOCATION
+#elif defined(CONFIG_RAMBOOT_SPIFLASH)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SPI_BUS	0
+#define CONFIG_ENV_SPI_CS	0
+#define CONFIG_ENV_SPI_MAX_HZ	10000000
+#define CONFIG_ENV_SPI_MODE	0
+#define CONFIG_ENV_OFFSET	0x100000	/* 1MB */
+#define CONFIG_ENV_SECT_SIZE	0x10000
+#define CONFIG_ENV_SIZE		0x2000
+#elif defined(CONFIG_NAND)
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+#define CONFIG_ENV_OFFSET	((512 * 1024) + CONFIG_SYS_NAND_BLOCK_SIZE)
+#define CONFIG_ENV_RANGE	(3 * CONFIG_ENV_SIZE)
+#elif defined(CONFIG_SYS_RAMBOOT)
+#define CONFIG_ENV_IS_NOWHERE		/* Store ENV in memory only */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE - 0x1000)
+#define CONFIG_ENV_SIZE			0x2000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#if CONFIG_SYS_MONITOR_BASE > 0xfff80000
+#define CONFIG_ENV_ADDR	0xfff80000
+#else
+#define CONFIG_ENV_ADDR	(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#endif
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_LOADS_ECHO		/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+#if defined(CONFIG_MMC) || defined(CONFIG_USB_EHCI)
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+						/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq:1ms ticks */
+
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20) /* Initial Memory map for Linux */
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20) /* Increase max gunzip size */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#endif
+
+#define CONFIG_HOSTNAME		BSC9132qds
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	"u-boot.bin"
+
+#define CONFIG_BAUDRATE		115200
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_DEF_HWCONFIG	"hwconfig=usb1:dr_mode=host,phy_type=ulpi\0"
+#else
+#define CONFIG_DEF_HWCONFIG	"hwconfig=sim;usb1:dr_mode=host,phy_type=ulpi\0"
+#endif
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"netdev=eth0\0"						\
+	"uboot=" CONFIG_UBOOTPATH "\0"				\
+	"loadaddr=1000000\0"			\
+	"bootfile=uImage\0"	\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"			\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=bsc9132qds.dtb\0"		\
+	"bdev=sda1\0"	\
+	CONFIG_DEF_HWCONFIG\
+	"othbootargs=mem=880M ramdisk_size=600000 " \
+		"default_hugepagesz=256m hugepagesz=256m hugepages=1 " \
+		"isolcpus=0\0" \
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+		"console=$consoledev,$baudrate $othbootargs; "	\
+		"usb start;"			\
+		"ext2load usb 0:4 $loadaddr $bootfile;"		\
+		"ext2load usb 0:4 $fdtaddr $fdtfile;"	\
+		"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+		"bootm $loadaddr $ramdiskaddr $fdtaddr\0"	\
+	"debug_halt_off=mw ff7e0e30 0xf0000000;"
+
+#define CONFIG_NFSBOOTCOMMAND	\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "	\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;" \
+	"tftp $loadaddr $bootfile;"	\
+	"tftp $fdtaddr $fdtfile;"	\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_HDBOOT	\
+	"setenv bootargs root=/dev/$bdev rw rootdelay=30 "	\
+	"console=$consoledev,$baudrate $othbootargs;" \
+	"usb start;"	\
+	"ext2load usb 0:1 $loadaddr /boot/$bootfile;"	\
+	"ext2load usb 0:1 $fdtaddr /boot/$fdtfile;"	\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND		\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND CONFIG_RAMBOOTCOMMAND
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/C29XPCIE.h b/include/configs/C29XPCIE.h
new file mode 100644
index 0000000..0061426
--- /dev/null
+++ b/include/configs/C29XPCIE.h
@@ -0,0 +1,562 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * C29XPCIE board configuration file
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef CONFIG_36BIT
+#define CONFIG_PHYS_64BIT
+#endif
+
+#ifdef CONFIG_C291PCIE
+#define CONFIG_C291
+#endif
+
+#ifdef CONFIG_C292PCIE
+#define CONFIG_C292
+#endif
+
+#ifdef CONFIG_C293PCIE
+#define CONFIG_C293
+#endif
+
+#if defined(CONFIG_C291) || defined(CONFIG_C292) || defined(CONFIG_C293)
+#define CONFIG_C29X
+#endif
+
+#ifdef CONFIG_SPIFLASH
+#define CONFIG_RAMBOOT_SPIFLASH
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE		0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE			/* BOOKE */
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_MPC85xx
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+#define CONFIG_SYS_HAS_SERDES		/* common SERDES init code */
+
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#ifdef CONFIG_PCI
+#define CONFIG_PCIE1			/* PCIE controler 1 (slot 1) */
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET		/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PCI
+
+#define CONFIG_E1000
+
+/* Add Sil3132 support */
+#define CONFIG_CMD_SATA
+#define CONFIG_SATA_SIL
+#define CONFIG_SYS_SATA_MAX_DEVICE  1
+#define CONFIG_LIBATA
+#define CONFIG_LBA48
+
+/*
+ * PCI Windows
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+/* controller 1, Slot 1, tgtid 1, Base address a000 */
+#define CONFIG_SYS_PCIE1_NAME		"Slot 1"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xfffc00000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc00000
+#endif
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_TSEC_ENET
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_DDR_CLK_FREQ	100000000
+#define CONFIG_SYS_CLK_FREQ	66666666
+
+#define CONFIG_HWCONFIG
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+
+#define CONFIG_ADDR_STREAMING		/* toggle addr streaming */
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP			1
+#define CONFIG_SYS_NUM_ADDR_MAP		16	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x00200000
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_PANIC_HANG
+
+/* DDR Setup */
+#define CONFIG_FSL_DDR3
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_SPD_BUS_NUM		0
+#define SPD_EEPROM_ADDRESS		0x50
+#define CONFIG_SYS_DDR_RAW_TIMING
+
+#define CONFIG_DDR_ECC
+
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_MEM_INIT_VALUE		0xDeadBeef
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#endif
+
+#define CONFIG_SYS_SDRAM_SIZE		512
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+
+#define CONFIG_SYS_CCSRBAR		0xffe00000
+#define CONFIG_SYS_CCSRBAR_PHYS_LOW	CONFIG_SYS_CCSRBAR
+
+/* Platform SRAM setting  */
+#define CONFIG_SYS_PLATFORM_SRAM_BASE	0xffb00000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PLATFORM_SRAM_BASE_PHYS \
+			(0xf00000000ull | CONFIG_SYS_PLATFORM_SRAM_BASE)
+#else
+#define CONFIG_SYS_PLATFORM_SRAM_BASE_PHYS CONFIG_SYS_PLATFORM_SRAM_BASE
+#endif
+#define CONFIG_SYS_PLATFORM_SRAM_SIZE	(512 << 10)
+
+/*
+ * IFC Definitions
+ */
+/* NOR Flash on IFC */
+#define CONFIG_SYS_FLASH_BASE		0xec000000
+#define CONFIG_SYS_MAX_FLASH_SECT	512	/* 64M */
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE_PHYS }
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* in ms */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* in ms */
+
+/* 16Bit NOR Flash - S29GL512S10TFI01 */
+#define CONFIG_SYS_NOR_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(64*1024*1024)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(4)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x1e) | \
+				FTIM1_NOR_TRAD_NOR(0x0f) | \
+				FTIM1_NOR_TSEQRAD_NOR(0x0f))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+/* CFI for NOR Flash */
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+/* NAND Flash on IFC */
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfff800000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+/* 8Bit NAND Flash - K9F1G08U0B */
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_NAND \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+#define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN	/* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4	/* 4-bit ECC */ \
+				| CSOR_NAND_RAL_2	/* RAL = 2 Bytes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2k */ \
+				| CSOR_NAND_SPRZ_64	/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/* 64 Pages Per Block */
+#define CONFIG_SYS_NAND_FTIM0	(FTIM0_NAND_TCCST(0x01) | \
+				FTIM0_NAND_TWP(0x0c)   | \
+				FTIM0_NAND_TWCHT(0x08) | \
+				FTIM0_NAND_TWH(0x06))
+#define CONFIG_SYS_NAND_FTIM1	(FTIM1_NAND_TADLE(0x28) | \
+				FTIM1_NAND_TWBE(0x1d)  | \
+				FTIM1_NAND_TRR(0x08)   | \
+				FTIM1_NAND_TRP(0x0c))
+#define CONFIG_SYS_NAND_FTIM2	(FTIM2_NAND_TRAD(0x0c) | \
+				FTIM2_NAND_TREH(0x0a) | \
+				FTIM2_NAND_TWHRE(0x18))
+#define CONFIG_SYS_NAND_FTIM3	(FTIM3_NAND_TWW(0x04))
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+
+/* Set up IFC registers for boot location NOR/NAND */
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+/* CPLD on IFC, selected by CS2 */
+#define CONFIG_SYS_CPLD_BASE		0xffdf0000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_CPLD_BASE_PHYS	(0xf00000000ull \
+					| CONFIG_SYS_CPLD_BASE)
+#else
+#define CONFIG_SYS_CPLD_BASE_PHYS	CONFIG_SYS_CPLD_BASE
+#endif
+
+#define CONFIG_SYS_CSPR2	(CSPR_PHYS_ADDR(CONFIG_SYS_CPLD_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+#define CONFIG_SYS_AMASK2	IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR2	0x0
+/* CPLD Timing parameters for IFC CS2 */
+#define CONFIG_SYS_CS2_FTIM0	(FTIM0_GPCM_TACSE(0x0e) | \
+				FTIM0_GPCM_TEADC(0x0e) | \
+				FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS2_FTIM1	(FTIM1_GPCM_TACO(0x0e) | \
+				FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_CS2_FTIM2	(FTIM2_GPCM_TCS(0x0e) | \
+				FTIM2_GPCM_TCH(0x0) | \
+				FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS2_FTIM3	0x0
+
+#if defined(CONFIG_RAMBOOT_SPIFLASH)
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#else
+#undef CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_R
+
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000
+#define CONFIG_SYS_INIT_RAM_END		0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_END \
+						- GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SERIAL_MULTI		/* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+#define CONFIG_FSL_I2C
+#define CONFIG_HARD_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/* I2C EEPROM */
+/* enable read and write access to EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 2
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+#define CONFIG_CMD_I2C
+
+/* eSPI - Enhanced SPI */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_EON
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED		10000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+
+#ifdef CONFIG_TSEC_ENET
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI
+#endif
+
+#define CONFIG_MII			/* MII PHY management */
+#define CONFIG_MII_DEFAULT_TSEC	1	/* Allow unregistered phys */
+#define CONFIG_TSEC1		1
+#define CONFIG_TSEC1_NAME	"eTSEC1"
+#define CONFIG_TSEC2		1
+#define CONFIG_TSEC2_NAME	"eTSEC2"
+
+/* Default mode is RGMII mode */
+#define TSEC1_PHY_ADDR		0
+#define TSEC2_PHY_ADDR		2
+
+#define TSEC1_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC2_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define CONFIG_ETHPRIME		"eTSEC1"
+
+#define CONFIG_PHY_GIGE
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Environment
+ */
+#if defined(CONFIG_SYS_RAMBOOT)
+#if defined(CONFIG_RAMBOOT_SPIFLASH)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SPI_BUS	0
+#define CONFIG_ENV_SPI_CS	0
+#define CONFIG_ENV_SPI_MAX_HZ	10000000
+#define CONFIG_ENV_SPI_MODE	0
+#define CONFIG_ENV_OFFSET	0x100000	/* 1MB */
+#define CONFIG_ENV_SECT_SIZE	0x10000
+#define CONFIG_ENV_SIZE		0x2000
+#endif
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#if CONFIG_SYS_MONITOR_BASE > 0xfff80000
+#define CONFIG_ENV_ADDR	0xfff80000
+#else
+#define CONFIG_ENV_ADDR	(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#endif
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000
+#endif
+
+#define CONFIG_LOADS_ECHO
+#define CONFIG_SYS_LOADS_BAUD_CHANGE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+						/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* dec freq: 1ms ticks */
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02		/* Software reboot */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20) /* Initial Memory map for Linux */
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20) /* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#ifdef CONFIG_TSEC_ENET
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#endif
+
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	u-boot.bin/* U-Boot image on TFTP server */
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+
+#define CONFIG_BAUDRATE		115200
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=" __stringify(CONFIG_DEF_HWCONFIG)  "\0"	\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
+	"loadaddr=1000000\0"				\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"				\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=c293pcie.dtb\0"			\
+	"bdev=sda1\0"					\
+	"hwconfig=usb1:dr_mode=host,phy_type=utmi\0"	\
+	"othbootargs=ramdisk_size=600000\0"		\
+	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"					\
+	"fatload usb 0:2 $loadaddr $bootfile;"		\
+	"fatload usb 0:2 $fdtaddr $fdtfile;"		\
+	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"	\
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"					\
+	"ext2load usb 0:4 $loadaddr $bootfile;"		\
+	"ext2load usb 0:4 $fdtaddr $fdtfile;"		\
+	"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"	\
+
+#define CONFIG_RAMBOOTCOMMAND			\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND CONFIG_RAMBOOTCOMMAND
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/MPC8544DS.h b/include/configs/MPC8544DS.h
index 83b8668..d5f3c5f 100644
--- a/include/configs/MPC8544DS.h
+++ b/include/configs/MPC8544DS.h
@@ -415,6 +415,18 @@ extern unsigned long get_board_sys_clk(unsigned long dummy);
     #define CONFIG_CMD_EXT2
 #endif
 
+/*
+ * USB
+ */
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI_PCI
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_STORAGE
+#define CONFIG_PCI_EHCI_DEVICE			0
+#endif
 
 #undef CONFIG_WATCHDOG			/* watchdog disabled */
 
diff --git a/include/configs/MPC8572DS.h b/include/configs/MPC8572DS.h
index a62b7d5..016c7da 100644
--- a/include/configs/MPC8572DS.h
+++ b/include/configs/MPC8572DS.h
@@ -735,7 +735,7 @@
 #define CONFIG_BAUDRATE	115200
 
 #define	CONFIG_EXTRA_ENV_SETTINGS				\
-"hwconfig=fsl_ddr:ctlr_intlv=bank,ecc=off\0"			\
+"hwconfig=fsl_ddr:ctlr_intlv=bank,bank_intlv=cs0_cs1,ecc=off\0"	\
 "netdev=eth0\0"						\
 "uboot=" __stringify(CONFIG_UBOOTPATH) "\0"				\
 "tftpflash=tftpboot $loadaddr $uboot; "			\
diff --git a/include/configs/P1010RDB.h b/include/configs/P1010RDB.h
index 437ee6e..972f624 100644
--- a/include/configs/P1010RDB.h
+++ b/include/configs/P1010RDB.h
@@ -31,10 +31,10 @@
 #define CONFIG_PHYS_64BIT
 #endif
 
-#ifdef CONFIG_P1010RDB
 #define CONFIG_P1010
+#define CONFIG_E500			/* BOOKE e500 family */
+#include <asm/config_mpc85xx.h>
 #define CONFIG_NAND_FSL_IFC
-#endif
 
 #ifdef CONFIG_SDCARD
 #define CONFIG_RAMBOOT_SDCARD
@@ -48,15 +48,25 @@
 #define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
 #endif
 
-#ifdef CONFIG_NAND	/* NAND Boot */
-#define CONFIG_RAMBOOT_NAND
-#define CONFIG_NAND_U_BOOT
-#define CONFIG_SYS_TEXT_BASE_SPL	0xff800000
-#ifdef CONFIG_NAND_SPL
-#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE_SPL
-#else
-#define CONFIG_SYS_TEXT_BASE		0x11001000
-#endif /* CONFIG_NAND_SPL */
+#ifdef CONFIG_NAND
+#define CONFIG_SPL
+#define CONFIG_SPL_INIT_MINIMAL
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_MINIMAL
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+
+#define CONFIG_SYS_TEXT_BASE		0x00201000
+#define CONFIG_SPL_TEXT_BASE		0xFFFFE000
+#define CONFIG_SPL_MAX_SIZE		8192
+#define CONFIG_SPL_RELOC_TEXT_BASE	0x00100000
+#define CONFIG_SPL_RELOC_STACK		0x00100000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	((512 << 10) - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(0x00200000 - CONFIG_SPL_MAX_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_START	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	0
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
 #endif
 
 
@@ -74,8 +84,10 @@
 #define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
 #endif
 
-#ifndef CONFIG_SYS_MONITOR_BASE
-#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
 #endif
 
 /* High Level Configuration Options */
@@ -155,11 +167,9 @@
 #define CONFIG_DDR_CLK_FREQ	66666666 /* DDRCLK on P1010 RDB */
 #define CONFIG_SYS_CLK_FREQ	66666666 /* SYSCLK for P1010 RDB */
 
-#ifndef CONFIG_SDCARD
 #define CONFIG_MISC_INIT_R
-#endif
-
 #define CONFIG_HWCONFIG
+
 /*
  * These can be toggled for performance analysis, otherwise use default.
  */
@@ -241,7 +251,7 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_SYS_CCSRBAR_PHYS_LOW		CONFIG_SYS_CCSRBAR
 
 /* Don't relocate CCSRBAR while in NAND_SPL */
-#ifdef CONFIG_NAND_SPL
+#ifdef CONFIG_SPL_BUILD
 #define CONFIG_SYS_CCSR_DO_NOT_RELOCATE
 #endif
 
@@ -267,6 +277,10 @@ extern unsigned long get_sdram_size(void);
  * IFC Definitions
  */
 /* NOR Flash on IFC */
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_NO_FLASH
+#endif
+
 #define CONFIG_SYS_FLASH_BASE		0xee000000
 #define CONFIG_SYS_MAX_FLASH_SECT	256	/* 32M */
 
@@ -352,7 +366,7 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_SYS_NAND_DDR_LAW		11
 
 /* Set up IFC registers for boot location NOR/NAND */
-#if defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SECBOOT)
+#if defined(CONFIG_NAND) || defined(CONFIG_NAND_SECBOOT)
 #define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
 #define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
 #define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
@@ -384,15 +398,6 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
 #endif
 
-/* NAND boot: 8K NAND loader config */
-#define CONFIG_SYS_NAND_SPL_SIZE	0x2000
-#define CONFIG_SYS_NAND_U_BOOT_SIZE	(512 << 10)
-#define CONFIG_SYS_NAND_U_BOOT_DST	(0x11000000 - CONFIG_SYS_NAND_SPL_SIZE)
-#define CONFIG_SYS_NAND_U_BOOT_START	0x11000000
-#define CONFIG_SYS_NAND_U_BOOT_OFFS	(0)
-#define CONFIG_SYS_NAND_U_BOOT_RELOC	0x10000
-#define CONFIG_SYS_NAND_U_BOOT_RELOC_SP	(CONFIG_SYS_NAND_U_BOOT_RELOC + 0x10000)
-
 /* CPLD on IFC */
 #define CONFIG_SYS_CPLD_BASE		0xffb00000
 
@@ -420,14 +425,20 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_SYS_CS3_FTIM3		0x0
 #endif	/* CONFIG_SDCARD */
 
-#if defined(CONFIG_RAMBOOT_SDCARD) || defined(CONFIG_RAMBOOT_SPIFLASH) || \
-    defined(CONFIG_RAMBOOT_NAND)
+#if defined(CONFIG_RAMBOOT_SDCARD) || defined(CONFIG_RAMBOOT_SPIFLASH)
 #define CONFIG_SYS_RAMBOOT
 #define CONFIG_SYS_EXTRA_ENV_RELOC
 #else
 #undef CONFIG_SYS_RAMBOOT
 #endif
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_IFC_A003399
+#if !defined(CONFIG_SPL) && !defined(CONFIG_SYS_RAMBOOT)\
+	&& !defined(CONFIG_SECURE_BOOT)
+#define CONFIG_A003399_NOR_WORKAROUND
+#endif
+#endif
+
 #define CONFIG_BOARD_EARLY_INIT_F	/* Call board_pre_init */
 #define CONFIG_BOARD_EARLY_INIT_R
 
@@ -449,7 +460,7 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_SYS_NS16550_SERIAL
 #define CONFIG_SYS_NS16550_REG_SIZE	1
 #define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
-#ifdef CONFIG_NAND_SPL
+#ifdef CONFIG_SPL_BUILD
 #define CONFIG_NS16550_MIN_FUNCTIONS
 #endif
 
@@ -484,6 +495,8 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_SYS_I2C_SLAVE		0x7F
 #define CONFIG_SYS_I2C_OFFSET		0x3000
 #define CONFIG_SYS_I2C2_OFFSET		0x3100
+#define CONFIG_SYS_I2C_PCA9557_ADDR	0x18
+#define CONFIG_SYS_PCA9557_BUS_NUM	0
 
 /* I2C EEPROM */
 #undef CONFIG_ID_EEPROM
@@ -504,7 +517,7 @@ extern unsigned long get_sdram_size(void);
  * SPI interface will not be available in case of NAND boot SPI CS0 will be
  * used for SLIC
  */
-#if !defined(CONFIG_NAND_U_BOOT) || !defined(CONFIG_NAND_SECBOOT)
+#if !defined(CONFIG_NAND) || !defined(CONFIG_NAND_SECBOOT)
 /* eSPI - Enhanced SPI */
 #define CONFIG_FSL_ESPI
 #define CONFIG_SPI_FLASH
@@ -569,11 +582,10 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_LBA48
 #endif /* #ifdef CONFIG_FSL_SATA  */
 
-/*  SD interface will only be available in case of SD boot */
 #ifdef CONFIG_SDCARD
-#define CONFIG_MMC
-#define CONFIG_DEF_HWCONFIG		esdhc
+#define CONFIG_DEF_HWCONFIG	esdhc
 #endif
+#define CONFIG_MMC
 
 #ifdef CONFIG_MMC
 #define CONFIG_CMD_MMC
@@ -599,7 +611,6 @@ extern unsigned long get_sdram_size(void);
 /*
  * Environment
  */
-#if defined(CONFIG_SYS_RAMBOOT)
 #if defined(CONFIG_RAMBOOT_SDCARD)
 #define CONFIG_ENV_IS_IN_MMC
 #define CONFIG_FSL_FIXED_MMC_LOCATION
@@ -614,16 +625,15 @@ extern unsigned long get_sdram_size(void);
 #define CONFIG_ENV_OFFSET	0x100000	/* 1MB */
 #define CONFIG_ENV_SECT_SIZE	0x10000
 #define CONFIG_ENV_SIZE		0x2000
-#elif defined(CONFIG_NAND_U_BOOT)
+#elif defined(CONFIG_NAND)
 #define CONFIG_ENV_IS_IN_NAND
 #define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
-#define CONFIG_ENV_OFFSET	CONFIG_SYS_NAND_U_BOOT_SIZE
+#define CONFIG_ENV_OFFSET	((512 * 1024) + CONFIG_SYS_NAND_BLOCK_SIZE)
 #define CONFIG_ENV_RANGE	(3 * CONFIG_ENV_SIZE)
-#else
+#elif defined(CONFIG_SYS_RAMBOOT)
 #define CONFIG_ENV_IS_NOWHERE		/* Store ENV in memory only */
 #define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE - 0x1000)
 #define CONFIG_ENV_SIZE			0x2000
-#endif
 #else
 #define CONFIG_ENV_IS_IN_FLASH
 #if CONFIG_SYS_MONITOR_BASE > 0xfff80000
diff --git a/include/configs/P1022DS.h b/include/configs/P1022DS.h
index 14d597a..b282e7b 100644
--- a/include/configs/P1022DS.h
+++ b/include/configs/P1022DS.h
@@ -34,6 +34,29 @@
 #define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
 #endif
 
+#define CONFIG_NAND_FSL_ELBC
+
+#ifdef CONFIG_NAND
+#define CONFIG_SPL
+#define CONFIG_SPL_INIT_MINIMAL
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_MINIMAL
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET              "u-boot-with-spl.bin"
+
+#define CONFIG_SYS_TEXT_BASE           0x00201000
+#define CONFIG_SPL_TEXT_BASE           0xfffff000
+#define CONFIG_SPL_MAX_SIZE            (4 * 1024)
+#define CONFIG_SPL_RELOC_TEXT_BASE     0x00100000
+#define CONFIG_SPL_RELOC_STACK         0x00100000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE    ((512 << 10) + CONFIG_SPL_MAX_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_DST     (0x00200000 - CONFIG_SPL_MAX_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_START   0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS    0
+#define CONFIG_SYS_LDSCRIPT            "arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
+#endif
+
 /* High Level Configuration Options */
 #define CONFIG_BOOKE			/* BOOKE */
 #define CONFIG_E500			/* BOOKE e500 family */
@@ -84,6 +107,13 @@
 #define CONFIG_SYS_CCSRBAR		0xffe00000
 #define CONFIG_SYS_CCSRBAR_PHYS_LOW	CONFIG_SYS_CCSRBAR
 
+/* IN case of NAND bootloader relocate CCSRBAR in RAMboot code not in the 4k
+       SPL code*/
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_CCSR_DO_NOT_RELOCATE
+#endif
+
+
 /* DDR Setup */
 #define CONFIG_DDR_SPD
 #define CONFIG_VERY_BIG_RAM
@@ -105,6 +135,30 @@
 #define CONFIG_SYS_SPD_BUS_NUM		1
 #define SPD_EEPROM_ADDRESS		0x51	/* CTLR 0 DIMM 0 */
 
+/* These are used when DDR doesn't use SPD.  */
+#define CONFIG_SYS_SDRAM_SIZE		2048
+#define CONFIG_SYS_SDRAM_SIZE_LAW	LAW_SIZE_2G
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000003F
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80014202
+#define CONFIG_SYS_DDR_CS1_BNDS		0x0040007F
+#define CONFIG_SYS_DDR_CS1_CONFIG	0x80014202
+#define CONFIG_SYS_DDR_TIMING_3		0x00010000
+#define CONFIG_SYS_DDR_TIMING_0		0x40110104
+#define CONFIG_SYS_DDR_TIMING_1		0x5c5bd746
+#define CONFIG_SYS_DDR_TIMING_2		0x0fa8d4ca
+#define CONFIG_SYS_DDR_MODE_1		0x00441221
+#define CONFIG_SYS_DDR_MODE_2		0x00000000
+#define CONFIG_SYS_DDR_INTERVAL		0x0a280100
+#define CONFIG_SYS_DDR_DATA_INIT	0xdeadbeef
+#define CONFIG_SYS_DDR_CLK_CTRL		0x02800000
+#define CONFIG_SYS_DDR_CONTROL		0xc7000008
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401041
+#define	CONFIG_SYS_DDR_TIMING_4		0x00220001
+#define	CONFIG_SYS_DDR_TIMING_5		0x02401400
+#define	CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8675f608
+
+
 /*
  * Memory map
  *
@@ -118,6 +172,7 @@
  * Localbus non-cacheable
  * 0xe000_0000	0xe80f_ffff	Promjet/free		128M non-cacheable
  * 0xe800_0000	0xefff_ffff	FLASH			128M non-cacheable
+ * 0xff80_0000	0xff80_7fff	NAND			32K non-cacheable
  * 0xffdf_0000	0xffdf_7fff	PIXIS			32K non-cacheable TLB0
  * 0xffd0_0000	0xffd0_3fff	L1 for stack		16K Cacheable TLB0
  * 0xffe0_0000	0xffef_ffff	CCSR			1M non-cacheable
@@ -126,38 +181,84 @@
 /*
  * Local Bus Definitions
  */
-#define CONFIG_SYS_FLASH_BASE		0xe0000000 /* start of FLASH 128M */
+#define CONFIG_SYS_FLASH_BASE		0xe8000000 /* start of FLASH 128M */
 #ifdef CONFIG_PHYS_64BIT
-#define CONFIG_SYS_FLASH_BASE_PHYS	0xfe0000000ull
+#define CONFIG_SYS_FLASH_BASE_PHYS	0xfe8000000ull
 #else
 #define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
 #endif
 
 #define CONFIG_FLASH_BR_PRELIM  \
-	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000) | BR_PS_16 | BR_V)
+	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_16 | BR_V)
 #define CONFIG_FLASH_OR_PRELIM	(OR_AM_128MB | 0xff7)
 
+#ifdef CONFIG_NAND
+#define CONFIG_SYS_BR1_PRELIM	CONFIG_FLASH_BR_PRELIM	/* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM	CONFIG_FLASH_OR_PRELIM	/* NOR Options */
+#else
 #define CONFIG_SYS_BR0_PRELIM	CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
 #define CONFIG_SYS_OR0_PRELIM	CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#endif
 
-#define CONFIG_SYS_BR1_PRELIM	\
-	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_16 | BR_V)
-#define CONFIG_SYS_OR1_PRELIM	CONFIG_FLASH_OR_PRELIM
-
-#define CONFIG_SYS_FLASH_BANKS_LIST	\
-	{CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000, CONFIG_SYS_FLASH_BASE_PHYS}
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS}
 #define CONFIG_SYS_FLASH_QUIET_TEST
 #define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
 
-#define CONFIG_SYS_MAX_FLASH_BANKS	2
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
 #define CONFIG_SYS_MAX_FLASH_SECT	1024
 
+#ifndef CONFIG_SYS_MONITOR_BASE
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SPL_TEXT_BASE
+#else
 #define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+#endif
 
 #define CONFIG_FLASH_CFI_DRIVER
 #define CONFIG_SYS_FLASH_CFI
 #define CONFIG_SYS_FLASH_EMPTY_INFO
 
+/* Nand Flash */
+#if defined(CONFIG_NAND_FSL_ELBC)
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfff800000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+
+#define CONFIG_SYS_NAND_BASE_LIST     { CONFIG_SYS_NAND_BASE, }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND			1
+#define CONFIG_SYS_NAND_BLOCK_SIZE    (256 * 1024)
+#define CONFIG_ELBC_NAND_SPL_STATIC_PGSIZE
+
+/* NAND flash config */
+#define CONFIG_SYS_NAND_BR_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+			       | (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
+			       | BR_PS_8	       /* Port Size = 8 bit */ \
+			       | BR_MS_FCM	       /* MSEL = FCM */ \
+			       | BR_V)		       /* valid */
+#define CONFIG_SYS_NAND_OR_PRELIM  (OR_AM_32KB	       /* length 256K */ \
+			       | OR_FCM_PGS	       /* Large Page*/ \
+			       | OR_FCM_CSCT \
+			       | OR_FCM_CST \
+			       | OR_FCM_CHT \
+			       | OR_FCM_SCY_1 \
+			       | OR_FCM_TRLX \
+			       | OR_FCM_EHTR)
+#ifdef CONFIG_NAND
+#define CONFIG_SYS_BR0_PRELIM	CONFIG_SYS_NAND_BR_PRELIM /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM	CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+#else
+#define CONFIG_SYS_BR1_PRELIM	CONFIG_SYS_NAND_BR_PRELIM /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM	CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+#endif
+
+#endif /* CONFIG_NAND_FSL_ELBC */
+
 #define CONFIG_BOARD_EARLY_INIT_F
 #define CONFIG_BOARD_EARLY_INIT_R
 #define CONFIG_MISC_INIT_R
@@ -177,6 +278,8 @@
 #define PIXIS_LBMAP_SWITCH	7
 #define PIXIS_LBMAP_MASK	0xF0
 #define PIXIS_LBMAP_ALTBANK	0x20
+#define PIXIS_SPD		0x07
+#define PIXIS_SPD_SYSCLK_MASK	0x07
 #define PIXIS_ELBC_SPI_MASK	0xc0
 #define PIXIS_SPI		0x80
 
@@ -199,6 +302,9 @@
 #define CONFIG_SYS_NS16550_SERIAL
 #define CONFIG_SYS_NS16550_REG_SIZE	1
 #define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_NS16550_MIN_FUNCTIONS
+#endif
 
 #define CONFIG_SYS_BAUDRATE_TABLE	\
 	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
@@ -419,7 +525,6 @@
 /*
  * Environment
  */
-#ifdef CONFIG_SYS_RAMBOOT
 #ifdef CONFIG_RAMBOOT_SPIFLASH
 #define CONFIG_ENV_IS_IN_SPI_FLASH
 #define CONFIG_ENV_SPI_BUS	0
@@ -433,16 +538,15 @@
 #define CONFIG_ENV_IS_IN_MMC
 #define CONFIG_ENV_SIZE		0x2000
 #define CONFIG_SYS_MMC_ENV_DEV	0
-#elif defined(CONFIG_NAND_U_BOOT)
+#elif defined(CONFIG_NAND)
 #define CONFIG_ENV_IS_IN_NAND
 #define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
 #define CONFIG_ENV_OFFSET	((512 * 1024) + CONFIG_SYS_NAND_BLOCK_SIZE)
 #define CONFIG_ENV_RANGE	(3 * CONFIG_ENV_SIZE)
-#else
+#elif defined(CONFIG_SYS_RAMBOOT)
 #define CONFIG_ENV_IS_NOWHERE	/* Store ENV in memory only */
 #define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - 0x1000)
 #define CONFIG_ENV_SIZE		0x2000
-#endif
 #else
 #define CONFIG_ENV_IS_IN_FLASH
 #if CONFIG_SYS_MONITOR_BASE > 0xfff80000
diff --git a/include/configs/P1023RDB.h b/include/configs/P1023RDB.h
new file mode 100644
index 0000000..782740f
--- /dev/null
+++ b/include/configs/P1023RDB.h
@@ -0,0 +1,407 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Authors:  Roy Zang <tie-fei.zang@freescale.com>
+ *	     Chunhe Lan <Chunhe.Lan@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff80000
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		/* BOOKE */
+#define CONFIG_E500		/* BOOKE e500 family */
+#define CONFIG_MPC85xx
+#define CONFIG_P1023
+#define CONFIG_MP		/* support multiple processors */
+
+#define CONFIG_FSL_ELBC		/* Has Enhanced localbus controller */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controler 1 (slot 1) */
+#define CONFIG_PCIE2		/* PCIE controler 2 (slot 2) */
+#define CONFIG_PCIE3		/* PCIE controler 3 (slot 3) */
+#define CONFIG_FSL_PCI_INIT	/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET	/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
+#define CONFIG_FSL_LAW		/* Use common FSL init code */
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_clock_freq(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ	66666666
+#define CONFIG_DDR_CLK_FREQ	CONFIG_SYS_CLK_FREQ
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+#define CONFIG_HWCONFIG
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#define CONFIG_SYS_MEMTEST_START	0x01000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x02000000
+
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+/* Implement conversion of addresses in the LBC */
+#define CONFIG_SYS_LBC_LBCR		0x00000000
+#define CONFIG_SYS_LBC_LCRR		LCRR_CLKDIV_8
+
+/* DDR Setup */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+
+#define CONFIG_DDR_SPD
+#define CONFIG_FSL_DDR3
+#define CONFIG_FSL_DDR_INTERACTIVE
+#define CONFIG_SYS_SDRAM_SIZE		512u	/* DDR is 512M */
+#define CONFIG_SYS_SPD_BUS_NUM          0
+#define SPD_EEPROM_ADDRESS              0x50
+#define CONFIG_SYS_DDR_RAW_TIMING
+
+/*
+ * Memory map
+ *
+ * 0x0000_0000	0x1fff_ffff	DDR			500M Cacheable
+ * 0x8000_0000	0xbfff_ffff	PCI Express Mem		1G non-cacheable
+ * 0xc000_0000	0xdfff_ffff	PCI			512M non-cacheable
+ * 0xe100_0000	0xe3ff_ffff	PCI IO range		4M non-cacheable
+ * 0xff00_0000	0xff3f_ffff	DPAA_QBMAN		4M
+ *
+ * Localbus non-cacheable
+ *
+ * 0xec00_0000	0xefff_ffff	NOR flash		64M NOR flash
+ * 0xff60_0000	0xff7f_ffff	CCSR			2M non-cacheable
+ * 0xffa0_0000	0xffaf_ffff	NAND			1M non-cacheable
+ * 0xffd0_0000	0xffd0_3fff	init ram		16K Cacheable TLB0
+ */
+
+/*
+ * Local Bus Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE		0xec000000 /* start of FLASH 64M */
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_FLASH_BR_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) \
+				| BR_PS_16 | BR_V)
+#define CONFIG_FLASH_OR_PRELIM	0xfc000ff7
+
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	512	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_BOARD_EARLY_INIT_F	/* call board_early_init_f function */
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_END	0x00004000	/* End of used area in RAM */
+
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* num bytes initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	\
+	(CONFIG_SYS_INIT_RAM_END - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN	(512 * 1024)	  /* Reserve 512 kB for Mon */
+#define CONFIG_SYS_MALLOC_LEN	(6 * 1024 * 1024) /* Reserved for malloc */
+
+#define CONFIG_SYS_NAND_BASE		0xffa00000
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+
+#define CONFIG_SYS_NAND_BASE_LIST	{CONFIG_SYS_NAND_BASE}
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+#define CONFIG_NAND_FSL_ELBC
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+/* NAND flash config */
+#define CONFIG_SYS_NAND_BR_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
+				| BR_PS_8		/* Port Size = 8bit */ \
+				| BR_MS_FCM		/* MSEL = FCM */ \
+				| BR_V)			/* valid */
+#define CONFIG_SYS_NAND_OR_PRELIM  (OR_AM_256KB		/* length 256K */ \
+				| OR_FCM_PGS \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR)
+
+#define CONFIG_SYS_BR0_PRELIM	CONFIG_FLASH_BR_PRELIM	/* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM	CONFIG_FLASH_OR_PRELIM	/* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM	CONFIG_SYS_NAND_BR_PRELIM
+#define CONFIG_SYS_OR1_PRELIM	CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX		1
+#undef	CONFIG_SERIAL_SOFTWARE_FIFO
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR + 0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR + 0x4600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_SYS_I2C_SPEED	400000	/* I2C speed and slave address */
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/*
+ * I2C2 EEPROM
+ */
+#define CONFIG_ID_EEPROM
+#ifdef CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#endif
+#define CONFIG_SYS_I2C_EEPROM_ADDR		0x50
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN		1
+#define CONFIG_SYS_EEPROM_BUS_NUM		0
+
+#define CONFIG_CMD_I2C
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/* controller 3, Slot 1, tgtid 3, Base address b000 */
+#define CONFIG_SYS_PCIE3_NAME		"Slot 3"
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCIE3_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0x80000000
+#define CONFIG_SYS_PCIE3_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xffc00000
+#define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 2, direct to uli, tgtid 2, Base address 9000 */
+#define CONFIG_SYS_PCIE2_NAME		"Slot 2"
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 1, Slot 2, tgtid 1, Base address a000 */
+#define CONFIG_SYS_PCIE1_NAME		"Slot 1"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xc0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc0000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc20000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc20000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+#if defined(CONFIG_PCI)
+#define CONFIG_E1000		/* Defind e1000 pci Ethernet card */
+#define CONFIG_PCI_PNP		/* do pci plug-and-play */
+#define CONFIG_PCI_SCAN_SHOW	/* show pci devices on startup */
+#endif	/* CONFIG_PCI */
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_ENV_IS_IN_FLASH
+#if CONFIG_SYS_MONITOR_BASE > 0xfff80000
+#define CONFIG_ENV_ADDR		0xfff80000
+#else
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#endif
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+
+#define CONFIG_LOADS_ECHO		/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+#if defined(CONFIG_PCI)
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+ * USB
+ */
+#define CONFIG_HAS_FSL_DR_USB
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING		/* Command-line editing */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_HZ	1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 16 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(16 << 20) /* Initial Memory map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(16 << 20) /* Increase max gunzip size */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	(u-boot.bin) /* U-Boot image on TFTP server */
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY 10	/* -1 disables auto-boot */
+
+#define CONFIG_BAUDRATE	115200
+
+/* Qman/Bman */
+#define CONFIG_SYS_DPAA_QBMAN		/* support Q/Bman */
+#define CONFIG_SYS_QMAN_MEM_BASE	0xff000000
+#define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_MEM_BASE	0xff200000
+#define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+
+/* For FM */
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHY_ATHEROS
+#endif
+
+/* Default address of microcode for the Linux Fman driver */
+/* QE microcode/firmware address */
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0xeff40000
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_SYS_FM1_DTSEC1_PHY_ADDR	0x1
+#define CONFIG_SYS_FM1_DTSEC2_PHY_ADDR	0x2
+
+#define CONFIG_SYS_TBIPA_VALUE	8
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC1"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"hwconfig=usb1:dr_mode=host,phy_type=ulpi\0"
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/P2041RDB.h b/include/configs/P2041RDB.h
index 8b9b0db..7f2421a 100644
--- a/include/configs/P2041RDB.h
+++ b/include/configs/P2041RDB.h
@@ -27,6 +27,8 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define ACCTON_AS6700_32X
+
 #define CONFIG_P2041RDB
 #define CONFIG_PHYS_64BIT
 #define CONFIG_PPC_P2041
@@ -34,8 +36,11 @@
 #ifdef CONFIG_RAMBOOT_PBL
 #define CONFIG_RAMBOOT_TEXT_BASE	CONFIG_SYS_TEXT_BASE
 #define CONFIG_RESET_VECTOR_ADDRESS	0xfffffffc
+#define CONFIG_PBLPBI_CONFIG $(SRCTREE)/board/freescale/corenet_ds/pbi.cfg
+#define CONFIG_PBLRCW_CONFIG $(SRCTREE)/board/freescale/corenet_ds/rcw_p2041rdb.cfg
 #endif
 
+#if 0
 #ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
 /* Set 1M boot space */
 #define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR (CONFIG_SYS_TEXT_BASE & 0xfff00000)
@@ -44,6 +49,7 @@
 #define CONFIG_RESET_VECTOR_ADDRESS 0xfffffffc
 #define CONFIG_SYS_NO_FLASH
 #endif
+#endif
 
 /* High Level Configuration Options */
 #define CONFIG_BOOKE
@@ -51,7 +57,6 @@
 #define CONFIG_E500MC			/* BOOKE e500mc family */
 #define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
 #define CONFIG_MPC85xx			/* MPC85xx/PQ3 platform */
-#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_MP			/* support multiple processors */
 
 #ifndef CONFIG_SYS_TEXT_BASE
@@ -72,15 +77,20 @@
 #define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
 #define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
 
+#if 0
 #define CONFIG_SYS_SRIO
 #define CONFIG_SRIO1			/* SRIO port 1 */
 #define CONFIG_SRIO2			/* SRIO port 2 */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
 #define CONFIG_SYS_DPAA_RMAN		/* RMan */
+#endif
 
 #define CONFIG_FSL_LAW			/* Use common FSL init code */
 
 #define CONFIG_ENV_OVERWRITE
 
+#define CONFIG_SYS_NO_FLASH
+
 #ifdef CONFIG_SYS_NO_FLASH
 #if !defined(CONFIG_RAMBOOT_PBL) && !defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
 #define CONFIG_ENV_IS_NOWHERE
@@ -91,6 +101,10 @@
 #define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
 #endif
 
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_SPI_FLASH_BAR
+
 #if defined(CONFIG_SPIFLASH)
 	#define CONFIG_SYS_EXTRA_ENV_RELOC
 	#define CONFIG_ENV_IS_IN_SPI_FLASH
@@ -107,7 +121,7 @@
 	#define CONFIG_FSL_FIXED_MMC_LOCATION
 	#define CONFIG_SYS_MMC_ENV_DEV          0
 	#define CONFIG_ENV_SIZE			0x2000
-	#define CONFIG_ENV_OFFSET		(512 * 1097)
+	#define CONFIG_ENV_OFFSET		(512 * 1105)
 #elif defined(CONFIG_NAND)
 #define CONFIG_SYS_EXTRA_ENV_RELOC
 #define CONFIG_ENV_IS_IN_NAND
@@ -127,6 +141,15 @@
 	#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
 #endif
 
+/*#define CONFIG_BOOTARGS     "root=/dev/ram rw console=ttyS0,115200 mem=3968M quiet"*/
+#define CONFIG_ETHADDR      00:E0:0C:00:00:FD
+#define CONFIG_ETH2ADDR     00:00:00:00:00:02
+#define CONFIG_ETH3ADDR     00:00:00:00:00:03
+#define CONFIG_IPADDR       192.168.3.10
+#define CONFIG_SERVERIP     192.168.3.14
+#define CONFIG_GATEWAYIP    192.168.3.14
+#define CONFIG_NETMASK      255.255.255.0
+
 #ifndef __ASSEMBLY__
 unsigned long get_board_sys_clk(unsigned long dummy);
 #endif
@@ -186,40 +209,50 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 #define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
 
 #define CONFIG_DIMM_SLOTS_PER_CTLR	1
-#define CONFIG_CHIP_SELECTS_PER_CTRL	(4 * CONFIG_DIMM_SLOTS_PER_CTLR)
+#define CONFIG_CHIP_SELECTS_PER_CTRL    (1 * CONFIG_DIMM_SLOTS_PER_CTLR)
 
 #define CONFIG_DDR_SPD
 #define CONFIG_FSL_DDR3
 
+#define CONFIG_DDR_ECC
+#define CONFIG_MEM_INIT_VALUE 0xdeadbeef
+/*#define CONFIG_SYS_DRAM_TEST*/
+
 #define CONFIG_SYS_SPD_BUS_NUM	0
-#define SPD_EEPROM_ADDRESS	0x52
-#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
+
+#define SPD_EEPROM_ADDRESS 0x50
+#define CONFIG_SYS_SDRAM_SIZE 2048  /* for fixed parameter use */
 
 /*
  * Local Bus Definitions
  */
 
 /* Set the local bus clock 1/8 of platform clock */
-#define CONFIG_SYS_LBC_LCRR		LCRR_CLKDIV_8
+#define CONFIG_SYS_LBC_LCRR     LCRR_CLKDIV_32
 
 /*
  * This board doesn't have a promjet connector.
  * However, it uses commone corenet board LAW and TLB.
  * It is necessary to use the same start address with proper offset.
  */
-#define CONFIG_SYS_FLASH_BASE		0xe0000000
+#define CONFIG_SYS_FLASH_BASE       0xec000000
 #ifdef CONFIG_PHYS_64BIT
-#define CONFIG_SYS_FLASH_BASE_PHYS	0xfe0000000ull
+#define CONFIG_SYS_FLASH_BASE_PHYS  0xfec000000ull
 #else
 #define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
 #endif
 
-#define CONFIG_SYS_FLASH_BR_PRELIM \
+/*#define CONFIG_SYS_FLASH_BR_PRELIM \
 		(BR_PHYS_ADDR((CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000)) | \
-		BR_PS_16 | BR_V)
-#define CONFIG_SYS_FLASH_OR_PRELIM \
+		BR_PS_16 | BR_V)*/
+#define CONFIG_SYS_FLASH_BR_PRELIM \
+        (BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_16 | BR_V)
+/*#define CONFIG_SYS_FLASH_OR_PRELIM \
 		((0xf8000ff7 & ~OR_GPCM_SCY & ~OR_GPCM_EHTR) \
-		 | OR_GPCM_SCY_8 | OR_GPCM_EHTR_CLEAR)
+		 | OR_GPCM_SCY_8 | OR_GPCM_EHTR_CLEAR)*/
+#define CONFIG_SYS_FLASH_OR_PRELIM \
+        ((0xfc000ff7 & ~OR_GPCM_SCY & ~OR_GPCM_EHTR) \
+         | OR_GPCM_SCY_8 | OR_GPCM_EHTR_CLEAR)
 
 #define CONFIG_FSL_CPLD
 #define CPLD_BASE		0xffdf0000	/* CPLD registers */
@@ -251,7 +284,7 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 #define CONFIG_SYS_RAMBOOT
 #endif
 
-#define CONFIG_NAND_FSL_ELBC
+/*#define CONFIG_NAND_FSL_ELBC*/
 /* Nand Flash */
 #ifdef CONFIG_NAND_FSL_ELBC
 #define CONFIG_SYS_NAND_BASE		0xffa00000
@@ -300,7 +333,8 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 
 #define CONFIG_SYS_FLASH_EMPTY_INFO
 #define CONFIG_SYS_FLASH_AMD_CHECK_DQ7
-#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000}
+/*#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000}*/
+#define CONFIG_SYS_FLASH_BANKS_LIST {CONFIG_SYS_FLASH_BASE_PHYS}
 
 #define CONFIG_BOARD_EARLY_INIT_F
 #define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
@@ -372,7 +406,11 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 #define CONFIG_SYS_I2C_SLAVE		0x7F
 #define CONFIG_SYS_I2C_OFFSET		0x118000
 #define CONFIG_SYS_I2C2_OFFSET		0x118100
+#define CONFIG_SYS_I2C3_OFFSET      0x119000
+#define CONFIG_SYS_I2C4_OFFSET      0x119100
+
 
+#if 0
 /*
  * RapidIO
  */
@@ -421,16 +459,20 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
 #endif
 
+#endif
+
 /*
  * eSPI - Enhanced SPI
  */
 #define CONFIG_FSL_ESPI
 #define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_SPANSION
+/*#define CONFIG_SPI_FLASH_SPANSION*/
 #define CONFIG_CMD_SF
 #define CONFIG_SF_DEFAULT_SPEED         10000000
-#define CONFIG_SF_DEFAULT_MODE          0
+#define CONFIG_SF_DEFAULT_MODE          3
 
+/*PCIE default setting*/
+#if 0
 /*
  * General PCI
  * Memory space is mapped 1-1, but I/O space must start from 0.
@@ -492,6 +534,40 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 #define CONFIG_SYS_PCIE3_IO_PHYS	0xf8020000
 #endif
 #define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT   0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS    0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS   0xd0000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE1_IO_VIRT    0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS    0xf8000000
+#define CONFIG_SYS_PCIE1_IO_SIZE    0x00010000  /* 64k */
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#define CONFIG_SYS_PCIE2_MEM_VIRT   0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_BUS    0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS   0xd8000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE2_IO_VIRT    0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS    0xf8010000
+#define CONFIG_SYS_PCIE2_IO_SIZE    0x00010000  /* 64k */
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#define CONFIG_SYS_PCIE3_MEM_VIRT   0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_BUS    0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS   0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_SIZE   0x08000000  /* 128M */
+
+#define CONFIG_SYS_PCIE3_IO_VIRT    0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS     0x00000000
+#define CONFIG_SYS_PCIE3_IO_PHYS    0xf8020000
+#define CONFIG_SYS_PCIE3_IO_SIZE    0x00010000  /* 64k */
 
 /* Qman/Bman */
 #define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
@@ -553,11 +629,15 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 #ifdef CONFIG_SYS_DPAA_FMAN
 #define CONFIG_FMAN_ENET
 #define CONFIG_PHYLIB_10G
-#define CONFIG_PHY_VITESSE
+
+/*#define CONFIG_PHY_VITESSE*/
+#define CONFIG_PHY_BROADCOM
+
 #define CONFIG_PHY_TERANETICS
 #endif
 
 #ifdef CONFIG_PCI
+#define CONFIG_NET_MULTI
 #define CONFIG_PCI_PNP			/* do pci plug-and-play */
 #define CONFIG_E1000
 
@@ -596,7 +676,7 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 #define CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR	0x1c
 #define CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR	0x1d
 #define CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR	0x1e
-#define CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR	0x1f
+#define CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR    0x01
 
 #define CONFIG_SYS_FM1_10GEC1_PHY_ADDR	0
 
@@ -703,14 +783,17 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 #define CONFIG_UBOOTPATH	u-boot.bin
 
 /* default location for tftp and bootm */
-#define CONFIG_LOADADDR		1000000
+#define CONFIG_LOADADDR     2000000
 
-#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+/* -1 disables auto-boot */
+#define CONFIG_BOOTDELAY 3
 
 #define CONFIG_BAUDRATE	115200
 
 #define __USB_PHY_TYPE	utmi
 
+/*ONIE redefined*/
+/*
 #define	CONFIG_EXTRA_ENV_SETTINGS				\
 	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
 	"bank_intlv=cs0_cs1\0"					\
@@ -732,7 +815,7 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 	"fdtfile=p2041rdb/p2041rdb.dtb\0"			\
 	"bdev=sda3\0"						\
 	"c=ffe\0"
-
+*/
 #define CONFIG_HDBOOT					\
 	"setenv bootargs root=/dev/$bdev rw "		\
 	"console=$consoledev,$baudrate $othbootargs;"	\
@@ -757,10 +840,61 @@ unsigned long get_board_sys_clk(unsigned long dummy);
 	"tftp $fdtaddr $fdtfile;"			\
 	"bootm $loadaddr $ramdiskaddr $fdtaddr"
 
-#define CONFIG_BOOTCOMMAND		CONFIG_HDBOOT
+/*#define CONFIG_BOOTCOMMAND        CONFIG_HDBOOT*/ /*ONIE redefined*/
 
 #ifdef CONFIG_SECURE_BOOT
 #include <asm/fsl_secure_boot.h>
 #endif
 
+/* ICOS Fastpath app image file support */
+#define CONFIG_FASTPATH
+
+#ifdef CONFIG_FASTPATH
+#define CONFIG_FDT_INDEX        4
+#endif
+
+/* ONIE */
+#include "common_config.h"
+
+#define CONFIG_SYS_EEPROM_LOAD_ENV_MAC
+#define CONFIG_CMD_SYS_EEPROM
+#define CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS 2
+
+#if defined(CONFIG_SPIFLASH)
+#define CONFIG_SYS_EEPROM_USE_COMMON_SPI_IO
+#define CONFIG_SYS_SPI_FLASH_HWINFO_ADDR        0x00120000
+#define CONFIG_SYS_SPI_FLASH_HWINFO_SECT_SIZE   0x00010000
+#define CONFIG_PLATFORM_ENV     \
+    "hwconfig=fsl_ddr:ctlr_intlv=cacheline," \
+    "bank_intlv=cs0_cs1\0"      \
+    "consoledev=ttyS0\0"        \
+    "boot_diag=if test -n $onie_boot_reason; then " \
+        "if test $onie_boot_reason = diag; then "   \
+        "run diag_bootcmd; fi; fi\0"                \
+    "diag_bootcmd=setenv bootargs root=/dev/ram rw console=ttyS0,$baudrate quiet $diagargs;"    \
+        "run fan_default_speed;"    \
+        "sf probe; sf read $loadaddr $diag_start ${diag_sz.b}; bootm $loadaddr\0"   \
+    "fan_speed_level=7\0"       \
+    "fan_default_speed=i2c dev 1; i2c mw 0x35 0x20 $fan_speed_level\0"  \
+    "onie_boot_reason=diag\0"     \
+    "diag_start=0x00930000\0"   \
+    "diag_sz.b=0x02000000\0"    \
+    "onie_start=0x00130000\0"   \
+    "onie_sz.b=0x800000\0"
+#else
+#define CONFIG_SYS_EEPROM_USE_COMMON_FLASH_IO
+#define CONFIG_SYS_FLASH_HWINFO_ADDR        0xec020000
+#define CONFIG_SYS_FLASH_HWINFO_SECT_SIZE   0x00020000
+#define CONFIG_PLATFORM_ENV     \
+    "consoledev=ttyS0\0"        \
+    "onie_start=0xec040000\0"   \
+    "onie_sz.b=0xd00000\0"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    CONFIG_PLATFORM_ENV           \
+    CONFIG_ONIE_COMMON_UBOOT_ENV
+/* ONIE */
+
+
 #endif	/* __CONFIG_H */
diff --git a/include/configs/P3041DS.h b/include/configs/P3041DS.h
index ce8f9b0..f65aa16 100644
--- a/include/configs/P3041DS.h
+++ b/include/configs/P3041DS.h
@@ -35,11 +35,12 @@
 #define CONFIG_FSL_SATA_V2
 #define CONFIG_PCIE3
 #define CONFIG_PCIE4
-#define CONFIG_SYS_DPAA_RMAN
-
 #define CONFIG_SYS_SRIO
 #define CONFIG_SRIO1			/* SRIO port 1 */
 #define CONFIG_SRIO2			/* SRIO port 2 */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+#define CONFIG_SYS_DPAA_RMAN
+#define CONFIG_SYS_DPAA_PME
 
 #define CONFIG_ICS307_REFCLK_HZ		25000000  /* ICS307 ref clk freq */
 
diff --git a/include/configs/P4080DS.h b/include/configs/P4080DS.h
index 53979dd..4db3075 100644
--- a/include/configs/P4080DS.h
+++ b/include/configs/P4080DS.h
@@ -32,10 +32,12 @@
 
 #define CONFIG_MMC
 #define CONFIG_PCIE3
-
 #define CONFIG_SYS_SRIO
 #define CONFIG_SRIO1			/* SRIO port 1 */
 #define CONFIG_SRIO2			/* SRIO port 2 */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+
+#define CONFIG_SYS_DPAA_PME
 
 #define CONFIG_ICS307_REFCLK_HZ		33333000  /* ICS307 ref clk freq */
 
diff --git a/include/configs/P5020DS.h b/include/configs/P5020DS.h
index 778230d..42d0be3 100644
--- a/include/configs/P5020DS.h
+++ b/include/configs/P5020DS.h
@@ -35,12 +35,13 @@
 #define CONFIG_FSL_SATA_V2
 #define CONFIG_PCIE3
 #define CONFIG_PCIE4
-#define CONFIG_SYS_FSL_RAID_ENGINE
-#define CONFIG_SYS_DPAA_RMAN
-
 #define CONFIG_SYS_SRIO
 #define CONFIG_SRIO1			/* SRIO port 1 */
 #define CONFIG_SRIO2			/* SRIO port 2 */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+#define CONFIG_SYS_FSL_RAID_ENGINE
+#define CONFIG_SYS_DPAA_RMAN
+#define CONFIG_SYS_DPAA_PME
 
 #define CONFIG_ICS307_REFCLK_HZ		25000000  /* ICS307 ref clk freq */
 
diff --git a/include/configs/P5040DS.h b/include/configs/P5040DS.h
index 50d9e54..a3ecfb4 100644
--- a/include/configs/P5040DS.h
+++ b/include/configs/P5040DS.h
@@ -32,6 +32,7 @@
 
 #define CONFIG_MMC
 #define CONFIG_NAND_FSL_ELBC
+#define CONFIG_FSL_SATA_V2
 #define CONFIG_PCIE3
 #define CONFIG_SYS_FSL_RAID_ENGINE
 
diff --git a/include/configs/T1040QDS.h b/include/configs/T1040QDS.h
new file mode 100644
index 0000000..19a036e
--- /dev/null
+++ b/include/configs/T1040QDS.h
@@ -0,0 +1,721 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * T1040 QDS board configuration file
+ */
+#define CONFIG_T1040QDS
+#define CONFIG_PHYS_64BIT
+#define CONFIG_PPC_T1040
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_RAMBOOT_TEXT_BASE	CONFIG_SYS_TEXT_BASE
+#define CONFIG_RESET_VECTOR_ADDRESS	0xfffffffc
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_E500MC			/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
+#define CONFIG_MPC85xx			/* MPC85xx/PQ3 platform */
+#define CONFIG_MP			/* support multiple processors */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#define CONFIG_SYS_FSL_CPC		/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC		CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#define CONFIG_PCIE1			/* PCIE controler 1 */
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+#define CONFIG_SYS_SRIO
+#define CONFIG_SRIO1			/* SRIO port 1 */
+#define CONFIG_SRIO2			/* SRIO port 2 */
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+
+#define CONFIG_ENV_OVERWRITE
+
+#ifdef CONFIG_SYS_NO_FLASH
+#define CONFIG_ENV_IS_NOWHERE
+#else
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+#ifndef CONFIG_SYS_NO_FLASH
+#if defined(CONFIG_SPIFLASH)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SPI_BUS              0
+#define CONFIG_ENV_SPI_CS               0
+#define CONFIG_ENV_SPI_MAX_HZ           10000000
+#define CONFIG_ENV_SPI_MODE             0
+#define CONFIG_ENV_SIZE                 0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET               0x100000        /* 1MB */
+#define CONFIG_ENV_SECT_SIZE            0x10000
+#elif defined(CONFIG_SDCARD)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV          0
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(512 * 1105)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE			CONFIG_SYS_NAND_BLOCK_SIZE
+#define CONFIG_ENV_OFFSET		(5 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+#else /* CONFIG_SYS_NO_FLASH */
+#define CONFIG_ENV_SIZE                0x2000
+#define CONFIG_ENV_SECT_SIZE   0x20000 /* 128K (one sector) */
+#endif
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk() /* sysclk for MPC85xx */
+#define CONFIG_DDR_CLK_FREQ	get_board_ddr_clk()
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BTB			/* toggle branch predition */
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#endif
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP
+#define CONFIG_SYS_NUM_ADDR_MAP		64	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+/*
+ *  Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		CONFIG_RAMBOOT_TEXT_BASE
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_DCSRBAR		0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS		0xf00000000ull
+#endif
+
+/* EEPROM */
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+/* CONFIG_NUM_DDR_CONTROLLERS is defined in include/asm/config_mpc85xx.h */
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(4 * CONFIG_DIMM_SLOTS_PER_CTLR)
+
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_DDR_RAW_TIMING
+#define CONFIG_FSL_DDR3
+
+#define CONFIG_SYS_SPD_BUS_NUM	0
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS2	0x53
+
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
+#define CONFIG_SYS_SDRAM_SIZE	2048	/* for fixed parameter use */
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE	0xe0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
+				+ 0x8000000) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR1_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR1_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(4)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1a) | \
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS \
+					+ 0x8000000, CONFIG_SYS_FLASH_BASE_PHYS}
+#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
+#define QIXIS_BASE		0xffdf0000
+#ifdef CONFIG_PHYS_64BIT
+#define QIXIS_BASE_PHYS		(0xf00000000ull | QIXIS_BASE)
+#else
+#define QIXIS_BASE_PHYS		QIXIS_BASE
+#endif
+#define QIXIS_LBMAP_SWITCH		0x01
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x01
+#define QIXIS_LBMAP_ALTBANK		0x07
+#define QIXIS_RST_CTL_RESET		0x83
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+
+#define CONFIG_SYS_CSPR3_EXT	(0xf)
+#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+#define CONFIG_SYS_AMASK3	IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR3	0x0
+/* QIXIS Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0x0e) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+					FTIM2_GPCM_TCH(0x0) | \
+					FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_R
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xfdd00000	/* Initial L1 address */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH	0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW	0xfe0ec000
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#else
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	0xfe0ec000 /* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+#endif
+#define CONFIG_SYS_INIT_RAM_SIZE		0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+					GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(4 * 1024 * 1024)
+
+/* Serial Port - controlled on board with jumper J8
+ * open - index 2
+ * shorted - index 1
+ */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3	(CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4	(CONFIG_SYS_CCSRBAR+0x11D600)
+#define CONFIG_SERIAL_MULTI		/* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000	/* I2C speed in Hz */
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x118000
+#define CONFIG_SYS_I2C2_OFFSET		0x119000
+
+/*
+ * RTC configuration
+ */
+#define RTC
+#define CONFIG_RTC_DS3231               1
+#define CONFIG_SYS_I2C_RTC_ADDR         0x68
+
+/*
+ * RapidIO
+ */
+#ifdef CONFIG_SYS_SRIO
+#ifdef CONFIG_SRIO1
+#define CONFIG_SYS_SRIO1_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_SRIO1_MEM_SIZE	0x10000000	/* 256M */
+#endif
+
+#ifdef CONFIG_SRIO2
+#define CONFIG_SYS_SRIO2_MEM_VIRT	0xb0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xc30000000ull
+#else
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xb0000000
+#endif
+#define CONFIG_SYS_SRIO2_MEM_SIZE	0x10000000	/* 256M */
+#endif
+#endif
+
+/*
+ * for slave u-boot IMAGE instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef080000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff80000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE 0x80000	/* 512K */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff80000ull
+/*
+ * for slave UCODE and ENV instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef040000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS 0x3ffe00000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE 0x40000	/* 256K */
+
+/* slave core release by master*/
+#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET 0xe00e4
+#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK 0x00000001 /* release core 0 */
+
+/*
+ * SRIO_PCIE_BOOT - SLAVE
+ */
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
+#endif
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED         10000000
+#define CONFIG_SF_DEFAULT_MODE          0
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xf8000000
+#endif
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+/* Qman/Bman */
+#ifndef CONFIG_NOBQFMAN
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#else
+#define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_NUM_PORTALS	25
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
+#else
+#define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_SYS_DPAA_PME
+
+/* Default address of microcode for the Linux Fman driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0x110000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 545KB (1089 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 1089 + 16 = 1113, enlarge it to 1130.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(512 * 1130)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(6 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_QE_FMAN_FW_ADDR		0xEFF40000
+#endif
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+#endif /* CONFIG_NOBQFMAN */
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHYLIB_10G
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_TERANETICS
+#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
+#define SGMII_CARD_PORT2_PHY_ADDR 0x10
+#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
+#define SGMII_CARD_PORT4_PHY_ADDR 0x11
+#endif
+
+#ifdef CONFIG_PCI
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_E1000
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif	/* CONFIG_PCI */
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_SYS_FM1_DTSEC5_PHY_ADDR	0x10
+#define CONFIG_SYS_FM1_DTSEC6_PHY_ADDR	0x11
+#define CONFIG_SYS_FM1_10GEC1_PHY_ADDR	4
+
+#define CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR    0x1c
+#define CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR    0x1d
+#define CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR    0x1e
+#define CONFIG_SYS_FM1_DTSEC4_RISER_PHY_ADDR    0x1f
+
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC1"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+/*
+ * Environment
+ */
+#define CONFIG_LOADS_ECHO		/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+* USB
+*/
+#define CONFIG_HAS_FSL_DR_USB
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_CMD_EXT2
+#endif
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks*/
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	"u-boot.bin"	/* U-Boot image on TFTP server*/
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY 	10	/* -1 disables auto-boot */
+
+#define CONFIG_BAUDRATE	115200
+
+#define __USB_PHY_TYPE	ulpi
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
+	"bank_intlv=cs0_cs1;"					\
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"	\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"ramdiskfile=b4860qds/ramdisk.uboot\0"			\
+	"fdtaddr=c00000\0"					\
+	"fdtfile=b4860qds/b4860qds.dtb\0"				\
+	"bdev=sda3\0"						\
+	"c=ffe\0"
+
+/* For emulation this causes u-boot to jump to the start of the proof point
+   app code automatically */
+#define CONFIG_PROOF_POINTS			\
+ "setenv bootargs root=/dev/$bdev rw "		\
+ "console=$consoledev,$baudrate $othbootargs;"	\
+ "cpu 1 release 0x29000000 - - -;"              \
+ "cpu 2 release 0x29000000 - - -;"              \
+ "cpu 3 release 0x29000000 - - -;"              \
+ "cpu 4 release 0x29000000 - - -;"              \
+ "cpu 5 release 0x29000000 - - -;"              \
+ "cpu 6 release 0x29000000 - - -;"              \
+ "cpu 7 release 0x29000000 - - -;"              \
+ "go 0x29000000"
+
+#define CONFIG_HVBOOT	\
+ "setenv bootargs config-addr=0x60000000; "	\
+ "bootm 0x01000000 - 0x00f00000"
+
+#define CONFIG_ALU                     \
+ "setenv bootargs root=/dev/$bdev rw "          \
+ "console=$consoledev,$baudrate $othbootargs;"  \
+ "cpu 1 release 0x01000000 - - -;"              \
+ "cpu 2 release 0x01000000 - - -;"              \
+ "cpu 3 release 0x01000000 - - -;"              \
+ "cpu 4 release 0x01000000 - - -;"              \
+ "cpu 5 release 0x01000000 - - -;"              \
+ "cpu 6 release 0x01000000 - - -;"              \
+ "cpu 7 release 0x01000000 - - -;"              \
+ "go 0x01000000"
+
+#define CONFIG_LINUX                       \
+ "setenv bootargs root=/dev/ram rw "            \
+ "console=$consoledev,$baudrate $othbootargs;"  \
+ "setenv ramdiskaddr 0x02000000;"                       \
+ "setenv fdtaddr 0x00c00000;"                           \
+ "setenv loadaddr 0x1000000;"				\
+ "bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_HDBOOT					\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_NFSBOOTCOMMAND			\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND				\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $ramdiskaddr $ramdiskfile;"		\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND		CONFIG_LINUX
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/T4240EMU.h b/include/configs/T4240EMU.h
new file mode 100644
index 0000000..fd7205d
--- /dev/null
+++ b/include/configs/T4240EMU.h
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * T4240 EMU board configuration file
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_T4240EMU
+#define CONFIG_PHYS_64BIT
+
+#define CONFIG_SYS_NO_FLASH		1
+#define CONFIG_SYS_FSL_DDR_EMU		1
+#define CONFIG_SYS_FSL_NO_QIXIS		1
+#define CONFIG_SYS_FSL_NO_SERDES	1
+
+#include "t4qds.h"
+
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_CACHE_FLUSH
+
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE         0x2000
+
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	133333333
+#define CONFIG_FSL_TBCLK_EXTRA_DIV 100
+
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_SYS_SPD_BUS_NUM	1
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS2	0x52
+#ifndef CONFIG_SYS_FSL_EMU_AP1
+#define SPD_EEPROM_ADDRESS3	0x53
+#define SPD_EEPROM_ADDRESS4	0x54
+#define SPD_EEPROM_ADDRESS5	0x55
+#define SPD_EEPROM_ADDRESS6	0x56
+#endif
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1	/* for p3041/p5010 */
+#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
+				+ 0x8000000) | \
+				CSPR_PORT_SIZE_32 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(0)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x1) | \
+				FTIM0_NOR_TEADC(0x1) | \
+				FTIM0_NOR_TEAHC(0x1))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x1) | \
+				FTIM1_NOR_TRAD_NOR(0x1))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x0) | \
+				FTIM2_NOR_TCH(0x0) | \
+				FTIM2_NOR_TWP(0x1))
+#define CONFIG_SYS_NOR_FTIM3	0x04000000
+#define CONFIG_SYS_IFC_CCR	0x01000000
+
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+
+
+/* I2C */
+#define CONFIG_SYS_I2C_SPEED		4000000	/* faster speed for emulator */
+
+
+/* Qman/Bman */
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	50
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_NUM_PORTALS	50
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_SYS_DPAA_PME
+#define CONFIG_SYS_PMAN
+#define CONFIG_SYS_DPAA_DCE
+#define CONFIG_SYS_DPAA_RMAN		/* RMan */
+#define CONFIG_SYS_INTERLAKEN
+
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_QE_FMAN_FW_ADDR		0xEFF40000
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+
+
+
+#define CONFIG_BOOTDELAY	0
+
+/*
+ * T4240 has 3 DDR controllers. Default to 3-way interleaving. It can be
+ * 3way_1KB, 3way_4KB, 3way_8KB. T4160 has 2 DDR controllers. Default to 2-way
+ * interleaving. It can be cacheline, page, bank, superbank.
+ * See doc/README.fsl-ddr for details.
+ */
+#ifdef CONFIG_SYS_FSL_EMU_AP1
+#define CTRL_INTLV_PREFERED null
+#else
+#ifdef CONFIG_PPC_T4240
+#define CTRL_INTLV_PREFERED 3way_4KB
+#else
+#define CTRL_INTLV_PREFERED cacheline
+#endif
+#endif
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:"					\
+	"ctlr_intlv=" __stringify(CTRL_INTLV_PREFERED) ","	\
+	"bank_intlv=auto;"					\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"			\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"		\
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"ramdiskfile=t4240emu/ramdisk.uboot\0"			\
+	"fdtaddr=c00000\0"					\
+	"fdtfile=t4240emu/t4240emu.dtb\0"				\
+	"bdev=sda3\0"						\
+	"c=ffe\0"
+
+/*
+ * For emulation this causes u-boot to jump to the start of the proof point
+ * app code automatically
+ */
+#define CONFIG_PROOF_POINTS			\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"cpu 1 release 0x29000000 - - -;"		\
+	"cpu 2 release 0x29000000 - - -;"		\
+	"cpu 3 release 0x29000000 - - -;"		\
+	"cpu 4 release 0x29000000 - - -;"		\
+	"cpu 5 release 0x29000000 - - -;"		\
+	"cpu 6 release 0x29000000 - - -;"		\
+	"cpu 7 release 0x29000000 - - -;"		\
+	"go 0x29000000"
+
+#define CONFIG_HVBOOT				\
+	"setenv bootargs config-addr=0x60000000; "	\
+	"bootm 0x01000000 - 0x00f00000"
+
+#define CONFIG_LINUX					\
+	"errata;"					\
+	"setenv othbootargs ignore_loglevel;"		\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"setenv ramdiskaddr 0x02000000;"		\
+	"setenv fdtaddr 0x00c00000;"			\
+	"setenv loadaddr 0x1000000;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND		CONFIG_LINUX
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/T4240QDS.h b/include/configs/T4240QDS.h
index 76b3ca6..3a166d9 100644
--- a/include/configs/T4240QDS.h
+++ b/include/configs/T4240QDS.h
@@ -23,13 +23,558 @@
 /*
  * T4240 QDS board configuration file
  */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
 #define CONFIG_T4240QDS
 #define CONFIG_PHYS_64BIT
-#define CONFIG_PPC_T4240
 
 #define CONFIG_FSL_SATA_V2
 #define CONFIG_PCIE4
 
 #define CONFIG_ICS307_REFCLK_HZ		25000000  /* ICS307 ref clk freq */
 
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_RAMBOOT_TEXT_BASE	CONFIG_SYS_TEXT_BASE
+#define CONFIG_RESET_VECTOR_ADDRESS	0xfffffffc
+#define CONFIG_PBLPBI_CONFIG $(SRCTREE)/board/freescale/t4qds/t4_pbi.cfg
+#define CONFIG_PBLRCW_CONFIG $(SRCTREE)/board/freescale/t4qds/t4_rcw.cfg
+#endif
+
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+/* Set 1M boot space */
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR (CONFIG_SYS_TEXT_BASE & 0xfff00000)
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR)
+#define CONFIG_RESET_VECTOR_ADDRESS 0xfffffffc
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+#define CONFIG_DDR_ECC
+
 #include "t4qds.h"
+
+#ifdef CONFIG_SYS_NO_FLASH
+#if !defined(CONFIG_SRIO_PCIE_BOOT_SLAVE) && !defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_ENV_IS_NOWHERE
+#endif
+#else
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+#if defined(CONFIG_SPIFLASH)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SPI_BUS              0
+#define CONFIG_ENV_SPI_CS               0
+#define CONFIG_ENV_SPI_MAX_HZ           10000000
+#define CONFIG_ENV_SPI_MODE             0
+#define CONFIG_ENV_SIZE                 0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET               0x100000        /* 1MB */
+#define CONFIG_ENV_SECT_SIZE            0x10000
+#elif defined(CONFIG_SDCARD)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV          0
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(512 * 1105)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE			CONFIG_SYS_NAND_BLOCK_SIZE
+#define CONFIG_ENV_OFFSET		(5 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+#define CONFIG_ENV_IS_IN_REMOTE
+#define CONFIG_ENV_ADDR		0xffe20000
+#define CONFIG_ENV_SIZE		0x2000
+#elif defined(CONFIG_ENV_IS_NOWHERE)
+#define CONFIG_ENV_SIZE		0x2000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk()
+#define CONFIG_DDR_CLK_FREQ	get_board_ddr_clk()
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_SYS_SPD_BUS_NUM	0
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS2	0x52
+#define SPD_EEPROM_ADDRESS3	0x53
+#define SPD_EEPROM_ADDRESS4	0x54
+#define SPD_EEPROM_ADDRESS5	0x55
+#define SPD_EEPROM_ADDRESS6	0x56
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1	/* for p3041/p5010 */
+#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
+				+ 0x8000000) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR1_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR1_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR	CSOR_NAND_TRHZ_80
+
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1A) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS \
+					+ 0x8000000, CONFIG_SYS_FLASH_BASE_PHYS}
+
+#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
+#define QIXIS_BASE			0xffdf0000
+#define QIXIS_LBMAP_SWITCH		6
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+#define QIXIS_RST_CTL_RESET		0x83
+#define QIXIS_RST_FORCE_MEM		0x1
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+#define QIXIS_BASE_PHYS		(0xf00000000ull | QIXIS_BASE)
+
+#define CONFIG_SYS_CSPR3_EXT	(0xf)
+#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+#define CONFIG_SYS_AMASK3	IFC_AMASK(4*1024)
+#define CONFIG_SYS_CSOR3	0x0
+/* QIXIS Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
+					FTIM1_GPCM_TRAD(0x3f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+					FTIM2_GPCM_TCH(0x0) | \
+					FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+
+/* NAND Flash on IFC */
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#define CONFIG_SYS_NAND_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_NAND_BASE)
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 2Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x07) | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0x0e)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
+					FTIM2_NAND_TREH(0x0a) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+#if defined(CONFIG_NAND)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+
+/* I2C */
+#define CONFIG_SYS_I2C_SPEED		100000	/* I2C speed */
+#define I2C_MUX_PCA_ADDR_PRI		0x77 /* I2C bus multiplexer,primary */
+#define I2C_MUX_PCA_ADDR_SEC		0x76 /* I2C bus multiplexer,secondary */
+
+#define I2C_MUX_CH_DEFAULT	0x8
+#define I2C_MUX_CH_VOL_MONITOR	0xa
+#define I2C_MUX_CH_VSC3316_FS	0xc
+#define I2C_MUX_CH_VSC3316_BS	0xd
+
+/* Voltage monitor on channel 2*/
+#define I2C_VOL_MONITOR_ADDR		0x40
+#define I2C_VOL_MONITOR_BUS_V_OFFSET	0x2
+#define I2C_VOL_MONITOR_BUS_V_OVF	0x1
+#define I2C_VOL_MONITOR_BUS_V_SHIFT	3
+
+/* VSC Crossbar switches */
+#define CONFIG_VSC_CROSSBAR
+#define VSC3316_FSM_TX_ADDR	0x70
+#define VSC3316_FSM_RX_ADDR	0x71
+
+/*
+ * RapidIO
+ */
+
+/*
+ * for slave u-boot IMAGE instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef080000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff80000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE 0x80000	/* 512K */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff80000ull
+/*
+ * for slave UCODE and ENV instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef040000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS 0x3ffe00000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE 0x40000	/* 256K */
+
+/* slave core release by master*/
+#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET 0xe00e4
+#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK 0x00000001 /* release core 0 */
+
+/*
+ * SRIO_PCIE_BOOT - SLAVE
+ */
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
+#endif
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED         10000000
+#define CONFIG_SF_DEFAULT_MODE          0
+
+
+/* Qman/Bman */
+#ifndef CONFIG_NOBQFMAN
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	50
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_NUM_PORTALS	50
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_SYS_DPAA_PME
+#define CONFIG_SYS_PMAN
+#define CONFIG_SYS_DPAA_DCE
+#define CONFIG_SYS_DPAA_RMAN		/* RMan */
+#define CONFIG_SYS_INTERLAKEN
+
+/* Default address of microcode for the Linux Fman driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0x110000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 545KB (1089 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 1089 + 16 = 1113, enlarge it to 1130.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(512 * 1130)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	(6 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+/*
+ * Slave has no ucode locally, it can fetch this from remote. When implementing
+ * in two corenet boards, slave's ucode could be stored in master's memory
+ * space, the address can be mapped from slave TLB->slave LAW->
+ * slave SRIO or PCIE outbound window->master inbound window->
+ * master LAW->the ucode address in master's memory space.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0xFFE00000
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_QE_FMAN_FW_ADDR		0xEFF40000
+#endif
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+#endif /* CONFIG_NOBQFMAN */
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHYLIB_10G
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_TERANETICS
+#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
+#define SGMII_CARD_PORT2_PHY_ADDR 0x1D
+#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
+#define SGMII_CARD_PORT4_PHY_ADDR 0x1F
+#define FM1_10GEC1_PHY_ADDR	0x0
+#define FM1_10GEC2_PHY_ADDR	0x1
+#define FM2_10GEC1_PHY_ADDR	0x2
+#define FM2_10GEC2_PHY_ADDR	0x3
+#endif
+
+
+/* SATA */
+#ifdef CONFIG_FSL_SATA_V2
+#define CONFIG_LIBATA
+#define CONFIG_FSL_SATA
+
+#define CONFIG_SYS_SATA_MAX_DEVICE	2
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+#define CONFIG_SATA2
+#define CONFIG_SYS_SATA2		CONFIG_SYS_MPC85xx_SATA2_ADDR
+#define CONFIG_SYS_SATA2_FLAGS		FLAGS_DMA
+
+#define CONFIG_LBA48
+#define CONFIG_CMD_SATA
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_EXT2
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC1"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+/*
+* USB
+*/
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_CMD_EXT2
+#define CONFIG_HAS_FSL_DR_USB
+
+#define CONFIG_MMC
+
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR       CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_SYS_FSL_ESDHC_BROKEN_TIMEOUT
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+
+#define __USB_PHY_TYPE	utmi
+
+/*
+ * T4240 has 3 DDR controllers. Default to 3-way interleaving. It can be
+ * 3way_1KB, 3way_4KB, 3way_8KB. T4160 has 2 DDR controllers. Default to 2-way
+ * interleaving. It can be cacheline, page, bank, superbank.
+ * See doc/README.fsl-ddr for details.
+ */
+#ifdef CONFIG_PPC_T4240
+#define CTRL_INTLV_PREFERED 3way_4KB
+#else
+#define CTRL_INTLV_PREFERED cacheline
+#endif
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:"					\
+	"ctlr_intlv=" __stringify(CTRL_INTLV_PREFERED) ","	\
+	"bank_intlv=auto;"					\
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"			\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"		\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"ramdiskfile=t4240qds/ramdisk.uboot\0"			\
+	"fdtaddr=c00000\0"					\
+	"fdtfile=t4240qds/t4240qds.dtb\0"				\
+	"bdev=sda3\0"						\
+	"c=ffe\0"
+
+#define CONFIG_HVBOOT				\
+	"setenv bootargs config-addr=0x60000000; "	\
+	"bootm 0x01000000 - 0x00f00000"
+
+#define CONFIG_ALU				\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"cpu 1 release 0x01000000 - - -;"		\
+	"cpu 2 release 0x01000000 - - -;"		\
+	"cpu 3 release 0x01000000 - - -;"		\
+	"cpu 4 release 0x01000000 - - -;"		\
+	"cpu 5 release 0x01000000 - - -;"		\
+	"cpu 6 release 0x01000000 - - -;"		\
+	"cpu 7 release 0x01000000 - - -;"		\
+	"go 0x01000000"
+
+#define CONFIG_LINUX				\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"setenv ramdiskaddr 0x02000000;"		\
+	"setenv fdtaddr 0x00c00000;"			\
+	"setenv loadaddr 0x1000000;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_HDBOOT					\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_NFSBOOTCOMMAND			\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND				\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $ramdiskaddr $ramdiskfile;"		\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND		CONFIG_LINUX
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+/* Secure Boot target was not getting build for T4240 because of
+ * increased binary size. So the size is being reduced by removing USB
+ * which is anyways not used in Secure Environment.
+ */
+#undef CONFIG_CMD_USB
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/corenet_ds.h b/include/configs/corenet_ds.h
index 3f42cd9..26d1689 100644
--- a/include/configs/corenet_ds.h
+++ b/include/configs/corenet_ds.h
@@ -38,6 +38,8 @@
 #define CONFIG_PBLRCW_CONFIG $(SRCTREE)/board/freescale/corenet_ds/rcw_p4080ds.cfg
 #elif defined(CONFIG_P5020DS)
 #define CONFIG_PBLRCW_CONFIG $(SRCTREE)/board/freescale/corenet_ds/rcw_p5020ds.cfg
+#elif defined(CONFIG_P5040DS)
+#define CONFIG_PBLRCW_CONFIG $(SRCTREE)/board/freescale/corenet_ds/rcw_p5040ds.cfg
 #endif
 #endif
 
@@ -56,7 +58,6 @@
 #define CONFIG_E500MC			/* BOOKE e500mc family */
 #define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
 #define CONFIG_MPC85xx			/* MPC85xx/PQ3 platform */
-#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_MP			/* support multiple processors */
 
 #ifndef CONFIG_SYS_TEXT_BASE
@@ -106,7 +107,7 @@
 #define CONFIG_FSL_FIXED_MMC_LOCATION
 #define CONFIG_SYS_MMC_ENV_DEV          0
 #define CONFIG_ENV_SIZE			0x2000
-#define CONFIG_ENV_OFFSET		(512 * 1097)
+#define CONFIG_ENV_OFFSET		(512 * 1105)
 #elif defined(CONFIG_NAND)
 #define CONFIG_SYS_EXTRA_ENV_RELOC
 #define CONFIG_ENV_IS_IN_NAND
@@ -517,7 +518,6 @@
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
 
 #define CONFIG_SYS_DPAA_FMAN
-#define CONFIG_SYS_DPAA_PME
 /* Default address of microcode for the Linux Fman driver */
 #if defined(CONFIG_SPIFLASH)
 /*
@@ -714,6 +714,7 @@
 #define	CONFIG_EXTRA_ENV_SETTINGS				\
 	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
 	"bank_intlv=cs0_cs1;"					\
+	"usb2:dr_mode=peripheral,phy_type=" __stringify(__USB_PHY_TYPE) ";"\
 	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
 	"netdev=eth0\0"						\
 	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
diff --git a/include/configs/onie_common_config.h b/include/configs/onie_common_config.h
index c941e2a..094d3f8 100644
--- a/include/configs/onie_common_config.h
+++ b/include/configs/onie_common_config.h
@@ -45,7 +45,7 @@
 	"onie_bootcmd=echo Loading Open Network Install Environment ...; " \
 	  "echo Platform: $onie_platform ; "				\
 	  "echo Version : $onie_version ; "				\
-	  "cp.b $onie_start $loadaddr ${onie_sz.b} && "			\
+	  "sf probe; sf read ${loadaddr} $onie_start ${onie_sz.b} && "     \
 	  "run onie_args && bootm ${loadaddr}\0"
 
 /*
diff --git a/include/configs/p1_p2_rdb_pc.h b/include/configs/p1_p2_rdb_pc.h
index 964bfcd..834257e 100644
--- a/include/configs/p1_p2_rdb_pc.h
+++ b/include/configs/p1_p2_rdb_pc.h
@@ -66,6 +66,35 @@
 #define CONFIG_SYS_L2_SIZE	(256 << 10)
 #endif
 
+/*
+ * P1020RDB-PD board has user selectable switches for evaluating different
+ * frequency and boot options for the P1020 device. The table that
+ * follow describe the available options. The front six binary number was in
+ * accordance with SW3[1:6].
+ * 111101 533 533 267 667 NOR Core0 boot; Core1 hold-off
+ * 101101 667 667 333 667 NOR Core0 boot; Core1 hold-off
+ * 011001 800 800 400 667 NOR Core0 boot; Core1 hold-off
+ * 001001 800 800 400 667 SD/MMC Core0 boot; Core1 hold-off
+ * 001101 800 800 400 667 SPI Core0 boot; Core1 hold-off
+ * 010001 800 800 400 667 NAND Core0 boot; Core1 hold-off
+ * 011101 800 800 400 667 PCIe-2 Core0 boot; Core1 hold-off
+ */
+#if defined(CONFIG_P1020RDB_PD)
+#define CONFIG_BOARDNAME "P1020RDB-PD"
+#define CONFIG_NAND_FSL_ELBC
+#define CONFIG_P1020
+#define CONFIG_SPI_FLASH
+#define CONFIG_VSC7385_ENET
+#define CONFIG_SLIC
+#define __SW_BOOT_MASK		0x03
+#define __SW_BOOT_NOR		0x64
+#define __SW_BOOT_SPI		0x34
+#define __SW_BOOT_SD		0x24
+#define __SW_BOOT_NAND		0x44
+#define __SW_BOOT_PCIE		0x74
+#define CONFIG_SYS_L2_SIZE	(256 << 10)
+#endif
+
 #if defined(CONFIG_P1021RDB)
 #define CONFIG_BOARDNAME "P1021RDB-PC"
 #define CONFIG_NAND_FSL_ELBC
@@ -154,6 +183,10 @@
 #define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
 #endif
 
+#if (defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L2_ADDR))
+#undef CONFIG_SYS_INIT_L2_ADDR
+#endif
+
 #ifdef CONFIG_NAND
 #define CONFIG_SPL
 #define CONFIG_SPL_INIT_MINIMAL
@@ -274,7 +307,7 @@
 #define SPD_EEPROM_ADDRESS 0x52
 #undef CONFIG_FSL_DDR_INTERACTIVE
 
-#ifdef CONFIG_P1020MBG
+#if (defined(CONFIG_P1020MBG) || defined(CONFIG_P1020RDB_PD))
 #define CONFIG_SYS_SDRAM_SIZE_LAW	LAW_SIZE_2G
 #define CONFIG_CHIP_SELECTS_PER_CTRL	2
 #else
@@ -345,7 +378,7 @@
 /*
  * Local Bus Definitions
  */
-#if defined(CONFIG_P1020MBG)
+#if (defined(CONFIG_P1020MBG) || defined(CONFIG_P1020RDB_PD))
 #define CONFIG_SYS_MAX_FLASH_SECT	512	/* 64M */
 #define CONFIG_SYS_FLASH_BASE		0xec000000
 #elif defined(CONFIG_P1020UTM)
@@ -396,13 +429,27 @@
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
 #define CONFIG_MTD_NAND_VERIFY_WRITE
 #define CONFIG_CMD_NAND
+#if defined(CONFIG_P1020RDB_PD)
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+#else
 #define CONFIG_SYS_NAND_BLOCK_SIZE	(16 * 1024)
+#endif
 
 #define CONFIG_SYS_NAND_BR_PRELIM (BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
 	| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
 	| BR_PS_8	/* Port Size = 8 bit */ \
 	| BR_MS_FCM	/* MSEL = FCM */ \
 	| BR_V)	/* valid */
+#if defined(CONFIG_P1020RDB_PD)
+#define CONFIG_SYS_NAND_OR_PRELIM	(OR_AM_32KB \
+	| OR_FCM_PGS	/* Large Page*/ \
+	| OR_FCM_CSCT \
+	| OR_FCM_CST \
+	| OR_FCM_CHT \
+	| OR_FCM_SCY_1 \
+	| OR_FCM_TRLX \
+	| OR_FCM_EHTR)
+#else
 #define CONFIG_SYS_NAND_OR_PRELIM	(OR_AM_32KB	/* small page */ \
 	| OR_FCM_CSCT \
 	| OR_FCM_CST \
@@ -410,6 +457,7 @@
 	| OR_FCM_SCY_1 \
 	| OR_FCM_TRLX \
 	| OR_FCM_EHTR)
+#endif
 #endif /* CONFIG_NAND_FSL_ELBC */
 
 #define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
@@ -712,9 +760,22 @@
 #define CONFIG_ENV_SPI_CS	0
 #define CONFIG_ENV_SPI_MAX_HZ	10000000
 #define CONFIG_ENV_SPI_MODE	0
-#define CONFIG_ENV_SIZE		0x2000	/* 8KB */
 #define CONFIG_ENV_OFFSET	0x100000	/* 1MB */
 #define CONFIG_ENV_SECT_SIZE	0x10000
+/* This is a workaround for issues on the P2020RDB.
+ * Issue discription:
+ * In P2020RDB, after saved environment parameters in SPI flash,
+ * setting HRESET_REQ in reset process will hang the system.
+ *
+ * Change the ENV buffer size to SPI Flash block size, and it can avoid
+ * the extra read/write to the ENV block in SPI Flash, finally, it can
+ * avoid the hang issue.
+ */
+#if defined(CONFIG_P2020RDB)
+#define CONFIG_ENV_SIZE		CONFIG_ENV_SECT_SIZE
+#else
+#define CONFIG_ENV_SIZE		0x2000	/* 8KB */
+#endif
 #elif defined(CONFIG_RAMBOOT_SDCARD)
 #define CONFIG_ENV_IS_IN_MMC
 #define CONFIG_FSL_FIXED_MMC_LOCATION
diff --git a/include/configs/p1_twr.h b/include/configs/p1_twr.h
new file mode 100644
index 0000000..6c0371f
--- /dev/null
+++ b/include/configs/p1_twr.h
@@ -0,0 +1,636 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * QorIQ P1 Tower boards configuration file
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#if defined(CONFIG_TWR_P1025)
+#define CONFIG_BOARDNAME "TWR-P1025"
+#define CONFIG_P1025
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_QE
+#define CONFIG_SYS_LBC_LBCR	0x00080000	/* Conversion of LBC addr */
+#define CONFIG_SYS_LBC_LCRR	0x80000002	/* LB clock ratio reg */
+#endif
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RAMBOOT_SDCARD
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE		0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE
+#define CONFIG_E500
+#define CONFIG_MPC85xx
+
+#define CONFIG_MP
+
+#define CONFIG_FSL_ELBC
+#define CONFIG_PCI
+#define CONFIG_PCIE1	/* PCIE controler 1 (slot 1) */
+#define CONFIG_PCIE2	/* PCIE controler 2 (slot 2) */
+#define CONFIG_FSL_PCI_INIT	/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET	/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
+
+#define CONFIG_FSL_LAW
+#define CONFIG_TSEC_ENET	/* tsec ethernet support */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_CMD_SATA
+#define CONFIG_SATA_SIL3114
+#define CONFIG_SYS_SATA_MAX_DEVICE	2
+#define CONFIG_LIBATA
+#define CONFIG_LBA48
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_board_sys_clk(unsigned long dummy);
+#endif
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk(0) /*sysclk for TWR-P1025 */
+
+#define CONFIG_DDR_CLK_FREQ	66666666
+
+#define CONFIG_HWCONFIG
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE
+#define CONFIG_BTB
+
+#define CONFIG_BOARD_EARLY_INIT_F	/* Call board_pre_init */
+
+#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x1fffffff
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+#define CONFIG_SYS_CCSRBAR		0xffe00000
+#define CONFIG_SYS_CCSRBAR_PHYS_LOW	CONFIG_SYS_CCSRBAR
+
+/* DDR Setup */
+#define CONFIG_FSL_DDR3
+
+#define CONFIG_SYS_SDRAM_SIZE_LAW	LAW_SIZE_512M
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+
+#define CONFIG_SYS_SDRAM_SIZE		(1u << (CONFIG_SYS_SDRAM_SIZE_LAW - 19))
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+
+/* Default settings for DDR3 */
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000001f
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80014202
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_CS1_BNDS		0x00000000
+#define CONFIG_SYS_DDR_CS1_CONFIG	0x00000000
+#define CONFIG_SYS_DDR_CS1_CONFIG_2	0x00000000
+
+#define CONFIG_SYS_DDR_DATA_INIT	0xdeadbeef
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8655a608
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0xc70c0000	/* Type = DDR3	*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x04401050
+#define CONFIG_SYS_DDR_TIMING_4		0x00220001
+#define CONFIG_SYS_DDR_TIMING_5		0x03402400
+
+#define CONFIG_SYS_DDR_TIMING_3		0x00020000
+#define CONFIG_SYS_DDR_TIMING_0		0x00220004
+#define CONFIG_SYS_DDR_TIMING_1		0x5c5b6544
+#define CONFIG_SYS_DDR_TIMING_2		0x0fa880de
+#define CONFIG_SYS_DDR_CLK_CTRL		0x03000000
+#define CONFIG_SYS_DDR_MODE_1		0x80461320
+#define CONFIG_SYS_DDR_MODE_2		0x00008000
+#define CONFIG_SYS_DDR_INTERVAL		0x09480000
+
+/*
+ * Memory map
+ *
+ * 0x0000_0000 0x1fff_ffff	DDR		Up to 512MB cacheable
+ * 0x8000_0000 0xdfff_ffff	PCI Express Mem	1.5G non-cacheable(PCIe * 3)
+ * 0xffc0_0000 0xffc3_ffff	PCI IO range	256k non-cacheable
+ *
+ * Localbus
+ * 0xe000_0000 0xe002_0000	SSD1289		128K non-cacheable
+ * 0xec00_0000 0xefff_ffff	FLASH		Up to 64M non-cacheable
+ *
+ * 0xff90_0000 0xff97_ffff	L2 SRAM		Up to 512K cacheable
+ * 0xffd0_0000 0xffd0_3fff	init ram	16K Cacheable
+ * 0xffe0_0000 0xffef_ffff	CCSR		1M non-cacheable
+ */
+
+/*
+ * Local Bus Definitions
+ */
+#define CONFIG_SYS_MAX_FLASH_SECT	512	/* 64M */
+#define CONFIG_SYS_FLASH_BASE		0xec000000
+
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_FLASH_BR_PRELIM (BR_PHYS_ADDR((CONFIG_SYS_FLASH_BASE_PHYS)) \
+	| BR_PS_16 | BR_V)
+
+#define CONFIG_FLASH_OR_PRELIM	0xfc0000b1
+
+#define CONFIG_SYS_SSD_BASE	0xe0000000
+#define CONFIG_SYS_SSD_BASE_PHYS	CONFIG_SYS_SSD_BASE
+#define CONFIG_SSD_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_SSD_BASE_PHYS) | \
+					BR_PS_16 | BR_V)
+#define CONFIG_SSD_OR_PRELIM	(OR_AM_64KB | OR_GPCM_CSNT | OR_GPCM_XACS | \
+				 OR_GPCM_ACS_DIV2 | OR_GPCM_SCY | \
+				 OR_GPCM_TRLX | OR_GPCM_EHTR | OR_GPCM_EAD)
+
+#define CONFIG_SYS_BR2_PRELIM CONFIG_SSD_BR_PRELIM
+#define CONFIG_SYS_OR2_PRELIM CONFIG_SSD_OR_PRELIM
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS}
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45	/* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+
+#undef CONFIG_SYS_FLASH_CHECKSUM
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000
+/* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	CONFIG_SYS_INIT_RAM_ADDR
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+/* Size of used area in RAM */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+					GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN	(512 * 1024)/* Reserve 512 kB for Mon */
+#define CONFIG_SYS_MALLOC_LEN	(1024 * 1024)/* Reserved for malloc */
+
+#define CONFIG_SYS_BR0_PRELIM	CONFIG_FLASH_BR_PRELIM	/* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM	CONFIG_FLASH_OR_PRELIM	/* NOR Options */
+
+/* Serial Port
+ * open - index 2
+ * shorted - index 1
+ */
+#define CONFIG_CONS_INDEX		1
+#undef CONFIG_SERIAL_SOFTWARE_FIFO
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+#define CONFIG_SYS_64BIT_VSPRINTF
+#define CONFIG_SYS_64BIT_STRTOUL
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_FSL_I2C			/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C			/* I2C with hardware support */
+#undef CONFIG_SOFT_I2C			/* I2C bit-banged */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000	/* I2C spd and slave address */
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x52
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/*
+ * I2C2 EEPROM
+ */
+#undef CONFIG_ID_EEPROM
+
+#define CONFIG_SYS_I2C_PCA9555_ADDR	0x23
+
+/* enable read and write access to EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_HARD_SPI
+#define CONFIG_FSL_ESPI
+
+#if defined(CONFIG_PCI)
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/* controller 2, direct to uli, tgtid 2, Base address 9000 */
+#define CONFIG_SYS_PCIE2_NAME		"TWR-ELEV PCIe SLOT"
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 1, tgtid 1, Base address a000 */
+#define CONFIG_SYS_PCIE1_NAME		"mini PCIe SLOT"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP	/* do pci plug-and-play */
+#define CONFIG_E1000	/* Defind e1000 pci Ethernet card*/
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+
+#define CONFIG_PCI_SCAN_SHOW	/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif /* CONFIG_PCI */
+
+#if defined(CONFIG_TSEC_ENET)
+
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI
+#endif
+
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_TSEC1
+#define CONFIG_TSEC1_NAME	"eTSEC1"
+#undef CONFIG_TSEC2
+#undef CONFIG_TSEC2_NAME
+#define CONFIG_TSEC3
+#define CONFIG_TSEC3_NAME	"eTSEC3"
+
+#define TSEC1_PHY_ADDR	2
+#define TSEC2_PHY_ADDR	0
+#define TSEC3_PHY_ADDR	1
+
+#define TSEC1_FLAGS	(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC2_FLAGS	(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC3_FLAGS	(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define TSEC1_PHYIDX	0
+#define TSEC2_PHYIDX	0
+#define TSEC3_PHYIDX	0
+
+#define CONFIG_ETHPRIME	"eTSEC1"
+
+#define CONFIG_PHY_GIGE	1	/* Include GbE speed/duplex detection */
+
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#undef CONFIG_HAS_ETH2
+#endif /* CONFIG_TSEC_ENET */
+
+#ifdef CONFIG_QE
+/* QE microcode/firmware address */
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_QE_FMAN_FW_ADDR	0xefec0000
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#endif /* CONFIG_QE */
+
+#ifdef CONFIG_TWR_P1025
+/*
+ * QE UEC ethernet configuration
+ */
+#define CONFIG_MIIM_ADDRESS	(CONFIG_SYS_CCSRBAR + 0x82120)
+
+#undef CONFIG_UEC_ETH
+#define CONFIG_PHY_MODE_NEED_CHANGE
+
+#define CONFIG_UEC_ETH1	/* ETH1 */
+#define CONFIG_HAS_ETH0
+
+#ifdef CONFIG_UEC_ETH1
+#define CONFIG_SYS_UEC1_UCC_NUM	0	/* UCC1 */
+#define CONFIG_SYS_UEC1_RX_CLK	QE_CLK12 /* CLK12 for MII */
+#define CONFIG_SYS_UEC1_TX_CLK	QE_CLK9 /* CLK9 for MII */
+#define CONFIG_SYS_UEC1_ETH_TYPE	FAST_ETH
+#define CONFIG_SYS_UEC1_PHY_ADDR	0x18	/* 0x18 for MII */
+#define CONFIG_SYS_UEC1_INTERFACE_TYPE PHY_INTERFACE_MODE_MII
+#define CONFIG_SYS_UEC1_INTERFACE_SPEED	100
+#endif /* CONFIG_UEC_ETH1 */
+
+#define CONFIG_UEC_ETH5	/* ETH5 */
+#define CONFIG_HAS_ETH1
+
+#ifdef CONFIG_UEC_ETH5
+#define CONFIG_SYS_UEC5_UCC_NUM	4	/* UCC5 */
+#define CONFIG_SYS_UEC5_RX_CLK	QE_CLK_NONE
+#define CONFIG_SYS_UEC5_TX_CLK	QE_CLK13 /* CLK 13 for RMII */
+#define CONFIG_SYS_UEC5_ETH_TYPE	FAST_ETH
+#define CONFIG_SYS_UEC5_PHY_ADDR	0x19	/* 0x19 for RMII */
+#define CONFIG_SYS_UEC5_INTERFACE_TYPE PHY_INTERFACE_MODE_RMII
+#define CONFIG_SYS_UEC5_INTERFACE_SPEED	100
+#endif /* CONFIG_UEC_ETH5 */
+#endif /* CONFIG_TWR-P1025 */
+
+/*
+ * Environment
+ */
+#ifdef CONFIG_SYS_RAMBOOT
+#ifdef CONFIG_RAMBOOT_SDCARD
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_SYS_MMC_ENV_DEV	0
+#else
+#define CONFIG_ENV_IS_NOWHERE	/* Store ENV in memory only */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - 0x1000)
+#define CONFIG_ENV_SIZE		0x2000
+#endif
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#if CONFIG_SYS_MONITOR_BASE > 0xfff80000
+#define CONFIG_ENV_ADDR	0xfff80000
+#else
+#define CONFIG_ENV_ADDR	(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#endif
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_LOADS_ECHO		/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+/*
+ * USB
+ */
+#define CONFIG_HAS_FSL_DR_USB
+
+#if defined(CONFIG_HAS_FSL_DR_USB)
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_USB_STORAGE
+#endif
+#endif
+
+#define CONFIG_MMC
+
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#endif
+
+#if defined(CONFIG_MMC) || defined(CONFIG_USB_EHCI) \
+		 || defined(CONFIG_FSL_SATA)
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+#undef CONFIG_WATCHDOG	/* watchdog disabled */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory */
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+	/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000	/* decrementer freq: 1ms tick */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial Memory for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_HOSTNAME		unknown
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	u-boot.bin /* U-Boot image on TFTP server */
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR	1000000
+
+#define CONFIG_BOOTDELAY 10	/* -1 disables auto-boot */
+#define CONFIG_BOOTARGS	/* the boot command will set bootargs */
+
+#define CONFIG_BAUDRATE	115200
+
+#define	CONFIG_EXTRA_ENV_SETTINGS	\
+"netdev=eth0\0"	\
+"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"	\
+"loadaddr=1000000\0"	\
+"bootfile=uImage\0"	\
+"dtbfile=twr-p1025twr.dtb\0"	\
+"ramdiskfile=rootfs.ext2.gz.uboot\0"	\
+"qefirmwarefile=fsl_qe_ucode_1021_10_A.bin\0"	\
+"tftpflash=tftpboot $loadaddr $uboot; "	\
+	"protect off " __stringify(CONFIG_SYS_TEXT_BASE) " +$filesize; " \
+	"erase " __stringify(CONFIG_SYS_TEXT_BASE) " +$filesize; "	\
+	"cp.b $loadaddr " __stringify(CONFIG_SYS_TEXT_BASE) " $filesize; " \
+	"protect on " __stringify(CONFIG_SYS_TEXT_BASE) " +$filesize; "	\
+	"cmp.b $loadaddr " __stringify(CONFIG_SYS_TEXT_BASE) " $filesize\0" \
+"kernelflash=tftpboot $loadaddr $bootfile; "	\
+	"protect off 0xefa80000 +$filesize; "	\
+	"erase 0xefa80000 +$filesize; "	\
+	"cp.b $loadaddr 0xefa80000 $filesize; "	\
+	"protect on 0xefa80000 +$filesize; "	\
+	"cmp.b $loadaddr 0xefa80000 $filesize\0"	\
+"dtbflash=tftpboot $loadaddr $dtbfile; "	\
+	"protect off 0xefe80000 +$filesize; "	\
+	"erase 0xefe80000 +$filesize; "	\
+	"cp.b $loadaddr 0xefe80000 $filesize; "	\
+	"protect on 0xefe80000 +$filesize; "	\
+	"cmp.b $loadaddr 0xefe80000 $filesize\0"	\
+"ramdiskflash=tftpboot $loadaddr $ramdiskfile; "	\
+	"protect off 0xeeb80000 +$filesize; "	\
+	"erase 0xeeb80000 +$filesize; "	\
+	"cp.b $loadaddr 0xeeb80000 $filesize; "	\
+	"protect on 0xeeb80000 +$filesize; "	\
+	"cmp.b $loadaddr 0xeeb80000 $filesize\0"	\
+"qefirmwareflash=tftpboot $loadaddr $qefirmwarefile; "	\
+	"protect off 0xefec0000 +$filesize; "	\
+	"erase 0xefec0000 +$filesize; "	\
+	"cp.b $loadaddr 0xefec0000 $filesize; "	\
+	"protect on 0xefec0000 +$filesize; "	\
+	"cmp.b $loadaddr 0xefec0000 $filesize\0"	\
+"consoledev=ttyS0\0"	\
+"ramdiskaddr=2000000\0"	\
+"ramdiskfile=rootfs.ext2.gz.uboot\0"	\
+"fdtaddr=c00000\0"	\
+"bdev=sda1\0"	\
+"norbootaddr=ef080000\0"	\
+"norfdtaddr=ef040000\0"	\
+"ramdisk_size=120000\0" \
+"usbboot=setenv bootargs root=/dev/sda1 rw rootdelay=5 " \
+"console=$consoledev,$baudrate $othbootargs ; bootm 0xefa80000 - 0xefe80000"
+
+#define CONFIG_NFSBOOTCOMMAND	\
+"setenv bootargs root=/dev/nfs rw "	\
+"nfsroot=$serverip:$rootpath "	\
+"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+"console=$consoledev,$baudrate $othbootargs;" \
+"tftp $loadaddr $bootfile&&"	\
+"tftp $fdtaddr $fdtfile&&"	\
+"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_HDBOOT	\
+"setenv bootargs root=/dev/$bdev rw rootdelay=30 "	\
+"console=$consoledev,$baudrate $othbootargs;" \
+"usb start;"	\
+"ext2load usb 0:1 $loadaddr /boot/$bootfile;"	\
+"ext2load usb 0:1 $fdtaddr /boot/$fdtfile;"	\
+"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_USB_FAT_BOOT	\
+"setenv bootargs root=/dev/ram rw "	\
+"console=$consoledev,$baudrate $othbootargs " \
+"ramdisk_size=$ramdisk_size;"	\
+"usb start;"	\
+"fatload usb 0:2 $loadaddr $bootfile;"	\
+"fatload usb 0:2 $fdtaddr $fdtfile;"	\
+"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_USB_EXT2_BOOT	\
+"setenv bootargs root=/dev/ram rw "	\
+"console=$consoledev,$baudrate $othbootargs " \
+"ramdisk_size=$ramdisk_size;"	\
+"usb start;"	\
+"ext2load usb 0:4 $loadaddr $bootfile;"	\
+"ext2load usb 0:4 $fdtaddr $fdtfile;" \
+"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;" \
+"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_NORBOOT	\
+"setenv bootargs root=/dev/mtdblock3 rw "	\
+"console=$consoledev,$baudrate rootfstype=jffs2 $othbootargs;"	\
+"bootm $norbootaddr - $norfdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND_TFTP	\
+"setenv bootargs root=/dev/ram rw "	\
+"console=$consoledev,$baudrate $othbootargs " \
+"ramdisk_size=$ramdisk_size;"	\
+"tftp $ramdiskaddr $ramdiskfile;"	\
+"tftp $loadaddr $bootfile;"	\
+"tftp $fdtaddr $fdtfile;"	\
+"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND	\
+"setenv bootargs root=/dev/ram rw "	\
+"console=$consoledev,$baudrate $othbootargs " \
+"ramdisk_size=$ramdisk_size;"	\
+"bootm 0xefa80000 0xeeb80000 0xefe80000"
+
+#define CONFIG_BOOTCOMMAND	CONFIG_RAMBOOTCOMMAND
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/t4qds.h b/include/configs/t4qds.h
index d58c24c..44f9ab9 100644
--- a/include/configs/t4qds.h
+++ b/include/configs/t4qds.h
@@ -23,24 +23,18 @@
 /*
  * Corenet DS style board configuration file
  */
-#ifndef __CONFIG_H
-#define __CONFIG_H
+#ifndef __T4QDS_H
+#define __T4QDS_H
 
-#ifdef CONFIG_RAMBOOT_PBL
-#define CONFIG_RAMBOOT_TEXT_BASE	CONFIG_SYS_TEXT_BASE
-#define CONFIG_RESET_VECTOR_ADDRESS	0xfffffffc
-#endif
 
 #define CONFIG_CMD_REGINFO
 
 /* High Level Configuration Options */
 #define CONFIG_BOOKE
-#define CONFIG_E6500
 #define CONFIG_E500			/* BOOKE e500 family */
 #define CONFIG_E500MC			/* BOOKE e500mc family */
 #define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
 #define CONFIG_MPC85xx			/* MPC85xx/PQ3 platform */
-#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_MP			/* support multiple processors */
 
 #ifndef CONFIG_SYS_TEXT_BASE
@@ -69,63 +63,12 @@
 
 #define CONFIG_ENV_OVERWRITE
 
-#ifdef CONFIG_SYS_NO_FLASH
-#define CONFIG_ENV_IS_NOWHERE
-#else
-#define CONFIG_FLASH_CFI_DRIVER
-#define CONFIG_SYS_FLASH_CFI
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
-#endif
-
-#ifndef CONFIG_SYS_NO_FLASH
-#if defined(CONFIG_SPIFLASH)
-#define CONFIG_SYS_EXTRA_ENV_RELOC
-#define CONFIG_ENV_IS_IN_SPI_FLASH
-#define CONFIG_ENV_SPI_BUS              0
-#define CONFIG_ENV_SPI_CS               0
-#define CONFIG_ENV_SPI_MAX_HZ           10000000
-#define CONFIG_ENV_SPI_MODE             0
-#define CONFIG_ENV_SIZE                 0x2000          /* 8KB */
-#define CONFIG_ENV_OFFSET               0x100000        /* 1MB */
-#define CONFIG_ENV_SECT_SIZE            0x10000
-#elif defined(CONFIG_SDCARD)
-#define CONFIG_SYS_EXTRA_ENV_RELOC
-#define CONFIG_ENV_IS_IN_MMC
-#define CONFIG_SYS_MMC_ENV_DEV          0
-#define CONFIG_ENV_SIZE			0x2000
-#define CONFIG_ENV_OFFSET		(512 * 1097)
-#elif defined(CONFIG_NAND)
-#define CONFIG_SYS_EXTRA_ENV_RELOC
-#define CONFIG_ENV_IS_IN_NAND
-#define CONFIG_ENV_SIZE			CONFIG_SYS_NAND_BLOCK_SIZE
-#define CONFIG_ENV_OFFSET		(5 * CONFIG_SYS_NAND_BLOCK_SIZE)
-#else
-#define CONFIG_ENV_IS_IN_FLASH
-#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
-#define CONFIG_ENV_SIZE		0x2000
-#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
-#endif
-#else /* CONFIG_SYS_NO_FLASH */
-#define CONFIG_ENV_SIZE                0x2000
-#define CONFIG_ENV_SECT_SIZE   0x20000 /* 128K (one sector) */
-#endif
-
-
-
-#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk()
-#define CONFIG_DDR_CLK_FREQ	get_board_ddr_clk()
-
-#ifndef __ASSEMBLY__
-unsigned long get_board_sys_clk(void);
-unsigned long get_board_ddr_clk(void);
-#endif
 
 /*
  * These can be toggled for performance analysis, otherwise use default.
  */
 #define CONFIG_SYS_CACHE_STASHING
 #define CONFIG_BTB			/* toggle branch predition */
-#define	CONFIG_DDR_ECC
 #ifdef CONFIG_DDR_ECC
 #define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
 #define CONFIG_MEM_INIT_VALUE		0xdeadbeef
@@ -133,14 +76,9 @@ unsigned long get_board_ddr_clk(void);
 
 #define CONFIG_ENABLE_36BIT_PHYS
 
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_ADDR_MAP
 #define CONFIG_SYS_NUM_ADDR_MAP		64	/* number of TLB1 entries */
-#endif
 
-#if 0
-#define CONFIG_POST CONFIG_SYS_POST_MEMORY	/* test POST memory test */
-#endif
 #define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
 #define CONFIG_SYS_MEMTEST_END		0x00400000
 #define CONFIG_SYS_ALT_MEMTEST
@@ -151,17 +89,8 @@ unsigned long get_board_ddr_clk(void);
  */
 #define CONFIG_SYS_INIT_L3_ADDR		CONFIG_RAMBOOT_TEXT_BASE
 
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_DCSRBAR		0xf0000000
 #define CONFIG_SYS_DCSRBAR_PHYS		0xf00000000ull
-#endif
-
-/* EEPROM */
-#define CONFIG_ID_EEPROM
-#define CONFIG_SYS_I2C_EEPROM_NXID
-#define CONFIG_SYS_EEPROM_BUS_NUM	0
-#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
-#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
 
 /*
  * DDR Setup
@@ -177,200 +106,18 @@ unsigned long get_board_ddr_clk(void);
 
 #define CONFIG_DDR_SPD
 #define CONFIG_FSL_DDR3
+#define CONFIG_FSL_DDR_INTERACTIVE
 
-#define CONFIG_SYS_SPD_BUS_NUM	0
-#define SPD_EEPROM_ADDRESS1	0x51
-#define SPD_EEPROM_ADDRESS2	0x52
-#define SPD_EEPROM_ADDRESS3	0x53
-#define SPD_EEPROM_ADDRESS4	0x54
-#define SPD_EEPROM_ADDRESS5	0x55
-#define SPD_EEPROM_ADDRESS6	0x56
-#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1	/* for p3041/p5010 */
-#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
 
 /*
  * IFC Definitions
  */
 #define CONFIG_SYS_FLASH_BASE	0xe0000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
-#else
-#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
-#endif
-
-#define CONFIG_SYS_NOR0_CSPR_EXT	(0xf)
-#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
-				+ 0x8000000) | \
-				CSPR_PORT_SIZE_16 | \
-				CSPR_MSEL_NOR | \
-				CSPR_V)
-#define CONFIG_SYS_NOR1_CSPR_EXT	(0xf)
-#define CONFIG_SYS_NOR1_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
-				CSPR_PORT_SIZE_16 | \
-				CSPR_MSEL_NOR | \
-				CSPR_V)
-#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
-/* NOR Flash Timing Params */
-#define CONFIG_SYS_NOR_CSOR	CSOR_NAND_TRHZ_80
-
-#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x01) | \
-				FTIM0_NOR_TEADC(0x01) | \
-				FTIM0_NOR_TEAHC(0x20))
-#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
-				FTIM1_NOR_TRAD_NOR(0x1A) |\
-				FTIM1_NOR_TSEQRAD_NOR(0x13))
-#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x01) | \
-				FTIM2_NOR_TCH(0x0E) | \
-				FTIM2_NOR_TWPH(0x0E) | \
-				FTIM2_NOR_TWP(0x1c))
-#define CONFIG_SYS_NOR_FTIM3	0x0
-
-#define CONFIG_SYS_FLASH_QUIET_TEST
-#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
-
-#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
-#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
-#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
-#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
-
-#define CONFIG_SYS_FLASH_EMPTY_INFO
-#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS \
-					+ 0x8000000, CONFIG_SYS_FLASH_BASE_PHYS}
-
-#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
-#define QIXIS_BASE			0xffdf0000
-#define QIXIS_LBMAP_SWITCH		6
-#define QIXIS_LBMAP_MASK		0x0f
-#define QIXIS_LBMAP_SHIFT		0
-#define QIXIS_LBMAP_DFLTBANK		0x00
-#define QIXIS_LBMAP_ALTBANK		0x04
-#define QIXIS_RST_CTL_RESET		0x83
-#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
-#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
-#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
-#ifdef CONFIG_PHYS_64BIT
-#define QIXIS_BASE_PHYS		(0xf00000000ull | QIXIS_BASE)
-#else
-#define QIXIS_BASE_PHYS		QIXIS_BASE
-#endif
 
-#define CONFIG_SYS_CSPR3_EXT	(0xf)
-#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
-				| CSPR_PORT_SIZE_8 \
-				| CSPR_MSEL_GPCM \
-				| CSPR_V)
-#define CONFIG_SYS_AMASK3	IFC_AMASK(64*1024)
-#define CONFIG_SYS_CSOR3	0x0
-/* QIXIS Timing parameters for IFC CS3 */
-#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
-					FTIM0_GPCM_TEADC(0x0e) | \
-					FTIM0_GPCM_TEAHC(0x0e))
-#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
-					FTIM1_GPCM_TRAD(0x3f))
-#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
-					FTIM2_GPCM_TCH(0x0) | \
-					FTIM2_GPCM_TWP(0x1f))
-#define CONFIG_SYS_CS3_FTIM3		0x0
-
-/* NAND Flash on IFC */
-#define CONFIG_NAND_FSL_IFC
-#define CONFIG_SYS_NAND_BASE		0xff800000
-#ifdef CONFIG_PHYS_64BIT
-#define CONFIG_SYS_NAND_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_NAND_BASE)
-#else
-#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
-#endif
-
-#define CONFIG_SYS_NAND_CSPR_EXT	(0xf)
-#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
-				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
-				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
-				| CSPR_V)
-#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
-
-#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
-				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
-				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
-				| CSOR_NAND_RAL_3	/* RAL = 2Byes */ \
-				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
-				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
-				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
-
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* ONFI NAND Flash mode0 Timing Params */
-#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
-					FTIM0_NAND_TWP(0x18)   | \
-					FTIM0_NAND_TWCHT(0x07) | \
-					FTIM0_NAND_TWH(0x0a))
-#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
-					FTIM1_NAND_TWBE(0x39)  | \
-					FTIM1_NAND_TRR(0x0e)   | \
-					FTIM1_NAND_TRP(0x18))
-#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
-					FTIM2_NAND_TREH(0x0a) | \
-					FTIM2_NAND_TWHRE(0x1e))
-#define CONFIG_SYS_NAND_FTIM3		0x0
-
-#define CONFIG_SYS_NAND_DDR_LAW		11
-
-#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define CONFIG_MTD_NAND_VERIFY_WRITE
-#define CONFIG_CMD_NAND
-
-#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
-
-#if defined(CONFIG_NAND)
-#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
-#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
-#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
-#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
-#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
-#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
-#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
-#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
-#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR0_CSPR
-#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
-#else
-#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
-#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
-#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
-#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
-#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
-#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
-#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
-#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
-#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
-#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
-#endif
-#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
-#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
-#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
 
 #define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
 
-#if defined(CONFIG_RAMBOOT_PBL)
-#define CONFIG_SYS_RAMBOOT
-#endif
-
 #define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
 #define CONFIG_MISC_INIT_R
 
@@ -380,18 +127,12 @@ unsigned long get_board_ddr_clk(void);
 #define CONFIG_L1_INIT_RAM
 #define CONFIG_SYS_INIT_RAM_LOCK
 #define CONFIG_SYS_INIT_RAM_ADDR	0xfdd00000	/* Initial L1 address */
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH	0xf
 #define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW	0xfe0ec000
 /* The assembler doesn't like typecast */
 #define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
 	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
 	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
-#else
-#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	0xfe0ec000 /* Initial L1 address */
-#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
-#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
-#endif
 #define CONFIG_SYS_INIT_RAM_SIZE		0x00004000
 
 #define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
@@ -437,138 +178,54 @@ unsigned long get_board_ddr_clk(void);
 #define CONFIG_HARD_I2C		/* I2C with hardware support */
 #define CONFIG_I2C_MULTI_BUS
 #define CONFIG_I2C_CMD_TREE
-#define CONFIG_SYS_I2C_SPEED		100000	/* I2C speed */
 #define CONFIG_SYS_I2C_SLAVE		0x7F
 #define CONFIG_SYS_I2C_OFFSET		0x118000
 #define CONFIG_SYS_I2C2_OFFSET		0x118100
-#define I2C_MUX_PCA_ADDR_PRI		0x77 /* I2C bus multiplexer,primary */
-#define I2C_MUX_PCA_ADDR_SEC		0x76 /* I2C bus multiplexer,secondary */
-
-/* VSC Crossbar switches */
-#define CONFIG_VSC_CROSSBAR
-#define I2C_MUX_CH_DEFAULT	0x8
-#define I2C_MUX_CH_VSC3316_FS	0xc
-#define I2C_MUX_CH_VSC3316_BS	0xd
-#define VSC3316_FSM_TX_ADDR	0x70
-#define VSC3316_FSM_RX_ADDR	0x71
 
 /*
  * RapidIO
  */
 #define CONFIG_SYS_SRIO1_MEM_VIRT	0xa0000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_SRIO1_MEM_PHYS	0xc20000000ull
-#else
-#define CONFIG_SYS_SRIO1_MEM_PHYS	0xa0000000
-#endif
 #define CONFIG_SYS_SRIO1_MEM_SIZE	0x10000000	/* 256M */
 
 #define CONFIG_SYS_SRIO2_MEM_VIRT	0xb0000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_SRIO2_MEM_PHYS	0xc30000000ull
-#else
-#define CONFIG_SYS_SRIO2_MEM_PHYS	0xb0000000
-#endif
 #define CONFIG_SYS_SRIO2_MEM_SIZE	0x10000000	/* 256M */
 
 /*
- * for slave u-boot IMAGE instored in master memory space,
- * PHYS must be aligned based on the SIZE
- */
-#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef080000ull
-#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff80000ull
-#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE 0x80000	/* 512K */
-#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff80000ull
-/*
- * for slave UCODE and ENV instored in master memory space,
- * PHYS must be aligned based on the SIZE
- */
-#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef040000ull
-#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS 0x3ffe00000ull
-#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE 0x40000	/* 256K */
-
-/* slave core release by master*/
-#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET 0xe00e4
-#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK 0x00000001 /* release core 0 */
-
-/*
- * SRIO_PCIE_BOOT - SLAVE
- */
-#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
-#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
-#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
-		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
-#endif
-/*
- * eSPI - Enhanced SPI
- */
-#define CONFIG_FSL_ESPI
-#define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_SPANSION
-#define CONFIG_CMD_SF
-#define CONFIG_SF_DEFAULT_SPEED         10000000
-#define CONFIG_SF_DEFAULT_MODE          0
-
-/*
  * General PCI
  * Memory space is mapped 1-1, but I/O space must start from 0.
  */
 
 /* controller 1, direct to uli, tgtid 3, Base address 20000 */
 #define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
 #define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
-#else
-#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
-#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
-#endif
 #define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
 #define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
 #define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
-#else
-#define CONFIG_SYS_PCIE1_IO_PHYS	0xf8000000
-#endif
 #define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 2, Slot 2, tgtid 2, Base address 201000 */
 #define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_PCIE2_MEM_BUS	0xe0000000
 #define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
-#else
-#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
-#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
-#endif
 #define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
 #define CONFIG_SYS_PCIE2_IO_VIRT	0xf8010000
 #define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_PCIE2_IO_PHYS	0xff8010000ull
-#else
-#define CONFIG_SYS_PCIE2_IO_PHYS	0xf8010000
-#endif
 #define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 3, Slot 1, tgtid 1, Base address 202000 */
 #define CONFIG_SYS_PCIE3_MEM_VIRT	0xc0000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_PCIE3_MEM_BUS	0xe0000000
 #define CONFIG_SYS_PCIE3_MEM_PHYS	0xc40000000ull
-#else
-#define CONFIG_SYS_PCIE3_MEM_BUS	0xc0000000
-#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc0000000
-#endif
 #define CONFIG_SYS_PCIE3_MEM_SIZE	0x20000000	/* 512M */
 #define CONFIG_SYS_PCIE3_IO_VIRT	0xf8020000
 #define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
-#ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_PCIE3_IO_PHYS	0xff8020000ull
-#else
-#define CONFIG_SYS_PCIE3_IO_PHYS	0xf8020000
-#endif
 #define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 4, Base address 203000 */
@@ -579,79 +236,6 @@ unsigned long get_board_ddr_clk(void);
 #define CONFIG_SYS_PCIE4_IO_PHYS	0xff8030000ull
 #define CONFIG_SYS_PCIE4_IO_SIZE	0x00010000	/* 64k */
 
-/* Qman/Bman */
-#ifndef CONFIG_NOBQFMAN
-#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
-#define CONFIG_SYS_BMAN_NUM_PORTALS	50
-#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
-#ifdef CONFIG_PHYS_64BIT
-#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
-#else
-#define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
-#endif
-#define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
-#define CONFIG_SYS_QMAN_NUM_PORTALS	50
-#define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
-#ifdef CONFIG_PHYS_64BIT
-#define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
-#else
-#define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
-#endif
-#define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
-
-#define CONFIG_SYS_DPAA_FMAN
-#define CONFIG_SYS_DPAA_PME
-#define CONFIG_SYS_PMAN
-#define CONFIG_SYS_DPAA_DCE
-#define CONFIG_SYS_INTERLAKEN
-
-/* Default address of microcode for the Linux Fman driver */
-#if defined(CONFIG_SPIFLASH)
-/*
- * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
- * env, so we got 0x110000.
- */
-#define CONFIG_SYS_QE_FW_IN_SPIFLASH
-#define CONFIG_SYS_QE_FMAN_FW_ADDR	0x110000
-#elif defined(CONFIG_SDCARD)
-/*
- * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
- * about 545KB (1089 blocks), Env is stored after the image, and the env size is
- * 0x2000 (16 blocks), 8 + 1089 + 16 = 1113, enlarge it to 1130.
- */
-#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
-#define CONFIG_SYS_QE_FMAN_FW_ADDR	(512 * 1130)
-#elif defined(CONFIG_NAND)
-#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
-#define CONFIG_SYS_QE_FMAN_FW_ADDR	(6 * CONFIG_SYS_NAND_BLOCK_SIZE)
-#else
-#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
-#define CONFIG_SYS_QE_FMAN_FW_ADDR		0xEFF40000
-#endif
-#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
-#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
-#endif /* CONFIG_NOBQFMAN */
-
-#ifdef CONFIG_SYS_DPAA_FMAN
-#define CONFIG_FMAN_ENET
-#define CONFIG_PHYLIB_10G
-#define CONFIG_PHY_VITESSE
-#define CONFIG_PHY_TERANETICS
-#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
-#define SGMII_CARD_PORT2_PHY_ADDR 0x1D
-#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
-#define SGMII_CARD_PORT4_PHY_ADDR 0x1F
-#define XFI_CARD_PORT1_PHY_ADDR	0x1 /* tmp, FIXME below addr */
-#define XFI_CARD_PORT2_PHY_ADDR	0x2
-#define XFI_CARD_PORT3_PHY_ADDR	0x3
-#define XFI_CARD_PORT4_PHY_ADDR	0x4
-#define QSGMII_CARD_PHY_ADDR	0x5
-#define FM1_10GEC1_PHY_ADDR	0x6
-#define FM1_10GEC2_PHY_ADDR	0x7
-#define FM2_10GEC1_PHY_ADDR	0x8
-#define FM2_10GEC2_PHY_ADDR	0x9
-#endif
-
 #ifdef CONFIG_PCI
 #define CONFIG_NET_MULTI
 #define CONFIG_PCI_PNP			/* do pci plug-and-play */
@@ -713,30 +297,6 @@ unsigned long get_board_ddr_clk(void);
 #endif
 
 /*
-* USB
-*/
-#define CONFIG_CMD_USB
-#define CONFIG_USB_STORAGE
-#define CONFIG_USB_EHCI
-#define CONFIG_USB_EHCI_FSL
-#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
-#define CONFIG_CMD_EXT2
-#define CONFIG_HAS_FSL_DR_USB
-
-#define CONFIG_MMC
-
-#ifdef CONFIG_MMC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_SYS_FSL_ESDHC_ADDR       CONFIG_SYS_MPC85xx_ESDHC_ADDR
-#define CONFIG_SYS_FSL_ESDHC_BROKEN_TIMEOUT
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_EXT2
-#define CONFIG_CMD_FAT
-#define CONFIG_DOS_PARTITION
-#endif
-
-/*
  * Miscellaneous configurable options
  */
 #define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
@@ -777,99 +337,11 @@ unsigned long get_board_ddr_clk(void);
 /* default location for tftp and bootm */
 #define CONFIG_LOADADDR		1000000
 
-#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
 
 #define CONFIG_BAUDRATE	115200
 
-#define __USB_PHY_TYPE	utmi
-
-#define	CONFIG_EXTRA_ENV_SETTINGS				\
-	"hwconfig=fsl_ddr:ctlr_intlv=3way_4KB,"		\
-	"bank_intlv=auto;"					\
-	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
-	"netdev=eth0\0"						\
-	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"			\
-	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"		\
-	"tftpflash=tftpboot $loadaddr $uboot && "		\
-	"protect off $ubootaddr +$filesize && "			\
-	"erase $ubootaddr +$filesize && "			\
-	"cp.b $loadaddr $ubootaddr $filesize && "		\
-	"protect on $ubootaddr +$filesize && "			\
-	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
-	"consoledev=ttyS0\0"					\
-	"ramdiskaddr=2000000\0"					\
-	"ramdiskfile=t4240qds/ramdisk.uboot\0"			\
-	"fdtaddr=c00000\0"					\
-	"fdtfile=t4240qds/t4240qds.dtb\0"				\
-	"bdev=sda3\0"						\
-	"c=ffe\0"
-
-/* For emulation this causes u-boot to jump to the start of the proof point
-   app code automatically */
-#define CONFIG_PROOF_POINTS			\
- "setenv bootargs root=/dev/$bdev rw "		\
- "console=$consoledev,$baudrate $othbootargs;"	\
- "cpu 1 release 0x29000000 - - -;"		\
- "cpu 2 release 0x29000000 - - -;"		\
- "cpu 3 release 0x29000000 - - -;"		\
- "cpu 4 release 0x29000000 - - -;"		\
- "cpu 5 release 0x29000000 - - -;"		\
- "cpu 6 release 0x29000000 - - -;"		\
- "cpu 7 release 0x29000000 - - -;"		\
- "go 0x29000000"
-
 #define CONFIG_HVBOOT				\
  "setenv bootargs config-addr=0x60000000; "	\
  "bootm 0x01000000 - 0x00f00000"
 
-#define CONFIG_ALU				\
- "setenv bootargs root=/dev/$bdev rw "		\
- "console=$consoledev,$baudrate $othbootargs;"	\
- "cpu 1 release 0x01000000 - - -;"		\
- "cpu 2 release 0x01000000 - - -;"		\
- "cpu 3 release 0x01000000 - - -;"		\
- "cpu 4 release 0x01000000 - - -;"		\
- "cpu 5 release 0x01000000 - - -;"		\
- "cpu 6 release 0x01000000 - - -;"		\
- "cpu 7 release 0x01000000 - - -;"		\
- "go 0x01000000"
-
-#define CONFIG_LINUX				\
- "setenv bootargs root=/dev/ram rw "		\
- "console=$consoledev,$baudrate $othbootargs;"	\
- "setenv ramdiskaddr 0x02000000;"		\
- "setenv fdtaddr 0x00c00000;"			\
- "setenv loadaddr 0x1000000;"			\
- "bootm $loadaddr $ramdiskaddr $fdtaddr"
-
-#define CONFIG_HDBOOT					\
-	"setenv bootargs root=/dev/$bdev rw "		\
-	"console=$consoledev,$baudrate $othbootargs;"	\
-	"tftp $loadaddr $bootfile;"			\
-	"tftp $fdtaddr $fdtfile;"			\
-	"bootm $loadaddr - $fdtaddr"
-
-#define CONFIG_NFSBOOTCOMMAND			\
-	"setenv bootargs root=/dev/nfs rw "	\
-	"nfsroot=$serverip:$rootpath "		\
-	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
-	"console=$consoledev,$baudrate $othbootargs;"	\
-	"tftp $loadaddr $bootfile;"		\
-	"tftp $fdtaddr $fdtfile;"		\
-	"bootm $loadaddr - $fdtaddr"
-
-#define CONFIG_RAMBOOTCOMMAND				\
-	"setenv bootargs root=/dev/ram rw "		\
-	"console=$consoledev,$baudrate $othbootargs;"	\
-	"tftp $ramdiskaddr $ramdiskfile;"		\
-	"tftp $loadaddr $bootfile;"			\
-	"tftp $fdtaddr $fdtfile;"			\
-	"bootm $loadaddr $ramdiskaddr $fdtaddr"
-
-#define CONFIG_BOOTCOMMAND		CONFIG_LINUX
-
-#ifdef CONFIG_SECURE_BOOT
-#include <asm/fsl_secure_boot.h>
-#endif
-
 #endif	/* __CONFIG_H */
diff --git a/include/desc.h b/include/desc.h
new file mode 100644
index 0000000..27d8e46
--- /dev/null
+++ b/include/desc.h
@@ -0,0 +1,1609 @@
+/*
+ * CAAM descriptor composition header
+ * Definitions to support CAAM descriptor instruction generation
+ *
+ * Copyright 2008-2011, 2012 Freescale Semiconductor, Inc.
+ */
+
+#ifndef DESC_H
+#define DESC_H
+
+/* Max size of any CAAM descriptor in 32-bit words, inclusive of header */
+#define MAX_CAAM_DESCSIZE       64
+
+/* Block size of any entity covered/uncovered with a KEK/TKEK */
+#define KEK_BLOCKSIZE		16
+
+/*
+ * Supported descriptor command types as they show up
+ * inside a descriptor command word.
+ */
+#define CMD_SHIFT               27
+#define CMD_MASK                0xf8000000
+
+#define CMD_KEY                 (0x00 << CMD_SHIFT)
+#define CMD_SEQ_KEY             (0x01 << CMD_SHIFT)
+#define CMD_LOAD                (0x02 << CMD_SHIFT)
+#define CMD_SEQ_LOAD            (0x03 << CMD_SHIFT)
+#define CMD_FIFO_LOAD           (0x04 << CMD_SHIFT)
+#define CMD_SEQ_FIFO_LOAD       (0x05 << CMD_SHIFT)
+#define CMD_STORE               (0x0a << CMD_SHIFT)
+#define CMD_SEQ_STORE           (0x0b << CMD_SHIFT)
+#define CMD_FIFO_STORE          (0x0c << CMD_SHIFT)
+#define CMD_SEQ_FIFO_STORE      (0x0d << CMD_SHIFT)
+#define CMD_MOVE_LEN            (0x0e << CMD_SHIFT)
+#define CMD_MOVE                (0x0f << CMD_SHIFT)
+#define CMD_OPERATION           (0x10 << CMD_SHIFT)
+#define CMD_SIGNATURE           (0x12 << CMD_SHIFT)
+#define CMD_JUMP                (0x14 << CMD_SHIFT)
+#define CMD_MATH                (0x15 << CMD_SHIFT)
+#define CMD_DESC_HDR            (0x16 << CMD_SHIFT)
+#define CMD_SHARED_DESC_HDR     (0x17 << CMD_SHIFT)
+#define CMD_SEQ_IN_PTR          (0x1e << CMD_SHIFT)
+#define CMD_SEQ_OUT_PTR         (0x1f << CMD_SHIFT)
+
+/* General-purpose class selector for all commands */
+#define CLASS_SHIFT             25
+#define CLASS_MASK              (0x03 << CLASS_SHIFT)
+
+#define CLASS_NONE              (0x00 << CLASS_SHIFT)
+#define CLASS_1                 (0x01 << CLASS_SHIFT)
+#define CLASS_2                 (0x02 << CLASS_SHIFT)
+#define CLASS_BOTH              (0x03 << CLASS_SHIFT)
+
+/*
+ * Descriptor header command constructs
+ * Covers shared, job, and trusted descriptor headers
+ */
+
+/*
+ * Do Not Run - marks a descriptor inexecutable if there was
+ * a preceding error somewhere
+ */
+#define HDR_DNR                 0x01000000
+
+/*
+ * ONE - should always be set. Combination of ONE (always
+ * set) and ZRO (always clear) forms an endianness sanity check
+ */
+#define HDR_ONE                 0x00800000
+#define HDR_ZRO                 0x00008000
+
+/* Start Index or SharedDesc Length */
+#define HDR_START_IDX_MASK      0x3f
+#define HDR_START_IDX_SHIFT     16
+
+/* If shared descriptor header, 6-bit length */
+#define HDR_DESCLEN_SHR_MASK  0x3f
+
+/* If non-shared header, 7-bit length */
+#define HDR_DESCLEN_MASK      0x7f
+
+/* This is a TrustedDesc (if not SharedDesc) */
+#define HDR_TRUSTED             0x00004000
+
+/* Make into TrustedDesc (if not SharedDesc) */
+#define HDR_MAKE_TRUSTED        0x00002000
+
+/* Save context if self-shared (if SharedDesc) */
+#define HDR_SAVECTX             0x00001000
+
+/* Next item points to SharedDesc */
+#define HDR_SHARED              0x00001000
+
+/*
+ * Reverse Execution Order - execute JobDesc first, then
+ * execute SharedDesc (normally SharedDesc goes first).
+ */
+#define HDR_REVERSE             0x00000800
+
+/* Propogate DNR property to SharedDesc */
+#define HDR_PROP_DNR            0x00000800
+
+/* JobDesc/SharedDesc share property */
+#define HDR_SD_SHARE_MASK       0x03
+#define HDR_SD_SHARE_SHIFT      8
+#define HDR_JD_SHARE_MASK       0x07
+#define HDR_JD_SHARE_SHIFT      8
+
+#define HDR_SHARE_NEVER         (0x00 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_WAIT          (0x01 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_SERIAL        (0x02 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_ALWAYS        (0x03 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_DEFER         (0x04 << HDR_SD_SHARE_SHIFT)
+
+/* JobDesc/SharedDesc descriptor length */
+#define HDR_JD_LENGTH_MASK      0x7f
+#define HDR_SD_LENGTH_MASK      0x3f
+
+/*
+ * KEY/SEQ_KEY Command Constructs
+ */
+
+/* Key Destination Class: 01 = Class 1, 02 - Class 2  */
+#define KEY_DEST_CLASS_SHIFT    25  /* use CLASS_1 or CLASS_2 */
+#define KEY_DEST_CLASS_MASK     (0x03 << KEY_DEST_CLASS_SHIFT)
+
+/* Scatter-Gather Table/Variable Length Field */
+#define KEY_SGF                 0x01000000
+#define KEY_VLF                 0x01000000
+
+/* Immediate - Key follows command in the descriptor */
+#define KEY_IMM                 0x00800000
+
+/*
+ * Encrypted - Key is encrypted either with the KEK, or
+ * with the TDKEK if TK is set
+ */
+#define KEY_ENC                 0x00400000
+
+/*
+ * No Write Back - Do not allow key to be FIFO STOREd
+ */
+#define KEY_NWB			0x00200000
+
+/*
+ * Enhanced Encryption of Key
+ */
+#define KEY_EKT			0x00100000
+
+/*
+ * Encrypted with Trusted Key
+ */
+#define KEY_TK			0x00008000
+
+/*
+ * KDEST - Key Destination: 0 - class key register,
+ * 1 - PKHA 'e', 2 - AFHA Sbox, 3 - MDHA split-key
+ */
+#define KEY_DEST_SHIFT          16
+#define KEY_DEST_MASK           (0x03 << KEY_DEST_SHIFT)
+
+#define KEY_DEST_CLASS_REG      (0x00 << KEY_DEST_SHIFT)
+#define KEY_DEST_PKHA_E         (0x01 << KEY_DEST_SHIFT)
+#define KEY_DEST_AFHA_SBOX      (0x02 << KEY_DEST_SHIFT)
+#define KEY_DEST_MDHA_SPLIT     (0x03 << KEY_DEST_SHIFT)
+
+/* Length in bytes */
+#define KEY_LENGTH_MASK         0x000003ff
+
+/*
+ * LOAD/SEQ_LOAD/STORE/SEQ_STORE Command Constructs
+ */
+
+/*
+ * Load/Store Destination: 0 = class independent CCB,
+ * 1 = class 1 CCB, 2 = class 2 CCB, 3 = DECO
+ */
+#define LDST_CLASS_SHIFT        25
+#define LDST_CLASS_MASK         (0x03 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_IND_CCB      (0x00 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_1_CCB        (0x01 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_2_CCB        (0x02 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_DECO         (0x03 << LDST_CLASS_SHIFT)
+
+/* Scatter-Gather Table/Variable Length Field */
+#define LDST_SGF                0x01000000
+#define LDST_VLF		LDST_SGF
+
+/* Immediate - Key follows this command in descriptor    */
+#define LDST_IMM_MASK           1
+#define LDST_IMM_SHIFT          23
+#define LDST_IMM                (LDST_IMM_MASK << LDST_IMM_SHIFT)
+
+/* SRC/DST - Destination for LOAD, Source for STORE   */
+#define LDST_SRCDST_SHIFT       16
+#define LDST_SRCDST_MASK        (0x7f << LDST_SRCDST_SHIFT)
+
+#define LDST_SRCDST_BYTE_CONTEXT	(0x20 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_KEY		(0x40 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_INFIFO		(0x7c << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_OUTFIFO	(0x7e << LDST_SRCDST_SHIFT)
+
+#define LDST_SRCDST_WORD_MODE_REG	(0x00 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_KEYSZ_REG	(0x01 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DATASZ_REG	(0x02 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_ICVSZ_REG	(0x03 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CHACTRL	(0x06 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECOCTRL       (0x06 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_IRQCTRL	(0x07 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_PCLOVRD   (0x07 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CLRW		(0x08 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH0     (0x08 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_STAT		(0x09 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH1     (0x09 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH2     (0x0a << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_AAD_SZ    (0x0b << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH3     (0x0b << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CLASS1_ICV_SZ  (0x0c << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_ALTDS_CLASS1   (0x0f << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_A_SZ      (0x10 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_B_SZ      (0x11 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_N_SZ      (0x12 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_E_SZ      (0x13 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DESCBUF        (0x40 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_INFO_FIFO      (0x7a << LDST_SRCDST_SHIFT)
+
+/* Offset in source/destination                        */
+#define LDST_OFFSET_SHIFT       8
+#define LDST_OFFSET_MASK        (0xff << LDST_OFFSET_SHIFT)
+
+/* LDOFF definitions used when DST = LDST_SRCDST_WORD_DECOCTRL */
+/* These could also be shifted by LDST_OFFSET_SHIFT - this reads better */
+#define LDOFF_CHG_SHARE_SHIFT        0
+#define LDOFF_CHG_SHARE_MASK         (0x3 << LDOFF_CHG_SHARE_SHIFT)
+#define LDOFF_CHG_SHARE_NEVER        (0x1 << LDOFF_CHG_SHARE_SHIFT)
+#define LDOFF_CHG_SHARE_OK_NO_PROP   (0x2 << LDOFF_CHG_SHARE_SHIFT)
+#define LDOFF_CHG_SHARE_OK_PROP      (0x3 << LDOFF_CHG_SHARE_SHIFT)
+
+#define LDOFF_ENABLE_AUTO_NFIFO         (1 << 2)
+#define LDOFF_DISABLE_AUTO_NFIFO        (1 << 3)
+
+#define LDOFF_CHG_NONSEQLIODN_SHIFT     4
+#define LDOFF_CHG_NONSEQLIODN_MASK      (0x3 << LDOFF_CHG_NONSEQLIODN_SHIFT)
+#define LDOFF_CHG_NONSEQLIODN_SEQ       (0x1 << LDOFF_CHG_NONSEQLIODN_SHIFT)
+#define LDOFF_CHG_NONSEQLIODN_NON_SEQ   (0x2 << LDOFF_CHG_NONSEQLIODN_SHIFT)
+#define LDOFF_CHG_NONSEQLIODN_TRUSTED   (0x3 << LDOFF_CHG_NONSEQLIODN_SHIFT)
+
+#define LDOFF_CHG_SEQLIODN_SHIFT     6
+#define LDOFF_CHG_SEQLIODN_MASK      (0x3 << LDOFF_CHG_SEQLIODN_SHIFT)
+#define LDOFF_CHG_SEQLIODN_SEQ       (0x1 << LDOFF_CHG_SEQLIODN_SHIFT)
+#define LDOFF_CHG_SEQLIODN_NON_SEQ   (0x2 << LDOFF_CHG_SEQLIODN_SHIFT)
+#define LDOFF_CHG_SEQLIODN_TRUSTED   (0x3 << LDOFF_CHG_SEQLIODN_SHIFT)
+
+/* Data length in bytes                                 */
+#define LDST_LEN_SHIFT          0
+#define LDST_LEN_MASK           (0xff << LDST_LEN_SHIFT)
+
+/* Special Length definitions when dst=deco-ctrl */
+#define LDLEN_ENABLE_OSL_COUNT      (1 << 7)
+#define LDLEN_RST_CHA_OFIFO_PTR     (1 << 6)
+#define LDLEN_RST_OFIFO             (1 << 5)
+#define LDLEN_SET_OFIFO_OFF_VALID   (1 << 4)
+#define LDLEN_SET_OFIFO_OFF_RSVD    (1 << 3)
+#define LDLEN_SET_OFIFO_OFFSET_SHIFT 0
+#define LDLEN_SET_OFIFO_OFFSET_MASK (3 << LDLEN_SET_OFIFO_OFFSET_SHIFT)
+
+/*
+ * FIFO_LOAD/FIFO_STORE/SEQ_FIFO_LOAD/SEQ_FIFO_STORE
+ * Command Constructs
+ */
+
+/*
+ * Load Destination: 0 = skip (SEQ_FIFO_LOAD only),
+ * 1 = Load for Class1, 2 = Load for Class2, 3 = Load both
+ * Store Source: 0 = normal, 1 = Class1key, 2 = Class2key
+ */
+#define FIFOLD_CLASS_SHIFT      25
+#define FIFOLD_CLASS_MASK       (0x03 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_SKIP       (0x00 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_CLASS1     (0x01 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_CLASS2     (0x02 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_BOTH       (0x03 << FIFOLD_CLASS_SHIFT)
+
+#define FIFOST_CLASS_SHIFT      25
+#define FIFOST_CLASS_MASK       (0x03 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_NORMAL     (0x00 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_CLASS1KEY  (0x01 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_CLASS2KEY  (0x02 << FIFOST_CLASS_SHIFT)
+
+/*
+ * Scatter-Gather Table/Variable Length Field
+ * If set for FIFO_LOAD, refers to a SG table. Within
+ * SEQ_FIFO_LOAD, is variable input sequence
+ */
+#define FIFOLDST_SGF_SHIFT      24
+#define FIFOLDST_SGF_MASK       (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_VLF_MASK       (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_SGF            (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_VLF            (1 << FIFOLDST_SGF_SHIFT)
+
+/* Immediate - Data follows command in descriptor */
+#define FIFOLD_IMM_SHIFT      23
+#define FIFOLD_IMM_MASK       (1 << FIFOLD_IMM_SHIFT)
+#define FIFOLD_IMM            (1 << FIFOLD_IMM_SHIFT)
+
+/* Continue - Not the last FIFO store to come */
+#define FIFOST_CONT_SHIFT     23
+#define FIFOST_CONT_MASK      (1 << FIFOST_CONT_SHIFT)
+#define FIFOST_CONT_MASK      (1 << FIFOST_CONT_SHIFT)
+
+/*
+ * Extended Length - use 32-bit extended length that
+ * follows the pointer field. Illegal with IMM set
+ */
+#define FIFOLDST_EXT_SHIFT      22
+#define FIFOLDST_EXT_MASK       (1 << FIFOLDST_EXT_SHIFT)
+#define FIFOLDST_EXT            (1 << FIFOLDST_EXT_SHIFT)
+
+/* Input data type.*/
+#define FIFOLD_TYPE_SHIFT       16
+#define FIFOLD_CONT_TYPE_SHIFT  19 /* shift past last-flush bits */
+#define FIFOLD_TYPE_MASK        (0x3f << FIFOLD_TYPE_SHIFT)
+
+/* PK types */
+#define FIFOLD_TYPE_PK          (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_MASK     (0x30 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_TYPEMASK (0x0f << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A0       (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A1       (0x01 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A2       (0x02 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A3       (0x03 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B0       (0x04 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B1       (0x05 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B2       (0x06 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B3       (0x07 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_N        (0x08 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A        (0x0c << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B        (0x0d << FIFOLD_TYPE_SHIFT)
+
+/* Other types. Need to OR in last/flush bits as desired */
+#define FIFOLD_TYPE_MSG_MASK    (0x38 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_MSG         (0x10 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_MSG1OUT2    (0x18 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_IV          (0x20 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_BITDATA     (0x28 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_AAD         (0x30 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_ICV         (0x38 << FIFOLD_TYPE_SHIFT)
+
+/* Last/Flush bits for use with "other" types above */
+#define FIFOLD_TYPE_ACT_MASK    (0x07 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_NOACTION    (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_FLUSH1      (0x01 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST1       (0x02 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2FLUSH  (0x03 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2       (0x04 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2FLUSH1 (0x05 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LASTBOTH    (0x06 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LASTBOTHFL  (0x07 << FIFOLD_TYPE_SHIFT)
+
+#define FIFOLDST_LEN_MASK       0xffff
+#define FIFOLDST_EXT_LEN_MASK   0xffffffff
+
+/* Output data types */
+#define FIFOST_TYPE_SHIFT       16
+#define FIFOST_TYPE_MASK        (0x3f << FIFOST_TYPE_SHIFT)
+
+#define FIFOST_TYPE_PKHA_A0      (0x00 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A1      (0x01 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A2      (0x02 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A3      (0x03 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B0      (0x04 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B1      (0x05 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B2      (0x06 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B3      (0x07 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_N       (0x08 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A       (0x0c << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B       (0x0d << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_AF_SBOX_JKEK (0x10 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_AF_SBOX_TKEK (0x21 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_E_JKEK  (0x22 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_E_TKEK  (0x23 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_KEY_KEK      (0x24 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_KEY_TKEK     (0x25 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SPLIT_KEK    (0x26 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SPLIT_TKEK   (0x27 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_OUTFIFO_KEK  (0x28 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_OUTFIFO_TKEK (0x29 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_MESSAGE_DATA (0x30 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_RNGSTORE     (0x34 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_RNGFIFO      (0x35 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SKIP         (0x3f << FIFOST_TYPE_SHIFT)
+
+/*
+ * OPERATION Command Constructs
+ */
+
+/* Operation type selectors - OP TYPE */
+#define OP_TYPE_SHIFT           24
+#define OP_TYPE_MASK            (0x07 << OP_TYPE_SHIFT)
+
+#define OP_TYPE_UNI_PROTOCOL    (0x00 << OP_TYPE_SHIFT)
+#define OP_TYPE_PK              (0x01 << OP_TYPE_SHIFT)
+#define OP_TYPE_CLASS1_ALG      (0x02 << OP_TYPE_SHIFT)
+#define OP_TYPE_CLASS2_ALG      (0x04 << OP_TYPE_SHIFT)
+#define OP_TYPE_DECAP_PROTOCOL  (0x06 << OP_TYPE_SHIFT)
+#define OP_TYPE_ENCAP_PROTOCOL  (0x07 << OP_TYPE_SHIFT)
+
+/* ProtocolID selectors - PROTID */
+#define OP_PCLID_SHIFT          16
+#define OP_PCLID_MASK           (0xff << 16)
+
+/* Assuming OP_TYPE = OP_TYPE_UNI_PROTOCOL */
+#define OP_PCLID_IKEV1_PRF      (0x01 << OP_PCLID_SHIFT)
+#define OP_PCLID_IKEV2_PRF      (0x02 << OP_PCLID_SHIFT)
+#define OP_PCLID_SSL30_PRF      (0x08 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS10_PRF      (0x09 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS11_PRF      (0x0a << OP_PCLID_SHIFT)
+#define OP_PCLID_DTLS10_PRF     (0x0c << OP_PCLID_SHIFT)
+#define OP_PCLID_PRF            (0x06 << OP_PCLID_SHIFT)
+#define OP_PCLID_BLOB           (0x0d << OP_PCLID_SHIFT)
+#define OP_PCLID_SECRETKEY      (0x11 << OP_PCLID_SHIFT)
+#define OP_PCLID_PUBLICKEYPAIR  (0x14 << OP_PCLID_SHIFT)
+#define OP_PCLID_DSASIGN        (0x15 << OP_PCLID_SHIFT)
+#define OP_PCLID_DSAVERIFY      (0x16 << OP_PCLID_SHIFT)
+
+/* Assuming OP_TYPE = OP_TYPE_DECAP_PROTOCOL/ENCAP_PROTOCOL */
+#define OP_PCLID_IPSEC          (0x01 << OP_PCLID_SHIFT)
+#define OP_PCLID_SRTP           (0x02 << OP_PCLID_SHIFT)
+#define OP_PCLID_MACSEC         (0x03 << OP_PCLID_SHIFT)
+#define OP_PCLID_WIFI           (0x04 << OP_PCLID_SHIFT)
+#define OP_PCLID_WIMAX          (0x05 << OP_PCLID_SHIFT)
+#define OP_PCLID_SSL30          (0x08 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS10          (0x09 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS11          (0x0a << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS12          (0x0b << OP_PCLID_SHIFT)
+#define OP_PCLID_DTLS           (0x0c << OP_PCLID_SHIFT)
+
+/*
+ * ProtocolInfo selectors
+ */
+#define OP_PCLINFO_MASK                          0xffff
+
+/* for OP_PCLID_IPSEC */
+#define OP_PCL_IPSEC_CIPHER_MASK                 0xff00
+#define OP_PCL_IPSEC_AUTH_MASK                   0x00ff
+
+#define OP_PCL_IPSEC_DES_IV64                    0x0100
+#define OP_PCL_IPSEC_DES                         0x0200
+#define OP_PCL_IPSEC_3DES                        0x0300
+#define OP_PCL_IPSEC_AES_CBC                     0x0c00
+#define OP_PCL_IPSEC_AES_CTR                     0x0d00
+#define OP_PCL_IPSEC_AES_XTS                     0x1600
+#define OP_PCL_IPSEC_AES_CCM8                    0x0e00
+#define OP_PCL_IPSEC_AES_CCM12                   0x0f00
+#define OP_PCL_IPSEC_AES_CCM16                   0x1000
+#define OP_PCL_IPSEC_AES_GCM8                    0x1200
+#define OP_PCL_IPSEC_AES_GCM12                   0x1300
+#define OP_PCL_IPSEC_AES_GCM16                   0x1400
+
+#define OP_PCL_IPSEC_HMAC_NULL                   0x0000
+#define OP_PCL_IPSEC_HMAC_MD5_96                 0x0001
+#define OP_PCL_IPSEC_HMAC_SHA1_96                0x0002
+#define OP_PCL_IPSEC_AES_XCBC_MAC_96             0x0005
+#define OP_PCL_IPSEC_HMAC_MD5_128                0x0006
+#define OP_PCL_IPSEC_HMAC_SHA1_160               0x0007
+#define OP_PCL_IPSEC_HMAC_SHA2_256_128           0x000c
+#define OP_PCL_IPSEC_HMAC_SHA2_384_192           0x000d
+#define OP_PCL_IPSEC_HMAC_SHA2_512_256           0x000e
+
+/* For SRTP - OP_PCLID_SRTP */
+#define OP_PCL_SRTP_CIPHER_MASK                  0xff00
+#define OP_PCL_SRTP_AUTH_MASK                    0x00ff
+
+#define OP_PCL_SRTP_AES_CTR                      0x0d00
+
+#define OP_PCL_SRTP_HMAC_SHA1_160                0x0007
+
+/* For SSL 3.0 - OP_PCLID_SSL30 */
+#define OP_PCL_SSL30_AES_128_CBC_SHA             0x002f
+#define OP_PCL_SSL30_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_SSL30_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_SSL30_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_SSL30_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_SSL30_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_SSL30_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_SSL30_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_SSL30_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_SSL30_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_SSL30_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_SSL30_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_SSL30_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_SSL30_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_SSL30_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_SSL30_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_SSL30_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_SSL30_AES_256_CBC_SHA             0x0035
+#define OP_PCL_SSL30_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_SSL30_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_SSL30_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_SSL30_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_SSL30_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_SSL30_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_SSL30_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_SSL30_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_SSL30_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_SSL30_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_SSL30_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_SSL30_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_SSL30_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_SSL30_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_SSL30_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_SSL30_AES_256_CBC_SHA_17          0xc022
+
+#define OP_PCL_SSL30_3DES_EDE_CBC_MD5            0x0023
+
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_SSL30_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_SSL30_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_SSL30_DES40_CBC_SHA               0x0008
+#define OP_PCL_SSL30_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_SSL30_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_SSL30_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_SSL30_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_SSL30_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_SSL30_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_SSL30_DES_CBC_SHA                 0x001e
+#define OP_PCL_SSL30_DES_CBC_SHA_2               0x0009
+#define OP_PCL_SSL30_DES_CBC_SHA_3               0x000c
+#define OP_PCL_SSL30_DES_CBC_SHA_4               0x000f
+#define OP_PCL_SSL30_DES_CBC_SHA_5               0x0012
+#define OP_PCL_SSL30_DES_CBC_SHA_6               0x0015
+#define OP_PCL_SSL30_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_SSL30_RC4_128_MD5                 0x0024
+#define OP_PCL_SSL30_RC4_128_MD5_2               0x0004
+#define OP_PCL_SSL30_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_SSL30_RC4_40_MD5                  0x002b
+#define OP_PCL_SSL30_RC4_40_MD5_2                0x0003
+#define OP_PCL_SSL30_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_SSL30_RC4_128_SHA                 0x0020
+#define OP_PCL_SSL30_RC4_128_SHA_2               0x008a
+#define OP_PCL_SSL30_RC4_128_SHA_3               0x008e
+#define OP_PCL_SSL30_RC4_128_SHA_4               0x0092
+#define OP_PCL_SSL30_RC4_128_SHA_5               0x0005
+#define OP_PCL_SSL30_RC4_128_SHA_6               0xc002
+#define OP_PCL_SSL30_RC4_128_SHA_7               0xc007
+#define OP_PCL_SSL30_RC4_128_SHA_8               0xc00c
+#define OP_PCL_SSL30_RC4_128_SHA_9               0xc011
+#define OP_PCL_SSL30_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_SSL30_RC4_40_SHA                  0x0028
+
+
+/* For TLS 1.0 - OP_PCLID_TLS10 */
+#define OP_PCL_TLS10_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS10_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS10_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS10_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS10_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS10_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS10_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS10_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS10_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS10_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS10_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS10_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS10_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS10_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS10_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS10_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS10_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS10_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS10_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS10_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS10_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS10_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS10_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS10_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS10_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS10_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS10_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS10_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS10_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS10_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS10_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS10_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS10_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS10_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS10_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS10_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS10_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS10_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS10_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS10_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS10_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS10_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS10_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS10_DES40_CBC_SHA_7             0x0026
+
+
+#define OP_PCL_TLS10_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS10_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS10_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS10_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS10_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS10_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS10_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS10_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS10_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS10_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS10_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS10_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS10_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS10_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS10_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS10_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS10_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS10_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS10_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS10_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS10_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS10_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS10_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS10_RC4_40_SHA                  0x0028
+
+#define OP_PCL_TLS10_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS10_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS10_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS10_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS10_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS10_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS10_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS10_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS10_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS10_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS10_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS10_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS10_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS10_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS10_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS10_AES_256_CBC_SHA512          0xff65
+
+
+
+/* For TLS 1.1 - OP_PCLID_TLS11 */
+#define OP_PCL_TLS11_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS11_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS11_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS11_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS11_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS11_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS11_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS11_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS11_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS11_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS11_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS11_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS11_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS11_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS11_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS11_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS11_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS11_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS11_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS11_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS11_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS11_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS11_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS11_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS11_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS11_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS11_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS11_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS11_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS11_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS11_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS11_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS11_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS11_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS11_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS11_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS11_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS11_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS11_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS11_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS11_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS11_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS11_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS11_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_TLS11_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS11_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS11_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS11_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS11_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS11_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS11_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS11_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS11_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS11_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS11_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS11_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS11_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS11_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS11_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS11_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS11_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS11_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS11_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS11_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS11_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS11_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS11_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS11_RC4_40_SHA                  0x0028
+
+#define OP_PCL_TLS11_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS11_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS11_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS11_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS11_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS11_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS11_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS11_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS11_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS11_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS11_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS11_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS11_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS11_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS11_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS11_AES_256_CBC_SHA512          0xff65
+
+
+/* For TLS 1.2 - OP_PCLID_TLS12 */
+#define OP_PCL_TLS12_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS12_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS12_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS12_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS12_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS12_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS12_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS12_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS12_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS12_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS12_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS12_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS12_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS12_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS12_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS12_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS12_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS12_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS12_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS12_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS12_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS12_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS12_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS12_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS12_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS12_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS12_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS12_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS12_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS12_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS12_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS12_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS12_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS12_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS12_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS12_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS12_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS12_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS12_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS12_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS12_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS12_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS12_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS12_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_TLS12_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS12_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS12_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS12_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS12_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS12_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS12_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS12_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS12_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS12_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS12_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS12_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS12_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS12_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS12_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS12_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS12_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS12_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS12_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS12_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS12_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS12_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS12_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS12_RC4_40_SHA                  0x0028
+
+/* #define OP_PCL_TLS12_AES_128_CBC_SHA256          0x003c */
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_2        0x003e
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_3        0x003f
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_4        0x0040
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_5        0x0067
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_6        0x006c
+
+/* #define OP_PCL_TLS12_AES_256_CBC_SHA256          0x003d */
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_2        0x0068
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_3        0x0069
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_4        0x006a
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_5        0x006b
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_6        0x006d
+
+/* AEAD_AES_xxx_CCM/GCM remain to be defined... */
+
+#define OP_PCL_TLS12_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS12_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS12_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS12_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS12_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS12_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS12_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS12_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS12_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS12_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS12_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS12_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS12_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS12_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS12_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS12_AES_256_CBC_SHA512          0xff65
+
+/* For DTLS - OP_PCLID_DTLS */
+
+#define OP_PCL_DTLS_AES_128_CBC_SHA              0x002f
+#define OP_PCL_DTLS_AES_128_CBC_SHA_2            0x0030
+#define OP_PCL_DTLS_AES_128_CBC_SHA_3            0x0031
+#define OP_PCL_DTLS_AES_128_CBC_SHA_4            0x0032
+#define OP_PCL_DTLS_AES_128_CBC_SHA_5            0x0033
+#define OP_PCL_DTLS_AES_128_CBC_SHA_6            0x0034
+#define OP_PCL_DTLS_AES_128_CBC_SHA_7            0x008c
+#define OP_PCL_DTLS_AES_128_CBC_SHA_8            0x0090
+#define OP_PCL_DTLS_AES_128_CBC_SHA_9            0x0094
+#define OP_PCL_DTLS_AES_128_CBC_SHA_10           0xc004
+#define OP_PCL_DTLS_AES_128_CBC_SHA_11           0xc009
+#define OP_PCL_DTLS_AES_128_CBC_SHA_12           0xc00e
+#define OP_PCL_DTLS_AES_128_CBC_SHA_13           0xc013
+#define OP_PCL_DTLS_AES_128_CBC_SHA_14           0xc018
+#define OP_PCL_DTLS_AES_128_CBC_SHA_15           0xc01d
+#define OP_PCL_DTLS_AES_128_CBC_SHA_16           0xc01e
+#define OP_PCL_DTLS_AES_128_CBC_SHA_17           0xc01f
+
+#define OP_PCL_DTLS_AES_256_CBC_SHA              0x0035
+#define OP_PCL_DTLS_AES_256_CBC_SHA_2            0x0036
+#define OP_PCL_DTLS_AES_256_CBC_SHA_3            0x0037
+#define OP_PCL_DTLS_AES_256_CBC_SHA_4            0x0038
+#define OP_PCL_DTLS_AES_256_CBC_SHA_5            0x0039
+#define OP_PCL_DTLS_AES_256_CBC_SHA_6            0x003a
+#define OP_PCL_DTLS_AES_256_CBC_SHA_7            0x008d
+#define OP_PCL_DTLS_AES_256_CBC_SHA_8            0x0091
+#define OP_PCL_DTLS_AES_256_CBC_SHA_9            0x0095
+#define OP_PCL_DTLS_AES_256_CBC_SHA_10           0xc005
+#define OP_PCL_DTLS_AES_256_CBC_SHA_11           0xc00a
+#define OP_PCL_DTLS_AES_256_CBC_SHA_12           0xc00f
+#define OP_PCL_DTLS_AES_256_CBC_SHA_13           0xc014
+#define OP_PCL_DTLS_AES_256_CBC_SHA_14           0xc019
+#define OP_PCL_DTLS_AES_256_CBC_SHA_15           0xc020
+#define OP_PCL_DTLS_AES_256_CBC_SHA_16           0xc021
+#define OP_PCL_DTLS_AES_256_CBC_SHA_17           0xc022
+
+/* #define OP_PCL_DTLS_3DES_EDE_CBC_MD5             0x0023 */
+
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA             0x001f
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_2           0x008b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_3           0x008f
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_4           0x0093
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_5           0x000a
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_6           0x000d
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_7           0x0010
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_8           0x0013
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_9           0x0016
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_10          0x001b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_11          0xc003
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_12          0xc008
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_13          0xc00d
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_14          0xc012
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_15          0xc017
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_16          0xc01a
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_17          0xc01b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_18          0xc01c
+
+#define OP_PCL_DTLS_DES40_CBC_MD5                0x0029
+
+#define OP_PCL_DTLS_DES_CBC_MD5                  0x0022
+
+#define OP_PCL_DTLS_DES40_CBC_SHA                0x0008
+#define OP_PCL_DTLS_DES40_CBC_SHA_2              0x000b
+#define OP_PCL_DTLS_DES40_CBC_SHA_3              0x000e
+#define OP_PCL_DTLS_DES40_CBC_SHA_4              0x0011
+#define OP_PCL_DTLS_DES40_CBC_SHA_5              0x0014
+#define OP_PCL_DTLS_DES40_CBC_SHA_6              0x0019
+#define OP_PCL_DTLS_DES40_CBC_SHA_7              0x0026
+
+
+#define OP_PCL_DTLS_DES_CBC_SHA                  0x001e
+#define OP_PCL_DTLS_DES_CBC_SHA_2                0x0009
+#define OP_PCL_DTLS_DES_CBC_SHA_3                0x000c
+#define OP_PCL_DTLS_DES_CBC_SHA_4                0x000f
+#define OP_PCL_DTLS_DES_CBC_SHA_5                0x0012
+#define OP_PCL_DTLS_DES_CBC_SHA_6                0x0015
+#define OP_PCL_DTLS_DES_CBC_SHA_7                0x001a
+
+
+#define OP_PCL_DTLS_3DES_EDE_CBC_MD5             0xff23
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA160          0xff30
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA224          0xff34
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA256          0xff36
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA384          0xff33
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA512          0xff35
+#define OP_PCL_DTLS_AES_128_CBC_SHA160           0xff80
+#define OP_PCL_DTLS_AES_128_CBC_SHA224           0xff84
+#define OP_PCL_DTLS_AES_128_CBC_SHA256           0xff86
+#define OP_PCL_DTLS_AES_128_CBC_SHA384           0xff83
+#define OP_PCL_DTLS_AES_128_CBC_SHA512           0xff85
+#define OP_PCL_DTLS_AES_192_CBC_SHA160           0xff20
+#define OP_PCL_DTLS_AES_192_CBC_SHA224           0xff24
+#define OP_PCL_DTLS_AES_192_CBC_SHA256           0xff26
+#define OP_PCL_DTLS_AES_192_CBC_SHA384           0xff23
+#define OP_PCL_DTLS_AES_192_CBC_SHA512           0xff25
+#define OP_PCL_DTLS_AES_256_CBC_SHA160           0xff60
+#define OP_PCL_DTLS_AES_256_CBC_SHA224           0xff64
+#define OP_PCL_DTLS_AES_256_CBC_SHA256           0xff66
+#define OP_PCL_DTLS_AES_256_CBC_SHA384           0xff63
+#define OP_PCL_DTLS_AES_256_CBC_SHA512           0xff65
+
+/* 802.16 WiMAX protinfos */
+#define OP_PCL_WIMAX_OFDM                        0x0201
+#define OP_PCL_WIMAX_OFDMA                       0x0231
+
+/* 802.11 WiFi protinfos */
+#define OP_PCL_WIFI                              0xac04
+
+/* MacSec protinfos */
+#define OP_PCL_MACSEC                            0x0001
+
+/* PKI unidirectional protocol protinfo bits */
+#define OP_PCL_PKPROT_TEST                       0x0008
+#define OP_PCL_PKPROT_DECRYPT                    0x0004
+#define OP_PCL_PKPROT_ECC                        0x0002
+#define OP_PCL_PKPROT_F2M                        0x0001
+
+/* For non-protocol/alg-only op commands */
+#define OP_ALG_TYPE_SHIFT	24
+#define OP_ALG_TYPE_MASK	(0x7 << OP_ALG_TYPE_SHIFT)
+#define OP_ALG_TYPE_CLASS1	2
+#define OP_ALG_TYPE_CLASS2	4
+
+#define OP_ALG_ALGSEL_SHIFT	16
+#define OP_ALG_ALGSEL_MASK	(0xff << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SUBMASK	(0x0f << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_AES	(0x10 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_DES	(0x20 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_3DES	(0x21 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_ARC4	(0x30 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_MD5	(0x40 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA1	(0x41 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA224	(0x42 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA256	(0x43 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA384	(0x44 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA512	(0x45 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_RNG	(0x50 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SNOW	(0x60 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SNOW_F8	(0x60 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_KASUMI	(0x70 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_CRC	(0x90 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SNOW_F9	(0xA0 << OP_ALG_ALGSEL_SHIFT)
+
+#define OP_ALG_AAI_SHIFT	4
+#define OP_ALG_AAI_MASK		(0x1ff << OP_ALG_AAI_SHIFT)
+
+/* blockcipher AAI set */
+#define OP_ALG_AAI_CTR_MOD128	(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD8	(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD16	(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD24	(0x03 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD32	(0x04 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD40	(0x05 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD48	(0x06 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD56	(0x07 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD64	(0x08 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD72	(0x09 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD80	(0x0a << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD88	(0x0b << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD96	(0x0c << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD104	(0x0d << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD112	(0x0e << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD120	(0x0f << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CBC		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_ECB		(0x20 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CFB		(0x30 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_OFB		(0x40 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_XTS		(0x50 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CMAC		(0x60 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_XCBC_MAC	(0x70 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CCM		(0x80 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_GCM		(0x90 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CBC_XCBCMAC	(0xa0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_XCBCMAC	(0xb0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CHECKODD	(0x80 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DK		(0x100 << OP_ALG_AAI_SHIFT)
+
+/* randomizer AAI set */
+#define OP_ALG_AAI_RNG		(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_RNG_NOZERO	(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_RNG_ODD	(0x20 << OP_ALG_AAI_SHIFT)
+
+/* hmac/smac AAI set */
+#define OP_ALG_AAI_HASH		(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_HMAC		(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_SMAC		(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_HMAC_PRECOMP	(0x04 << OP_ALG_AAI_SHIFT)
+
+/* CRC AAI set*/
+#define OP_ALG_AAI_802		(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_3385		(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CUST_POLY	(0x04 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DIS		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DOS		(0x20 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DOC		(0x40 << OP_ALG_AAI_SHIFT)
+
+/* Kasumi/SNOW AAI set */
+#define OP_ALG_AAI_F8		(0xc0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_F9		(0xc8 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_GSM		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_EDGE		(0x20 << OP_ALG_AAI_SHIFT)
+
+/* RNG4 set */
+#define OP_ALG_RNG4_SHIFT	4
+#define OP_ALG_RNG4_MAS		(0x1f3 << OP_ALG_RNG4_SHIFT)
+#define OP_ALG_RNG4_SK		(0x100 << OP_ALG_RNG4_SHIFT)
+
+#define OP_ALG_AS_SHIFT		2
+#define OP_ALG_AS_MASK		(0x3 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_UPDATE	(0 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_INIT		(1 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_FINALIZE	(2 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_INITFINAL	(3 << OP_ALG_AS_SHIFT)
+
+#define OP_ALG_ICV_SHIFT	1
+#define OP_ALG_ICV_MASK		(1 << OP_ALG_ICV_SHIFT)
+#define OP_ALG_ICV_OFF		(0 << OP_ALG_ICV_SHIFT)
+#define OP_ALG_ICV_ON		(1 << OP_ALG_ICV_SHIFT)
+
+#define OP_ALG_DIR_SHIFT	0
+#define OP_ALG_DIR_MASK		1
+#define OP_ALG_DECRYPT		0
+#define OP_ALG_ENCRYPT		1
+
+/* PKHA algorithm type set */
+#define OP_ALG_PK                    0x00800000
+#define OP_ALG_PK_FUN_MASK           0x3f /* clrmem, modmath, or cpymem */
+
+/* PKHA mode clear memory functions */
+#define OP_ALG_PKMODE_A_RAM          0x80000
+#define OP_ALG_PKMODE_B_RAM          0x40000
+#define OP_ALG_PKMODE_E_RAM          0x20000
+#define OP_ALG_PKMODE_N_RAM          0x10000
+#define OP_ALG_PKMODE_CLEARMEM       0x00001
+
+/* PKHA mode modular-arithmetic functions */
+#define OP_ALG_PKMODE_MOD_IN_MONTY   0x80000
+#define OP_ALG_PKMODE_MOD_OUT_MONTY  0x40000
+#define OP_ALG_PKMODE_MOD_F2M        0x20000
+#define OP_ALG_PKMODE_MOD_R2_IN      0x10000
+#define OP_ALG_PKMODE_PRJECTV        0x00800
+#define OP_ALG_PKMODE_TIME_EQ        0x400
+#define OP_ALG_PKMODE_OUT_B          0x000
+#define OP_ALG_PKMODE_OUT_A          0x100
+#define OP_ALG_PKMODE_MOD_ADD        0x002
+#define OP_ALG_PKMODE_MOD_SUB_AB     0x003
+#define OP_ALG_PKMODE_MOD_SUB_BA     0x004
+#define OP_ALG_PKMODE_MOD_MULT       0x005
+#define OP_ALG_PKMODE_MOD_EXPO       0x006
+#define OP_ALG_PKMODE_MOD_REDUCT     0x007
+#define OP_ALG_PKMODE_MOD_INV        0x008
+#define OP_ALG_PKMODE_MOD_ECC_ADD    0x009
+#define OP_ALG_PKMODE_MOD_ECC_DBL    0x00a
+#define OP_ALG_PKMODE_MOD_ECC_MULT   0x00b
+#define OP_ALG_PKMODE_MOD_MONT_CNST  0x00c
+#define OP_ALG_PKMODE_MOD_CRT_CNST   0x00d
+#define OP_ALG_PKMODE_MOD_GCD        0x00e
+#define OP_ALG_PKMODE_MOD_PRIMALITY  0x00f
+
+/* PKHA mode copy-memory functions */
+#define OP_ALG_PKMODE_SRC_REG_SHIFT  13
+#define OP_ALG_PKMODE_SRC_REG_MASK   (7 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_SHIFT  10
+#define OP_ALG_PKMODE_DST_REG_MASK   (7 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_SHIFT  8
+#define OP_ALG_PKMODE_SRC_SEG_MASK   (3 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_SHIFT  6
+#define OP_ALG_PKMODE_DST_SEG_MASK   (3 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+
+#define OP_ALG_PKMODE_SRC_REG_A      (0 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_REG_B      (1 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_REG_N      (3 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_A      (0 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_B      (1 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_E      (2 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_N      (3 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_0      (0 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_1      (1 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_2      (2 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_3      (3 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_0      (0 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_1      (1 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_2      (2 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_3      (3 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_CPYMEM_N_SZ    0x80
+#define OP_ALG_PKMODE_CPYMEM_SRC_SZ  0x81
+
+/*
+ * SEQ_IN_PTR Command Constructs
+ */
+
+/* Release Buffers */
+#define SQIN_RBS               0x04000000
+
+/* Sequence pointer is really a descriptor */
+#define SQIN_INL               0x02000000
+
+/* Sequence pointer is a scatter-gather table */
+#define SQIN_SGF               0x01000000
+
+/* Appends to a previous pointer */
+#define SQIN_PRE               0x00800000
+
+/* Use extended length following pointer */
+#define SQIN_EXT               0x00400000
+
+/* Restore sequence with pointer/length */
+#define SQIN_RTO               0x00200000
+
+/* Replace job descriptor */
+#define SQIN_RJD               0x00100000
+
+#define SQIN_LEN_SHIFT           0
+#define SQIN_LEN_MASK           (0xffff << SQIN_LEN_SHIFT)
+
+/*
+ * SEQ_OUT_PTR Command Constructs
+ */
+
+/* Sequence pointer is a scatter-gather table */
+#define SQOUT_SGF              0x01000000
+
+/* Appends to a previous pointer */
+#define SQOUT_PRE              0x00800000
+
+/* Restore sequence with pointer/length */
+#define SQOUT_RTO              0x00200000
+
+/* Use extended length following pointer */
+#define SQOUT_EXT              0x00400000
+
+#define SQOUT_LEN_SHIFT           0
+#define SQOUT_LEN_MASK           (0xffff << SQOUT_LEN_SHIFT)
+
+
+/*
+ * SIGNATURE Command Constructs
+ */
+
+/* TYPE field is all that's relevant */
+#define SIGN_TYPE_SHIFT         16
+#define SIGN_TYPE_MASK          (0x0f << SIGN_TYPE_SHIFT)
+
+#define SIGN_TYPE_FINAL         (0x00 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_FINAL_RESTORE (0x01 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_FINAL_NONZERO (0x02 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_2         (0x0a << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_3         (0x0b << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_4         (0x0c << SIGN_TYPE_SHIFT)
+
+/*
+ * MOVE Command Constructs
+ */
+
+#define MOVE_AUX_SHIFT          25
+#define MOVE_AUX_MASK           (3 << MOVE_AUX_SHIFT)
+#define MOVE_AUX_MS             (2 << MOVE_AUX_SHIFT)
+#define MOVE_AUX_LS             (1 << MOVE_AUX_SHIFT)
+
+#define MOVE_WAITCOMP_SHIFT     24
+#define MOVE_WAITCOMP_MASK      (1 << MOVE_WAITCOMP_SHIFT)
+#define MOVE_WAITCOMP           (1 << MOVE_WAITCOMP_SHIFT)
+
+#define MOVE_SRC_SHIFT          20
+#define MOVE_SRC_MASK           (0x0f << MOVE_SRC_SHIFT)
+#define MOVE_SRC_CLASS1CTX      (0x00 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_CLASS2CTX      (0x01 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_OUTFIFO        (0x02 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_DESCBUF        (0x03 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH0          (0x04 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH1          (0x05 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH2          (0x06 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH3          (0x07 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_INFIFO         (0x08 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_INFIFO_CL      (0x09 << MOVE_SRC_SHIFT)
+
+#define MOVE_DEST_SHIFT         16
+#define MOVE_DEST_MASK          (0x0f << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS1CTX     (0x00 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2CTX     (0x01 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_OUTFIFO       (0x02 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_DESCBUF       (0x03 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH0         (0x04 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH1         (0x05 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH2         (0x06 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH3         (0x07 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS1INFIFO  (0x08 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2INFIFO  (0x09 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_PK_A          (0x0c << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS1KEY     (0x0d << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2KEY     (0x0e << MOVE_DEST_SHIFT)
+
+#define MOVE_OFFSET_SHIFT       8
+#define MOVE_OFFSET_MASK        (0xff << MOVE_OFFSET_SHIFT)
+
+#define MOVE_LEN_SHIFT          0
+#define MOVE_LEN_MASK           (0xff << MOVE_LEN_SHIFT)
+
+#define MOVELEN_MRSEL_SHIFT     0
+#define MOVELEN_MRSEL_MASK      (0x3 << MOVE_LEN_SHIFT)
+
+/*
+ * MATH Command Constructs
+ */
+
+#define MATH_IFB_SHIFT          26
+#define MATH_IFB_MASK           (1 << MATH_IFB_SHIFT)
+#define MATH_IFB                (1 << MATH_IFB_SHIFT)
+
+#define MATH_NFU_SHIFT          25
+#define MATH_NFU_MASK           (1 << MATH_NFU_SHIFT)
+#define MATH_NFU                (1 << MATH_NFU_SHIFT)
+
+#define MATH_STL_SHIFT          24
+#define MATH_STL_MASK           (1 << MATH_STL_SHIFT)
+#define MATH_STL                (1 << MATH_STL_SHIFT)
+
+/* Function selectors */
+#define MATH_FUN_SHIFT          20
+#define MATH_FUN_MASK           (0x0f << MATH_FUN_SHIFT)
+#define MATH_FUN_ADD            (0x00 << MATH_FUN_SHIFT)
+#define MATH_FUN_ADDC           (0x01 << MATH_FUN_SHIFT)
+#define MATH_FUN_SUB            (0x02 << MATH_FUN_SHIFT)
+#define MATH_FUN_SUBB           (0x03 << MATH_FUN_SHIFT)
+#define MATH_FUN_OR             (0x04 << MATH_FUN_SHIFT)
+#define MATH_FUN_AND            (0x05 << MATH_FUN_SHIFT)
+#define MATH_FUN_XOR            (0x06 << MATH_FUN_SHIFT)
+#define MATH_FUN_LSHIFT         (0x07 << MATH_FUN_SHIFT)
+#define MATH_FUN_RSHIFT         (0x08 << MATH_FUN_SHIFT)
+#define MATH_FUN_SHLD           (0x09 << MATH_FUN_SHIFT)
+#define MATH_FUN_ZBYT           (0x0a << MATH_FUN_SHIFT)
+
+/* Source 0 selectors */
+#define MATH_SRC0_SHIFT         16
+#define MATH_SRC0_MASK          (0x0f << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG0          (0x00 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG1          (0x01 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG2          (0x02 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG3          (0x03 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_IMM           (0x04 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_SEQINLEN      (0x08 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_SEQOUTLEN     (0x09 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_VARSEQINLEN   (0x0a << MATH_SRC0_SHIFT)
+#define MATH_SRC0_VARSEQOUTLEN  (0x0b << MATH_SRC0_SHIFT)
+#define MATH_SRC0_ZERO          (0x0c << MATH_SRC0_SHIFT)
+
+/* Source 1 selectors */
+#define MATH_SRC1_SHIFT         12
+#define MATH_SRC1_MASK          (0x0f << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG0          (0x00 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG1          (0x01 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG2          (0x02 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG3          (0x03 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_IMM           (0x04 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_INFIFO        (0x0a << MATH_SRC1_SHIFT)
+#define MATH_SRC1_OUTFIFO       (0x0b << MATH_SRC1_SHIFT)
+#define MATH_SRC1_ONE           (0x0c << MATH_SRC1_SHIFT)
+
+/* Destination selectors */
+#define MATH_DEST_SHIFT         8
+#define MATH_DEST_MASK          (0x0f << MATH_DEST_SHIFT)
+#define MATH_DEST_REG0          (0x00 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG1          (0x01 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG2          (0x02 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG3          (0x03 << MATH_DEST_SHIFT)
+#define MATH_DEST_SEQINLEN      (0x08 << MATH_DEST_SHIFT)
+#define MATH_DEST_SEQOUTLEN     (0x09 << MATH_DEST_SHIFT)
+#define MATH_DEST_VARSEQINLEN   (0x0a << MATH_DEST_SHIFT)
+#define MATH_DEST_VARSEQOUTLEN  (0x0b << MATH_DEST_SHIFT)
+#define MATH_DEST_NONE          (0x0f << MATH_DEST_SHIFT)
+
+/* Length selectors */
+#define MATH_LEN_SHIFT          0
+#define MATH_LEN_MASK           (0x0f << MATH_LEN_SHIFT)
+#define MATH_LEN_1BYTE          0x01
+#define MATH_LEN_2BYTE          0x02
+#define MATH_LEN_4BYTE          0x04
+#define MATH_LEN_8BYTE          0x08
+
+/*
+ * JUMP Command Constructs
+ */
+
+#define JUMP_CLASS_SHIFT        25
+#define JUMP_CLASS_MASK		(3 << JUMP_CLASS_SHIFT)
+#define JUMP_CLASS_NONE		0
+#define JUMP_CLASS_CLASS1	(1 << JUMP_CLASS_SHIFT)
+#define JUMP_CLASS_CLASS2	(2 << JUMP_CLASS_SHIFT)
+#define JUMP_CLASS_BOTH		(3 << JUMP_CLASS_SHIFT)
+
+#define JUMP_JSL_SHIFT          24
+#define JUMP_JSL_MASK           (1 << JUMP_JSL_SHIFT)
+#define JUMP_JSL                (1 << JUMP_JSL_SHIFT)
+
+#define JUMP_TYPE_SHIFT         22
+#define JUMP_TYPE_MASK          (0x03 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_LOCAL         (0x00 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_NONLOCAL      (0x01 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_HALT          (0x02 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_HALT_USER     (0x03 << JUMP_TYPE_SHIFT)
+
+#define JUMP_TEST_SHIFT         16
+#define JUMP_TEST_MASK          (0x03 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_ALL           (0x00 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_INVALL        (0x01 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_ANY           (0x02 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_INVANY        (0x03 << JUMP_TEST_SHIFT)
+
+/* Condition codes. JSL bit is factored in */
+#define JUMP_COND_SHIFT         8
+#define JUMP_COND_MASK          (0x100ff << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_0          (0x80 << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_GCD_1      (0x40 << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_PRIME      (0x20 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_N        (0x08 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_Z        (0x04 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_C        (0x02 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_NV       (0x01 << JUMP_COND_SHIFT)
+
+#define JUMP_COND_JRP           ((0x80 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_SHRD          ((0x40 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_SELF          ((0x20 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_CALM          ((0x10 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NIP           ((0x08 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NIFP          ((0x04 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NOP           ((0x02 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NCP           ((0x01 << JUMP_COND_SHIFT) | JUMP_JSL)
+
+#define JUMP_OFFSET_SHIFT       0
+#define JUMP_OFFSET_MASK        (0xff << JUMP_OFFSET_SHIFT)
+
+/*
+ * NFIFO ENTRY
+ * Data Constructs
+ *
+ */
+#define NFIFOENTRY_DEST_SHIFT	30
+#define NFIFOENTRY_DEST_MASK	(3 << NFIFOENTRY_DEST_SHIFT)
+#define NFIFOENTRY_DEST_DECO	(0 << NFIFOENTRY_DEST_SHIFT)
+#define NFIFOENTRY_DEST_CLASS1	(1 << NFIFOENTRY_DEST_SHIFT)
+#define NFIFOENTRY_DEST_CLASS2	(2 << NFIFOENTRY_DEST_SHIFT)
+#define NFIFOENTRY_DEST_BOTH	(3 << NFIFOENTRY_DEST_SHIFT)
+
+#define NFIFOENTRY_LC2_SHIFT	29
+#define NFIFOENTRY_LC2_MASK		(1 << NFIFOENTRY_LC2_SHIFT)
+#define NFIFOENTRY_LC2			(1 << NFIFOENTRY_LC2_SHIFT)
+
+#define NFIFOENTRY_LC1_SHIFT	28
+#define NFIFOENTRY_LC1_MASK		(1 << NFIFOENTRY_LC1_SHIFT)
+#define NFIFOENTRY_LC1			(1 << NFIFOENTRY_LC1_SHIFT)
+
+#define NFIFOENTRY_FC2_SHIFT	27
+#define NFIFOENTRY_FC2_MASK		(1 << NFIFOENTRY_FC2_SHIFT)
+#define NFIFOENTRY_FC2			(1 << NFIFOENTRY_FC2_SHIFT)
+
+#define NFIFOENTRY_FC1_SHIFT	26
+#define NFIFOENTRY_FC1_MASK		(1 << NFIFOENTRY_FC1_SHIFT)
+#define NFIFOENTRY_FC1			(1 << NFIFOENTRY_FC1_SHIFT)
+
+#define NFIFOENTRY_STYPE_SHIFT	24
+#define NFIFOENTRY_STYPE_MASK	(3 << NFIFOENTRY_STYPE_SHIFT)
+#define NFIFOENTRY_STYPE_DFIFO	(0 << NFIFOENTRY_STYPE_SHIFT)
+#define NFIFOENTRY_STYPE_OFIFO	(1 << NFIFOENTRY_STYPE_SHIFT)
+#define NFIFOENTRY_STYPE_PAD	(2 << NFIFOENTRY_STYPE_SHIFT)
+#define NFIFOENTRY_STYPE_SNOOP	(3 << NFIFOENTRY_STYPE_SHIFT)
+
+#define NFIFOENTRY_DTYPE_SHIFT	20
+#define NFIFOENTRY_DTYPE_MASK	(0xF << NFIFOENTRY_DTYPE_SHIFT)
+
+#define NFIFOENTRY_DTYPE_SBOX      (0x0  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_AAD       (0x1  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_IV        (0x2  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_SAD       (0x3  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_ICV       (0xA  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_SKIP      (0xE  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_MSG       (0xF  << NFIFOENTRY_DTYPE_SHIFT)
+
+#define NFIFOENTRY_DTYPE_PK_A0     (0x0  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_A1     (0x1  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_A2     (0x2  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_A3     (0x3  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B0     (0x4  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B1     (0x5  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B2     (0x6  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B3     (0x7  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_N      (0x8  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_E      (0x9  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_A      (0xC  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B      (0xD  << NFIFOENTRY_DTYPE_SHIFT)
+
+
+#define NFIFOENTRY_BND_SHIFT	19
+#define NFIFOENTRY_BND_MASK		(1 << NFIFOENTRY_BND_SHIFT)
+#define NFIFOENTRY_BND			(1 << NFIFOENTRY_BND_SHIFT)
+
+#define NFIFOENTRY_PTYPE_SHIFT	16
+#define NFIFOENTRY_PTYPE_MASK	(0x7 << NFIFOENTRY_PTYPE_SHIFT)
+
+#define NFIFOENTRY_PTYPE_ZEROS         (0x0  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_RND_NOZEROS   (0x1  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_INCREMENT     (0x2  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_RND           (0x3  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_ZEROS_NZ      (0x4  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_RND_NZ_LZ     (0x5  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_N             (0x6  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_RND_NZ_N      (0x7  << NFIFOENTRY_PTYPE_SHIFT)
+
+#define NFIFOENTRY_OC_SHIFT		15
+#define NFIFOENTRY_OC_MASK		(1 << NFIFOENTRY_OC_SHIFT)
+#define NFIFOENTRY_OC			(1 << NFIFOENTRY_OC_SHIFT)
+
+#define NFIFOENTRY_AST_SHIFT	14
+#define NFIFOENTRY_AST_MASK		(1 << NFIFOENTRY_OC_SHIFT)
+#define NFIFOENTRY_AST			(1 << NFIFOENTRY_OC_SHIFT)
+
+#define NFIFOENTRY_BM_SHIFT		11
+#define NFIFOENTRY_BM_MASK		(1 << NFIFOENTRY_BM_SHIFT)
+#define NFIFOENTRY_BM			(1 << NFIFOENTRY_BM_SHIFT)
+
+#define NFIFOENTRY_PS_SHIFT		10
+#define NFIFOENTRY_PS_MASK		(1 << NFIFOENTRY_PS_SHIFT)
+#define NFIFOENTRY_PS			(1 << NFIFOENTRY_PS_SHIFT)
+
+
+#define NFIFOENTRY_DLEN_SHIFT	0
+#define NFIFOENTRY_DLEN_MASK	(0xFFF << NFIFOENTRY_DLEN_SHIFT)
+
+#define NFIFOENTRY_PLEN_SHIFT	0
+#define NFIFOENTRY_PLEN_MASK	(0xFF << NFIFOENTRY_PLEN_SHIFT)
+
+/*
+ * PDB internal definitions
+ */
+
+/* IPSec ESP CBC Encap/Decap Options */
+#define PDBOPTS_ESPCBC_ARSNONE  0x00   /* no antireplay window              */
+#define PDBOPTS_ESPCBC_ARS32    0x40   /* 32-entry antireplay window        */
+#define PDBOPTS_ESPCBC_ARS64    0xc0   /* 64-entry antireplay window        */
+#define PDBOPTS_ESPCBC_IVSRC    0x20   /* IV comes from internal random gen */
+#define PDBOPTS_ESPCBC_ESN      0x10   /* extended sequence included        */
+#define PDBOPTS_ESPCBC_OUTFMT   0x08   /* output only decapsulation (decap) */
+#define PDBOPTS_ESPCBC_IPHDRSRC 0x08   /* IP header comes from PDB (encap)  */
+#define PDBOPTS_ESPCBC_INCIPHDR 0x04   /* Prepend IP header to output frame */
+#define PDBOPTS_ESPCBC_IPVSN    0x02   /* process IPv6 header               */
+#define PDBOPTS_ESPCBC_TUNNEL   0x01   /* tunnel mode next-header byte      */
+
+#endif /* DESC_H */
diff --git a/include/desc_constr.h b/include/desc_constr.h
new file mode 100644
index 0000000..e3e778f
--- /dev/null
+++ b/include/desc_constr.h
@@ -0,0 +1,200 @@
+/*
+ * caam descriptor construction helper functions
+ *
+ * Copyright 2008-2011, 2012 Freescale Semiconductor, Inc.
+ */
+
+#include "desc.h"
+
+#define IMMEDIATE (1 << 23)
+#define CAAM_CMD_SZ sizeof(u32)
+#define CAAM_PTR_SZ sizeof(dma_addr_t)
+#define CAAM_DESC_BYTES_MAX (CAAM_CMD_SZ * 64)
+
+#define PRINT_POS
+
+#define DISABLE_AUTO_INFO_FIFO (IMMEDIATE | LDST_CLASS_DECO | \
+				LDST_SRCDST_WORD_DECOCTRL | \
+				(LDOFF_DISABLE_AUTO_NFIFO << LDST_OFFSET_SHIFT))
+#define ENABLE_AUTO_INFO_FIFO (IMMEDIATE | LDST_CLASS_DECO | \
+			       LDST_SRCDST_WORD_DECOCTRL | \
+			       (LDOFF_ENABLE_AUTO_NFIFO << LDST_OFFSET_SHIFT))
+
+static inline int desc_len(u32 *desc)
+{
+	return *desc & HDR_DESCLEN_MASK;
+}
+
+static inline int desc_bytes(void *desc)
+{
+	return desc_len(desc) * CAAM_CMD_SZ;
+}
+
+static inline u32 *desc_end(u32 *desc)
+{
+	return desc + desc_len(desc);
+}
+
+static inline void *sh_desc_pdb(u32 *desc)
+{
+	return desc + 1;
+}
+
+static inline void init_desc(u32 *desc, u32 options)
+{
+	*desc = options | HDR_ONE | 1;
+}
+
+static inline void init_sh_desc(u32 *desc, u32 options)
+{
+	PRINT_POS;
+	init_desc(desc, CMD_SHARED_DESC_HDR | options);
+}
+
+static inline void init_sh_desc_pdb(u32 *desc, u32 options, size_t pdb_bytes)
+{
+	u32 pdb_len = pdb_bytes / CAAM_CMD_SZ + 1;
+
+	init_sh_desc(desc, ((pdb_len << HDR_START_IDX_SHIFT) + pdb_len) |
+		     options);
+}
+
+static inline void init_job_desc(u32 *desc, u32 options)
+{
+	init_desc(desc, CMD_DESC_HDR | options);
+}
+
+static inline void append_ptr(u32 *desc, dma_addr_t ptr)
+{
+	dma_addr_t *offset = (dma_addr_t *)desc_end(desc);
+
+	*offset = ptr;
+
+	(*desc) += CAAM_PTR_SZ / CAAM_CMD_SZ;
+}
+
+static inline void init_job_desc_shared(u32 *desc, dma_addr_t ptr, int len,
+					u32 options)
+{
+	PRINT_POS;
+	init_job_desc(desc, HDR_SHARED | options |
+		      (len << HDR_START_IDX_SHIFT));
+	append_ptr(desc, ptr);
+}
+
+static inline void append_data(u32 *desc, void *data, int len)
+{
+	u32 *offset = desc_end(desc);
+
+	if (len) /* avoid sparse warning: memcpy with byte count of 0 */
+		memcpy(offset, data, len);
+
+	(*desc) += (len + CAAM_CMD_SZ - 1) / CAAM_CMD_SZ;
+}
+
+static inline void append_cmd(u32 *desc, u32 command)
+{
+	u32 *cmd = desc_end(desc);
+
+	*cmd = command;
+
+	(*desc)++;
+}
+
+static inline void append_cmd_ptr(u32 *desc, dma_addr_t ptr, int len,
+				  u32 command)
+{
+	append_cmd(desc, command | len);
+	append_ptr(desc, ptr);
+}
+
+static inline void append_cmd_data(u32 *desc, void *data, int len,
+				   u32 command)
+{
+	append_cmd(desc, command | IMMEDIATE | len);
+	append_data(desc, data, len);
+}
+
+static inline u32 *append_jump(u32 *desc, u32 options)
+{
+	u32 *cmd = desc_end(desc);
+
+	PRINT_POS;
+	append_cmd(desc, CMD_JUMP | options);
+
+	return cmd;
+}
+
+static inline void set_jump_tgt_here(u32 *desc, u32 *jump_cmd)
+{
+	*jump_cmd = *jump_cmd | (desc_len(desc) - (jump_cmd - desc));
+}
+
+#define APPEND_CMD(cmd, op) \
+static inline void append_##cmd(u32 *desc, u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd(desc, CMD_##op | options); \
+}
+APPEND_CMD(operation, OPERATION)
+APPEND_CMD(move, MOVE)
+
+#define APPEND_CMD_LEN(cmd, op) \
+static inline void append_##cmd(u32 *desc, unsigned int len, u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd(desc, CMD_##op | len | options); \
+}
+APPEND_CMD_LEN(seq_store, SEQ_STORE)
+APPEND_CMD_LEN(seq_fifo_load, SEQ_FIFO_LOAD)
+APPEND_CMD_LEN(seq_fifo_store, SEQ_FIFO_STORE)
+
+#define APPEND_CMD_PTR(cmd, op) \
+static inline void append_##cmd(u32 *desc, dma_addr_t ptr, unsigned int len, \
+				u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd_ptr(desc, ptr, len, CMD_##op | options); \
+}
+APPEND_CMD_PTR(key, KEY)
+APPEND_CMD_PTR(seq_in_ptr, SEQ_IN_PTR)
+APPEND_CMD_PTR(seq_out_ptr, SEQ_OUT_PTR)
+APPEND_CMD_PTR(load, LOAD)
+APPEND_CMD_PTR(store, STORE)
+APPEND_CMD_PTR(fifo_load, FIFO_LOAD)
+APPEND_CMD_PTR(fifo_store, FIFO_STORE)
+
+#define APPEND_CMD_PTR_TO_IMM(cmd, op) \
+static inline void append_##cmd##_as_imm(u32 *desc, void *data, \
+					 unsigned int len, u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd_data(desc, data, len, CMD_##op | options); \
+}
+APPEND_CMD_PTR_TO_IMM(load, LOAD);
+APPEND_CMD_PTR_TO_IMM(fifo_load, FIFO_LOAD);
+
+/*
+ * 2nd variant for commands whose specified immediate length differs
+ * from length of immediate data provided, e.g., split keys
+ */
+#define APPEND_CMD_PTR_TO_IMM2(cmd, op) \
+static inline void append_##cmd##_as_imm(u32 *desc, void *data, \
+					 unsigned int data_len, \
+					 unsigned int len, u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd(desc, CMD_##op | IMMEDIATE | len | options); \
+	append_data(desc, data, data_len); \
+}
+APPEND_CMD_PTR_TO_IMM2(key, KEY);
+
+#define APPEND_CMD_RAW_IMM(cmd, op, type) \
+static inline void append_##cmd##_imm_##type(u32 *desc, type immediate, \
+					     u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd(desc, CMD_##op | IMMEDIATE | options | sizeof(type)); \
+	append_cmd(desc, immediate); \
+}
+APPEND_CMD_RAW_IMM(load, LOAD, u32);
diff --git a/include/fdtdec.h b/include/fdtdec.h
index f77d195..ae1ae7d 100644
--- a/include/fdtdec.h
+++ b/include/fdtdec.h
@@ -78,7 +78,10 @@ enum fdt_compat_id {
 	COMPAT_SAMSUNG_EXYNOS_SPI,	/* Exynos SPI */
 	COMPAT_SAMSUNG_EXYNOS_EHCI,	/* Exynos EHCI controller */
 	COMPAT_SAMSUNG_EXYNOS_USB_PHY,	/* Exynos phy controller for usb2.0 */
+    COMPAT_SAMSUNG_EXYNOS_TMU,      /* Exynos TMU */
 	COMPAT_MAXIM_MAX77686_PMIC,	/* MAX77686 PMIC */
+    COMPAT_GENERIC_SPI_FLASH,       /* Generic SPI Flash chip */
+    COMPAT_MAXIM_98095_CODEC,       /* MAX98095 Codec */
 
 	COMPAT_COUNT,
 };
diff --git a/include/fm_eth.h b/include/fm_eth.h
index 495765b..3a566fe 100644
--- a/include/fm_eth.h
+++ b/include/fm_eth.h
@@ -88,7 +88,7 @@ enum fm_eth_type {
 
 #define FM_TGEC_INFO_INITIALIZER(idx, n) \
 {									\
-	FM_ETH_INFO_INITIALIZER(idx, CONFIG_SYS_FM1_TGEC_MDIO_ADDR)	\
+	FM_ETH_INFO_INITIALIZER(idx, CONFIG_SYS_FM2_TGEC_MDIO_ADDR)	\
 	.index		= idx,						\
 	.num		= n - 1,					\
 	.type		= FM_ETH_10G_E,					\
@@ -96,7 +96,7 @@ enum fm_eth_type {
 	.rx_port_id	= RX_PORT_10G_BASE + n - 1,			\
 	.tx_port_id	= TX_PORT_10G_BASE + n - 1,			\
 	.compat_offset	= CONFIG_SYS_FSL_FM##idx##_OFFSET +		\
-				offsetof(struct ccsr_fman, memac[n-1]),\
+				offsetof(struct ccsr_fman, memac[n-1+8]),\
 }
 #else
 #define FM_DTSEC_INFO_INITIALIZER(idx, n) \
@@ -151,6 +151,14 @@ struct memac_mdio_info {
 	char *name;
 };
 
+struct fixed_link {
+	int phy_id;
+	int duplex;
+	int link_speed;
+	int pause;
+	int asym_pause;
+};
+
 int fm_tgec_mdio_init(bd_t *bis, struct tgec_mdio_info *info);
 int fm_memac_mdio_init(bd_t *bis, struct memac_mdio_info *info);
 
diff --git a/include/fsl_secboot_err.h b/include/fsl_secboot_err.h
new file mode 100644
index 0000000..3f6ced6
--- /dev/null
+++ b/include/fsl_secboot_err.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _FSL_SECBOOT_ERR_H
+#define _FSL_SECBOOT_ERR_H
+
+#define ERROR_ESBC_PAMU_INIT					0x100000
+#define ERROR_ESBC_SEC_RESET					0x200000
+#define ERROR_ESBC_SEC_INIT					0x400000
+#define ERROR_ESBC_SEC_DEQ					0x800000
+#define ERROR_ESBC_SEC_DEQ_TO					0x1000000
+#define ERROR_ESBC_SEC_ENQ					0x2000000
+#define ERROR_ESBC_SEC_JOBQ_STATUS				0x4000000
+#define ERROR_ESBC_CLIENT_CPUID_NO_MATCH			0x1
+#define ERROR_ESBC_CLIENT_HDR_LOC				0x2
+#define ERROR_ESBC_CLIENT_HEADER_BARKER				0x4
+#define ERROR_ESBC_CLIENT_HEADER_KEY_LEN			0x8
+#define ERROR_ESBC_CLIENT_HEADER_SIG_LEN			0x10
+#define ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN	0x20
+#define ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1			0x40
+#define ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2			0x80
+#define ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD			0x100
+#define ERROR_ESBC_CLIENT_HEADER_SG_ESBC_EP			0x200
+#define ERROR_ESBC_CLIENT_HASH_COMPARE_KEY			0x400
+#define ERROR_ESBC_CLIENT_HASH_COMPARE_EM			0x800
+#define ERROR_ESBC_CLIENT_SSM_TRUSTSTS				0x1000
+#define ERROR_ESBC_CLIENT_BAD_ADDRESS				0x2000
+#define ERROR_ESBC_CLIENT_MISC					0x4000
+#define ERROR_ESBC_CLIENT_HEADER_SG_ENTIRES_BAD			0x8000
+#define ERROR_ESBC_CLIENT_HEADER_SG				0x10000
+#define ERROR_ESBC_CLIENT_HEADER_IMG_SIZE			0x20000
+#define ERROR_ESBC_WRONG_CMD					0x40000
+#define ERROR_ESBC_MISSING_BOOTM				0x80000
+#define ERROR_ESBC_CLIENT_MAX					0x0
+
+struct fsl_secboot_errcode {
+	int errcode;
+	const char *name;
+};
+
+static const struct fsl_secboot_errcode fsl_secboot_errcodes[] = {
+	{ ERROR_ESBC_PAMU_INIT,
+		"Error in initializing PAMU"},
+	{ ERROR_ESBC_SEC_RESET,
+		"Error in resetting Job ring of SEC"},
+	{ ERROR_ESBC_SEC_INIT,
+		"Error in initializing SEC"},
+	{ ERROR_ESBC_SEC_ENQ,
+		"Error in enqueue operation by SEC"},
+	{ ERROR_ESBC_SEC_DEQ_TO,
+		"Dequeue operation by SEC is timed out"},
+	{ ERROR_ESBC_SEC_DEQ,
+		"Error in dequeue operation by SEC"},
+	{ ERROR_ESBC_SEC_JOBQ_STATUS,
+		"Error in status of the job submitted to SEC"},
+	{ ERROR_ESBC_CLIENT_CPUID_NO_MATCH,
+		"Current core is not boot core i.e core0" },
+	{ ERROR_ESBC_CLIENT_HDR_LOC,
+		"Header address not in allowed memory range" },
+	{ ERROR_ESBC_CLIENT_HEADER_BARKER,
+		"Wrong barker code in header" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_LEN,
+		"Wrong public key length in header" },
+	{ ERROR_ESBC_CLIENT_HEADER_SIG_LEN,
+		"Wrong signature length in header" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN,
+		"Public key length not twice of signature length" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1,
+		"Public key Modulus most significant bit not set" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2,
+		"Public key Modulus in header not odd" },
+	{ ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD,
+		"Signature not less than modulus" },
+	{ ERROR_ESBC_CLIENT_HEADER_SG_ESBC_EP,
+		"Entry point not in allowed space or one of the SG entries" },
+	{ ERROR_ESBC_CLIENT_HASH_COMPARE_KEY,
+		"Public key hash comparison failed" },
+	{ ERROR_ESBC_CLIENT_HASH_COMPARE_EM,
+		"RSA verification failed" },
+	{ ERROR_ESBC_CLIENT_SSM_TRUSTSTS,
+		"SNVS not in TRUSTED state" },
+	{ ERROR_ESBC_CLIENT_BAD_ADDRESS,
+		"Bad address error" },
+	{ ERROR_ESBC_CLIENT_MISC,
+		"Miscallaneous error" },
+	{ ERROR_ESBC_CLIENT_HEADER_SG,
+		"No SG support"  },
+	{ ERROR_ESBC_WRONG_CMD,
+		"Failure in command/Unknown command/Wrong arguments," \
+		" Core in infinite loop"},
+	{ ERROR_ESBC_MISSING_BOOTM,
+		"Bootm command missing from bootscript"},
+	{ ERROR_ESBC_CLIENT_MAX, "NULL" }
+};
+
+void fsl_secboot_handle_error(int error);
+#endif
diff --git a/include/fsl_secboot_types.h b/include/fsl_secboot_types.h
new file mode 100644
index 0000000..f66c822
--- /dev/null
+++ b/include/fsl_secboot_types.h
@@ -0,0 +1,17 @@
+/*
+ * Portions Copyrighted by Freescale Semiconductor, Inc., 2010-2012
+ */
+
+#ifndef __FSL_SECBOOT_TYPES_H_
+#define __FSL_SECBOOT_TYPES_H_
+
+#include <linux/types.h>
+
+#define WORD_SIZE 4
+
+/* Minimum and maximum size of RSA signature length in bits */
+#define KEY_SIZE       4096
+#define KEY_SIZE_BYTES (KEY_SIZE/8)
+#define KEY_SIZE_WORDS (KEY_SIZE_BYTES/(WORD_SIZE))
+
+#endif
diff --git a/include/fsl_validate.h b/include/fsl_validate.h
new file mode 100644
index 0000000..a4ddcea
--- /dev/null
+++ b/include/fsl_validate.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _FSL_VALIDATE_H_
+#define _FSL_VALIDATE_H_
+
+#include <fsl_secboot_types.h>
+#include <command.h>
+
+/* Barker code size in bytes */
+#define ESBC_BARKER_LEN	4	/* barker code length in ESBC uboot client */
+				/* header */
+
+/* No-error return values */
+#define ESBC_VALID_HDR	0	/* header is valid */
+
+/* Maximum number of SG entries allowed */
+#define MAX_SG_ENTRIES	8
+
+/*
+ * ESBC uboot client header structure.
+ * The struct contain the following fields
+ * barker code
+ * public key offset
+ * pub key length
+ * signature offset
+ * length of the signature
+ * ptr to SG table
+ * no of entries in SG table
+ * esbc ptr
+ * size of esbc
+ * esbc entry point
+ * Scatter gather flag
+ * UID flag
+ * FSL UID
+ * OEM UID
+ * Here, pub key is modulus concatenated with exponent
+ * of equal length
+ */
+struct fsl_secboot_img_hdr {
+	u8 barker[ESBC_BARKER_LEN];	/* barker code */
+	u32 pkey;		/* public key offset */
+	u32 key_len;		/* pub key length in bytes */
+	u32 psign;		/* signature offset */
+	u32 sign_len;		/* length of the signature in bytes */
+	union {
+		struct fsl_secboot_sg_table *psgtable;	/* ptr to SG table */
+		u8 *pimg;	/* ptr to ESBC client image */
+	};
+	union {
+		u32 sg_entries;	/* no of entries in SG table */
+		u32 img_size;	/* ESBC client image size in bytes */
+	};
+	ulong img_start;		/* ESBC client entry point */
+	u32 sg_flag;		/* Scatter gather flag */
+	u32 uid_flag;		/* Flag to indicate uid is present or not */
+	u32 fsl_uid;		/* Freescale unique id */
+	u32 oem_uid;		/* OEM unique id */
+};
+
+/*
+ * SG table.
+ * This struct contains the following fields
+ * length of the segment
+ * pointer to data segment
+ */
+struct fsl_secboot_sg_table {
+	u32 len;		/* length of the segment in bytes */
+	u8 *pdata;		/* ptr to the data segment */
+};
+
+/*
+ * ESBC private structure.
+ * Private structure used by ESBC to store following fields
+ * ESBC client key
+ * ESBC client key hash
+ * ESBC client Signature
+ * Encoded hash recovered from signature
+ * Encoded hash of ESBC client header plus ESBC client image
+ */
+struct fsl_secboot_img_priv {
+	uint32_t hdr_location;
+	struct fsl_secboot_img_hdr hdr;
+
+	u8 img_key[2 * KEY_SIZE_BYTES];	/* ESBC client key */
+	u8 img_key_hash[32];	/* ESBC client key hash */
+
+	u8 img_sign[KEY_SIZE_BYTES];		/* ESBC client signature */
+
+	u8 img_encoded_hash[KEY_SIZE_BYTES];	/* EM wrt RSA PKCSv1.5  */
+						/* Includes hash recovered after
+						 * signature verification
+						 */
+
+	u8 img_encoded_hash_second[KEY_SIZE_BYTES];/* EM' wrt RSA PKCSv1.5 */
+						/* Includes hash of
+						 * ESBC client header plus
+						 * ESBC client image
+						 */
+
+	struct fsl_secboot_sg_table sgtbl[MAX_SG_ENTRIES];	/* SG table */
+	u32 ehdrloc;		/* ESBC client location */
+};
+
+int fsl_secboot_validate(cmd_tbl_t *cmdtp, int flag, int argc,
+		char * const argv[]);
+int fsl_secboot_blob_encap(cmd_tbl_t *cmdtp, int flag, int argc,
+	char * const argv[]);
+int fsl_secboot_blob_decap(cmd_tbl_t *cmdtp, int flag, int argc,
+	char * const argv[]);
+
+#endif
diff --git a/include/i2c.h b/include/i2c.h
index c60d075..46461a5 100644
--- a/include/i2c.h
+++ b/include/i2c.h
@@ -47,7 +47,7 @@
 #define I2C_RXTX_LEN	128	/* maximum tx/rx buffer length */
 
 #ifdef	CONFIG_I2C_MULTI_BUS
-#define	MAX_I2C_BUS			2
+#define	MAX_I2C_BUS			4
 #define	I2C_MULTI_BUS			1
 #else
 #define	MAX_I2C_BUS			1
diff --git a/include/jobdesc.h b/include/jobdesc.h
new file mode 100644
index 0000000..c3398a6
--- /dev/null
+++ b/include/jobdesc.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __JOBDESC_H
+#define __JOBDESC_H
+
+#include <common.h>
+#include <sha.h>
+#include <rsa_sec.h>
+
+#define KEY_IDNFR_SZ_BYTES		16
+
+void inline_cnstr_jobdesc_pkha_rsaexp(uint32_t *desc,
+			      struct pk_in_params *pkin, uint8_t *out,
+			      uint32_t out_siz);
+
+void inline_cnstr_jobdesc_sha256(uint32_t *desc,
+	uint8_t *msg, uint32_t msgsz, uint8_t *digest);
+
+void inline_cnstr_jobdesc_blob_encap(uint32_t *desc, uint8_t *key_idnfr,
+				     uint8_t *plain_txt, uint8_t *enc_blob,
+				     uint32_t in_sz);
+
+void inline_cnstr_jobdesc_blob_decap(uint32_t *desc, uint8_t *key_idnfr,
+				     uint8_t *enc_blob, uint8_t *plain_txt,
+				     uint32_t out_sz);
+
+#endif
diff --git a/include/jr.h b/include/jr.h
new file mode 100644
index 0000000..d0ccb6f
--- /dev/null
+++ b/include/jr.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __JR_H
+#define __JR_H
+
+#include <linux/compiler.h>
+
+#define JR_SIZE 4
+/* Timeout currently defined as 10 sec */
+#define CONFIG_SEC_DEQ_TIMEOUT	10000000U
+
+#define DEFAULT_JR_ID		0
+#define DEFAULT_JR_LIODN	0
+#define DEFAULT_IRQ		0	/* Interrupts not to be configured */
+
+#define MCFGR_SWRST       ((uint32_t)(1)<<31) /* Software Reset */
+#define MCFGR_DMA_RST     ((uint32_t)(1)<<28) /* DMA Reset */
+#define MCFGR_PS_SHIFT          16
+#define JR_INTMASK	  0x00000001
+#define JRCR_RESET                  0x01
+#define JRINT_ERR_HALT_INPROGRESS   0x4
+#define JRINT_ERR_HALT_MASK         0xc
+#define JRNSLIODN_SHIFT		16
+#define JRNSLIODN_MASK		0x0fff0000
+#define JRSLIODN_SHIFT		0
+#define JRSLIODN_MASK		0x00000fff
+
+#define JQ_DEQ_ERR		-1
+#define JQ_DEQ_TO_ERR		-2
+#define JQ_ENQ_ERR		-3
+
+struct op_ring {
+	dma_addr_t desc;
+	uint32_t status;
+} __packed;
+
+typedef struct jr_info {
+	void (*callback)(dma_addr_t desc, uint32_t status, void *arg);
+	dma_addr_t desc_phys_addr;
+	uint32_t desc_addr;
+	uint32_t desc_len;
+	uint32_t op_done;
+	void *arg;
+} jr_info_t;
+
+typedef struct jobring {
+	int jq_id;
+	int irq;
+	int liodn;
+	/* Head is the index where software would enq the descriptor in
+	 * the i/p ring
+	 */
+	int head;
+	/* Tail index would be used by s/w ehile enqueuing to determine if
+	 * there is any space left in the s/w maintained i/p rings
+	 */
+	/* Also in case of deq tail will be incremented only in case of
+	 * in-order job completion
+	 */
+	int tail;
+	/* Read index of the output ring. It may not match with tail in case
+	 * of out of order completetion
+	 */
+	int read_idx;
+	/* Write index to input ring. Would be always equal to head */
+	int write_idx;
+	/* Size of the rings. */
+	int size;
+	/* The ip and output rings have to be accessed by SEC. So the
+	 * pointers will ahve to point to the housekeeping region provided
+	 * by SEC
+	 */
+	/*Circular  Ring of i/p descriptors */
+	dma_addr_t *input_ring;
+	/* Circular Ring of o/p descriptors */
+	/* Circula Ring containing info regarding descriptors in i/p
+	 * and o/p ring
+	 */
+	/* This ring can be on the stack */
+	jr_info_t info[JR_SIZE];
+	struct op_ring *output_ring;
+} jobring_t;
+
+struct result {
+	int done;
+	int err;
+	uint32_t status;
+	char outstr[256];
+};
+
+int sec_init(struct jobring *jr);
+u8 get_rng_vid(void);
+int rng_init(struct jobring *jr);
+int jr_enqueue(struct jobring *jr, uint32_t *desc_addr,
+		void (*callback)(uint32_t desc, uint32_t status, void *arg),
+		void *arg);
+int jr_dequeue(struct jobring *jr);
+int caam_jr_strstatus(char *outstr, u32 status);
+int jr_reset(struct jobring *jr);
+
+#endif
diff --git a/include/mmc.h b/include/mmc.h
index a13e2bd..7b7dfe5 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -233,7 +233,6 @@ struct mmc {
 	void *priv;
 	uint voltages;
 	uint version;
-	uint has_init;
 	uint f_min;
 	uint f_max;
 	int high_capacity;
diff --git a/include/pci.h b/include/pci.h
index 15f583f..c0ed553 100644
--- a/include/pci.h
+++ b/include/pci.h
@@ -426,13 +426,6 @@
 #define PCI_MAX_PCI_DEVICES	32
 #define PCI_MAX_PCI_FUNCTIONS	8
 
-#define PCI_DCR		0x54    /* PCIe Device Control Register */
-#define PCI_DSR		0x56    /* PCIe Device Status Register */
-#define PCI_LSR		0x5e    /* PCIe Link Status Register */
-#define PCI_LCR		0x5c    /* PCIe Link Control Register */
-#define PCI_LTSSM	0x404   /* PCIe Link Training, Status State Machine */
-#define  PCI_LTSSM_L0	0x16    /* L0 state */
-
 /* Include the ID list */
 
 #include <pci_ids.h>
diff --git a/include/phy.h b/include/phy.h
index 3c30f11..c952e9e 100644
--- a/include/phy.h
+++ b/include/phy.h
@@ -52,6 +52,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_MII,
 	PHY_INTERFACE_MODE_GMII,
 	PHY_INTERFACE_MODE_SGMII,
+	PHY_INTERFACE_MODE_QSGMII,
 	PHY_INTERFACE_MODE_TBI,
 	PHY_INTERFACE_MODE_RMII,
 	PHY_INTERFACE_MODE_RGMII,
@@ -67,6 +68,7 @@ static const char *phy_interface_strings[] = {
 	[PHY_INTERFACE_MODE_MII]		= "mii",
 	[PHY_INTERFACE_MODE_GMII]		= "gmii",
 	[PHY_INTERFACE_MODE_SGMII]		= "sgmii",
+	[PHY_INTERFACE_MODE_QSGMII]		= "qsgmii",
 	[PHY_INTERFACE_MODE_TBI]		= "tbi",
 	[PHY_INTERFACE_MODE_RMII]		= "rmii",
 	[PHY_INTERFACE_MODE_RGMII]		= "rgmii",
diff --git a/include/rsa_sec.h b/include/rsa_sec.h
new file mode 100644
index 0000000..21d66b6
--- /dev/null
+++ b/include/rsa_sec.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __RSA_SEC_H
+#define __RSA_SEC_H
+
+#include <common.h>
+#include <jr.h>
+
+struct pk_in_params {
+	uint8_t *e;
+	uint32_t e_siz;
+	uint8_t *n;
+	uint32_t n_siz;
+	uint8_t *a;
+	uint32_t a_siz;
+	uint8_t *b;
+	uint32_t b_siz;
+};
+
+struct rsa_context {
+	struct pk_in_params pkin;
+	uint32_t rsa_desc[64];
+	struct result op;
+};
+
+int rsa_public_verif_sec(unsigned char *sign, uint8_t *to, uint8_t *rsa_pub_key,
+			int klen, struct rsa_context *ctx, struct jobring *jr);
+
+#endif
diff --git a/include/sha.h b/include/sha.h
new file mode 100644
index 0000000..c65635d
--- /dev/null
+++ b/include/sha.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SHA_H
+#define _SHA_H
+
+#include <jr.h>
+
+/* number of bytes in the SHA256-256 digest */
+#define SHA256_DIGEST_SIZE 32
+
+/*
+ * number of words in the digest - Digest is kept internally
+ * as 8 32-bit words
+ */
+#define _SHA256_DIGEST_LENGTH 8
+
+/*
+ * block length - A block, treated as a sequence of
+ * 32-bit words
+ */
+#define SHA256_BLOCK_LENGTH 16
+
+/* number of bytes in the block */
+#define SHA256_DATA_SIZE 64
+
+#define MAX_SG		12
+
+/*
+ * Scatter Gather Entry - Speicifies the the Scatter Gather Format
+ * related information
+ */
+struct sg_entry {
+	uint16_t reserved_zero;
+	uint16_t addr_hi;	/* Memory Address of the start of the
+				 * buffer - hi
+				 */
+	uint32_t addr_lo;	/* Memory Address - lo */
+	unsigned int extension:1;
+	unsigned int final:1;
+	unsigned int length:30;	/* Length of the data in the frame */
+	uint8_t reserved_zero2;
+	uint8_t bpid;		/* Buffer Pool Id */
+	unsigned int reserved_offset:3;
+	unsigned int offset:13;
+};
+
+/*
+ * SHA256-256 context
+ * contain the following fields
+ * State
+ * count low
+ * count high
+ * block data buffer
+ * index to the buffer
+ */
+struct sha_ctx {
+	struct sg_entry sg_tbl[MAX_SG];
+	uint32_t sha_desc[64];
+	u8 hash[SHA256_DIGEST_SIZE];
+	struct result op;
+	uint32_t sg_num;
+	struct jobring *jr;
+};
+
+void sha_init(struct sha_ctx *ctx, struct jobring *jr);
+void sha_update(struct sha_ctx *ctx, uint8_t *data, uint32_t length);
+int sha_final(struct sha_ctx *ctx);
+int sha_digest(struct sha_ctx *ctx, uint8_t *digest);
+
+#endif
diff --git a/include/spi.h b/include/spi.h
index 60e85db..ffd6647 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -1,31 +1,15 @@
 /*
+ * Common SPI Interface: Controller-specific definitions
+ *
  * (C) Copyright 2001
  * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #ifndef _SPI_H_
 #define _SPI_H_
 
-/* Controller-specific definitions: */
-
 /* SPI mode flags */
 #define	SPI_CPHA	0x01			/* clock phase */
 #define	SPI_CPOL	0x02			/* clock polarity */
@@ -37,32 +21,116 @@
 #define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
 #define	SPI_3WIRE	0x10			/* SI/SO signals shared */
 #define	SPI_LOOP	0x20			/* loopback mode */
+#define	SPI_SLAVE	0x40			/* slave mode */
+#define	SPI_PREAMBLE	0x80			/* Skip preamble bytes */
 
 /* SPI transfer flags */
-#define SPI_XFER_BEGIN	0x01			/* Assert CS before transfer */
-#define SPI_XFER_END	0x02			/* Deassert CS after transfer */
+#define SPI_XFER_BEGIN		0x01	/* Assert CS before transfer */
+#define SPI_XFER_END		0x02	/* Deassert CS after transfer */
+#define SPI_XFER_MMAP		0x08	/* Memory Mapped start */
+#define SPI_XFER_MMAP_END	0x10	/* Memory Mapped End */
+#define SPI_XFER_ONCE		(SPI_XFER_BEGIN | SPI_XFER_END)
+#define SPI_XFER_U_PAGE		(1 << 5)
+
+/* SPI TX operation modes */
+#define SPI_OPM_TX_QPP		1 << 0
+
+/* SPI RX operation modes */
+#define SPI_OPM_RX_AS		1 << 0
+#define SPI_OPM_RX_DOUT		1 << 1
+#define SPI_OPM_RX_DIO		1 << 2
+#define SPI_OPM_RX_QOF		1 << 3
+#define SPI_OPM_RX_QIOF		1 << 4
+#define SPI_OPM_RX_EXTN		SPI_OPM_RX_AS | SPI_OPM_RX_DOUT | \
+				SPI_OPM_RX_DIO | SPI_OPM_RX_QOF | \
+				SPI_OPM_RX_QIOF
+
+/* SPI bus connection options */
+#define SPI_CONN_DUAL_SHARED	1 << 0
+#define SPI_CONN_DUAL_SEPARATED	1 << 1
+
+/* Header byte that marks the start of the message */
+#define SPI_PREAMBLE_END_BYTE	0xec
 
-/*-----------------------------------------------------------------------
- * Representation of a SPI slave, i.e. what we're communicating with.
+#define SPI_DEFAULT_WORDLEN 8
+
+/**
+ * struct spi_slave - Representation of a SPI slave
  *
  * Drivers are expected to extend this with controller-specific data.
  *
- *   bus:	ID of the bus that the slave is attached to.
- *   cs:	ID of the chip select connected to the slave.
+ * @bus:		ID of the bus that the slave is attached to.
+ * @cs:			ID of the chip select connected to the slave.
+ * @op_mode_rx:		SPI RX operation mode.
+ * @op_mode_tx:		SPI TX operation mode.
+ * @wordlen:		Size of SPI word in number of bits
+ * @max_write_size:	If non-zero, the maximum number of bytes which can
+ *			be written at once, excluding command bytes.
+ * @memory_map:		Address of read-only SPI flash access.
+ * @option:		Varies SPI bus options - separate, shared bus.
+ * @flags:		Indication of SPI flags.
  */
 struct spi_slave {
-	unsigned int	bus;
-	unsigned int	cs;
+	unsigned int bus;
+	unsigned int cs;
+	u8 op_mode_rx;
+	u8 op_mode_tx;
+	unsigned int wordlen;
+	unsigned int max_write_size;
+	void *memory_map;
+	u8 option;
+	u8 flags;
 };
 
-/*-----------------------------------------------------------------------
+/**
  * Initialization, must be called once on start up.
  *
  * TODO: I don't think we really need this.
  */
 void spi_init(void);
 
-/*-----------------------------------------------------------------------
+/**
+ * spi_do_alloc_slave - Allocate a new SPI slave (internal)
+ *
+ * Allocate and zero all fields in the spi slave, and set the bus/chip
+ * select. Use the helper macro spi_alloc_slave() to call this.
+ *
+ * @offset:	Offset of struct spi_slave within slave structure.
+ * @size:	Size of slave structure.
+ * @bus:	Bus ID of the slave chip.
+ * @cs:		Chip select ID of the slave chip on the specified bus.
+ */
+void *spi_do_alloc_slave(int offset, int size, unsigned int bus,
+			 unsigned int cs);
+
+/**
+ * spi_alloc_slave - Allocate a new SPI slave
+ *
+ * Allocate and zero all fields in the spi slave, and set the bus/chip
+ * select.
+ *
+ * @_struct:	Name of structure to allocate (e.g. struct tegra_spi).
+ *		This structure must contain a member 'struct spi_slave *slave'.
+ * @bus:	Bus ID of the slave chip.
+ * @cs:		Chip select ID of the slave chip on the specified bus.
+ */
+#define spi_alloc_slave(_struct, bus, cs) \
+	spi_do_alloc_slave(offsetof(_struct, slave), \
+			    sizeof(_struct), bus, cs)
+
+/**
+ * spi_alloc_slave_base - Allocate a new SPI slave with no private data
+ *
+ * Allocate and zero all fields in the spi slave, and set the bus/chip
+ * select.
+ *
+ * @bus:	Bus ID of the slave chip.
+ * @cs:		Chip select ID of the slave chip on the specified bus.
+ */
+#define spi_alloc_slave_base(bus, cs) \
+	spi_do_alloc_slave(0, sizeof(struct spi_slave), bus, cs)
+
+/**
  * Set up communications parameters for a SPI slave.
  *
  * This must be called once for each slave. Note that this function
@@ -70,10 +138,10 @@ void spi_init(void);
  * contents of spi_slave so that the hardware can be easily
  * initialized later.
  *
- *   bus:     Bus ID of the slave chip.
- *   cs:      Chip select ID of the slave chip on the specified bus.
- *   max_hz:  Maximum SCK rate in Hz.
- *   mode:    Clock polarity, clock phase and other parameters.
+ * @bus:	Bus ID of the slave chip.
+ * @cs:		Chip select ID of the slave chip on the specified bus.
+ * @max_hz:	Maximum SCK rate in Hz.
+ * @mode:	Clock polarity, clock phase and other parameters.
  *
  * Returns: A spi_slave reference that can be used in subsequent SPI
  * calls, or NULL if one or more of the parameters are not supported.
@@ -81,14 +149,14 @@ void spi_init(void);
 struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 		unsigned int max_hz, unsigned int mode);
 
-/*-----------------------------------------------------------------------
+/**
  * Free any memory associated with a SPI slave.
  *
- *   slave:	The SPI slave
+ * @slave:	The SPI slave
  */
 void spi_free_slave(struct spi_slave *slave);
 
-/*-----------------------------------------------------------------------
+/**
  * Claim the bus and prepare it for communication with a given slave.
  *
  * This must be called before doing any transfers with a SPI slave. It
@@ -97,25 +165,37 @@ void spi_free_slave(struct spi_slave *slave);
  * allowed to claim the same bus for several slaves without releasing
  * the bus in between.
  *
- *   slave:	The SPI slave
+ * @slave:	The SPI slave
  *
  * Returns: 0 if the bus was claimed successfully, or a negative value
  * if it wasn't.
  */
 int spi_claim_bus(struct spi_slave *slave);
 
-/*-----------------------------------------------------------------------
+/**
  * Release the SPI bus
  *
  * This must be called once for every call to spi_claim_bus() after
  * all transfers have finished. It may disable any SPI hardware as
  * appropriate.
  *
- *   slave:	The SPI slave
+ * @slave:	The SPI slave
  */
 void spi_release_bus(struct spi_slave *slave);
 
-/*-----------------------------------------------------------------------
+/**
+ * Set the word length for SPI transactions
+ *
+ * Set the word length (number of bits per word) for SPI transactions.
+ *
+ * @slave:	The SPI slave
+ * @wordlen:	The number of bits in a word
+ *
+ * Returns: 0 on success, -1 on failure.
+ */
+int spi_set_wordlen(struct spi_slave *slave, unsigned int wordlen);
+
+/**
  * SPI transfer
  *
  * This writes "bitlen" bits out the SPI MOSI port and simultaneously clocks
@@ -128,19 +208,19 @@ void spi_release_bus(struct spi_slave *slave);
  * temporary variables, this is OK).
  *
  * spi_xfer() interface:
- *   slave:	The SPI slave which will be sending/receiving the data.
- *   bitlen:	How many bits to write and read.
- *   dout:	Pointer to a string of bits to send out.  The bits are
+ * @slave:	The SPI slave which will be sending/receiving the data.
+ * @bitlen:	How many bits to write and read.
+ * @dout:	Pointer to a string of bits to send out.  The bits are
  *		held in a byte array and are sent MSB first.
- *   din:	Pointer to a string of bits that will be filled in.
- *   flags:	A bitwise combination of SPI_XFER_* flags.
+ * @din:	Pointer to a string of bits that will be filled in.
+ * @flags:	A bitwise combination of SPI_XFER_* flags.
  *
- *   Returns: 0 on success, not 0 on failure
+ * Returns: 0 on success, not 0 on failure
  */
 int  spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 		void *din, unsigned long flags);
 
-/*-----------------------------------------------------------------------
+/**
  * Determine if a SPI chipselect is valid.
  * This function is provided by the board if the low-level SPI driver
  * needs it to determine if a given chipselect is actually valid.
@@ -150,7 +230,7 @@ int  spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
  */
 int  spi_cs_is_valid(unsigned int bus, unsigned int cs);
 
-/*-----------------------------------------------------------------------
+/**
  * Activate a SPI chipselect.
  * This function is provided by the board code when using a driver
  * that can't control its chipselects automatically (e.g.
@@ -159,7 +239,7 @@ int  spi_cs_is_valid(unsigned int bus, unsigned int cs);
  */
 void spi_cs_activate(struct spi_slave *slave);
 
-/*-----------------------------------------------------------------------
+/**
  * Deactivate a SPI chipselect.
  * This function is provided by the board code when using a driver
  * that can't control its chipselects automatically (e.g.
@@ -168,18 +248,18 @@ void spi_cs_activate(struct spi_slave *slave);
  */
 void spi_cs_deactivate(struct spi_slave *slave);
 
-/*-----------------------------------------------------------------------
+/**
  * Set transfer speed.
  * This sets a new speed to be applied for next spi_xfer().
- *   slave:	The SPI slave
- *   hz:	The transfer speed
+ * @slave:	The SPI slave
+ * @hz:		The transfer speed
  */
 void spi_set_speed(struct spi_slave *slave, uint hz);
 
-/*-----------------------------------------------------------------------
+/**
  * Write 8 bits, then read 8 bits.
- *   slave:	The SPI slave we're communicating with
- *   byte:	Byte to be written
+ * @slave:	The SPI slave we're communicating with
+ * @byte:	Byte to be written
  *
  * Returns: The value that was read, or a negative value on error.
  *
@@ -198,4 +278,31 @@ static inline int spi_w8r8(struct spi_slave *slave, unsigned char byte)
 	return ret < 0 ? ret : din[1];
 }
 
+/**
+ * Set up a SPI slave for a particular device tree node
+ *
+ * This calls spi_setup_slave() with the correct bus number. Call
+ * spi_free_slave() to free it later.
+ *
+ * @param blob:		Device tree blob
+ * @param slave_node:	Slave node to use
+ * @param spi_node:	SPI peripheral node to use
+ * @return pointer to new spi_slave structure
+ */
+struct spi_slave *spi_setup_slave_fdt(const void *blob, int slave_node,
+				      int spi_node);
+
+/**
+ * spi_base_setup_slave_fdt() - helper function to set up a SPI slace
+ *
+ * This decodes SPI properties from the slave node to determine the
+ * chip select and SPI parameters.
+ *
+ * @blob:	Device tree blob
+ * @busnum:	Bus number to use
+ * @node:	Device tree node for the SPI bus
+ */
+struct spi_slave *spi_base_setup_slave_fdt(const void *blob, int busnum,
+					   int node);
+
 #endif	/* _SPI_H_ */
diff --git a/include/spi_flash.h b/include/spi_flash.h
index 9da9062..2db53c7 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -1,7 +1,8 @@
 /*
- * Interface to SPI flash
+ * Common SPI flash Interface
  *
  * Copyright (C) 2008 Atmel Corporation
+ * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -9,17 +10,8 @@
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
  */
+
 #ifndef _SPI_FLASH_H_
 #define _SPI_FLASH_H_
 
@@ -27,28 +19,124 @@
 #include <linux/types.h>
 #include <linux/compiler.h>
 
+/* sf param flags */
+#define SECT_4K		1 << 1
+#define SECT_32K	1 << 2
+#define E_FSR		1 << 3
+#define WR_QPP		1 << 4
+
+/* Enum list - Full read commands */
+enum spi_read_cmds {
+	ARRAY_SLOW = 1 << 0,
+	DUAL_OUTPUT_FAST = 1 << 1,
+	DUAL_IO_FAST = 1 << 2,
+	QUAD_OUTPUT_FAST = 1 << 3,
+	QUAD_IO_FAST = 1 << 4,
+};
+#define RD_EXTN		ARRAY_SLOW | DUAL_OUTPUT_FAST | DUAL_IO_FAST
+#define RD_FULL		RD_EXTN | QUAD_OUTPUT_FAST | QUAD_IO_FAST
+
+/* Dual SPI flash memories */
+enum spi_dual_flash {
+	SF_SINGLE_FLASH = 0,
+	SF_DUAL_STACKED_FLASH = 1 << 0,
+	SF_DUAL_PARALLEL_FLASH = 1 << 1,
+};
+
+/**
+ * struct spi_flash_params - SPI/QSPI flash device params structure
+ *
+ * @name:		Device name ([MANUFLETTER][DEVTYPE][DENSITY][EXTRAINFO])
+ * @jedec:		Device jedec ID (0x[1byte_manuf_id][2byte_dev_id])
+ * @ext_jedec:		Device ext_jedec ID
+ * @sector_size:	Sector size of this device
+ * @nr_sectors:		No.of sectors on this device
+ * @e_rd_cmd:		Enum list for read commands
+ * @flags:		Important param, for flash specific behaviour
+ */
+struct spi_flash_params {
+	const char *name;
+	u32 jedec;
+	u16 ext_jedec;
+	u32 sector_size;
+	u32 nr_sectors;
+	u8 e_rd_cmd;
+	u16 flags;
+};
+
+extern const struct spi_flash_params spi_flash_params_table[];
+
+/**
+ * struct spi_flash - SPI flash structure
+ *
+ * @spi:		SPI slave
+ * @name:		Name of SPI flash
+ * @dual_flash:		Indicates dual flash memories - dual stacked, parallel
+ * @shift:		Flash shift useful in dual parallel
+ * @size:		Total flash size
+ * @page_size:		Write (page) size
+ * @sector_size:	Sector size
+ * @erase_size:		Erase size
+ * @bank_read_cmd:	Bank read cmd
+ * @bank_write_cmd:	Bank write cmd
+ * @bank_curr:		Current flash bank
+ * @poll_cmd:		Poll cmd - for flash erase/program
+ * @erase_cmd:		Erase cmd 4K, 32K, 64K
+ * @read_cmd:		Read cmd - Array Fast, Extn read and quad read.
+ * @write_cmd:		Write cmd - page and quad program.
+ * @dummy_byte:		Dummy cycles for read operation.
+ * @memory_map:		Address of read-only SPI flash access
+ * @read:		Flash read ops: Read len bytes at offset into buf
+ *			Supported cmds: Fast Array Read
+ * @write:		Flash write ops: Write len bytes from buf into offset
+ *			Supported cmds: Page Program
+ * @erase:		Flash erase ops: Erase len bytes from offset
+ *			Supported cmds: Sector erase 4K, 32K, 64K
+ * return 0 - Success, 1 - Failure
+ */
 struct spi_flash {
 	struct spi_slave *spi;
+	const char *name;
+	u8 dual_flash;
+	u8 shift;
 
-	const char	*name;
-
-	/* Total flash size */
-	u32		size;
-	/* Write (page) size */
-	u32		page_size;
-	/* Erase (sector) size */
-	u32		sector_size;
-
-	int		(*read)(struct spi_flash *flash, u32 offset,
-				size_t len, void *buf);
-	int		(*write)(struct spi_flash *flash, u32 offset,
-				size_t len, const void *buf);
-	int		(*erase)(struct spi_flash *flash, u32 offset,
-				size_t len);
+	u32 size;
+	u32 page_size;
+	u32 sector_size;
+	u32 erase_size;
+#ifdef CONFIG_SPI_FLASH_BAR
+	u8 bank_read_cmd;
+	u8 bank_write_cmd;
+	u8 bank_curr;
+#endif
+	u8 poll_cmd;
+	u8 erase_cmd;
+	u8 read_cmd;
+	u8 write_cmd;
+	u8 dummy_byte;
+
+	void *memory_map;
+	int (*read)(struct spi_flash *flash, u32 offset, size_t len, void *buf);
+	int (*write)(struct spi_flash *flash, u32 offset, size_t len,
+			const void *buf);
+	int (*erase)(struct spi_flash *flash, u32 offset, size_t len);
 };
 
 struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		unsigned int max_hz, unsigned int spi_mode);
+
+/**
+ * Set up a new SPI flash from an fdt node
+ *
+ * @param blob		Device tree blob
+ * @param slave_node	Pointer to this SPI slave node in the device tree
+ * @param spi_node	Cached pointer to the SPI interface this node belongs
+ *			to
+ * @return 0 if ok, -1 on error
+ */
+struct spi_flash *spi_flash_probe_fdt(const void *blob, int slave_node,
+				      int spi_node);
+
 void spi_flash_free(struct spi_flash *flash);
 
 static inline int spi_flash_read(struct spi_flash *flash, u32 offset,
@@ -70,5 +158,6 @@ static inline int spi_flash_erase(struct spi_flash *flash, u32 offset,
 }
 
 void spi_boot(void) __noreturn;
+void spi_spl_load_image(uint32_t offs, unsigned int size, void *vdst);
 
 #endif /* _SPI_FLASH_H_ */
diff --git a/include/spl.h b/include/spl.h
index b02f36f..fe257be 100644
--- a/include/spl.h
+++ b/include/spl.h
@@ -2,23 +2,7 @@
  * (C) Copyright 2012
  * Texas Instruments, <www.ti.com>
  *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 #ifndef	_SPL_H_
 #define	_SPL_H_
@@ -27,10 +11,12 @@
 #include <linux/compiler.h>
 #include <asm/spl.h>
 
+
 /* Boot type */
 #define MMCSD_MODE_UNDEFINED	0
 #define MMCSD_MODE_RAW		1
 #define MMCSD_MODE_FAT		2
+#define MMCSD_MODE_EMMCBOOT	3
 
 struct spl_image_info {
 	const char *name;
diff --git a/lib/fdtdec.c b/lib/fdtdec.c
index 16921e1..d38a762 100644
--- a/lib/fdtdec.c
+++ b/lib/fdtdec.c
@@ -53,7 +53,10 @@ static const char * const compat_names[COMPAT_COUNT] = {
 	COMPAT(SAMSUNG_EXYNOS_SPI, "samsung,exynos-spi"),
 	COMPAT(SAMSUNG_EXYNOS_EHCI, "samsung,exynos-ehci"),
 	COMPAT(SAMSUNG_EXYNOS_USB_PHY, "samsung,exynos-usb-phy"),
+    COMPAT(SAMSUNG_EXYNOS_TMU, "samsung,exynos-tmu"),
 	COMPAT(MAXIM_MAX77686_PMIC, "maxim,max77686_pmic"),
+    COMPAT(GENERIC_SPI_FLASH, "spi-flash"),
+    COMPAT(MAXIM_98095_CODEC, "maxim,max98095-codec"),
 };
 
 const char *fdtdec_get_compatible(enum fdt_compat_id id)
diff --git a/nand_spl/board/freescale/p1_p2_rdb/Makefile b/nand_spl/board/freescale/p1_p2_rdb/Makefile
index 9c77826..a87d5f4 100644
--- a/nand_spl/board/freescale/p1_p2_rdb/Makefile
+++ b/nand_spl/board/freescale/p1_p2_rdb/Makefile
@@ -125,6 +125,9 @@ ifneq ($(OBJTREE), $(SRCTREE))
 $(obj)nand_boot.c:
 	@rm -f $(obj)nand_boot.c
 	ln -s $(SRCTREE)/nand_spl/board/$(BOARDDIR)/nand_boot.c $(obj)nand_boot.c
+$(obj)../common.c:
+	@rm -f $(obj)../common.c
+	ln -s $(SRCTREE)/nand_spl/board/freescale/common.c $(obj)../common.c
 endif
 
 #########################################################################
diff --git a/snapshot.commit b/snapshot.commit
index aaca351..8d26309 100644
--- a/snapshot.commit
+++ b/snapshot.commit
@@ -1 +1 @@
-e8ae0fa5edd152b2b29c470b88429be4cdcd2c46  Thu, 31 Jan 2013 14:47:42 -0500
+$Format:%H  %cD$
diff --git a/spl/Makefile b/spl/Makefile
index 6dbb105..5cbc1a3 100644
--- a/spl/Makefile
+++ b/spl/Makefile
@@ -92,6 +92,14 @@ LIBS-y += arch/$(ARCH)/cpu/tegra-common/libcputegra-common.o
 LIBS-y += $(CPUDIR)/tegra-common/libtegra-common.o
 endif
 
++ifneq (,$(CONFIG_MX23)$(filter $(SOC), mx25 mx27 mx5 mx6 mx31 mx35))
+LIBS-y += arch/$(ARCH)/imx-common/libimx-common.o
+endif
+
+ifeq ($(SOC),exynos)
+LIBS-y += $(CPUDIR)/s5p-common/libs5p-common.o
+endif
+
 # Add GCC lib
 ifeq ("$(USE_PRIVATE_LIBGCC)", "yes")
 PLATFORM_LIBGCC = $(SPLTREE)/arch/$(ARCH)/lib/libgcc.o
diff --git a/tools/Makefile b/tools/Makefile
index 686840a..bcd5e20 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -21,7 +21,7 @@
 # MA 02111-1307 USA
 #
 
-TOOLSUBDIRS = kernel-doc
+TOOLSUBDIRS = kernel-doc env
 
 #
 # Include this after HOSTOS HOSTARCH check
