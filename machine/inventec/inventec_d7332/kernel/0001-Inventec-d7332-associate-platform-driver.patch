From b02b39e99ebaf8d664044a298b53f70f437bcefc Mon Sep 17 00:00:00 2001
From: "Ting.Jack" <ting.jack@inventec.com>
Date: Tue, 16 Mar 2021 15:21:58 +0800
Subject: [PATCH] Inventec d7332 associate platform driver

---
 drivers/gpio/gpio-ich.c             |   2 +-
 drivers/i2c/muxes/i2c-mux-pca9541.c | 197 ++++++++-
 drivers/mfd/lpc_ich.c               |   1 +
 drivers/platform/x86/Makefile       |   1 +
 drivers/platform/x86/inv_cpld.c     | 781 ++++++++++++++++++++++++++++++++++++
 drivers/platform/x86/inv_platform.c | 201 ++++++++++
 drivers/platform/x86/inv_psu.c      | 698 ++++++++++++++++++++++++++++++++
 drivers/platform/x86/inv_ucd90160.c | 259 ++++++++++++
 8 files changed, 2135 insertions(+), 5 deletions(-)
 create mode 100644 drivers/platform/x86/inv_cpld.c
 create mode 100644 drivers/platform/x86/inv_platform.c
 create mode 100644 drivers/platform/x86/inv_psu.c
 create mode 100644 drivers/platform/x86/inv_ucd90160.c

diff --git a/drivers/gpio/gpio-ich.c b/drivers/gpio/gpio-ich.c
index 4f6d643..4415d5d 100644
--- a/drivers/gpio/gpio-ich.c
+++ b/drivers/gpio/gpio-ich.c
@@ -109,7 +109,7 @@ static struct {
 	int outlvl_cache[3];	/* cached output values */
 } ichx_priv;
 
-static int modparam_gpiobase = -1;	/* dynamic */
+static int modparam_gpiobase = 0;	/* Default: -1 dynamic */
 module_param_named(gpiobase, modparam_gpiobase, int, 0444);
 MODULE_PARM_DESC(gpiobase, "The GPIO number base. -1 means dynamic, "
 			   "which is the default.");
diff --git a/drivers/i2c/muxes/i2c-mux-pca9541.c b/drivers/i2c/muxes/i2c-mux-pca9541.c
index 4ea7e69..117469b 100644
--- a/drivers/i2c/muxes/i2c-mux-pca9541.c
+++ b/drivers/i2c/muxes/i2c-mux-pca9541.c
@@ -59,11 +59,44 @@
 #define PCA9541_ISTAT_MYTEST	(1 << 6)
 #define PCA9541_ISTAT_NMYTEST	(1 << 7)
 
+#define PCA9641_ID		0x00
+#define PCA9641_ID_MAGIC	0x38
+
+#define PCA9641_CONTROL		0x01
+#define PCA9641_STATUS		0x02
+#define PCA9641_TIME		0x03
+
+#define PCA9641_CTL_LOCK_REQ		BIT(0)
+#define PCA9641_CTL_LOCK_GRANT		BIT(1)
+#define PCA9641_CTL_BUS_CONNECT		BIT(2)
+#define PCA9641_CTL_BUS_INIT		BIT(3)
+#define PCA9641_CTL_SMBUS_SWRST		BIT(4)
+#define PCA9641_CTL_IDLE_TIMER_DIS	BIT(5)
+#define PCA9641_CTL_SMBUS_DIS		BIT(6)
+#define PCA9641_CTL_PRIORITY		BIT(7)
+
+#define PCA9641_STS_OTHER_LOCK		BIT(0)
+#define PCA9641_STS_BUS_INIT_FAIL	BIT(1)
+#define PCA9641_STS_BUS_HUNG		BIT(2)
+#define PCA9641_STS_MBOX_EMPTY		BIT(3)
+#define PCA9641_STS_MBOX_FULL		BIT(4)
+#define PCA9641_STS_TEST_INT		BIT(5)
+#define PCA9641_STS_SCL_IO		BIT(6)
+#define PCA9641_STS_SDA_IO		BIT(7)
+
+#define PCA9641_RES_TIME	0x03
+
+
 #define BUSON		(PCA9541_CTL_BUSON | PCA9541_CTL_NBUSON)
 #define MYBUS		(PCA9541_CTL_MYBUS | PCA9541_CTL_NMYBUS)
 #define mybus(x)	(!((x) & MYBUS) || ((x) & MYBUS) == MYBUS)
 #define busoff(x)	(!((x) & BUSON) || ((x) & BUSON) == BUSON)
 
+#define BUSOFF(x, y)	(!((x) & PCA9641_CTL_LOCK_GRANT) && \
+			!((y) & PCA9641_STS_OTHER_LOCK))
+#define other_lock(x)	((x) & PCA9641_STS_OTHER_LOCK)
+#define lock_grant(x)	((x) & PCA9641_CTL_LOCK_GRANT)
+
 /* arbitration timeouts, in jiffies */
 #define ARB_TIMEOUT	(HZ / 8)	/* 125 ms until forcing bus ownership */
 #define ARB2_TIMEOUT	(HZ / 4)	/* 250 ms until acquisition failure */
@@ -80,6 +113,7 @@ struct pca9541 {
 
 static const struct i2c_device_id pca9541_id[] = {
 	{"pca9541", 0},
+	{"pca9641", 1},
 	{}
 };
 
@@ -88,6 +122,7 @@ MODULE_DEVICE_TABLE(i2c, pca9541_id);
 #ifdef CONFIG_OF
 static const struct of_device_id pca9541_of_match[] = {
 	{ .compatible = "nxp,pca9541" },
+	{ .compatible = "nxp,pca9641" },
 	{}
 };
 #endif
@@ -328,6 +363,146 @@ static int pca9541_release_chan(struct i2c_mux_core *muxc, u32 chan)
 }
 
 /*
+ * Arbitration management functions
+ */
+static void pca9641_release_bus(struct i2c_client *client)
+{
+	pca9541_reg_write(client, PCA9641_CONTROL, 0);
+}
+
+/*
+ * Channel arbitration
+ *
+ * Return values:
+ *  <0: error
+ *  0 : bus not acquired
+ *  1 : bus acquired
+ */
+static int pca9641_arbitrate(struct i2c_client *client)
+{
+	struct i2c_mux_core *muxc = i2c_get_clientdata(client);
+	struct pca9541 *data = i2c_mux_priv(muxc);
+	int reg_ctl, reg_sts;
+
+	reg_ctl = pca9541_reg_read(client, PCA9641_CONTROL);
+	if (reg_ctl < 0)
+		return reg_ctl;
+	reg_sts = pca9541_reg_read(client, PCA9641_STATUS);
+	if (reg_sts < 0)
+		return reg_sts;
+	if (reg_sts & PCA9641_STS_BUS_HUNG) reg_ctl |= PCA9641_CTL_BUS_INIT;
+	if (BUSOFF(reg_ctl, reg_sts)) {
+		/*
+		 * Bus is off. Request ownership or turn it on unless
+		 * other master requested ownership.
+		 */
+		reg_ctl |= PCA9641_CTL_LOCK_REQ | PCA9641_CTL_IDLE_TIMER_DIS | PCA9641_CTL_SMBUS_DIS;
+		pca9541_reg_write(client, PCA9641_CONTROL, reg_ctl);
+		reg_ctl = pca9541_reg_read(client, PCA9641_CONTROL);
+
+		if (lock_grant(reg_ctl)) {
+			/*
+			 * Other master did not request ownership,
+			 * or arbitration timeout expired. Take the bus.
+			 */
+			reg_ctl |= PCA9641_CTL_BUS_CONNECT
+					| PCA9641_CTL_LOCK_REQ;
+			pca9541_reg_write(client, PCA9641_CONTROL, reg_ctl);
+			if (reg_sts & PCA9641_STS_BUS_HUNG)
+			{
+				reg_sts = pca9541_reg_read(client, PCA9641_STATUS);
+				if(reg_sts < 0 || reg_sts & (PCA9641_STS_BUS_INIT_FAIL | PCA9641_STS_BUS_HUNG))
+					return -1;
+			}
+			data->select_timeout = SELECT_DELAY_SHORT;
+
+			return 1;
+		} else {
+		/*
+			 * Other master requested ownership.
+			 * Set extra long timeout to give it time to acquire it.
+			 */
+			if (reg_sts & PCA9641_STS_BUS_HUNG)
+			{
+				reg_sts = pca9541_reg_read(client, PCA9641_STATUS);
+				if(reg_sts < 0 || reg_sts & (PCA9641_STS_BUS_INIT_FAIL | PCA9641_STS_BUS_HUNG))
+					return -1;
+			}
+			data->select_timeout = SELECT_DELAY_LONG * 2;
+		}
+	} else if (lock_grant(reg_ctl)) {
+		/*
+		 * Bus is on, and we own it. We are done with acquisition.
+		 */
+		reg_ctl |= PCA9641_CTL_BUS_CONNECT | PCA9641_CTL_LOCK_REQ;
+		pca9541_reg_write(client, PCA9641_CONTROL, reg_ctl);
+		if (reg_sts & PCA9641_STS_BUS_HUNG)
+		{
+			reg_sts = pca9541_reg_read(client, PCA9641_STATUS);
+			if(reg_sts < 0 || reg_sts & (PCA9641_STS_BUS_INIT_FAIL | PCA9641_STS_BUS_HUNG))
+				return -1;
+		}
+		return 1;
+	} else if (other_lock(reg_sts)) {
+		/*
+		 * Other master owns the bus.
+		 * If arbitration timeout has expired, force ownership.
+		 * Otherwise request it.
+		 */
+		if (reg_sts & PCA9641_STS_BUS_HUNG) return -1;
+		data->select_timeout = SELECT_DELAY_LONG;
+		reg_ctl |= PCA9641_CTL_LOCK_REQ;
+		pca9541_reg_write(client, PCA9641_CONTROL, reg_ctl);
+	}
+	return 0;
+}
+
+static int pca9641_select_chan(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct pca9541 *data = i2c_mux_priv(muxc);
+	struct i2c_client *client = data->client;
+	int ret;
+	unsigned long timeout = jiffies + ARB2_TIMEOUT;
+		/* give up after this time */
+
+	data->arb_timeout = jiffies + ARB_TIMEOUT;
+		/* force bus ownership after this time */
+
+	do {
+		ret = pca9641_arbitrate(client);
+		if (ret)
+			return ret < 0 ? ret : 0;
+
+		if (data->select_timeout == SELECT_DELAY_SHORT)
+			udelay(data->select_timeout);
+		else
+			msleep(data->select_timeout / 1000);
+	} while (time_is_after_eq_jiffies(timeout));
+
+	return -ETIMEDOUT;
+}
+
+static int pca9641_release_chan(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct pca9541 *data = i2c_mux_priv(muxc);
+	struct i2c_client *client = data->client;
+
+	pca9641_release_bus(client);
+	return 0;
+}
+
+static int pca9641_detect_id(struct i2c_client *client)
+{
+	int reg;
+
+	reg = pca9541_reg_read(client, PCA9641_ID);
+	if (reg == PCA9641_ID_MAGIC)
+		return 1;
+	else
+		return 0;
+}
+
+/*
  * I2C init/probing/exit functions
  */
 static int pca9541_probe(struct i2c_client *client,
@@ -339,26 +514,40 @@ static int pca9541_probe(struct i2c_client *client,
 	struct pca9541 *data;
 	int force;
 	int ret;
+	int detect_id;
 
 	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE_DATA))
 		return -ENODEV;
 
+	detect_id = pca9641_detect_id(client);
 	/*
 	 * I2C accesses are unprotected here.
 	 * We have to lock the adapter before releasing the bus.
 	 */
-	i2c_lock_adapter(adap);
-	pca9541_release_bus(client);
-	i2c_unlock_adapter(adap);
+	if (detect_id == 0) {
+		i2c_lock_adapter(adap);
+		pca9541_release_bus(client);
+		i2c_unlock_adapter(adap);
+	} else {
+		i2c_lock_adapter(adap);
+		pca9641_release_bus(client);
+		i2c_unlock_adapter(adap);
+	}
 
 	/* Create mux adapter */
 
 	force = 0;
 	if (pdata)
 		force = pdata->modes[0].adap_id;
-	muxc = i2c_mux_alloc(adap, &client->dev, 1, sizeof(*data),
+	if (detect_id == 0) {
+		muxc = i2c_mux_alloc(adap, &client->dev, 1, sizeof(*data),
 			     I2C_MUX_ARBITRATOR,
 			     pca9541_select_chan, pca9541_release_chan);
+	} else {
+		muxc = i2c_mux_alloc(adap, &client->dev, 1, sizeof(*data),
+			     I2C_MUX_ARBITRATOR,
+			     pca9641_select_chan, pca9641_release_chan);
+	}
 	if (!muxc)
 		return -ENOMEM;
 
diff --git a/drivers/mfd/lpc_ich.c b/drivers/mfd/lpc_ich.c
index c8dee47..64738c4 100644
--- a/drivers/mfd/lpc_ich.c
+++ b/drivers/mfd/lpc_ich.c
@@ -493,6 +493,7 @@ static struct lpc_ich_info lpc_chipset_info[] = {
 	[LPC_LPT] = {
 		.name = "Lynx Point",
 		.iTCO_version = 2,
+		.gpio_version = ICH_V5_GPIO,
 	},
 	[LPC_LPT_LP] = {
 		.name = "Lynx Point_LP",
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 2efa86d..288ae21 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -2,6 +2,7 @@
 # Makefile for linux/drivers/platform/x86
 # x86 Platform-Specific Drivers
 #
+obj-y                           += inv_cpld.o inv_psu.o inv_ucd90160.o inv_platform.o
 obj-$(CONFIG_ASUS_LAPTOP)	+= asus-laptop.o
 obj-$(CONFIG_ASUS_WMI)		+= asus-wmi.o
 obj-$(CONFIG_ASUS_NB_WMI)	+= asus-nb-wmi.o
diff --git a/drivers/platform/x86/inv_cpld.c b/drivers/platform/x86/inv_cpld.c
new file mode 100644
index 0000000..8c23d28
--- /dev/null
+++ b/drivers/platform/x86/inv_cpld.c
@@ -0,0 +1,781 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/kthread.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/completion.h>
+#include <linux/ipmi.h>
+#include <linux/ipmi_smi.h>
+
+/* definition */
+#define CPLD_INFO_OFFSET		0x00
+#define CPLD_BIOSCS_OFFSET		0x04
+#define CPLD_PSU_OFFSET			0x08
+#define CPLD_CTL_OFFSET			0x0C
+#define CPLD_SYSLED_OFFSET		0x0E
+#define CPLD_PWM_OFFSET			0x40
+#define CPLD_RPM_OFFSET			0x46
+#define CPLD_FANSTATUS_OFFSET		0x5E
+#define CPLD_FANLED_OFFSET		0x60
+#define CPLD2_ADDRESS			0x33
+
+#define FAN_NUM				6
+static u8 hasCPLD2 = 1;
+static struct i2c_client *client2;
+
+/* Each client has this additional data */
+struct cpld_data {
+	struct device *hwmon_dev;
+	struct mutex update_lock;
+	u8 diag;
+	struct task_struct *tsk;
+};
+
+/*-----------------------------------------------------------------------*/
+static ssize_t cpld_i2c_read(struct i2c_client *client, u8 *buf, u8 offset, size_t count)
+{
+	int i;
+	s32 temp = 0;
+	
+	for(i=0; i<count; i++)
+	{
+		temp = i2c_smbus_read_byte_data(client, offset+i);
+		if(temp<0) 
+		{
+//			printk("CPLD Read fail! Error Code: %d\n",temp);
+			return 0;
+		}
+		buf[i] = temp & 0xff;
+	}
+	return count;
+}
+
+static ssize_t cpld_i2c_write(struct i2c_client *client, char *buf, unsigned offset, size_t count)
+{   
+	int i;
+	
+	for(i=0; i<count; i++)
+	{
+		i2c_smbus_write_byte_data(client, offset+i, buf[i]);
+	}
+	return count;
+}
+
+/*-----------------------IPMI API--------------------------------------*/
+#define MAX_IPMI_RECV_LENGTH	0xFF
+#define IPMI_MAX_INTF		4
+#define NETFN_OEM 0x30
+#define CMD_GETDATA 0x31
+#define CMD_SETDATA 0x32
+#define IPMI_DIAGFLAG_OFFSET 0x00
+
+struct ipmi_result{
+        char result[MAX_IPMI_RECV_LENGTH];
+        int result_length;
+};
+
+DEFINE_MUTEX(ipmi_mutex);
+DEFINE_MUTEX(ipmi2_mutex);
+static struct ipmi_result ipmiresult;
+static ipmi_user_t ipmi_mh_user = NULL;
+static void msg_handler(struct ipmi_recv_msg *msg,void* handler_data);
+static struct ipmi_user_hndl ipmi_hndlrs = {   .ipmi_recv_hndl = msg_handler,};
+
+static atomic_t dummy_count = ATOMIC_INIT(0);
+static void dummy_smi_free(struct ipmi_smi_msg *msg)
+{
+        atomic_dec(&dummy_count);
+}
+static void dummy_recv_free(struct ipmi_recv_msg *msg)
+{
+        atomic_dec(&dummy_count);
+}
+static struct ipmi_smi_msg halt_smi_msg = {
+        .done = dummy_smi_free
+};
+static struct ipmi_recv_msg halt_recv_msg = {
+        .done = dummy_recv_free
+};
+
+static void msg_handler(struct ipmi_recv_msg *recv_msg,void* handler_data)
+{
+    struct ipmi_result *msg_result = recv_msg->user_msg_data;
+
+    if(recv_msg->msg.data[0]==0 && recv_msg->msg.data_len>0) {
+        msg_result->result_length=recv_msg->msg.data_len-1;
+        memcpy(msg_result->result, &recv_msg->msg.data[1], recv_msg->msg.data_len-1);
+    }
+    ipmi_free_recv_msg(recv_msg);
+    mutex_unlock(&ipmi_mutex);
+
+    return;
+}
+
+int start_ipmi_command(char NetFn, char cmd,char *data,int data_length, char* result, int* result_length)
+{
+    int rv=0,i;
+    int timeout;
+
+    //wait previous command finish at least 50msec
+    timeout=50;
+    while((mutex_is_locked(&ipmi_mutex) == 1 || (mutex_is_locked(&ipmi2_mutex) == 1)) && (--timeout)>0) { usleep_range(1000,1010); }
+    if(timeout==0) { return -1; }
+    mutex_lock(&ipmi_mutex);
+    mutex_lock(&ipmi2_mutex);
+
+    if(ipmi_mh_user == NULL) {
+        for (i=0,rv=1; i<IPMI_MAX_INTF && rv; i++) {
+            rv = ipmi_create_user(i, &ipmi_hndlrs, NULL, &ipmi_mh_user);
+            }
+    }
+
+    if (rv < 0) {
+        mutex_unlock(&ipmi_mutex);
+        mutex_unlock(&ipmi2_mutex);
+        return rv;
+    }
+    else {
+        struct  ipmi_system_interface_addr addr;
+        struct  kernel_ipmi_msg msg;
+        uint8_t msg_data[data_length];
+
+        memcpy(msg_data,data,data_length);
+        addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;
+        addr.channel = IPMI_BMC_CHANNEL;
+        addr.lun = 0;
+
+        msg.netfn = NetFn;
+        msg.cmd = cmd;
+        msg.data = msg_data;
+        msg.data_len = data_length;
+
+        rv = ipmi_request_supply_msgs(ipmi_mh_user, (struct ipmi_addr*)&addr, 0,&msg, &ipmiresult, &halt_smi_msg, &halt_recv_msg, 0);
+        if (rv) {
+                mutex_unlock(&ipmi_mutex);
+                mutex_unlock(&ipmi2_mutex);
+                return -6;
+        }
+
+        //skip command if 1sec no response from remote
+        timeout=1000;
+        while(mutex_is_locked(&ipmi_mutex) == 1 && (--timeout)>0) { usleep_range(1000,1100);}
+        if(timeout==0) {
+                mutex_unlock(&ipmi2_mutex);
+                return -1;
+        }
+        else {
+                *result_length=ipmiresult.result_length;
+                memcpy(result,ipmiresult.result,*result_length);
+                mutex_unlock(&ipmi2_mutex);
+                return 0;
+        }
+    }
+    return 0;
+}
+EXPORT_SYMBOL(start_ipmi_command);
+
+static int cpld_thread(void *p)
+{
+    u8 byte[9];
+    uint8_t result[MAX_IPMI_RECV_LENGTH];
+    int result_len=0;
+
+    //Disable BMC Watchdog
+    byte[0]=0x04;
+    byte[1]=0x00;
+    byte[2]=0x00;
+    byte[3]=0x00;
+    byte[4]=0x2C;
+    byte[5]=0x01;
+    start_ipmi_command(0x06, 0x24, byte, 6, result, &result_len);
+    return 0;
+}
+
+/*-----------------------------------------------------------------------*/
+/* sysfs attributes for hwmon */
+static ssize_t show_info(struct device *dev, struct device_attribute *da,
+			char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	ssize_t len = 0;
+
+	u8 byte[4] = {0,0,0,0};
+
+	mutex_lock(&data->update_lock);
+	len = cpld_i2c_read(client, byte, CPLD_INFO_OFFSET, 4);
+	mutex_unlock(&data->update_lock);
+	if (len==0) return 0;
+
+	sprintf (buf, "The CPLD release date is %02d/%02d/%d.\n", 
+	byte[2] & 0xf, (byte[3] & 0x1f), 2014+(byte[2] >> 4));	/* mm/dd/yyyy*/
+	sprintf (buf, "%sThe PCB  version is %X\n", buf,  byte[0]&0xf);
+	sprintf (buf, "%sThe CPLD version is %d.%d\n", buf, byte[1]>>4, byte[1]&0xf);
+
+	if(hasCPLD2) {
+		mutex_lock(&data->update_lock);
+		cpld_i2c_read(client2, byte, CPLD_INFO_OFFSET, 4);
+		mutex_unlock(&data->update_lock);
+
+		sprintf (buf, "%s\nThe CPLD2 release date is %02d/%02d/%d.\n", buf, 
+		byte[2] & 0xf, (byte[3] & 0x1f), 2014+(byte[2] >> 4));	/* mm/dd/yyyy*/
+		sprintf (buf, "%sThe CPLD version is %d.%d\n", buf, byte[1]>>4, byte[1]&0xf);
+	}
+	
+	return strlen(buf);
+}
+
+static char* powerstatus_str[] = {
+    "Failed",     //0
+    "Good",       //1
+};
+
+static ssize_t show_diag(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	uint8_t ipmisend[]= { IPMI_DIAGFLAG_OFFSET, 1};
+	uint8_t result[MAX_IPMI_RECV_LENGTH];
+	int result_len=0;
+	start_ipmi_command(NETFN_OEM, CMD_GETDATA,ipmisend, 2, result, &result_len);
+	data->diag = (result[0] & 0x80) !=0;
+	return sprintf (buf, "%d\n", data->diag);
+}
+
+static ssize_t set_diag(struct device *dev,
+			   struct device_attribute *da,
+			   const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	uint8_t ipmisend[]= { IPMI_DIAGFLAG_OFFSET, 0x80};
+	uint8_t result[MAX_IPMI_RECV_LENGTH];
+	int result_len=0;
+	u8 diag = simple_strtol(buf, NULL, 10);
+	data->diag = diag?1:0;
+	if (data->diag==0) ipmisend[1] = 0x00;
+
+	start_ipmi_command(NETFN_OEM, CMD_SETDATA,ipmisend, 2, result, &result_len);
+
+	return count;
+}
+
+static char* bios_str[] = {
+    "BIOS1",     	//0
+    "BIOS2",      	//1
+};
+
+static ssize_t show_bios_cs(struct device *dev, struct device_attribute *da,
+                         char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	ssize_t len = 0;
+	u8 byte = 0;
+
+	mutex_lock(&data->update_lock);
+	len = cpld_i2c_read(client, &byte, CPLD_BIOSCS_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+	if (len==0) return 0;
+
+	byte &= 0x01;
+
+	return sprintf (buf, "%d:%s\n", byte,bios_str[byte]);
+}
+
+static ssize_t set_bios_cs(struct device *dev,
+                           struct device_attribute *da,
+                           const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 byte = 0;
+	u8 temp = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	cpld_i2c_read(client, &byte, CPLD_BIOSCS_OFFSET, 1);
+	if(temp) byte |= 0x01; else byte &= ~(0x01);
+	cpld_i2c_write(client, &byte, CPLD_BIOSCS_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static char* sysled_str[] = {
+    "OFF",     //000
+    "0.5 Hz",  //001
+    "1 Hz",    //010
+    "2 Hz",    //011
+    "4 Hz",    //100
+    "NA",      //101
+    "NA",      //110
+    "ON",      //111
+};
+
+static ssize_t show_sysled(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u32 status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 byte;
+	int shift = (attr->index == 0)?4:0;
+    
+	mutex_lock(&data->update_lock);
+	status = cpld_i2c_read(client, &byte, CPLD_SYSLED_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+	
+	byte = (byte >> shift) & 0x7;
+	status = sprintf (buf, "%d:%s\n", byte, sysled_str[byte]);
+	    
+	return strlen(buf);
+}
+
+static ssize_t set_sysled(struct device *dev,
+			   struct device_attribute *devattr,
+			   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+
+	u8 temp = simple_strtol(buf, NULL, 16);
+	u8 byte;
+	int shift = (attr->index == 0)?4:0;
+    
+	temp &= 0x7;    
+
+	mutex_lock(&data->update_lock);
+	cpld_i2c_read(client, &byte, CPLD_SYSLED_OFFSET, 1);
+	byte &= ~(0x7<<shift);
+	byte |= (temp<<shift);
+	cpld_i2c_write(client, &byte, CPLD_SYSLED_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static char* psu_str[] = {
+    "normal",		//000
+    "NA",		//001
+    "unpowered",	//010
+    "NA",		//011
+    "psu fault",        //100
+    "NA",		//101
+    "NA",		//110
+    "not installed",	//111
+};
+
+static ssize_t show_psu(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	ssize_t len = 0;
+	u8 byte=0;
+	int shift = (attr->index == 0)?0:4;
+
+	mutex_lock(&data->update_lock);
+	len = cpld_i2c_read(client, &byte, CPLD_PSU_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+	if (len==0) return 0;
+
+	byte = (byte >> shift) & 0x7;
+
+	return sprintf (buf, "%d:%s\n", byte, psu_str[byte]);
+}
+
+static ssize_t show_pwm(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	ssize_t len = 0;
+	u8 byte=0;
+	u8 offset = attr->index  + CPLD_PWM_OFFSET;
+
+	mutex_lock(&data->update_lock);
+	len = cpld_i2c_read(client, &byte, offset, 1);
+	mutex_unlock(&data->update_lock);
+	if (len==0) return 0;
+
+	return sprintf(buf, "%d\n", byte);
+}
+
+static ssize_t set_pwm(struct device *dev, struct device_attribute *da,
+			   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 offset = attr->index  + CPLD_PWM_OFFSET;
+	u8 byte = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	cpld_i2c_write(client, &byte, offset, 1);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static ssize_t show_rpm(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	ssize_t len = 0;
+	u8 offset = attr->index*2  + CPLD_RPM_OFFSET;
+	u8 byte[2] = {0,0};
+
+	mutex_lock(&data->update_lock);
+	len = cpld_i2c_read(client, byte, offset, 2);
+	mutex_unlock(&data->update_lock);
+	if (len==0) return 0;
+
+	return sprintf(buf, "%d\n", (byte[0]<<8 | byte[1]));
+}
+
+static char* fantype_str[] = {
+    "Normal Type",   //00
+    "REVERSAL Type", //01
+    "UNPLUGGED",     //10
+    "UNPLUGGED",     //11
+};
+
+static ssize_t show_fantype(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	ssize_t len = 0;
+	u8 offset = CPLD_FANSTATUS_OFFSET;
+	u8 byte[2] = {0,0};
+
+	mutex_lock(&data->update_lock);
+	len = cpld_i2c_read(client, byte, offset, 2);
+	mutex_unlock(&data->update_lock);
+	if (len==0) return 0;
+	status = (((byte[0] >> attr->index) & 0x01)) | (((byte[1] >> attr->index) & 0x01)<<1);
+
+	return sprintf(buf, "%d:%s\n",status,fantype_str[status]);
+}
+
+static char* fanled_str[] = {
+    "None",   //00
+    "Green",  //01
+    "Red",    //10
+    "Both",   //11
+};
+
+static ssize_t show_fanled(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	ssize_t len = 0;
+	u8 byte[2] = {0,0};
+
+	mutex_lock(&data->update_lock);
+	len = cpld_i2c_read(client, byte, CPLD_FANLED_OFFSET, 2);
+	mutex_unlock(&data->update_lock);
+	if (len==0) return 0;
+	status = (((byte[0] >> attr->index) & 0x01)) | (((byte[1] >> attr->index) & 0x01)<<1);
+
+	return sprintf(buf, "%d:%s\n",status,fanled_str[status]);
+}
+
+static ssize_t set_fanled(struct device *dev,
+			   struct device_attribute *da,
+			   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 byte[2] = {0,0};	
+	u8 temp = simple_strtol(buf, NULL, 16);	
+	int shift = attr->index;
+
+	temp &= 0x3;
+	mutex_lock(&data->update_lock);
+	cpld_i2c_read(client, byte, CPLD_FANLED_OFFSET, 2);
+	byte[0] &= ~(1<<shift);
+	byte[1] &= ~(1<<shift);
+	byte[0] |= (temp & 0x01)<<shift;
+	byte[1] |= ((temp >> 1) & 0x01)<<shift;
+	cpld_i2c_write(client, byte, CPLD_FANLED_OFFSET, 2);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static SENSOR_DEVICE_ATTR(info,         S_IRUGO,		show_info, 0, 0);
+static SENSOR_DEVICE_ATTR(diag, 	S_IWUSR|S_IRUGO,	show_diag, set_diag, 0);
+
+static SENSOR_DEVICE_ATTR(grn_led, S_IWUSR|S_IRUGO,	show_sysled, set_sysled, 0);
+static SENSOR_DEVICE_ATTR(red_led, S_IWUSR|S_IRUGO,	show_sysled, set_sysled, 1);
+
+static SENSOR_DEVICE_ATTR(pwm1, S_IWUSR|S_IRUGO,	show_pwm, set_pwm, 0);
+static SENSOR_DEVICE_ATTR(pwm2, S_IWUSR|S_IRUGO,	show_pwm, set_pwm, 1);
+static SENSOR_DEVICE_ATTR(pwm3, S_IWUSR|S_IRUGO,	show_pwm, set_pwm, 2);
+static SENSOR_DEVICE_ATTR(pwm4, S_IWUSR|S_IRUGO,	show_pwm, set_pwm, 3);
+#if FAN_NUM>4
+static SENSOR_DEVICE_ATTR(pwm5, S_IWUSR|S_IRUGO,	show_pwm, set_pwm, 4);
+#endif
+#if FAN_NUM>5
+static SENSOR_DEVICE_ATTR(pwm6, S_IWUSR|S_IRUGO,	show_pwm, set_pwm, 5);
+#endif
+
+static SENSOR_DEVICE_ATTR(fanmodule1_type, S_IRUGO,	show_fantype, 0, 0);
+static SENSOR_DEVICE_ATTR(fanmodule2_type, S_IRUGO,	show_fantype, 0, 1);
+static SENSOR_DEVICE_ATTR(fanmodule3_type, S_IRUGO,	show_fantype, 0, 2);
+static SENSOR_DEVICE_ATTR(fanmodule4_type, S_IRUGO,	show_fantype, 0, 3);
+#if FAN_NUM>4
+static SENSOR_DEVICE_ATTR(fanmodule5_type, S_IRUGO,	show_fantype, 0, 4);
+#endif
+#if FAN_NUM>5
+static SENSOR_DEVICE_ATTR(fanmodule6_type, S_IRUGO,	show_fantype, 0, 5);
+#endif
+
+static SENSOR_DEVICE_ATTR(fanmodule1_led, S_IWUSR|S_IRUGO,	show_fanled, set_fanled, 0);
+static SENSOR_DEVICE_ATTR(fanmodule2_led, S_IWUSR|S_IRUGO,	show_fanled, set_fanled, 1);
+static SENSOR_DEVICE_ATTR(fanmodule3_led, S_IWUSR|S_IRUGO,	show_fanled, set_fanled, 2);
+static SENSOR_DEVICE_ATTR(fanmodule4_led, S_IWUSR|S_IRUGO,	show_fanled, set_fanled, 3);
+#if FAN_NUM>4
+static SENSOR_DEVICE_ATTR(fanmodule5_led, S_IWUSR|S_IRUGO,	show_fanled, set_fanled, 4);
+#endif
+#if FAN_NUM>5
+static SENSOR_DEVICE_ATTR(fanmodule6_led, S_IWUSR|S_IRUGO,	show_fanled, set_fanled, 5);
+#endif
+
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO,	show_rpm, 0, 0);
+static SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO,	show_rpm, 0, 1);
+static SENSOR_DEVICE_ATTR(fan3_input, S_IRUGO,	show_rpm, 0, 2);
+static SENSOR_DEVICE_ATTR(fan4_input, S_IRUGO,	show_rpm, 0, 3);
+static SENSOR_DEVICE_ATTR(fan5_input, S_IRUGO,	show_rpm, 0, 4);
+static SENSOR_DEVICE_ATTR(fan6_input, S_IRUGO,	show_rpm, 0, 5);
+static SENSOR_DEVICE_ATTR(fan7_input, S_IRUGO,	show_rpm, 0, 6);
+static SENSOR_DEVICE_ATTR(fan8_input, S_IRUGO,	show_rpm, 0, 7);
+#if FAN_NUM>4
+static SENSOR_DEVICE_ATTR(fan9_input, S_IRUGO,	show_rpm, 0, 8);
+static SENSOR_DEVICE_ATTR(fan10_input,S_IRUGO,	show_rpm, 0, 9);
+#endif
+#if FAN_NUM>5
+static SENSOR_DEVICE_ATTR(fan11_input, S_IRUGO, show_rpm, 0, 10);
+static SENSOR_DEVICE_ATTR(fan12_input, S_IRUGO, show_rpm, 0, 11);
+#endif
+
+static SENSOR_DEVICE_ATTR(psu1,         S_IRUGO,           	show_psu, 0, 0);
+static SENSOR_DEVICE_ATTR(psu2,         S_IRUGO,           	show_psu, 0, 1);
+
+static SENSOR_DEVICE_ATTR(bios_cs,      	S_IWUSR|S_IRUGO,   	show_bios_cs, set_bios_cs, 0);
+			
+static struct attribute *cpld_attributes[] = {
+	&sensor_dev_attr_info.dev_attr.attr,
+	&sensor_dev_attr_diag.dev_attr.attr,
+	
+	&sensor_dev_attr_grn_led.dev_attr.attr,
+	&sensor_dev_attr_red_led.dev_attr.attr,
+	
+	&sensor_dev_attr_psu1.dev_attr.attr,
+	&sensor_dev_attr_psu2.dev_attr.attr,
+	
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_pwm2.dev_attr.attr,
+	&sensor_dev_attr_pwm3.dev_attr.attr,
+	&sensor_dev_attr_pwm4.dev_attr.attr,
+#if FAN_NUM>4
+	&sensor_dev_attr_pwm5.dev_attr.attr,
+#endif
+#if FAN_NUM>5
+	&sensor_dev_attr_pwm6.dev_attr.attr,
+#endif
+
+	&sensor_dev_attr_fanmodule1_type.dev_attr.attr,
+	&sensor_dev_attr_fanmodule2_type.dev_attr.attr,
+	&sensor_dev_attr_fanmodule3_type.dev_attr.attr,
+	&sensor_dev_attr_fanmodule4_type.dev_attr.attr,
+#if FAN_NUM>4
+	&sensor_dev_attr_fanmodule5_type.dev_attr.attr,
+#endif
+#if FAN_NUM>5
+	&sensor_dev_attr_fanmodule6_type.dev_attr.attr,
+#endif
+
+	&sensor_dev_attr_fanmodule1_led.dev_attr.attr,
+	&sensor_dev_attr_fanmodule2_led.dev_attr.attr,
+	&sensor_dev_attr_fanmodule3_led.dev_attr.attr,
+	&sensor_dev_attr_fanmodule4_led.dev_attr.attr,
+#if FAN_NUM>4
+	&sensor_dev_attr_fanmodule5_led.dev_attr.attr,
+#endif
+#if FAN_NUM>5
+	&sensor_dev_attr_fanmodule6_led.dev_attr.attr,
+#endif
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_fan3_input.dev_attr.attr,
+	&sensor_dev_attr_fan4_input.dev_attr.attr,
+	&sensor_dev_attr_fan5_input.dev_attr.attr,
+	&sensor_dev_attr_fan6_input.dev_attr.attr,
+	&sensor_dev_attr_fan7_input.dev_attr.attr,
+	&sensor_dev_attr_fan8_input.dev_attr.attr,
+#if FAN_NUM>4
+	&sensor_dev_attr_fan9_input.dev_attr.attr,
+	&sensor_dev_attr_fan10_input.dev_attr.attr,
+#endif
+#if FAN_NUM>4
+	&sensor_dev_attr_fan11_input.dev_attr.attr,
+	&sensor_dev_attr_fan12_input.dev_attr.attr,
+#endif
+	
+	&sensor_dev_attr_bios_cs.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group cpld_group = {
+	.attrs = cpld_attributes,
+};
+
+/*-----------------------------------------------------------------------*/
+/* device probe and removal */
+static int
+cpld_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct cpld_data *data;
+	int status;
+	u8 byte[5];
+   
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))
+		return -EIO;
+
+	data = kzalloc(sizeof(struct cpld_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &cpld_group);
+
+	if (status)
+		goto exit_free;
+
+	data->hwmon_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		status = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	//Check CPLD2 exist or not 
+	client2 = i2c_new_dummy(client->adapter, CPLD2_ADDRESS);
+	if(!client2) {
+		hasCPLD2 = 0;
+		client2 = client;
+	} else {
+		status = i2c_smbus_read_byte_data(client2, CPLD_INFO_OFFSET);
+		if(status<0) {
+			i2c_unregister_device(client2);
+			i2c_set_clientdata(client2, NULL);
+			hasCPLD2 = 0;
+			client2 = client;		
+		}
+	}
+
+	//Handle LED control by the driver
+	byte[0]=0x01;
+	cpld_i2c_write(client, byte, CPLD_CTL_OFFSET, 1);
+	data->tsk = kthread_run(cpld_thread,client,"%s",dev_name(data->hwmon_dev));
+	dev_info(&client->dev, "%s: sensor '%s'\n",
+		 dev_name(data->hwmon_dev), client->name);
+	
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &cpld_group);
+exit_free:
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return status;
+}
+
+static int cpld_remove(struct i2c_client *client)
+{	
+	struct cpld_data *data = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&client->dev.kobj, &cpld_group);
+	hwmon_device_unregister(data->hwmon_dev);
+	i2c_set_clientdata(client, NULL);
+	if(hasCPLD2) {
+		i2c_unregister_device(client2);
+		i2c_set_clientdata(client2, NULL);
+	}
+	kfree(data);
+	return 0;
+}
+
+static const struct i2c_device_id cpld_ids[] = {
+	{ "inv_cpld" , 0, },
+	{ /* LIST END */ }
+};
+MODULE_DEVICE_TABLE(i2c, cpld_ids);
+
+static struct i2c_driver cpld_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		.name	= "inv_cpld",
+	},
+	.probe		= cpld_probe,
+	.remove		= cpld_remove,
+	.id_table	= cpld_ids,
+};
+
+/*-----------------------------------------------------------------------*/
+
+/* module glue */
+
+static int __init inv_cpld_init(void)
+{
+	return i2c_add_driver(&cpld_driver);
+}
+
+static void __exit inv_cpld_exit(void)
+{
+	i2c_del_driver(&cpld_driver);
+}
+
+MODULE_AUTHOR("jack.ting <ting.jack@inventec>");
+MODULE_DESCRIPTION("cpld driver");
+MODULE_LICENSE("GPL");
+
+module_init(inv_cpld_init);
+module_exit(inv_cpld_exit);
diff --git a/drivers/platform/x86/inv_platform.c b/drivers/platform/x86/inv_platform.c
new file mode 100644
index 0000000..27345a9
--- /dev/null
+++ b/drivers/platform/x86/inv_platform.c
@@ -0,0 +1,201 @@
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/i2c/pca954x.h>
+
+struct inv_i2c_board_info {
+    int ch;
+    int size;
+    struct i2c_board_info *board_info;
+};
+
+#define bus_id(id)  (id)
+static struct pca954x_platform_mode pca9641_modes_1[] = {
+    {.adap_id = bus_id(2),},
+};
+static struct pca954x_platform_mode pca9641_modes_2[] = {
+    {.adap_id = bus_id(3),},
+};
+static struct pca954x_platform_mode mux_modes_0[] = {
+    {.adap_id = bus_id(6),},    {.adap_id = bus_id(7),},
+    {.adap_id = bus_id(8),},    {.adap_id = bus_id(9),},
+    {.adap_id = bus_id(10),},    {.adap_id = bus_id(11),},
+    {.adap_id = bus_id(12),},    {.adap_id = bus_id(13),},
+};
+static struct pca954x_platform_mode mux_modes_0_0[] = {
+    {.adap_id = bus_id(14),},    {.adap_id = bus_id(15),},
+    {.adap_id = bus_id(16),},    {.adap_id = bus_id(17),},
+    {.adap_id = bus_id(18),},    {.adap_id = bus_id(19),},
+    {.adap_id = bus_id(20),},    {.adap_id = bus_id(21),},
+};
+
+static struct pca954x_platform_mode mux_modes_0_1[] = {
+    {.adap_id = bus_id(22),},    {.adap_id = bus_id(23),},
+    {.adap_id = bus_id(24),},    {.adap_id = bus_id(25),},
+    {.adap_id = bus_id(26),},    {.adap_id = bus_id(27),},
+    {.adap_id = bus_id(28),},    {.adap_id = bus_id(29),},
+};
+
+static struct pca954x_platform_mode mux_modes_0_2[] = {
+    {.adap_id = bus_id(30),},    {.adap_id = bus_id(31),},
+    {.adap_id = bus_id(32),},    {.adap_id = bus_id(33),},
+    {.adap_id = bus_id(34),},    {.adap_id = bus_id(35),},
+    {.adap_id = bus_id(36),},    {.adap_id = bus_id(37),},
+};
+static struct pca954x_platform_mode mux_modes_0_3[] = {
+    {.adap_id = bus_id(38),},    {.adap_id = bus_id(39),},
+    {.adap_id = bus_id(40),},    {.adap_id = bus_id(41),},
+    {.adap_id = bus_id(42),},    {.adap_id = bus_id(43),},
+    {.adap_id = bus_id(44),},    {.adap_id = bus_id(45),},
+};
+
+static struct pca954x_platform_data pca9641_data_1 = {
+        .modes          = pca9641_modes_1,
+        .num_modes      = 1,
+};
+static struct pca954x_platform_data pca9641_data_2 = {
+        .modes          = pca9641_modes_2,
+        .num_modes      = 1,
+};
+static struct pca954x_platform_data mux_data_0 = {
+        .modes          = mux_modes_0,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_0 = {
+        .modes          = mux_modes_0_0,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_1 = {
+        .modes          = mux_modes_0_1,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_2 = {
+        .modes          = mux_modes_0_2,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_3 = {
+        .modes          = mux_modes_0_3,
+        .num_modes      = 8,
+};
+
+static struct i2c_board_info i2c_device_info0[] __initdata = {
+	{"pca9641",	     0, 0x76, &pca9641_data_1, 0, 0},	//PCA9641-1
+};
+static struct i2c_board_info i2c_device_info2[] __initdata = {
+	{"inv_cpld",         0, 0x77, 0, 0, 0},			//CPLD
+};
+static struct i2c_board_info i2c_device_info4[] __initdata = {
+	{"inv_psu",	     0, 0x58, 0, 0, 0},			//PSU1
+	{"inv_psu",	     0, 0x59, 0, 0, 0},			//PSU2
+};
+static struct i2c_board_info i2c_device_info5[] __initdata = {
+        {"inv_ucd90160",     0, 0x34, 0, 0, 0},                 //switch board ucd90160
+        {"inv_ucd90160",     0, 0x6b, 0, 0, 0},                 //CPU board ucd90160
+};
+static struct i2c_board_info i2c_device_info1[] __initdata = {
+	{"pca9548",          0, 0x70, &mux_data_0, 0, 0},	//mux root
+};
+static struct i2c_board_info i2c_device_info6[] __initdata = {
+        {"pca9548",          0, 0x72, &mux_data_0_0, 0, 0},	
+};
+static struct i2c_board_info i2c_device_info7[] __initdata = {
+        {"pca9548",          0, 0x72, &mux_data_0_1, 0, 0},	
+};
+static struct i2c_board_info i2c_device_info8[] __initdata = {
+        {"pca9548",          0, 0x72, &mux_data_0_2, 0, 0},	
+};
+static struct i2c_board_info i2c_device_info9[] __initdata = {
+        {"pca9548",          0, 0x72, &mux_data_0_3, 0, 0},	
+};
+static struct i2c_board_info i2c_device_info11[] __initdata = {
+        {"pca9641",          0, 0x73, &pca9641_data_2, 0, 0},   //PCA9641-2
+};
+static struct i2c_board_info i2c_device_info3[] __initdata = {
+        {"max6695",          0, 0x18, 0, 0, 0},                 //ASIC Temp
+        {"tmp75",            0, 0x48, 0, 0, 0},                 //CPU Board Temp
+        {"tmp75",            0, 0x49, 0, 0, 0},                 //Fan Board Temp
+        {"tmp75",            0, 0x4A, 0, 0, 0},                 //Temp
+        {"tmp75",            0, 0x4D, 0, 0, 0},                 //Temp
+        {"tmp75",            0, 0x4E, 0, 0, 0},                 //Temp
+};
+
+static struct inv_i2c_board_info i2cdev_list[] = {
+    {bus_id(0), ARRAY_SIZE(i2c_device_info0),  i2c_device_info0 },  //PCA9641-1
+    {bus_id(1), ARRAY_SIZE(i2c_device_info1),  i2c_device_info1 },  //mux root
+    {bus_id(6), ARRAY_SIZE(i2c_device_info6),  i2c_device_info6 },  //mux CH0
+    {bus_id(7), ARRAY_SIZE(i2c_device_info7),  i2c_device_info7 },  //mux CH1
+    {bus_id(8), ARRAY_SIZE(i2c_device_info8),  i2c_device_info8 },  //mux CH2
+    {bus_id(9), ARRAY_SIZE(i2c_device_info9),  i2c_device_info9 },  //mux CH3
+    {bus_id(11),ARRAY_SIZE(i2c_device_info11), i2c_device_info11},  //PCA9641-2
+    {bus_id(2), ARRAY_SIZE(i2c_device_info2),  i2c_device_info2 },  //CPLD
+    {bus_id(3), ARRAY_SIZE(i2c_device_info3),  i2c_device_info3 },  //Temperature
+    {bus_id(2), ARRAY_SIZE(i2c_device_info4),  i2c_device_info4 },  //PSU1 and PSU2
+    {bus_id(2), ARRAY_SIZE(i2c_device_info5),  i2c_device_info5 },  //UCD90160
+};
+
+static struct   platform_device         *device_i2c_gpio0;
+static struct 	i2c_gpio_platform_data 	i2c_gpio_platdata0 = {
+	.scl_pin = 58,
+	.sda_pin = 75,
+    
+	.udelay  = 5, //5:100kHz
+	.sda_is_open_drain = 0,
+	.scl_is_open_drain = 0,
+	.scl_is_output_only = 0
+};
+
+static int __init inv_platform_init(void)
+{
+    struct i2c_adapter *adap = NULL;
+    struct i2c_client *e = NULL;
+    int ret = 0;
+    int i,j,k;
+   
+    device_i2c_gpio0 = platform_device_alloc("i2c-gpio", 1);
+    if (!device_i2c_gpio0) {
+        printk(KERN_ERR "i2c-gpio: platform_device_alloc fail\n");
+        return -ENOMEM;
+    }
+    device_i2c_gpio0->name = "i2c-gpio";
+    device_i2c_gpio0->id     = 1;
+    device_i2c_gpio0->dev.platform_data = &i2c_gpio_platdata0;
+
+    ret = platform_device_add(device_i2c_gpio0);
+    if (ret) {
+        printk(KERN_ERR "i2c-gpio: platform_device_add fail %d\n", ret);
+    }
+    msleep(10);
+
+   for(i=0; i<ARRAY_SIZE(i2cdev_list); i++) {
+        adap = i2c_get_adapter( i2cdev_list[i].ch );
+        if (adap == NULL) {
+            printk("platform get channel %d adapter fail\n", i);
+            continue;
+        }
+        i2c_put_adapter(adap);
+        for(j=0; j<i2cdev_list[i].size; j++) {
+            for(k=0; k<300; k++) {
+                e = i2c_new_device(adap, &i2cdev_list[i].board_info[j] );
+                if(e == NULL) msleep(10); else break;
+            }
+        }
+    }
+    return ret;    
+}
+
+static void __exit inv_platform_exit(void)
+{
+	device_i2c_gpio0->dev.platform_data = NULL;
+	platform_device_unregister(device_i2c_gpio0);
+}
+
+module_init(inv_platform_init);
+module_exit(inv_platform_exit);
+
+MODULE_AUTHOR("Inventec");
+MODULE_DESCRIPTION("Platform devices");
+MODULE_LICENSE("GPL");
diff --git a/drivers/platform/x86/inv_psu.c b/drivers/platform/x86/inv_psu.c
new file mode 100644
index 0000000..5f07a1c
--- /dev/null
+++ b/drivers/platform/x86/inv_psu.c
@@ -0,0 +1,698 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+#define PMBUS_CAPABILITY	0x19
+#define PMBUS_VOUT_MODE		0x20
+#define PMBUS_FAN_PWM		0x3b
+#define PMBUS_READ_VIN		0x88
+#define PMBUS_READ_IIN		0x89
+#define PMBUS_READ_VOUT		0x8b
+#define PMBUS_READ_IOUT		0x8c
+#define PMBUS_READ_TEMP1	0x8d
+#define PMBUS_READ_TEMP2	0x8e
+#define PMBUS_READ_TEMP3	0x8f
+#define PMBUS_READ_FAN1		0x90
+#define PMBUS_READ_FAN2		0x91
+#define PMBUS_READ_POUT		0x96
+#define PMBUS_READ_PIN		0x97
+#define PMBUS_READ_MFR_ID	0x99
+#define PMBUS_READ_MFR_MODEL	0x9a
+#define PMBUS_READ_MFR_REV	0x9b
+#define PMBUS_READ_MFR_LOC	0x9c
+#define PMBUS_READ_MFR_DATE	0x9d
+#define PMBUS_READ_MFR_SERIAL	0x9e
+
+#define PB_CAPABILITY_ERROR_CHECK	0x10000000
+#define DEFAULT_MFR_FAIL_STR	"NA"
+
+static int retrys = 1;
+module_param(retrys, int, 0);
+MODULE_PARM_DESC(retrys, "Inventec PSU driver read retry times (default 1).");
+
+static int read_only_once = 0;
+module_param(read_only_once, int, 0);
+MODULE_PARM_DESC(read_only_once, "Inventec PSU driver MFR field read only once flag (default 0).");
+
+#define FAN_NUM	2
+#define TMP_NUM	3
+
+struct psu_data {
+	struct device *hwmon_dev;
+	s32 vin;
+	s32 vout;
+	s32 cin;
+	s32 cout;
+	s32 pin;
+	s32 pout;
+	s32 vout_mode;
+	s32 rpm[FAN_NUM];
+	s32	temp[TMP_NUM];
+	s32 pwm;
+	u8 id[I2C_SMBUS_BLOCK_MAX + 2];
+	u8 model[I2C_SMBUS_BLOCK_MAX + 2];
+	u8 revision[I2C_SMBUS_BLOCK_MAX + 2];
+	u8 location[I2C_SMBUS_BLOCK_MAX + 2];
+	u8 date[I2C_SMBUS_BLOCK_MAX + 2];
+	u8 serial[I2C_SMBUS_BLOCK_MAX + 2];
+};
+
+static s32 reg2data_linear(s32 value, s32 mode, u8 reg)
+{
+	s16 exponent;
+	s32 mantissa;
+	s32 val;
+
+	if (mode) {
+		s32 parameter = (mode & 0x1f);
+		exponent = (parameter & 0x10) ? - ((32 - parameter) & 0xf) : (parameter & 0xf);
+		mantissa = (u16) value;
+	} else {
+		exponent = ((s16)value) >> 11;
+		mantissa = ((s16)((value & 0x7ff) << 5)) >> 5;
+	}
+
+	val = mantissa;
+
+	if (reg != PMBUS_READ_FAN1 && reg != PMBUS_READ_FAN2 && reg != PMBUS_FAN_PWM)
+		val = val * 1000;
+
+	if (reg == PMBUS_READ_POUT || reg == PMBUS_READ_PIN)
+		val = val * 1000;
+
+	if (exponent >= 0)
+		val <<= exponent;
+	else
+		val >>= -exponent;
+
+	return val;
+}
+
+static void get_vout_mode(struct i2c_client *client, s32 clean)
+{
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 read = 0, trys = 0;
+
+	if (clean) {
+		data->vout_mode = 0;
+		return;
+	}
+
+	if (data->vout_mode)
+		return;
+
+	while (trys <= retrys) {
+		read = i2c_smbus_read_byte_data(client, PMBUS_VOUT_MODE);
+		if (read < 0) {
+			trys++;
+			if (trys > retrys)
+				return;
+			continue;
+		}
+		break;
+	}
+
+	data->vout_mode = read;
+}
+
+static ssize_t read_voltage_out(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 vout = 0, trys = 0;
+
+	while (trys <= retrys) {
+
+		vout = i2c_smbus_read_word_data(client, PMBUS_READ_VOUT);
+		if (vout < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			get_vout_mode(client, 1);
+			continue;
+		}
+
+		get_vout_mode(client, 0);
+
+		break;
+	}
+
+	data->vout = reg2data_linear(vout, data->vout_mode, PMBUS_READ_VOUT);
+
+	return sprintf(buf, "%d\n", data->vout);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t read_voltage_in(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 vin = 0, trys = 0;
+
+	while (trys <= retrys) {
+
+		vin = i2c_smbus_read_word_data(client, PMBUS_READ_VIN);
+		if (vin < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->vin = reg2data_linear(vin, 0, PMBUS_READ_VIN);
+
+	return sprintf(buf, "%d\n", data->vin);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t read_current_in(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 cin = 0, trys = 0;
+
+	while (trys <= retrys) {
+
+		cin = i2c_smbus_read_word_data(client, PMBUS_READ_IIN);
+		if (cin < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->cin = reg2data_linear(cin, 0, PMBUS_READ_IIN);
+
+	return sprintf(buf, "%d\n", data->cin);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t read_current_out(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 cout = 0, trys = 0;
+
+	while (trys <= retrys) {
+
+		cout = i2c_smbus_read_word_data(client, PMBUS_READ_IOUT);
+		if (cout < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->cout = reg2data_linear(cout, 0, PMBUS_READ_IOUT);
+
+	return sprintf(buf, "%d\n", data->cout);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t read_power_in(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 pin = 0, trys = 0;
+
+	while (trys <= retrys) {
+
+		pin = i2c_smbus_read_word_data(client, PMBUS_READ_PIN);
+		if (pin < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->pin = reg2data_linear(pin, 0, PMBUS_READ_PIN);
+
+	return sprintf(buf, "%d\n", data->pin);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t read_power_out(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 pout = 0, trys = 0;
+
+	while (trys <= retrys) {
+
+		pout = i2c_smbus_read_word_data(client, PMBUS_READ_POUT);
+		if (pout < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->pout = reg2data_linear(pout, 0, PMBUS_READ_POUT);
+
+	return sprintf(buf, "%d\n", data->pout);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t read_temp(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, trys = 0;
+	u8 nr = attr->index;
+
+	while (trys <= retrys) {
+
+		temp = i2c_smbus_read_word_data(client, PMBUS_READ_TEMP1 + nr);
+		if (temp < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->temp[nr] = reg2data_linear(temp, 0, PMBUS_READ_TEMP1 + nr);
+
+	return sprintf(buf, "%d\n", data->temp[nr]);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t read_fan(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 rpm = 0, trys = 0;
+	u8 nr = attr->index;
+
+	while (trys <= retrys) {
+
+		rpm = i2c_smbus_read_word_data(client, PMBUS_READ_FAN1 + nr);
+		if (rpm < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->rpm[nr] = reg2data_linear(rpm, 0, PMBUS_READ_FAN1 + nr);
+
+	return sprintf(buf, "%d\n", data->rpm[nr]);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t read_pwm(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 pwm = 0, trys = 0;
+
+	while (trys <= retrys) {
+
+		pwm = i2c_smbus_read_word_data(client, PMBUS_FAN_PWM);
+		if (pwm < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->pwm = reg2data_linear(pwm, 0, PMBUS_FAN_PWM);
+
+	return sprintf(buf, "%d\n", data->pwm);
+
+fail:
+	return  sprintf(buf, "0\n");
+}
+
+static ssize_t set_pwm(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, trys = 0;
+
+	u16 pwm = simple_strtol(buf, NULL, 10);
+	if(pwm > 100) pwm = 100;
+
+	while (trys <= retrys) {
+
+		temp = i2c_smbus_write_word_data(client, PMBUS_FAN_PWM, pwm);
+		if (temp < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->pwm = pwm;
+
+	return count;
+
+fail:
+	return -1;
+}
+
+static ssize_t read_mfr_id(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, trys = 0;
+
+	if (read_only_once && data->id[0] != 0)
+		return sprintf(buf, "%s\n", data->id);
+
+	while (trys <= retrys) {
+
+		temp = i2c_smbus_read_block_data(client, PMBUS_READ_MFR_ID, data->id);
+		if (temp < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	return sprintf(buf, "%s\n", data->id);
+
+fail:
+	memset(data->id, 0, I2C_SMBUS_BLOCK_MAX + 2);
+	return  sprintf(buf, "%s\n", DEFAULT_MFR_FAIL_STR);
+}
+
+static ssize_t read_mfr_model(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, trys = 0;
+
+	if (read_only_once && data->model[0] != 0)
+		return sprintf(buf, "%s\n", data->model);
+
+	while (trys <= retrys) {
+
+		temp = i2c_smbus_read_block_data(client, PMBUS_READ_MFR_MODEL, data->model);
+		if (temp < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	return sprintf(buf, "%s\n", data->model);
+
+fail:
+	memset(data->model, 0, I2C_SMBUS_BLOCK_MAX + 2);
+	return  sprintf(buf, "%s\n", DEFAULT_MFR_FAIL_STR);
+}
+
+static ssize_t read_mfr_revision(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, trys = 0;
+
+	if (read_only_once && data->revision[0] != 0)
+		return sprintf(buf, "%s\n", data->revision);
+
+	while (trys <= retrys) {
+
+		temp = i2c_smbus_read_block_data(client, PMBUS_READ_MFR_REV, data->revision);
+		if (temp < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	return sprintf(buf, "%s\n", data->revision);
+
+fail:
+	memset(data->revision, 0, I2C_SMBUS_BLOCK_MAX + 2);
+	return  sprintf(buf, "%s\n", DEFAULT_MFR_FAIL_STR);
+}
+
+static ssize_t read_mfr_location(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, trys = 0;
+
+	if (read_only_once && data->location[0] != 0)
+		return sprintf(buf, "%s\n", data->location);
+
+	while (trys <= retrys) {
+
+		temp = i2c_smbus_read_block_data(client, PMBUS_READ_MFR_LOC, data->location);
+		if (temp < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	return sprintf(buf, "%s\n", data->location);
+
+fail:
+	memset(data->location, 0, I2C_SMBUS_BLOCK_MAX + 2);
+	return  sprintf(buf, "%s\n", DEFAULT_MFR_FAIL_STR);
+}
+
+static ssize_t read_mfr_date(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, trys = 0;
+
+	if (read_only_once && data->date[0] != 0)
+		return sprintf(buf, "%s\n", data->date);
+
+	while (trys <= retrys) {
+
+		temp = i2c_smbus_read_block_data(client, PMBUS_READ_MFR_DATE, data->date);
+		if (temp < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	return sprintf(buf, "%s\n", data->date);
+
+fail:
+	memset(data->date, 0, I2C_SMBUS_BLOCK_MAX + 2);
+	return  sprintf(buf, "%s\n", DEFAULT_MFR_FAIL_STR);
+}
+
+static ssize_t read_mfr_sn(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psu_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, trys = 0;
+
+	if (read_only_once && data->serial[0] != 0)
+		return sprintf(buf, "%s\n", data->serial);
+
+	while (trys <= retrys) {
+
+		temp = i2c_smbus_read_block_data(client, PMBUS_READ_MFR_SERIAL, data->serial);
+		if (temp < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	return sprintf(buf, "%s\n", data->serial);
+
+fail:
+	memset(data->serial, 0, I2C_SMBUS_BLOCK_MAX + 2);
+	return  sprintf(buf, "%s\n", DEFAULT_MFR_FAIL_STR);
+}
+
+static SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, read_voltage_in, 0, 0);
+static SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, read_voltage_out, 0, 0);
+static SENSOR_DEVICE_ATTR(curr1_input, S_IRUGO, read_current_in, 0, 0);
+static SENSOR_DEVICE_ATTR(curr2_input, S_IRUGO, read_current_out, 0, 0);
+static SENSOR_DEVICE_ATTR(power1_input, S_IRUGO, read_power_in, 0, 0);
+static SENSOR_DEVICE_ATTR(power2_input, S_IRUGO, read_power_out, 0, 0);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, read_temp, 0, 0);
+static SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, read_temp, 0, 1);
+static SENSOR_DEVICE_ATTR(temp3_input, S_IRUGO, read_temp, 0, 2);
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, read_fan, 0, 0);
+static SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO, read_fan, 0, 1);
+static SENSOR_DEVICE_ATTR(pwm1, S_IWUSR|S_IRUGO, read_pwm, set_pwm, 0);
+static SENSOR_DEVICE_ATTR(mfr_id, S_IRUGO, read_mfr_id, 0, 0);
+static SENSOR_DEVICE_ATTR(mfr_model, S_IRUGO, read_mfr_model, 0, 0);
+static SENSOR_DEVICE_ATTR(mfr_revision, S_IRUGO, read_mfr_revision, 0, 0);
+static SENSOR_DEVICE_ATTR(mfr_location, S_IRUGO, read_mfr_location, 0, 0);
+static SENSOR_DEVICE_ATTR(mfr_date, S_IRUGO, read_mfr_date, 0, 0);
+static SENSOR_DEVICE_ATTR(mfr_serial_number, S_IRUGO, read_mfr_sn, 0, 0);
+
+static struct attribute *psu_attributes[] = {
+	&sensor_dev_attr_in1_input.dev_attr.attr,
+	&sensor_dev_attr_in2_input.dev_attr.attr,
+	&sensor_dev_attr_curr1_input.dev_attr.attr,
+	&sensor_dev_attr_curr2_input.dev_attr.attr,
+	&sensor_dev_attr_power1_input.dev_attr.attr,
+	&sensor_dev_attr_power2_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp2_input.dev_attr.attr,
+	&sensor_dev_attr_temp3_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_mfr_id.dev_attr.attr,
+	&sensor_dev_attr_mfr_model.dev_attr.attr,
+	&sensor_dev_attr_mfr_revision.dev_attr.attr,
+	&sensor_dev_attr_mfr_location.dev_attr.attr,
+	&sensor_dev_attr_mfr_date.dev_attr.attr,
+	&sensor_dev_attr_mfr_serial_number.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group psu_group = {
+	.attrs = psu_attributes,
+};
+
+/*-----------------------------------------------------------------------*/
+/* device probe and removal */
+static int
+inv_psu_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct psu_data *data;
+	int status, ret;
+
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))
+		return -EIO;
+
+	data = kzalloc(sizeof(struct psu_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, data);
+	/* Enable PEC if the controller supports it */
+	ret = i2c_smbus_read_byte_data(client, PMBUS_CAPABILITY);
+	if (ret >= 0 && (ret & PB_CAPABILITY_ERROR_CHECK))
+		client->flags |= I2C_CLIENT_PEC;
+
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &psu_group);
+
+	if (status)
+		goto exit_free;
+
+	data->hwmon_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		status = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &psu_group);
+exit_free:
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return status;
+}
+
+static int inv_psu_remove(struct i2c_client *client)
+{
+	struct psu_data *data = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&client->dev.kobj, &psu_group);
+	hwmon_device_unregister(data->hwmon_dev);
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return 0;
+}
+
+static const struct i2c_device_id inv_psu_ids[] = {
+	{ "inv_psu" , 0, },
+	{ /* LIST END */ }
+};
+MODULE_DEVICE_TABLE(i2c, inv_psu_ids);
+
+static struct i2c_driver psu_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		.name	= "inv_psu",
+	},
+	.probe		= inv_psu_probe,
+	.remove		= inv_psu_remove,
+	.id_table	= inv_psu_ids,
+};
+
+static int __init inv_psu_init(void)
+{
+	return i2c_add_driver(&psu_driver);
+}
+
+static void __exit inv_psu_exit(void)
+{
+	i2c_del_driver(&psu_driver);
+}
+
+MODULE_AUTHOR("Roger Chang <chang.rogermc@inventec>");
+MODULE_DESCRIPTION("inventec psu driver");
+MODULE_LICENSE("GPL");
+
+module_init(inv_psu_init);
+module_exit(inv_psu_exit);
diff --git a/drivers/platform/x86/inv_ucd90160.c b/drivers/platform/x86/inv_ucd90160.c
new file mode 100644
index 0000000..da976f9
--- /dev/null
+++ b/drivers/platform/x86/inv_ucd90160.c
@@ -0,0 +1,259 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+#define PMBUS_PAGE	0x0
+#define PMBUS_VOUT_MODE	0x20
+#define PMBUS_READ_VOUT	0x8b
+
+
+static int retrys = 1;
+module_param(retrys, int, 0);
+MODULE_PARM_DESC(retrys, "Inventec UCD90160 read retry times (default 1).");
+
+struct ucd90160_data {
+	struct device *hwmon_dev;
+	s32	vout[16];
+	s32 vout_mode[16];
+	s32 pvout[16];
+};
+
+static s32 calc_voltage(struct device *dev, s32 vout, s32 vout_mode)
+{
+	s32 mode = (vout_mode & 0xe0) >> 5;
+	s32 parameter = (vout_mode & 0x1f);
+
+	switch (mode) {
+		case 0:
+			{
+				s32 exp = (parameter & 0x10) ? - ((32 - parameter) & 0xf) : (parameter & 0xf);
+				if (exp >= 0)
+					return ((vout * 1000) << exp);
+				else
+					return ((vout * 1000) >> -exp);
+			}
+		case 1:
+			dev_err(dev, "Not Support for VID mode");
+			return 0;
+		case 2:
+			dev_err(dev, "Not Support for Direct mode");
+			return 0;
+		default:
+			dev_err(dev, "Unknown Mode");
+			return 0;
+	}
+}
+
+static void update_vout_mode(struct i2c_client *client, u8 page, s32 clean)
+{
+	struct ucd90160_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, read = 0, trys = 0;
+
+	if (clean) {
+		data->vout_mode[page] = 0;
+		return;
+	}
+
+	if (data->vout_mode[page])
+		return;
+
+	while (trys <= retrys) {
+		read = i2c_smbus_read_byte_data(client, PMBUS_VOUT_MODE);
+		temp = i2c_smbus_read_byte_data(client, PMBUS_PAGE);
+		if (page != temp) {
+			trys++;
+			if (trys > retrys)
+				return;
+			continue;
+		}
+		break;
+	}
+
+	data->vout_mode[page] = read;
+}
+
+static ssize_t read_voltage_out(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ucd90160_data *data = i2c_get_clientdata(client);
+	s32 temp = 0, vout = 0, trys = 0;
+	u8 page = attr->index;
+
+	while (trys <= retrys) {
+		temp = i2c_smbus_write_byte_data(client, PMBUS_PAGE, page);
+		if (temp < 0) {
+			update_vout_mode(client, page, 1);
+			trys++;
+			if (trys > retrys)	goto absent;
+			continue;
+		}
+
+		update_vout_mode(client, page, 0);
+		vout = i2c_smbus_read_word_data(client, PMBUS_READ_VOUT);
+		if (vout < 0) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		temp = i2c_smbus_read_byte_data(client, PMBUS_PAGE);
+		if (page != temp) {
+			trys++;
+			if (trys > retrys)	goto fail;
+			continue;
+		}
+
+		break;
+	}
+
+	data->pvout[page] = data->vout[page];
+	data->vout[page] = calc_voltage(dev, vout, data->vout_mode[page]);
+
+	return sprintf(buf, "%d\n", data->vout[page]);
+
+fail:
+	return  sprintf(buf, "%d\n", data->pvout[page]);
+
+absent:
+	return  sprintf(buf, "0\n");
+}
+
+static SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, read_voltage_out, 0, 0);
+static SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, read_voltage_out, 0, 1);
+static SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, read_voltage_out, 0, 2);
+static SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, read_voltage_out, 0, 3);
+static SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, read_voltage_out, 0, 4);
+static SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, read_voltage_out, 0, 5);
+static SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, read_voltage_out, 0, 6);
+static SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, read_voltage_out, 0, 7);
+static SENSOR_DEVICE_ATTR(in9_input, S_IRUGO, read_voltage_out, 0, 8);
+static SENSOR_DEVICE_ATTR(in10_input, S_IRUGO, read_voltage_out, 0, 9);
+static SENSOR_DEVICE_ATTR(in11_input, S_IRUGO, read_voltage_out, 0, 10);
+static SENSOR_DEVICE_ATTR(in12_input, S_IRUGO, read_voltage_out, 0, 11);
+static SENSOR_DEVICE_ATTR(in13_input, S_IRUGO, read_voltage_out, 0, 12);
+static SENSOR_DEVICE_ATTR(in14_input, S_IRUGO, read_voltage_out, 0, 13);
+static SENSOR_DEVICE_ATTR(in15_input, S_IRUGO, read_voltage_out, 0, 14);
+static SENSOR_DEVICE_ATTR(in16_input, S_IRUGO, read_voltage_out, 0, 15);
+
+static struct attribute *ucd90160_attributes[] = {
+	&sensor_dev_attr_in1_input.dev_attr.attr,
+	&sensor_dev_attr_in2_input.dev_attr.attr,
+	&sensor_dev_attr_in3_input.dev_attr.attr,
+	&sensor_dev_attr_in4_input.dev_attr.attr,
+	&sensor_dev_attr_in5_input.dev_attr.attr,
+	&sensor_dev_attr_in6_input.dev_attr.attr,
+	&sensor_dev_attr_in7_input.dev_attr.attr,
+	&sensor_dev_attr_in8_input.dev_attr.attr,
+	&sensor_dev_attr_in9_input.dev_attr.attr,
+	&sensor_dev_attr_in10_input.dev_attr.attr,
+	&sensor_dev_attr_in11_input.dev_attr.attr,
+	&sensor_dev_attr_in12_input.dev_attr.attr,
+	&sensor_dev_attr_in13_input.dev_attr.attr,
+	&sensor_dev_attr_in14_input.dev_attr.attr,
+	&sensor_dev_attr_in15_input.dev_attr.attr,
+	&sensor_dev_attr_in16_input.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group ucd90160_group = {
+	.attrs = ucd90160_attributes,
+};
+
+/*-----------------------------------------------------------------------*/
+/* device probe and removal */
+static int
+inv_ucd90160_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct ucd90160_data *data;
+	int status;
+
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))
+		return -EIO;
+
+	data = kzalloc(sizeof(struct ucd90160_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, data);
+
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &ucd90160_group);
+
+	if (status)
+		goto exit_free;
+
+	data->hwmon_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		status = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &ucd90160_group);
+exit_free:
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return status;
+}
+
+static int inv_ucd90160_remove(struct i2c_client *client)
+{
+	struct ucd90160_data *data = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&client->dev.kobj, &ucd90160_group);
+	hwmon_device_unregister(data->hwmon_dev);
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return 0;
+}
+
+static const struct i2c_device_id inv_ucd90160_ids[] = {
+	{ "inv_ucd90160" , 0, },
+	{ "inv_ucd90160_cpu" , 0, },
+	{ "inv_ucd90160_switch" , 0, },
+	{ "inv_ucd90160_line" , 0, },
+	{ /* LIST END */ }
+};
+MODULE_DEVICE_TABLE(i2c, inv_ucd90160_ids);
+
+static struct i2c_driver ucd90160_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		.name	= "inv_ucd90160",
+	},
+	.probe		= inv_ucd90160_probe,
+	.remove		= inv_ucd90160_remove,
+	.id_table	= inv_ucd90160_ids,
+};
+
+static int __init inv_ucd90160_init(void)
+{
+	return i2c_add_driver(&ucd90160_driver);
+}
+
+static void __exit inv_ucd90160_exit(void)
+{
+	i2c_del_driver(&ucd90160_driver);
+}
+
+MODULE_AUTHOR("Roger Chang <chang.rogermc@inventec>");
+MODULE_DESCRIPTION("inventec ucd90160 driver");
+MODULE_LICENSE("GPL");
+
+module_init(inv_ucd90160_init);
+module_exit(inv_ucd90160_exit);
-- 
2.7.4

