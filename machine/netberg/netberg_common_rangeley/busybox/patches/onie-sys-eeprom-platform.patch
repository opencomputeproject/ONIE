diff --git a/include/applets.src.h b/include/applets.src.h
index 71b8cbd..891fb67 100644
--- a/include/applets.src.h
+++ b/include/applets.src.h
@@ -345,6 +345,7 @@ IF_WHOAMI(APPLET_NOFORK(whoami, whoami, BB_DIR_USR_BIN, BB_SUID_DROP, whoami))
 IF_YES(APPLET_NOFORK(yes, yes, BB_DIR_USR_BIN, BB_SUID_DROP, yes))
 IF_ZCIP(APPLET(zcip, BB_DIR_SBIN, BB_SUID_DROP))
 IF_SYS_EEPROM(APPLET_ODDNAME(onie-syseeprom, onie_syseeprom, BB_DIR_USR_BIN, BB_SUID_DROP, onie_syseeprom))
+APPLET_ODDNAME(mb_detect, mbdetect, BB_DIR_USR_BIN, BB_SUID_DROP, mbdetect)
 
 #if !defined(PROTOTYPES) && !defined(NAME_MAIN) && !defined(MAKE_USAGE) \
 	&& !defined(MAKE_LINKS) && !defined(MAKE_SUID)
diff --git a/include/i2c-dev.h b/include/i2c-dev.h
index 23f7c2c..23885b1 100644
--- a/include/i2c-dev.h
+++ b/include/i2c-dev.h
@@ -326,5 +326,158 @@ static inline __s32 i2c_smbus_block_process_call(int file, __u8 command,
 	}
 }
 
+static inline __s32 i2c_dev_smbus_access(__s32 file, __u8 read_write, __u8 command,
+                         __s32 size, union i2c_smbus_data *data)
+{
+    struct i2c_smbus_ioctl_data args;
+
+    args.read_write = read_write;
+    args.command = command;
+    args.size = size;
+    args.data = data;
+    return ioctl(file, I2C_SMBUS, &args);
+}
+
+static inline __s32 i2c_dev_open(__s32 i2cbus)
+{
+    __s32 file;
+    char filename[20] = "";
+
+    sprintf(filename, "/dev/i2c-%d", i2cbus);
+    file = open(filename, O_RDWR);
+
+    if (file < 0)
+        printf("Error: Could not open file %s\n", filename);
+
+    return file;
+}
+
+static inline __s32 i2c_dev_read(__s32 file, __u8 *buffer, __s32 offset, __s32 length)
+{
+    __s32 i;
+    union i2c_smbus_data data;
+
+    for (i = 0; i < length; i++)
+    {
+        if (i2c_dev_smbus_access(file, I2C_SMBUS_READ, (__u8)(i + offset), I2C_SMBUS_BYTE_DATA, &data))
+        {
+            return -1;
+        }
+        else
+        {
+            buffer[i] = 0x0FF & data.byte;
+        }
+        usleep(5000);
+    }
+
+    return 0;
+}
+
+static inline __s32 i2c_dev_write(__s32 file, __u8 *buffer, __s32 offset, __s32 length)
+{
+    __s32 i;
+    union i2c_smbus_data data;
+
+    for (i = 0; i < length; i++)
+    {
+        data.byte = (__u8)buffer[i];
+        if (i2c_dev_smbus_access(file, I2C_SMBUS_WRITE, (__u8)(i + offset), I2C_SMBUS_BYTE_DATA, &data) != 0)
+            return -1;
+        usleep(5000);
+    }
+    return 0;
+}
+
+static inline __s32 i2c_dev_seek(__s32 file, __s32 offset)
+{
+    return i2c_dev_smbus_access(file, I2C_SMBUS_WRITE, offset, I2C_SMBUS_BYTE, NULL);
+}
+
+static inline __s32 i2c_read(__s32 bus, __u8 dev, uint addr, __u8 *data, __s32 length)
+{
+    __s32 fd, ret;
+
+    fd = i2c_dev_open(bus);
+    if(fd < 0) {
+        return -1;
+    }
+
+    ret = ioctl(fd, I2C_SLAVE, dev);
+    if(ret < 0) {
+        close(fd);
+        return -1;
+    }
+
+    ret = i2c_dev_read(fd, data, addr, length);
+    if(ret < 0) {
+        close(fd);
+        return -1;
+    }
+
+    close(fd);
+    return 0;
+}
+
+static inline __s32 i2c_write(__s32 bus, __u8 dev, uint addr, __s32 alen, __u8 *data, __s32 length)
+{
+    __s32 fd, ret;
+
+    fd = i2c_dev_open(bus);
+    if(fd < 0) {
+        return -1;
+    }
+
+    ret = ioctl(fd, I2C_SLAVE, dev);
+    if(ret < 0) {
+        close(fd);
+        return -1;
+    }
+
+    ret = i2c_dev_seek(fd, addr);
+    if(ret < 0) {
+        close(fd);
+        return -1;
+    }
+
+    ret = i2c_dev_write(fd, data, alen, length);
+    if(ret < 0) {
+        close(fd);
+        return -1;
+    }
+
+    close(fd);
+    return 0;
+}
+
+/**
+ * i2c_mux_select - select channel for i2c mux
+ * 0xff will release i2c mux
+ */
+static inline __s32 i2c_mux_select(__s32 bus, __u8 chip, __u8 channel)
+{
+    __u8 data = 0;
+    if(channel == 0xff)
+    {
+        data = 0;
+    }
+    else if(channel >=0 && channel <8)
+    {
+        data = (0x01 << channel);
+    }
+    else
+    {
+        return -1;
+    }
+
+    return i2c_write(bus, chip, 0, 1, &data, 1);
+}
+
+/**
+ * i2c_mux_release - release channel for i2c mux
+ */
+static inline __s32 i2c_mux_release(__s32 bus, __u8 chip)
+{
+    return i2c_mux_select(bus, chip, 0xff);
+}
 
 #endif /* _LINUX_I2C_DEV_H */
diff --git a/miscutils/Kbuild.src b/miscutils/Kbuild.src
index 72ddcd1..7f9c2b4 100644
--- a/miscutils/Kbuild.src
+++ b/miscutils/Kbuild.src
@@ -56,3 +56,4 @@ lib-$(CONFIG_SYS_EEPROM_DEVICE_I2C) += sys_eeprom_i2c.o 24cXX.o
 lib-$(CONFIG_SYS_EEPROM_DEVICE_MTD) += sys_eeprom_mtd.o
 lib-$(CONFIG_SYS_EEPROM_DEVICE_DISK) += sys_eeprom_disk.o
 lib-$(CONFIG_SYS_EEPROM_SYSFS_FILE) += sys_eeprom_sysfs_file.o
+lib-y                     += mb_detect.o
diff --git a/miscutils/sys_eeprom.c b/miscutils/sys_eeprom.c
index 3003bd6..1c92f68 100644
--- a/miscutils/sys_eeprom.c
+++ b/miscutils/sys_eeprom.c
@@ -1,5 +1,6 @@
 #include "libbb.h"
 #include "onie_tlvinfo.h"
+#include "sys_eeprom.h"
 #include <getopt.h>
 
 static u_int8_t eeprom[SYS_EEPROM_SIZE];
diff --git a/miscutils/sys_eeprom_i2c.c b/miscutils/sys_eeprom_i2c.c
index ed3235b..0a638fe 100644
--- a/miscutils/sys_eeprom_i2c.c
+++ b/miscutils/sys_eeprom_i2c.c
@@ -2,6 +2,8 @@
 #include "onie_tlvinfo.h"
 #include "sys_eeprom.h"
 #include "24cXX.h"
+#include <i2c-dev.h>
+#include <mb_detect.h>
 
 #if SYS_EEPROM_I2C_MEM_ADDR_BITS == 8
     #define EEPROM_TYPE EEPROM_TYPE_8BIT_ADDR
@@ -22,9 +24,18 @@ int read_sys_eeprom(void *eeprom_data, int offset, int len)
     u_int8_t *c;
     int addr = SYS_EEPROM_OFFSET + offset;
 
+    SysEEPROMPath ep;
+    sys_eeprom_path_get(&ep);
+    if (ep.i2c_mux != 0x00)
+    {
+        if(i2c_mux_select(MB_DETECT_I2C_BUS, ep.i2c_mux, ep.i2c_channel) != 0) {
+            printf("ERROR: Cannot select I2C mux for eeprom\n");
+            return -1;
+        }
+    }
+
     c = eeprom_data;
-    if (eeprom_open(SYS_EEPROM_I2C_DEVICE, SYS_EEPROM_I2C_ADDR,
-		    EEPROM_TYPE, &e)) {
+    if (eeprom_open(ep.i2c_bus, ep.i2c_dev, EEPROM_TYPE, &e)) {
 	printf("ERROR: Cannot open I2C device\n");
 	return -1;
     }
@@ -33,6 +44,10 @@ int read_sys_eeprom(void *eeprom_data, int offset, int len)
 	c++; addr++;
     }
     eeprom_close(&e);
+
+    if (ep.i2c_mux != 0x00)
+        i2c_mux_release(MB_DETECT_I2C_BUS, ep.i2c_mux);
+
     return ret;
 }
 
@@ -47,17 +62,31 @@ int write_sys_eeprom(void *eeprom_data, int len)
     u_int8_t *c;
     u_int16_t  addr = SYS_EEPROM_OFFSET;
 
+    SysEEPROMPath ep;
+    sys_eeprom_path_get(&ep);
+    if (ep.i2c_mux != 0x00)
+    {
+        if(i2c_mux_select(MB_DETECT_I2C_BUS, ep.i2c_mux, ep.i2c_channel) != 0) {
+            printf("ERROR: Cannot select I2C mux for eeprom\n");
+            return -1;
+        }
+    }
+
+    if (eeprom_open(ep.i2c_bus, ep.i2c_dev, EEPROM_TYPE, &e)) {
+        printf("ERROR: Cannot open I2C device\n");
+        return -1;
+    }
+
     c = eeprom_data;
     for (i = 0; i < len; i++) {
-	if (eeprom_open(SYS_EEPROM_I2C_DEVICE, SYS_EEPROM_I2C_ADDR,
-			EEPROM_TYPE, &e)) {
-	    printf("ERROR: Cannot open I2C device\n");
-	    return -1;
-	}
 	eeprom_write_byte(&e, addr, *c);
-	eeprom_close(&e);
+        usleep(5000);
 	c++; addr++;
     }
+    eeprom_close(&e);
+
+    if (ep.i2c_mux != 0x00)
+        i2c_mux_release(MB_DETECT_I2C_BUS, ep.i2c_mux);
 
     return ret;
 }
