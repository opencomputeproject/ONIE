Quanta LB9

diff --git a/board/quanta/quanta_lb9/Makefile b/board/quanta/quanta_lb9/Makefile
new file mode 100644
index 0000000..657f9cd
--- /dev/null
+++ b/board/quanta/quanta_lb9/Makefile
@@ -0,0 +1,49 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+# (C) Copyright 2001-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+COBJS-y	+= sys_eeprom.o
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/quanta/quanta_lb9/ddr.c b/board/quanta/quanta_lb9/ddr.c
new file mode 100644
index 0000000..78d73b0
--- /dev/null
+++ b/board/quanta/quanta_lb9/ddr.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 as published by the Free Software Foundation.
+ */
+
+#include <common.h>
+
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	/*
+	 * Factors to consider for clock adjust:
+	 *	- number of chips on bus
+	 *	- position of slot
+	 *	- DDR1 vs. DDR2?
+	 *	- ???
+	 *
+	 * This needs to be determined on a board-by-board basis.
+	 *	0110	3/4 cycle late
+	 *	0111	7/8 cycle late
+	 */
+	popts->clk_adjust = 6;
+
+	/*
+	 * Factors to consider for CPO:
+	 *	- frequency
+	 *	- ddr1 vs. ddr2
+	 */
+	popts->cpo_override = 0;
+
+	/*
+	 * Factors to consider for write data delay:
+	 *	- number of DIMMs
+	 *
+	 * 1 = 1/4 clock delay
+	 * 2 = 1/2 clock delay
+	 * 3 = 3/4 clock delay
+	 * 4 = 1   clock delay
+	 * 5 = 5/4 clock delay
+	 * 6 = 3/2 clock delay
+	 */
+	popts->write_data_delay = 3;
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+}
diff --git a/board/quanta/quanta_lb9/law.c b/board/quanta/quanta_lb9/law.c
new file mode 100644
index 0000000..24e0923
--- /dev/null
+++ b/board/quanta/quanta_lb9/law.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+/*
+ * LAW(Local Access Window) configuration:
+ *
+ * 0x0000_0000     0x7fff_ffff     DDR                     2G
+ * 0x8000_0000     0x9fff_ffff     PCI1 MEM                512M
+ * 0xa000_0000     0xbfff_ffff     PCI2 MEM                512M
+ * 0xe000_0000     0xe000_ffff     CCSR                    1M
+ * 0xe200_0000     0xe20f_ffff     PCI1 IO                 1M
+ * 0xe210_0000     0xe21f_ffff     PCI2 IO                 1M
+ * 0xf000_0000     0xf000_ffff     CF CARD                 64K
+ * 0xf001_0000     0xf001_ffff     CF CARD                 64K
+ * 0xfc00_0000     0xfdff_ffff     FLASH (2nd bank)        32M
+ * 0xfe00_0000     0xffff_ffff     FLASH (boot bank)       32M
+ *
+ * Notes:
+ *    CCSRBAR and L2-as-SRAM don't need a configured Local Access Window.
+ */
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_PCI1_MEM_PHYS, LAW_SIZE_512M, LAW_TRGT_IF_PCI),
+	SET_LAW(CONFIG_SYS_PCI1_IO_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_PCI),
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_FLASH2_BASE_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_CFCARD0_BASE_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_CFCARD1_BASE_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_LBC),
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/quanta/quanta_lb9/quanta_lb9.c b/board/quanta/quanta_lb9/quanta_lb9.c
new file mode 100644
index 0000000..55c5609
--- /dev/null
+++ b/board/quanta/quanta_lb9/quanta_lb9.c
@@ -0,0 +1,465 @@
+/*
+ * Copyright 2004, 2011 Freescale Semiconductor.
+ *
+ * (C) Copyright 2002 Scott McNutt <smcnutt@artesyncp.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <ioports.h>
+#include <spd_sdram.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <phy.h>
+#include <linux/mdio.h>
+#include <flash.h>
+#include <i2c.h>
+
+#if defined(CONFIG_DDR_ECC) && !defined(CONFIG_ECC_INIT_VIA_DDRCONTROLLER)
+extern void ddr_enable_ecc(unsigned int dram_size);
+#endif
+
+void local_bus_init(void);
+
+/*
+ * I/O Port configuration table
+ *
+ * if conf is 1, then that port pin will be configured at boot time
+ * according to the five values podr/pdir/ppar/psor/pdat for that entry
+ */
+const iop_conf_t iop_conf_tab[4][32] = {
+    /* Port A configuration */
+    {   /*         conf ppar psor pdir podr pdat */
+	/* PA31 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA30 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist*/
+	/* PA29 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist*/
+	/* PA28 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA27 */ {   1,   0,   0,   0,   0,   0   }, /* AD_PWR_GD */
+	/* PA26 */ {   1,   0,   0,   0,   0,   0   }, /* P1V2_PG */
+	/* PA25 */ {   1,   0,   0,   1,   0,   1   }, /* SOFT_RST_N (Software reset, active low)*/
+	/* PA24 */ {   1,   0,   0,   1,   0,   1   }, /* HARD_RST_N (Hardware reset, active low)*/
+	/* PA23 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA22 */ {   1,   0,   0,   1,   0,   0   }, /* STATUS_LED (The LED indicate system status, active low)*/
+	/* PA21 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA20 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA19 */ {   1,   0,   0,   1,   0,   1   }, /* CF_BUS_EN_N (Bus enable for Compact Flash card, active low)*/
+	/* PA18 */ {   1,   0,   0,   1,   0,   1   }, /* CF_PWR_EN_N (Power enable for Compact Flash card, active low) */
+	/* PA17 */ {   1,   0,   0,   1,   0,   0   }, /* CF_RST_N (Reset Compact Flash card, active low)*/
+	/* PA16 */ {   1,   0,   0,   1,   0,   0   }, /* DMA_RST (Reset CPLD, active low)*/
+	/* PA15 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA14 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA13 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA12 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA11 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA10 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA9  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA8  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA7  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA6  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA5  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA4  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA3  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA2  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA1  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PA0  */ {   0,   0,   0,   0,   0,   0   }  /* pin doesn't exist */
+    },
+
+    /* Port B configuration */
+    {   /*         conf ppar psor pdir podr pdat */
+	/* PB31 */ {   0,   0,   0,   0,   0,   0   }, /* PCA9548 Reset, active low. */
+	/* PB30 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB29 */ {   0,   0,   0,   0,   0,   0   }, /* PHY Reset (BCM5461S), active low. */
+	/* PB28 */ {   0,   0,   0,   0,   0,   0   }, /* All PHY Reset (BCM54680*6+BCM8727*2+BCM5461S), active low. */
+	/* PB27 */ {   1,   0,   0,   0,   0,   0   }, /* MODULE_INT_N */
+	/* PB26 */ {   1,   0,   0,   1,   0,   1   }, /* PHY_ISO_N (set all 1G phy to super isolate (active low) */
+	/* PB25 */ {   1,   0,   0,   1,   0,   1   }, /* MOD_RST_N */
+	/* PB24 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB23 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB22 */ {   1,   0,   0,   1,   0,   1   }, /* F_RST_N */
+	/* PB21 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB20 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB19 */ {   1,   0,   0,   0,   0,   0   }, /* MOD_ID_SEL1 */
+	/* PB18 */ {   1,   0,   0,   0,   0,   0   }, /* MOD_ID_SEL0 */
+	/* PB17 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB16 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB15 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB14 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB13 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB12 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB11 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB10 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB9  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB8  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB7  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB6  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB5  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB4  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB3  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB2  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB1  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB0  */ {   0,   0,   0,   0,   0,   0   }  /* pin doesn't exist */
+    },
+
+    /* Port C */
+    {   /*         conf ppar psor pdir podr pdat */
+	/* PC31 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC30 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC29 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC28 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC27 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC26 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC25 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC24 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC23 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC22 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC21 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC20 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC19 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC18 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC17 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC16 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC15 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC14 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC13 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC12 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC11 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC10 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC9  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC8  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC7  */ {   1,   0,   0,   0,   0,   0   }, /* ADT_IRQ_N */
+	/* PC6  */ {   1,   0,   0,   0,   0,   0   }, /* CF_OC_N (Compact Flash card over-current detect active low)*/
+	/* PC5  */ {   1,   0,   0,   0,   0,   0   }, /* CF_DET1 (Compact Flash card present 1, active low)*/
+	/* PC4  */ {   1,   0,   0,   0,   0,   0   }, /* CF_DET0 (Compact Flash card present 0, active low)*/
+	/* PC3  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC2  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC1  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PC0  */ {   1,   0,   0,   0,   0,   0   }, /* RTC_IRQ_N */
+     },
+
+    /* Port D */
+    {   /*         conf ppar psor pdir podr pdat */
+	/* PD31 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD30 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD29 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD28 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD27 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD26 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD25 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD24 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD23 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD22 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD21 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD20 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD19 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD18 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD17 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD16 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD15 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD14 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD13 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD12 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD11 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD10 */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD9  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD8  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD7  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD6  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD5  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD4  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD3  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD2  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD1  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD0  */ {   0,   0,   0,   0,   0,   0   }  /* pin doesn't exist */
+    }
+};
+
+int
+board_phy_config(struct phy_device *phydev)
+{
+        struct mii_dev *bus = phydev->bus;
+	unsigned short tmp;
+
+        /*
+         * Take the management port phy out of isolate mode
+         */
+	tmp = bus->read(bus, TSEC1_PHYIDX, MDIO_DEVAD_NONE, MII_BMCR);
+        tmp &= ~BMCR_ISOLATE;
+	bus->write(bus, TSEC1_PHYIDX, MDIO_DEVAD_NONE, MII_BMCR, tmp);
+}
+
+void board_reset(void)
+{
+        volatile ccsr_cpm_t *cpm = (ccsr_cpm_t *)CONFIG_SYS_MPC85xx_CPM_ADDR;
+        volatile ioport_t *iop;
+
+	iop = ioport_addr(cpm, 0);  /* port A */
+        /* HARD_RST_N */
+	iop->pdat &= ~0x00000080;
+}
+
+int ide_preinit(void)
+{
+        volatile ccsr_cpm_t *cpm = (ccsr_cpm_t *)CONFIG_SYS_MPC85xx_CPM_ADDR;
+        volatile ioport_t *iop;
+
+        iop = ioport_addr(cpm, 2);  /* port C */
+        /*  Compact Flash Card Present Signal (Active Low)*/
+        if (iop->pdat & 0x08000000) {
+                printf ("compact flash not present\n");
+                return -1;
+        }
+
+	iop = ioport_addr(cpm, 0);  /* port A */
+        /* Power Enable for Compact Flash Card. */
+	iop->pdat &= ~0x00002000;
+
+	iop = ioport_addr(cpm, 0);  /* port A */
+        /* Bus Enable for Compact Flash Card. */
+        iop->pdat &= ~0x00001000;
+
+	iop = ioport_addr(cpm, 0);  /* port A */
+        /* Release the Compact Flash Card reset pin. */
+        iop->pdat |= 0x00004000;
+
+        return 0;
+}
+
+int checkboard (void)
+{
+	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	uint pci1_clk_sel = gur->porpllsr & 0x8000;	/* PORPLLSR[16] */
+
+	printf ("Board: Quanta LB9\n");
+
+	printf("PCI1: 32 bit, 66 MHz, %s\n",
+		pci1_clk_sel ? "sync" : "async");
+
+	local_bus_init();
+
+	return 0;
+}
+
+/*
+ * Initialize Local Bus
+ */
+void
+local_bus_init(void)
+{
+	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	volatile fsl_lbc_t *lbc = LBC_BASE_ADDR;
+
+	uint clkdiv;
+	uint lbc_hz;
+	sys_info_t sysinfo;
+	uint temp_lbcdll;
+
+	/*
+	 * Errata LBC11.
+	 * Fix Local Bus clock glitch when DLL is enabled.
+	 *
+	 * If localbus freq is < 66MHz, DLL bypass mode must be used.
+	 * If localbus freq is > 133MHz, DLL can be safely enabled.
+	 * Between 66 and 133, the DLL is enabled with an override workaround.
+	 */
+
+	get_sys_info(&sysinfo);
+	clkdiv = lbc->lcrr & LCRR_CLKDIV;
+	lbc_hz = sysinfo.freqSystemBus / 1000000 / clkdiv;
+
+	if (lbc_hz < 66) {
+		lbc->lcrr |= LCRR_DBYP;	/* DLL Bypass */
+
+	} else if (lbc_hz >= 133) {
+		lbc->lcrr &= (~LCRR_DBYP);		/* DLL Enabled */
+
+	} else {
+		lbc->lcrr &= (~LCRR_DBYP);	/* DLL Enabled */
+		udelay(200);
+
+		/*
+		 * Sample LBC DLL ctrl reg, upshift it to set the
+		 * override bits.
+		 */
+		temp_lbcdll = gur->lbcdllcr;
+		gur->lbcdllcr = (((temp_lbcdll & 0xff) << 16) | 0x80000000);
+		asm("sync;isync;msync");
+	}
+}
+
+#ifdef CONFIG_PCI
+static struct pci_controller hose[] = {
+	{},
+};
+#endif	/* CONFIG_PCI */
+
+void
+pci_init_board(void)
+{
+#ifdef CONFIG_PCI
+	pci_mpc85xx_init(hose);
+#endif
+}
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void
+ft_pci_setup(void *blob, bd_t *bd)
+{
+	int node, tmp[2];
+	const char *path;
+
+	node = fdt_path_offset(blob, "/aliases");
+	tmp[0] = 0;
+	if (node >= 0) {
+#ifdef CONFIG_PCI1
+		path = fdt_getprop(blob, node, "pci0", NULL);
+		if (path) {
+			tmp[1] = hose[0].last_busno - hose[0].first_busno;
+			do_fixup_by_path(blob, path, "bus-range", &tmp, 8, 1);
+		}
+#endif
+#ifdef CONFIG_MPC85XX_PCI2
+		path = fdt_getprop(blob, node, "pci1", NULL);
+		if (path) {
+			tmp[1] = hose[1].last_busno - hose[1].first_busno;
+			do_fixup_by_path(blob, path, "bus-range", &tmp, 8, 1);
+		}
+#endif
+	}
+}
+
+static void ft_flash_setup(void *blob, bd_t *bd)
+{
+	int node;
+
+	/*
+	 * The Quanta LB9 comes in two variants.  One variant has a
+	 * single 32MB flash part located at CONFIG_SYS_FLASH_BASE.
+	 * The other variant has an additional 32MB flash part located
+	 * at CONFIG_SYS_FLASH2_BASE.
+	 *
+	 * If we only have 1 flash part, but a node exists in the
+	 * device tree for the 2nd flash part disable it.
+	 *
+	 * Check if 2nd flash bank is present.  If it is not present
+	 * disable the corresponding device tree node.
+	 *
+	 * The check of flash_info[1] below relies on U-Boot's flash
+	 * detection.
+	 */
+	if (flash_info[1].flash_id != FLASH_MAN_CFI) {
+		/*
+		 * Look for NOR flash node @ CONFIG_SYS_FLASH2_BASE.
+		 */
+		node = fdt_node_offset_by_compat_reg(blob, "cfi-flash", CONFIG_SYS_FLASH2_BASE);
+		if (node >= 0) {
+			fdt_set_node_status(blob, node, FDT_STATUS_DISABLED, 0);
+		}
+	}
+
+}
+
+void
+ft_board_setup(void *blob, bd_t *bd)
+{
+        ft_cpu_setup(blob, bd);
+#ifdef CONFIG_PCI
+        ft_pci_setup(blob, bd);
+#endif
+	ft_flash_setup(blob, bd);
+}
+#endif
+
+void ide_set_reset(int idereset)
+{
+    return;
+}
+
+/*******************************************************************************
+ *
+ * MISC initializations after relocating to RAM.  Full C environment available.
+ * Before configuring network interfaces.
+ *
+ * Set the default fan speeds to 40% duty cycle.
+ *
+ */
+
+#define HW_MON_I2C_BUS	    (0)
+#define HW_MON_I2C_MUX_ADDR (0x70)
+
+enum {
+	ADT7470_PWM1_REG = 0x32,
+	ADT7470_PWM2_REG = 0x33,
+	ADT7470_PWM3_REG = 0x34,
+	ADT7470_PWM4_REG = 0x35,
+};
+
+#define ADT7470_1_ADDR	(0x2c)
+#define ADT7470_2_ADDR	(0x2f)
+
+int misc_init_r(void)
+{
+	u8 val;
+	u8 channel[2] = { 4, 5 };
+	u8 addr[2]    = { ADT7470_1_ADDR, ADT7470_2_ADDR };
+	u8 dev, reg;
+	int bus;
+	u8 pwm_reg[4] = {
+		ADT7470_PWM1_REG,
+		ADT7470_PWM2_REG,
+		ADT7470_PWM3_REG,
+		ADT7470_PWM4_REG,
+	};
+
+	bus = i2c_get_bus_num();
+	i2c_set_bus_num(HW_MON_I2C_BUS);
+
+	/*
+	 * Program all PWM registers on both ADT7470 devices to 40%.
+	 */
+	for (dev = 0; dev < 2; dev++) {
+		/* mux bus-select */
+		val = 0x1 << channel[dev];
+		i2c_write(HW_MON_I2C_MUX_ADDR, 0, 1, &val, 1);
+
+		/*
+		 * PWM 0x60 is ~ 40% duty cycle
+		 * Write all four PWM registers.
+		 */
+		val = 0x60;
+		for (reg = 0 ; reg < 4; reg++) {
+			i2c_write(addr[dev], pwm_reg[reg], 1, &val, 1);
+		}
+	}
+
+	/* Disable the MUX */
+	val = 0;
+	i2c_write(HW_MON_I2C_MUX_ADDR, 0, 1, &val, 1);
+
+	/* Restore i2c bus */
+	i2c_set_bus_num(bus);
+
+	return 0;
+}
diff --git a/board/quanta/quanta_lb9/sys_eeprom.c b/board/quanta/quanta_lb9/sys_eeprom.c
new file mode 100644
index 0000000..4290766
--- /dev/null
+++ b/board/quanta/quanta_lb9/sys_eeprom.c
@@ -0,0 +1,576 @@
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <asm/io.h>
+#include <linux/ctype.h>
+
+#include "sys_eeprom.h"
+
+/* Convert hex digit to hex character and vice-versa */
+static int i2xdigit(int digit)
+{
+    digit &= 0xf;
+    return (digit > 9) ? digit-10+'a' : digit+'0';
+}
+
+/*
+ * format_macaddr requires a buffer of 18 bytes minimum.
+ * It does not use sprintf so it can be called from an interrupt context.
+ */
+static void format_macaddr(char buf[18], char macaddr[6])
+{
+    int i;
+
+    for (i = 0;i <= 5;i++)
+    {
+        *buf++ = i2xdigit(macaddr[i]>>4);
+        *buf++ = i2xdigit(macaddr[i]);
+        *buf++ = ':';
+    }
+
+    *--buf = 0;
+}
+
+#define	MAX_DATE_STRING		21
+/*=======================================================================================*/
+u8 * versionToString(u32  version)
+{
+    static u8 verString[MAX_DATE_STRING] ;
+    u32 major, minor/*, build */;
+
+    major = (version & 0xff000000) >> 24 ;
+    minor = (version & 0x00ff0000) >> 16 ;
+/*    build = (version & 0x0000ffff) ;*/
+
+/*    sprintf(verString, "%02d.%02d.%04d", major, minor, build) ;*/
+    sprintf(verString, "%d.%d", major, minor) ;
+
+    return verString ;
+}
+u8 * SoftwareversionToString(u32  version)
+{
+    static u8 verString[MAX_DATE_STRING] ;
+    u32 major, minor ,v1, v2;/*, build */;
+
+    major = (version & 0xf0000000) >> 28 ;
+    minor = (version & 0x0f000000) >> 24 ;
+    v1 = (version & 0x00f00000) >> 20 ;
+    v2 = (version & 0x000f0000) >> 16 ;
+
+/*    build = (version & 0x0000ffff) ;*/
+
+/*    sprintf(verString, "%02d.%02d.%04d", major, minor, build) ;*/
+    sprintf(verString, "%d.%d.%d.%d", major, minor,v1,v2) ;
+
+    return verString ;
+}
+/*=======================================================================================*/
+u8 * dateToString(u32 date)
+{
+    static u8 dateString[MAX_DATE_STRING] ;
+    u32        year, month, day ;
+
+    year = (date & 0xffff0000) >> 16 ;
+    month = (date & 0x0000ff00) >> 8 ;
+    day = (date & 0x000000ff) ;
+
+    sprintf(dateString, "%04d/%d/%d", year, month, day) ;
+
+    return dateString ;
+}
+/*=======================================================================================*/
+static int Write_Boardinfo_EEPROM(struct SysBoardInfo *pbdinfo)
+{
+    u8 writebuffer[EEPROM_24C02_SIZE];
+    int i , ret=0;
+
+  memset(writebuffer, 0, EEPROM_24C02_SIZE);
+  memcpy(writebuffer, (u8 *)pbdinfo , SYS_BOARD_INFO_SIZE);
+
+  for (i=0;i<EEPROM_24C02_SIZE;i++)
+  {
+#if defined(CONFIG_SB1A_P1010) || defined(CONFIG_SB1B_P1010)
+	ret = i2c_write(I2C_AT24C02_EEPROM_MB, i , 2, &writebuffer[i] , 1);
+#else
+	ret = i2c_write(I2C_AT24C02_EEPROM_MB, i , 1, &writebuffer[i] , 1);
+#endif
+	udelay(12000);
+	if (ret != 0 ) break;
+
+  }
+
+  return ret;
+
+}
+/*=======================================================================================*/
+void ShowBoardInfo(struct SysBoardInfo *pbdinfo)
+{
+    char buf[128], macString[18];
+    printf("\n"MODEL_NAME" U-Boot\r\n");
+#if defined(CONFIG_SB1A_P1010) || defined(CONFIG_SB1B_P1010)
+    printf("  Manufacturer Name     : %s\r\n", pbdinfo->productName);
+#else
+    printf("  Product Name          : %s\r\n", pbdinfo->productName);
+#endif
+    printf("  Model Name            : %s\r\n", pbdinfo->modelName);
+    printf("  Serial Number         : %s\r\n", pbdinfo->serialNumber);
+    printf("  Part Number           : %s\r\n", pbdinfo->partNumber);
+    printf("  Label Revision Number : %s\r\n", pbdinfo->label_revisionNumber);
+    printf("  Hardware Version      : %s\r\n", versionToString(pbdinfo->hardwareVersion));
+#if 1 /* Only show platform number */
+    printf("  Platform Version      : 0x%04x\r\n", pbdinfo->softwareVersion & 0xffff);
+#else
+    printf("  Platform Version      : %s (0x%08x)\r\n", SoftwareversionToString(pbdinfo->softwareVersion) , pbdinfo->softwareVersion);
+#endif
+    printf("  Release Date          : %s\r\n", dateToString(pbdinfo->releaseDate));
+    format_macaddr(macString, pbdinfo->macAddr);
+    printf("  MAC Address           : %s\r\n", macString);
+}
+/*=======================================================================================*/
+
+void BuildBoardInfoDefault (struct SysBoardInfo *boardInfo)
+{
+    u8 macAddr[6];
+    u32 a, b, c;
+
+    memset(boardInfo, 0, sizeof(boardInfo));
+
+    strncpy((u8 *)boardInfo->productName, MODEL_NAME, SYS_PRODUCT_NAME_SIZE) ;
+    strncpy((u8 *)boardInfo->partNumber, "123456789", SYS_PART_NUMBER_SIZE) ;
+    strncpy((u8 *)boardInfo->serialNumber, "123456789", SYS_SERIAL_NUMBER_SIZE) ;
+
+    a = 0;      b = 1;          c = 0;
+    boardInfo->hardwareVersion = (((a & 0x000000FF) << 24) | ((b & 0x000000FF) << 16) | (c & 0x000000FF)) ;
+
+    macAddr[0] = 0x00;         macAddr[1] = 0xc0;         macAddr[2] = 0x9f;
+    macAddr[3] = 0x01;         macAddr[4] = 0x02;         macAddr[5] = 0x03;
+    memcpy(boardInfo->macAddr, macAddr, 6) ;
+
+    boardInfo->softwareVersion = CONFIG_QUANTA_SOFT_VERSION;
+
+    strncpy((u8 *)boardInfo->label_revisionNumber, "1", SYS_LABEL_REVISION_NUMBER_SIZE) ;
+    a = 2012;       b = 1;          c = 1;
+    boardInfo->releaseDate = (((a & 0x0000FFFF) << 16) | ((b & 0x000000FF) << 8) | (c & 0x000000FF)) ;
+    strncpy((u8 *)boardInfo->modelName, "QUANTA "MODEL_NAME, SYS_MODEL_NAME_SIZE) ;
+
+    boardInfo->checksum = crc32(0,boardInfo, SYS_BOARD_INFO_SIZE - sizeof(unsigned int)) ;
+
+    printf("\nUpdating board information by default, please wait ... ");
+#if 0
+    if (Write_Boardinfo_EEPROM(boardInfo)==0)
+	    printf(" Done.\n");
+    else
+	    printf(" FAIL.\n");
+#else
+	    printf(" NOT!\n");
+#endif
+}
+/*=======================================================================================*/
+
+void  BuildEEPROMData(struct SysBoardInfo *pbdinfo)
+{
+    unsigned short total_zize, str_length;
+    unsigned int  CradTypeNum;
+    unsigned short computed_crc;
+    unsigned char writebuffer[EEPROM_24C02_SIZE];
+    u32 a, b, c;
+    char macAddr[6];
+
+    memset(pbdinfo, 0, SYS_BOARD_INFO_SIZE);
+
+    strncpy((u8 *)pbdinfo->productName, MODEL_NAME, SYS_PRODUCT_NAME_SIZE) ;
+
+    strncpy((char *)pbdinfo->partNumber, "123456789", SYS_PART_NUMBER_SIZE) ;
+    strncpy((char *)pbdinfo->serialNumber, "123456789", SYS_SERIAL_NUMBER_SIZE) ;
+    a = 0;      b = 1;          c = 0;
+    pbdinfo->hardwareVersion = (((a & 0x000000FF) << 24) | ((b & 0x000000FF) << 16) | (c & 0x000000FF)) ;
+    macAddr[0] = 0x00;         macAddr[1] = 0xc0;         macAddr[2] = 0x9f;
+    macAddr[3] = 0x01;         macAddr[4] = 0x02;         macAddr[5] = 0x03;
+    memcpy(pbdinfo->macAddr, macAddr, 6) ;
+
+    pbdinfo->softwareVersion = CONFIG_QUANTA_SOFT_VERSION;
+
+    strncpy((char *)pbdinfo->label_revisionNumber, "1", SYS_LABEL_REVISION_NUMBER_SIZE) ;
+    a = 2012;       b = 1;          c = 1;
+    pbdinfo->releaseDate = (((a & 0x0000FFFF) << 16) | ((b & 0x000000FF) << 8) | (c & 0x000000FF)) ;
+
+    strncpy((u8 *)pbdinfo->modelName, "QUANTA "MODEL_NAME, SYS_MODEL_NAME_SIZE) ;
+
+ /*   pbdinfo->checksum = crc32(0,pbdinfo, SYS_BOARD_INFO_SIZE - sizeof(unsigned int)) ;*/
+
+    memset(writebuffer, 0, EEPROM_24C02_SIZE);
+    total_zize = 0;
+
+    /* Magic Number */
+    writebuffer[total_zize++] = EEPROM_Type_Magic_Num;
+    writebuffer[total_zize++] = EEPROM_Magic_Num_Length;
+    writebuffer[total_zize++] = EEPROM_Magic_Num;
+
+    /* Product Name */
+    str_length = strlen((char *)pbdinfo->productName);
+    if ((str_length>0)&&(str_length<=EEPROM_Max_Product_Name_Length))
+    {
+        writebuffer[total_zize++] = EEPROM_Type_Product_Name;
+        writebuffer[total_zize++] = str_length;
+        memcpy(&writebuffer[total_zize], pbdinfo->productName, str_length);
+        total_zize += str_length;
+    }
+
+    /* Part Number */
+    str_length = strlen((char *)pbdinfo->partNumber);
+    if ((str_length>0)&&(str_length<=EEPROM_Max_Part_Length))
+    {
+        writebuffer[total_zize++] = EEPROM_Type_Part;
+        writebuffer[total_zize++] = str_length;
+        memcpy(&writebuffer[total_zize], pbdinfo->partNumber, str_length);
+        total_zize += str_length;
+    }
+
+    /* Serial Number */
+    str_length = strlen((char *)pbdinfo->serialNumber);
+    if ((str_length>0)&&(str_length<=EEPROM_Max_Serial_Length))
+    {
+        writebuffer[total_zize++] = EEPROM_Type_Serial;
+        writebuffer[total_zize++] = str_length;
+        memcpy(&writebuffer[total_zize], pbdinfo->serialNumber, str_length);
+        total_zize += str_length;
+    }
+
+    /* MAC Address */
+    writebuffer[total_zize++] = EEPROM_Type_MAC;
+    writebuffer[total_zize++] = EEPROM_MAC_Length;
+    memcpy(&writebuffer[total_zize], pbdinfo->macAddr, EEPROM_MAC_Length);
+    total_zize += EEPROM_MAC_Length;
+
+    /* Date of Manufacture */
+    writebuffer[total_zize++] = EEPROM_Type_Date;
+    writebuffer[total_zize++] = EEPROM_Date_Length;
+    memcpy(&writebuffer[total_zize], (unsigned char *)&pbdinfo->releaseDate, EEPROM_Date_Length);
+    total_zize += EEPROM_Date_Length;
+
+    /* Card Type */
+    CradTypeNum = EEPROM_Card_Type;
+    writebuffer[total_zize++] = EEPROM_Type_Card_Type;
+    writebuffer[total_zize++] = EEPROM_Card_Type_Length;
+    memcpy(&writebuffer[total_zize], (unsigned char *)&CradTypeNum, EEPROM_Card_Type_Length);
+    total_zize += EEPROM_Card_Type_Length;
+
+    /* Hardware Revision */
+    writebuffer[total_zize++] = EEPROM_Type_Hardware_Version;
+    writebuffer[total_zize++] = EEPROM_Hardware_Version_Length;
+    memcpy(&writebuffer[total_zize], (unsigned char *)&pbdinfo->hardwareVersion, EEPROM_Hardware_Version_Length);
+    total_zize += EEPROM_Hardware_Version_Length;
+
+    /* Label Revision Number */
+    str_length = strlen((char *)pbdinfo->label_revisionNumber);
+    if ((str_length>0)&&(str_length<=EEPROM_Max_Label_Revision_Length))
+    {
+        writebuffer[total_zize++] = EEPROM_Type_Label_Revision;
+        writebuffer[total_zize++] = str_length;
+        memcpy(&writebuffer[total_zize], pbdinfo->label_revisionNumber, str_length);
+        total_zize += str_length;
+    }
+
+    /* Model Name */
+    str_length = strlen((char *)pbdinfo->modelName);
+    if ((str_length>0)&&(str_length<=EEPROM_Max_Model_Name_Length))
+    {
+        writebuffer[total_zize++] = EEPROM_Type_Model_Name;
+        writebuffer[total_zize++] = str_length;
+        memcpy(&writebuffer[total_zize], pbdinfo->modelName, str_length);
+        total_zize += str_length;
+    }
+
+    /* Software Revision */
+    writebuffer[total_zize++] = EEPROM_Type_Software_Version;
+    writebuffer[total_zize++] = EEPROM_Software_Version_Length;
+    memcpy(&writebuffer[total_zize], (unsigned char *)&pbdinfo->softwareVersion, EEPROM_Software_Version_Length);
+    total_zize += EEPROM_Software_Version_Length;
+
+    /* CRC16-CCITT */
+    writebuffer[total_zize++] = EEPROM_Type_CRC16;
+    writebuffer[total_zize++] = EEPROM_CRC16_Length;
+
+#if 0
+    CRC_Init();
+    computed_crc = (UI16)crcbitbybit(writebuffer, total_zize);
+#else
+    computed_crc = 0;
+    computed_crc = crc32(computed_crc, writebuffer, total_zize);
+#endif
+    writebuffer[total_zize++] = (computed_crc&0xff);
+    writebuffer[total_zize++] = (computed_crc>>8)&0xff;
+
+    printf("\nUpdating board information by default, please wait ... ");
+#if 0
+    if (Write_Boardinfo_EEPROM(writebuffer)==0)
+	    printf(" Done.\n");
+    else
+	    printf(" FAIL.\n");
+#else
+	    printf(" NOT!\n");
+#endif
+
+    return;
+}
+
+int ReadEEPROMData(struct SysBoardInfo *pbdinfo, unsigned char *Readbuffer)
+{
+    unsigned short	 idx, str_length, type;
+    unsigned short	 computed_crc, read_crc;
+    char magic_number_flag, crc_number_flag;
+
+    magic_number_flag = crc_number_flag = 0;
+    idx = 0;
+    while (1)
+    {
+        type = Readbuffer[idx++];
+        str_length = Readbuffer[idx++];
+        if (str_length>0)
+        {
+            switch(type)
+            {
+                /* Check Magic Number */
+                case EEPROM_Type_Magic_Num:
+                    if (Readbuffer[idx] == EEPROM_Magic_Num)
+                        magic_number_flag = 1;
+                break;
+
+                /* Read Product Name */
+                case EEPROM_Type_Product_Name:
+                    memcpy(pbdinfo->productName, &Readbuffer[idx], str_length);
+                break;
+
+                /* Read Model Name */
+                case EEPROM_Type_Model_Name:
+                    memcpy(pbdinfo->modelName, &Readbuffer[idx], str_length);
+                break;
+
+                /* Read Part Number */
+                case EEPROM_Type_Part:
+                    memcpy(pbdinfo->partNumber, &Readbuffer[idx],  str_length);
+                break;
+
+                /* Read Serial Number */
+                case EEPROM_Type_Serial:
+                    memcpy(pbdinfo->serialNumber, &Readbuffer[idx],  str_length);
+                break;
+
+                /* Read Label Revision Number */
+                case EEPROM_Type_Label_Revision:
+                    memcpy(pbdinfo->label_revisionNumber, &Readbuffer[idx],  str_length);
+                break;
+
+                /* Read MAC Address */
+                case EEPROM_Type_MAC:
+                    memcpy(pbdinfo->macAddr, &Readbuffer[idx],  str_length);
+                break;
+
+                /* Read Hardware Revision */
+                case EEPROM_Type_Hardware_Version:
+                   memcpy(&pbdinfo->hardwareVersion, &Readbuffer[idx],  str_length);
+                break;
+
+                /* Read Software Revision */
+                case EEPROM_Type_Software_Version:
+                   memcpy(&pbdinfo->softwareVersion, &Readbuffer[idx],  str_length);
+                break;
+
+                /* Read Release Date*/
+                case EEPROM_Type_Date:
+                   memcpy(&pbdinfo->releaseDate, &Readbuffer[idx],  str_length);
+                break;
+
+                /* Check CRC16-CCITT */
+                case EEPROM_Type_CRC16:
+                    computed_crc = read_crc = 0;
+                    read_crc = Readbuffer[idx] + (Readbuffer[idx+1]<<8);
+                    computed_crc = crc32(computed_crc, Readbuffer, idx);
+                    if (read_crc==computed_crc)
+                        crc_number_flag = 1;
+                break;
+            }
+            idx += str_length;
+        }
+        if (idx>(EEPROM_24C02_SIZE-5)) break;
+    }
+
+    if ((magic_number_flag)&&(crc_number_flag))
+        return 1;
+
+     printf("EEPROM data error (computed_crc(%#08x) != read_crc(%#08x)) , \r\nCan't read MAC address from EEPROM!!\r\n" ,computed_crc , read_crc);
+     return 0;
+}
+
+static struct SysBoardInfo g_pbdinfo;
+static int info_read = 0;
+
+static int PopulateBoardData(void)
+{
+    char dataBuffer[EEPROM_24C02_SIZE];
+    int i;
+    unsigned int chksum = 0;
+    int rc = 0;
+
+    if (info_read)
+	return 0;
+
+    memset(dataBuffer, 0, sizeof(dataBuffer));
+
+#if defined(CONFIG_LY2_P2020) || defined(CONFIG_LY3_P2020) /* Add By Arius ---- 09/13/2011 */
+    char data = 0x01;
+    /* Do Channel Select */
+    if (i2c_write(I2C_PCA9546_FAN_I2C_SWITCH, 0x00, 1, &data, 1 ) != 0)
+    {
+        puts("I2C error ! Can't select Channel for PCA9546A!!\r\n");
+	return 1;
+    }
+#endif
+
+#if 1 /*using Type/Length/Data  format*/
+    memset(dataBuffer, 0, sizeof(dataBuffer));
+    memset(&g_pbdinfo, 0, SYS_BOARD_INFO_SIZE);
+
+    i2c_set_bus_num(0);
+
+#if defined(CONFIG_SB1A_P1010) || defined(CONFIG_SB1B_P1010)
+    if (i2c_read(I2C_AT24C02_EEPROM_MB, 0x00, 2, dataBuffer, EEPROM_24C02_SIZE) == 0)
+#else
+    if (i2c_read(I2C_AT24C02_EEPROM_MB, 0x00, 1, dataBuffer, EEPROM_24C02_SIZE) == 0)
+#endif
+    {
+        if (ReadEEPROMData(&g_pbdinfo, dataBuffer))
+        {
+            ShowBoardInfo(&g_pbdinfo);
+        }
+        else
+        {
+            puts("Error parsing TLV EEPROM data :");
+	    rc = 1;
+            for(i = 0; i < EEPROM_24C02_SIZE; i++)
+            {
+                if ((i % 16) == 0) printf("\r\n");
+                printf(" %02x", dataBuffer[i]);
+            }
+            BuildEEPROMData(&g_pbdinfo);
+            ShowBoardInfo(&g_pbdinfo);
+        }
+    }
+    else
+    {
+        puts("I2C error ! Can't read EEPROM data!!\r\n");
+	rc = 1;
+        BuildEEPROMData(&g_pbdinfo);
+        ShowBoardInfo(&g_pbdinfo);
+    }
+#else
+    if (i2c_read(I2C_AT24C02_EEPROM_MB, 0x00, 1, dataBuffer, EEPROM_24C02_SIZE ) == 0)
+    {
+        memcpy(&g_pbdinfo, dataBuffer, sizeof(struct SysBoardInfo));
+        chksum = crc32(0, (unsigned char *)&g_pbdinfo, SYS_BOARD_INFO_SIZE - sizeof(unsigned int)) ;
+
+        if (g_pbdinfo.checksum == chksum)
+        {
+            ShowBoardInfo(&g_pbdinfo);
+        }
+        else
+        {
+            printf("EEPROM data error (checksum(%#08x) != pbdinfo.checksum(%#08x)) , \r\n"
+                   "Can't read MAC address from EEPROM!!\r\n" , chksum , g_pbdinfo.checksum);
+	    rc = 1;
+            puts("EEPROM data :");
+            for(i = 0; i < EEPROM_24C02_SIZE; i++)
+            {
+                if ((i % 16) == 0) printf("\r\n");
+                printf(" %02x", dataBuffer[i]);
+            }
+            BuildBoardInfoDefault(&g_pbdinfo);
+            ShowBoardInfo(&g_pbdinfo);
+        }
+    }
+    else
+    {
+        puts("I2C error ! Can't read EEPROM data!!\r\n");
+	rc = 1;
+        BuildBoardInfoDefault(&g_pbdinfo);
+        ShowBoardInfo(&g_pbdinfo);
+    }
+#endif
+
+    softwareVersion = g_pbdinfo.softwareVersion;
+
+#if defined(CONFIG_LY2_P2020) || defined(CONFIG_LY3_P2020) /* Add By Arius ---- 09/13/2011 */
+    /* Do Channel Release */
+    data = 0x00;
+    if (i2c_write(I2C_PCA9546_FAN_I2C_SWITCH, 0x00, 1, &data, 1 ) != 0)
+    {
+        puts("I2C error ! Can't Release Channel for PCA9546A!!\r\n");
+	rc = 1;
+    }
+#endif
+
+    info_read = 1;
+    return rc;
+}
+
+/**
+ *  mac_read_from_eeprom
+ *
+ *  Read the MAC addresses from EEPROM
+ *
+ *  This function reads the MAC addresses from EEPROM and sets the
+ *  appropriate environment variables for each one read.
+ *
+ *  The environment variables are only set if they haven't been set already.
+ *  This ensures that any user-saved variables are never overwritten.
+ *
+ *  This function must be called after relocation.
+ */
+int mac_read_from_eeprom(void)
+{
+    char macString[18];
+
+    if (PopulateBoardData() == 0) {
+	    if (getenv("ethaddr"))
+		    return 0;
+
+	    format_macaddr(macString, (char *)g_pbdinfo.macAddr);
+	    setenv ("ethaddr", macString);
+    } else {
+	    printf("Reading EEPROM failed.\n");
+	    return -1;
+    }
+
+    return 0;
+}
+
+#ifdef CONFIG_POPULATE_SERIAL_NUMBER
+/**
+ *  populate_serial_number - read the serial number from EEPROM
+ *
+ *  This function reads the serial number from the EEPROM and sets the
+ *  appropriate environment variable.
+ *
+ *  The environment variable is only set if it has not been set
+ *  already.  This ensures that any user-saved variables are never
+ *  overwritten.
+ *
+ *  This function must be called after relocation.
+ */
+int populate_serial_number(void)
+{
+
+    if (PopulateBoardData() == 0) {
+	    if (getenv("serial#"))
+		    return 0;
+
+	    g_pbdinfo.serialNumber[SYS_SERIAL_NUMBER_SIZE - 1] = '\0';
+	    setenv ("serial#", (char *)g_pbdinfo.serialNumber);
+    } else {
+	    printf("Reading EEPROM failed.\n");
+	    return 1;
+    }
+
+    return 0;
+}
+#endif /* CONFIG_POPULATE_SERIAL_NUMBER */
diff --git a/board/quanta/quanta_lb9/sys_eeprom.h b/board/quanta/quanta_lb9/sys_eeprom.h
new file mode 100644
index 0000000..f738bc1
--- /dev/null
+++ b/board/quanta/quanta_lb9/sys_eeprom.h
@@ -0,0 +1,77 @@
+#ifndef __SYS_EEPROM_H_
+#define __SYS_EEPROM_H_
+
+/*
+ * Board information definitions
+ */
+#define SYS_BOARD_INFO_SIZE		160		/* board info size */
+#define SYS_PRODUCT_NAME_SIZE		32		/* max. product name size */
+#define SYS_MODEL_NAME_SIZE		20		/* max. model name size */
+#define SYS_PART_NUMBER_SIZE		20		/* max. part number size */
+#define SYS_SERIAL_NUMBER_SIZE		20		/* max. serial number size */
+#define SYS_LABEL_REVISION_NUMBER_SIZE	20		/* max. label reversion number size */
+#define SYS_MAC_ADDR_SIZE		6		/* mac address size */
+
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+struct SysBoardInfo {
+   u8 productName[SYS_PRODUCT_NAME_SIZE];			/* product name */
+   u8 modelName[SYS_MODEL_NAME_SIZE];				/* model name */
+   u8 partNumber[SYS_PART_NUMBER_SIZE];			/* part number */
+   u8 serialNumber[SYS_SERIAL_NUMBER_SIZE];			/* serial number */
+   u8 label_revisionNumber[SYS_LABEL_REVISION_NUMBER_SIZE];	/* label revision serial number */
+   u32 hardwareVersion ;	/* hardware version of this board
+				* B1: major version, B2: minor version,
+				* B3: test stage, eg. A, B, C..., R for release,
+				* B4: test minor version
+				* eg. 1.03B1 for version 1.03 B Test 1
+				*/
+   u32 softwareVersion ;	/* software version of this board
+				* B1: major version, B2: minor version,
+				* B3: test stage, eg. A, B, C..., R for release,
+				* B4: test minor version
+				* eg. 1.03B1 for version 1.03 B Test 1
+				*/
+   u32 releaseDate ;				/* release date */
+   u8 macAddr[SYS_MAC_ADDR_SIZE] ;		/* mac address */
+   u8 Manufacture_Mode ;           /* 0 : Normal       1 : Auto in Diagnostic Test Mode    2 : Auto in Burn-In test Mode */
+   u8 reserved[25] ;				/* reserved, should be all zero! */
+   u32 checksum ;				/* checksum of BoardInfo except this field */
+} ;
+
+
+unsigned long softwareVersion ; /* software version of this board*/
+
+
+#define String_Type_Length 20
+#define EEPROM_Type_Magic_Num 0xFF
+#define EEPROM_Type_Product_Name 0x01
+#define EEPROM_Type_Part 0x02
+#define EEPROM_Type_Serial 0x03
+#define EEPROM_Type_MAC 0x04
+#define EEPROM_Type_Date 0x05
+#define EEPROM_Type_Card_Type 0x06
+#define EEPROM_Type_Hardware_Version 0x07
+#define EEPROM_Type_Label_Revision 0x08
+#define EEPROM_Type_Model_Name 0x09
+#define EEPROM_Type_Software_Version 0x0A
+#define EEPROM_Type_CRC16 0x00
+
+#define EEPROM_Magic_Num_Length 1
+#define EEPROM_Max_Product_Name_Length SYS_PRODUCT_NAME_SIZE
+#define EEPROM_Max_Part_Length SYS_PART_NUMBER_SIZE
+#define EEPROM_Max_Serial_Length SYS_SERIAL_NUMBER_SIZE
+#define EEPROM_MAC_Length SYS_MAC_ADDR_SIZE
+#define EEPROM_Max_Label_Revision_Length  SYS_LABEL_REVISION_NUMBER_SIZE
+#define EEPROM_Max_Model_Name_Length SYS_MODEL_NAME_SIZE
+#define EEPROM_Date_Length 4
+#define EEPROM_Card_Type_Length 4
+#define EEPROM_Hardware_Version_Length 4
+#define EEPROM_Software_Version_Length 4
+#define EEPROM_CRC16_Length 2
+
+#define EEPROM_Magic_Num 0xE0
+#define EEPROM_Card_Type 0x00000001
+
+#endif
diff --git a/board/quanta/quanta_lb9/tlb.c b/board/quanta/quanta_lb9/tlb.c
new file mode 100644
index 0000000..2c5a054
--- /dev/null
+++ b/board/quanta/quanta_lb9/tlb.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR, CONFIG_SYS_INIT_RAM_ADDR,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 , CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 , CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 , CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/*
+	 * CCSRBAR: Non-cacheable, guarded
+	 * 0xe000_0000	1M	CCSRBAR
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_1M, 1),
+
+	/*
+	 * FLASH: Non-cacheable, guarded
+	 * 0xfc000000	32M     2nd Flash
+	 * 0xfe000000	32M     Boot Flash
+	 * Out of reset this entry is only 4K.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH2_BASE, CONFIG_SYS_FLASH2_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_64M, 1),
+
+	/*
+         * PCI1 MEM First Half
+	 * 0x80000000	256M	Non-cacheable, guarded
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT, CONFIG_SYS_PCI1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+	/*
+         * PCI1 MEM Second Half
+	 * 0x90000000	256M	Non-cacheable, guarded
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_256M, 1),
+
+	/*
+	 * CF Card: Non-cacheable, guarded
+	 * 0xf0000000	64K     Control Registers
+	 * 0xf0010000	64K     Alt Registers
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CFCARD0_BASE, CONFIG_SYS_CFCARD0_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_64K, 1),
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/boards.cfg b/boards.cfg
index e4b0d44..27ada52 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -717,6 +717,8 @@ MPC8536DS_SDCARD             powerpc     mpc85xx     mpc8536ds           freesca
 MPC8536DS_SPIFLASH           powerpc     mpc85xx     mpc8536ds           freescale      -           MPC8536DS:SPIFLASH
 MPC8540ADS                   powerpc     mpc85xx     mpc8540ads          freescale
 MPC8541CDS                   powerpc     mpc85xx     mpc8541cds          freescale      -           MPC8541CDS
+QUANTA_LB9                   powerpc     mpc85xx     quanta_lb9          quanta
+QUANTA_LB9-R0                powerpc     mpc85xx     quanta_lb9          quanta         -           QUANTA_LB9:ONIE_PLATFORM_REV=0
 MPC8541CDS_legacy            powerpc     mpc85xx     mpc8541cds          freescale      -           MPC8541CDS:LEGACY
 MPC8544DS                    powerpc     mpc85xx     mpc8544ds           freescale
 MPC8548CDS                   powerpc     mpc85xx     mpc8548cds          freescale      -           MPC8548CDS
diff --git a/common/cmd_ide.c b/common/cmd_ide.c
index 0105bdb..ed240c7 100644
--- a/common/cmd_ide.c
+++ b/common/cmd_ide.c
@@ -679,7 +679,11 @@ static void ide_ident(block_dev_desc_t *dev_desc)
 		return;
 #endif
 
+#if defined(CONFIG_QUANTA_LB9)
+	ide_input_data(device, (ulong *)&iop, ATA_SECTORWORDS);
+#else
 	ide_input_swap_data(device, (ulong *)&iop, ATA_SECTORWORDS);
+#endif
 
 	ident_cpy((unsigned char *) dev_desc->revision, iop.fw_rev,
 		  sizeof(dev_desc->revision));
@@ -936,7 +940,11 @@ ulong ide_read(int device, ulong blknr, lbaint_t blkcnt, void *buffer)
 			break;
 		}
 
+#if defined(CONFIG_QUANTA_LB9)
+		ide_input_swap_data(device, buffer, ATA_SECTORWORDS);
+#else
 		ide_input_data(device, buffer, ATA_SECTORWORDS);
+#endif
 		(void) ide_inb(device, ATA_STATUS);	/* clear IRQ */
 
 		++n;
diff --git a/config.mk b/config.mk
index b7cd481..12c3afd 100644
--- a/config.mk
+++ b/config.mk
@@ -189,7 +189,7 @@ endif
 # who are porting old code to latest mainline but not updating $(AR).
 ARFLAGS = $(error update your Makefile to use cmd_link_o_target and not AR)
 RELFLAGS= $(PLATFORM_RELFLAGS)
-DBGFLAGS= -g # -DDEBUG
+DBGFLAGS= -g #-DDEBUG
 OPTFLAGS= -Os #-fomit-frame-pointer
 
 OBJCFLAGS += --gap-fill=0xff
diff --git a/include/configs/QUANTA_LB9.h b/include/configs/QUANTA_LB9.h
new file mode 100644
index 0000000..5a57323
--- /dev/null
+++ b/include/configs/QUANTA_LB9.h
@@ -0,0 +1,433 @@
+/*
+ * Copyright 2004, 2011 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * mpc8541cds board configuration file
+ *
+ * Please refer to doc/README.mpc85xxcds for more info.
+ *
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "configs/common_config.h"
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/60/55/41 */
+#define CONFIG_CPM2		1	/* has CPM2 */
+#define CONFIG_MPC8541		1	/* MPC8541 specific */
+#define CONFIG_QUANTA_LB9       1
+
+#define CONFIG_PCI
+#define CONFIG_PCI1
+#define CONFIG_TSEC_ENET		/* tsec ethernet support */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_FSL_LAW		1	/* Use common FSL init code */
+
+#define CONFIG_SYS_CLK_FREQ	66000000
+/*#define CONFIG_DDR_CLK_FREQ	66666666*/
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			    /* toggle L2 cache	*/
+#define CONFIG_BTB			    /* toggle branch predition */
+
+#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+
+#define CONFIG_SYS_CCSRBAR		0xe0000000
+#define CONFIG_SYS_CCSRBAR_PHYS_LOW	CONFIG_SYS_CCSRBAR
+
+/* DDR Setup */
+#define CONFIG_FSL_DDR1
+#define CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup*/
+#define CONFIG_DDR_SPD
+#undef CONFIG_FSL_DDR_INTERACTIVE
+
+#define CONFIG_MEM_INIT_VALUE		0xDeadBeef
+
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory*/
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(2 * CONFIG_DIMM_SLOTS_PER_CTLR)
+
+/* I2C addresses of SPD EEPROMs */
+#define SPD_EEPROM_ADDRESS	0x57	/* CTLR 0 DIMM 0 */
+
+/*
+ * Make sure required options are set
+ */
+#ifndef CONFIG_SPD_EEPROM
+#error ("CONFIG_SPD_EEPROM is required by LB9")
+#endif
+
+#undef CONFIG_CLOCKS_IN_MHZ
+
+/*
+ * Local Bus Definitions
+ */
+
+#define CONFIG_SYS_FLASH_BASE	0xfe000000	/* boot flash */
+#define CONFIG_SYS_FLASH2_BASE	0xfc000000	/* 2nd flash */
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_FLASH2_BASE_PHYS	CONFIG_SYS_FLASH2_BASE
+
+#define CONFIG_FLASH_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_16 | BR_V)
+#define CONFIG_FLASH2_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH2_BASE_PHYS) | BR_PS_16 | BR_V)
+
+#define CONFIG_FLASH_OR_PRELIM		0xfe007e65 /* 32M */
+#define CONFIG_FLASH2_OR_PRELIM		0xfe007e65 /* 32M */
+
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_FLASH_BR_PRELIM /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_FLASH2_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_FLASH2_OR_PRELIM  /* NOR Options */
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH2_BASE}
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS 45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	256	/* sectors per device */
+
+#define CFG_FLASH_SECT_SIZE 0x20000 /* 128k bytes per sector */
+#define CFG_FLASH_SECT_OFFSET_MASK (CFG_FLASH_SECT_SIZE-1)
+#define CFG_FLASH_SECT_MASK (~CFG_FLASH_SECT_OFFSET_MASK)
+
+#undef	CONFIG_SYS_FLASH_CHECKSUM
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define	CONFIG_SYS_TEXT_BASE	0xfff80000
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+
+/*
+ * Compact FLASH on the Local Bus
+ * Two bank, 1M, using the IDE driver.
+ *
+ * BR5,BR2:
+ *    Base address 5 = 0xF000_0000 = BR5[0:16] = 1111 0000 0000 0000 0
+ *    Base address 2 = 0xF001_0000 = BR2[0:16] = 1111 0000 0000 0001 0
+ *    Port Size = 32 bits = BRx[19:20] = 11
+ *    Use GPCM = BRx[24:26] = 000
+ *    Valid = BRx[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 0000 0000 0000 0001 1000 0000 0001 = f0001801    BR5
+ * 1111 0000 0000 0001 0001 1000 0000 0001 = f0011801    BR2
+ *
+ * OR5, OR2:
+ *    Addr Mask = 64K = ORx[0:16] = 1111 1111 1111 1111 0
+ *    Reserved ORx[17:18] = 11, confusion here?
+ *    BCTLD = LBCTL not asserted = ORx[19] = 0
+ *    CSNT = ORx[20] = 1
+ *    ACS = half cycle delay = ORx[21:22] = 00
+ *    XACS = no extra setup = ORx[23] = 0
+ *    SCY = 10 = ORx[24:27] = 1010
+ *    SETA = cycle terminated internaly = ORx[28] = 0
+ *    TRLX = use relaxed timing = ORx[29] = 0
+ *    EHTR = use relaxed timing = ORx[30] = 0
+ *    EAD = use external address latch delay = OR[31] = 0
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1111 1000 0000 0110 1000 1010 0000 = ffFF68A0    ORx
+ * 1111 1111 1000 0000 0110 1000 1010 0000 = ffFF68A0    ORx
+ */
+
+#define CONFIG_SYS_CFCARD0_BASE	0xf0000000	/* start of compact Flash */
+#define CONFIG_SYS_CFCARD0_BASE_PHYS CONFIG_SYS_CFCARD0_BASE
+#define CONFIG_SYS_CFCARD1_BASE	0xf0010000	/* start of compact Flash */
+#define CONFIG_SYS_CFCARD1_BASE_PHYS CONFIG_SYS_CFCARD1_BASE
+
+#define CONFIG_SYS_BR5_PRELIM		0xf0001801
+#define CONFIG_SYS_BR2_PRELIM		0xf0011801
+
+#define	CONFIG_SYS_OR5_PRELIM		0xffff68A0 /* 64k */
+#define	CONFIG_SYS_OR2_PRELIM		0xffff68A0 /* 64k */
+
+
+/*
+ * CPLD on the Local Bus
+ * One bank, 1M, using the IDE driver.
+ *
+ * BR4:
+ *    Base address = 0xF200_0000 = BRx[0:16] = 1111 0010 0000 0000 0
+ *    Port Size = 32 bits = BRx[19:20] = 11
+ *    Use GPCM = BRx[24:26] = 000
+ *    Valid = BRx[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 0010 0000 0010 0001 0000 0000 0001 = F2001801    BR4
+ *
+ * OR4:
+ *    Addr Mask = 64K = ORx[0:16] = 1111 1111 1111 1111 0
+ *    Reserved ORx[17:18] = 11, confusion here?
+ *    BCTLD = LBCTL not asserted = ORx[19] = 1
+ *    CSNT = ORx[20] = 0
+ *    ACS = half cycle delay = ORx[21:22] = 11
+ *    XACS = no extra setup = ORx[23] = 0
+ *    SCY = 6 = ORx[24:27] = 0110
+ *    SETA = cycle terminated internaly = ORx[28] = 0
+ *    TRLX = use relaxed timing = ORx[29] = 1
+ *    EHTR = use relaxed timing = ORx[30] = 0
+ *    EAD = use external address latch delay = OR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1111 1000 0000 0111 0110 0110 0101 = ffff7665    ORx
+ */
+#define CPLD_SYS_BASE_ADDR      0xf2000000
+#define CONFIG_SYS_BR4_PRELIM   0xf2001801
+#define CONFIG_SYS_OR4_PRELIM   0xffff7665
+
+
+
+/*#define CONFIG_SYS_INIT_RAM_LOCK	1*/
+#define CONFIG_SYS_INIT_RAM_ADDR	0xE8000000	/* Initial RAM address */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x4000	    /* Size of used area in RAM */
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024) /* Reserve 512 kB for Mon */
+#define CONFIG_SYS_MALLOC_LEN		(256 * 1024)	/* Reserved for malloc */
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX     1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE    1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SYS_NS16550_COM1        (CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2        (CONFIG_SYS_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef  CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT		1
+#define CONFIG_OF_BOARD_SETUP		1
+#define CONFIG_OF_STDOUT_VIA_ALIAS	1
+
+/*
+ * I2C
+ */
+#define CONFIG_CMD_EEPROM		/* EEPROM read/write support	*/
+/*
+ * bit of hack to enable reading MAC from EEPROM w/o using Freescale's
+ * 'mac' command.  Just having it defined enables the infra to call
+ * our mac_read_from_eeprom() to set $ethaddr.
+ *
+ */
+#define CONFIG_SYS_I2C_MAC_OFFSET
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN		1
+#define CONFIG_SYS_I2C_EEPROM_INFO_ADDR         0x0
+#define CONFIG_SYS_I2C_EEPROM_INFO_LEN          0x0
+
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support*/
+#undef	CONFIG_SOFT_I2C			/* I2C bit-banged */
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000	/* I2C speed and slave address */
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_I2C_EEPROM_ADDR  	0x53
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_NOPROBES        {0x69}	/* Don't probe these addrs */
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+
+/*
+ * Quanta Board Info
+ */
+
+#define CONFIG_QUANTA_SOFT_VERSION 0xffffffff
+#define I2C_AT24C02_EEPROM_MB 0x53
+#define EEPROM_24C02_SIZE 256
+#define MODEL_NAME CONFIG_QUANTA_MODEL_NAME
+#define CONFIG_QUANTA_MODEL_NAME "LB9"
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCI1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0x80000000
+#define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCI1_IO_VIRT	0xe2000000
+#define CONFIG_SYS_PCI1_IO_BUS	 	0x00000000
+#define CONFIG_SYS_PCI1_IO_PHYS	0xe2000000
+#define CONFIG_SYS_PCI1_IO_SIZE	0x1000000	/* 16M */
+
+#define CONFIG_SYS_PCI2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_PHYS	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCI2_IO_VIRT	0xe2100000
+#define CONFIG_SYS_PCI2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCI2_IO_PHYS	0xe2100000
+#define CONFIG_SYS_PCI2_IO_SIZE	0x1000000	/* 16M */
+
+#if defined(CONFIG_PCI)
+
+#undef CONFIG_MPC85XX_PCI2 /* disabled */
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#undef CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_SYS_PCI_SUBSYS_VENDORID 0x1057  /* Motorola */
+
+#endif	/* CONFIG_PCI */
+
+
+#if defined(CONFIG_TSEC_ENET)
+
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI	1
+#endif
+
+#define CONFIG_MII		1	/* MII PHY management */
+#define CONFIG_TSEC1    	1
+#define CONFIG_TSEC1_NAME	"eth0"
+#define TSEC1_PHY_ADDR		0
+#define TSEC1_PHYIDX		0
+#define TSEC1_FLAGS		TSEC_GIGABIT
+
+/* Options are: TSEC[0-1] */
+#define CONFIG_ETHPRIME		"eth0"
+
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_ADDR		0xfff60000
+#define CONFIG_ENV_SECT_SIZE	0x20000	/* one sector for env */
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_OFFSET	0
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+#if defined(CONFIG_PCI)
+    #define CONFIG_CMD_PCI
+#endif
+
+#undef CONFIG_WATCHDOG			/* watchdog disabled */
+
+#if 1
+#define CONFIG_CMD_IDE
+#undef  CONFIG_IDE_8xx_DIRECT           /* no pcmcia interface required */
+#undef  CONFIG_IDE_LED                  /* no led for ide supported     */
+#define CONFIG_IDE_RESET        1       /* reset for ide supported      */
+#define CONFIG_IDE_PREINIT        1       /* call board specific ide init */
+
+#define CONFIG_SYS_IDE_MAXBUS           1               /* max. 1 IDE busses    */
+#define CONFIG_SYS_IDE_MAXDEVICE        (CONFIG_SYS_IDE_MAXBUS*1) /* max. 1 drives per IDE bus */
+
+#define CONFIG_SYS_ATA_BASE_ADDR        0xF0000000
+#define CONFIG_SYS_ATA_IDE0_OFFSET      0
+
+#define CONFIG_SYS_ATA_DATA_OFFSET      2 /* Offset for data I/O                  */
+#define CONFIG_SYS_ATA_REG_OFFSET       3 /* Offset for normal register accesses  */
+#define CONFIG_SYS_ATA_ALT_OFFSET       0x10000 /* Offset for alternate registers       */
+#define CONFIG_SYS_ATA_STRIDE           4
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+/* enable platform specific init */
+#define CONFIG_MISC_INIT_R      1
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+/* The mac addresses for all ethernet interface */
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#endif
+
+#define CONFIG_HOSTNAME		quanta-lb9-unknown
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		0x08000000
+
+/*
+ * Platform environment variables needed by the common env
+ * infrastructure.
+ *
+ */
+#define CONFIG_PLATFORM_ENV	\
+ "consoledev=ttyS0\0"		\
+ "onie_start=0xffb60000\0"	\
+ "onie_sz.b=0x00400000\0"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS	\
+ CONFIG_PLATFORM_ENV			\
+ CONFIG_ONIE_COMMON_UBOOT_ENV
+
+#endif	/* __CONFIG_H */
