diff --git a/miscutils/sys_eeprom_i2c.c b/miscutils/sys_eeprom_i2c.c
index e69de29..720f873 100644
--- a/miscutils/sys_eeprom_i2c.c
+++ b/miscutils/sys_eeprom_i2c.c
@@ -0,0 +1,129 @@
+#include "libbb.h"
+#include "onie_tlvinfo.h"
+#include "sys_eeprom.h"
+#include "24cXX.h"
+#include <linux/i2c-dev.h>
+
+#if SYS_EEPROM_I2C_MEM_ADDR_BITS == 8
+    #define EEPROM_TYPE EEPROM_TYPE_8BIT_ADDR
+#elif SYS_EEPROM_I2C_MEM_ADDR_BITS == 16
+    #define EEPROM_TYPE EEPROM_TYPE_16BIT_ADDR
+#else
+    #define EEPROM_TYPE EEPROM_TYPE_UNKNOWN
+#endif
+
+/*
+ * read_sys_eeprom - read the hwinfo from i2c EEPROM
+ */
+int read_sys_eeprom(void *eeprom_data, int offset, int len)
+{
+    //mcp2221 read cmd, two bytes header. Always write two bytes first before reaad() to decide what address to start read.
+    unsigned char start_addr[2] =  {0x00, 0x00}; // value format:{high byte, low byte}
+    int status;
+    unsigned char buf[16] = {0};
+    int i;
+
+    struct eeprom e;
+    u_int8_t *c;
+    int addr = SYS_EEPROM_OFFSET + offset;
+    c = eeprom_data;
+    int fd = open(SYS_EEPROM_I2C_DEVICE, O_RDWR);
+    if (fd < 0) {
+        printf("ERROR: open(%d) failed\n", fd);
+        return -1;
+    }
+
+    // SETTING EEPROM ADDR
+    status = ioctl(fd, I2C_SLAVE, SYS_EEPROM_I2C_ADDR);
+    if (status < 0)
+    {
+        printf("ERROR: ioctl(fd, I2C_SLAVE, 0x%02X) failed\n", SYS_EEPROM_I2C_ADDR);
+        close(fd);
+        return -1;
+    }
+
+    for(i=0; i<len; i+=16)
+    {
+        int read_num = (len-i)>15?16:(len-i);
+        start_addr[0] = (u_int8_t)((i+addr)/256);
+        start_addr[1] = i+addr;
+
+        if(write(fd,start_addr,2)!=2){
+            printf("ERROR: buffer pointer initialization of read() step 2+ failed\n");
+            close(fd);
+            return -1;
+        }
+        if (read(fd,buf,read_num) != 1) {
+        printf("ERROR: read() failed\n");
+        }
+        memcpy(c+i,buf,read_num);
+    }
+    close(fd);
+    return 0;
+}
+
+/*
+ * write_sys_eeprom - write the hwinfo to i2c EEPROM
+ */
+int write_sys_eeprom(void *eeprom_data, int len)
+{
+    //mcp2221 write cmd, two bytes for header.
+    //First two byte decide write start addrress with EEPROM. Here is 0x0000, no address shift by default.
+    unsigned char tmp[18] = {0};
+    unsigned int i;
+
+    struct eeprom e;
+    u_int8_t *c;
+    c = eeprom_data;
+
+    int fd = open(SYS_EEPROM_I2C_DEVICE, O_RDWR);
+    if (fd < 0) {
+        printf("ERROR: open(%d) failed\n", fd);
+        return -1;
+    }
+
+    int status;
+    // SETTING EEPROM ADDR
+    status = ioctl(fd, I2C_SLAVE, SYS_EEPROM_I2C_ADDR);
+    if (status < 0)
+    {
+        printf("ERROR: ioctl(fd, I2C_SLAVE, 0x%02X) failed\n", SYS_EEPROM_I2C_ADDR);
+        close(fd);
+        return -1;
+    }
+
+    //write 16 bytes everytime. first 2 bytes are write addresses.
+    for(i = 0; i < len; i+=16)
+    {
+        int write_num = (len-i)>15?16:(len-i);
+        tmp[0] = (u_int8_t)(i/256);
+        tmp[1] = i;
+        memcpy(tmp+2, c+i, write_num);
+
+        if(write(fd,tmp,18)!=18){
+            printf("ERROR: buffer pointer initialization of read() step 2+ failed\n");
+        }
+    }
+
+    /*
+    // for get and dump values if needed.
+    unsigned char buf[1] = {0};
+    for(i = 0; i<11; i++)
+    {
+        tmp[0] = (u_int8_t)(i/256);
+        tmp[1] = i & 0x00ff;
+
+        if(write(fd,tmp,2)!=2){
+        printf("ERROR: buffer pointer initialization of read() step 2+ failed\n");
+        }
+
+        if (read(fd,buf,1) != 1) {
+        printf("ERROR: read() failed\n");
+        }
+        printf("%d=0x%02X(%d) \r\n", i, buf[0],buf[0]);
+    }
+    */
+    
+    close(fd);
+    return 0;
+}
