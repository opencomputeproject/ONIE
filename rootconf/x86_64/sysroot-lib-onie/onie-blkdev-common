
onie_boot_mnt=${onie_boot_mnt:-"/mnt/onie-boot"}
#  Copyright (C) 2014 Curt Brune <curt@cumulusnetworks.com>
#  Copyright (C) 2015 david_yang <david_yang@accton.com>
#
#  SPDX-License-Identifier:     GPL-2.0

onie_root_dir="${onie_boot_mnt}/onie"
onie_config_dir="${onie_root_dir}/config"

grub_root_dir="${onie_boot_mnt}/grub"
grub_env_file="${grub_root_dir}/grubenv"

onie_grub_dir="${onie_root_dir}/grub"
onie_grub_d_dir="${onie_root_dir}/grub.d"

nos_grub_script="${onie_grub_d_dir}/30_nos_grub"
diag_grub_script="${onie_grub_d_dir}/60_diag_grub"

# gfdisk types and GPT UUIDs from gptfdisk-0.8.8/parttypes.cc
grub_boot_gfdisk_type="0xEF02"
onie_boot_gfdisk_type="0x3000"

grub_boot_gpt_uuid="21686148-6449-6E6F-744E-656564454649"
onie_boot_gpt_uuid="7412F7D5-A156-4B13-81DC-867174929325"

onie_boot_fs_type="ext4"

grub_boot_label="GRUB-BOOT"
onie_boot_label="ONIE-BOOT"

# Set a few GRUB_xxx environment variables that will be picked up and
# used by the 50_onie_grub script.  This is similiar to what an OS
# would specify in /etc/default/grub.
#
# GRUB_SERIAL_COMMAND
# GRUB_CMDLINE_LINUX

DEFAULT_GRUB_SERIAL_COMMAND="serial --port=%%CONSOLE_PORT%% --speed=%%CONSOLE_SPEED%% --word=8 --parity=no --stop=1"
DEFAULT_GRUB_CMDLINE_LINUX="console=tty0 console=ttyS%%CONSOLE_DEV%%,%%CONSOLE_SPEED%%n8 %%EXTRA_CMDLINE_LINUX%%"
GRUB_SERIAL_COMMAND=${GRUB_SERIAL_COMMAND:-"$DEFAULT_GRUB_SERIAL_COMMAND"}
GRUB_CMDLINE_LINUX=${GRUB_CMDLINE_LINUX:-"$DEFAULT_GRUB_CMDLINE_LINUX"}
export GRUB_SERIAL_COMMAND
export GRUB_CMDLINE_LINUX

# Serial console configuration.  Presumably the host OS has already
# setup the following GRUB configuration variables, as is standard
# practice when configuring GRUB for a serial console:
#
#  GRUB_CMDLINE_LINUX="console=tty0 console=ttyS0,115200n8"
#  GRUB_SERIAL_COMMAND="serial --port=0x3f8 --speed=115200 --word=8 --parity=no --stop=1"

DEFAULT_SERIAL_COMMAND="serial --port=0x3f8 --speed=115200 --word=8 --parity=no --stop=1"
DEFAULT_CMDLINE="$GRUB_CMDLINE_LINUX $GRUB_CMDLINE_LINUX_DEFAULT $GRUB_ONIE_PLATFORM_ARGS $GRUB_ONIE_DEBUG_ARGS"
GRUB_ONIE_SERIAL_COMMAND=${GRUB_SERIAL_COMMAND:-"$DEFAULT_SERIAL_COMMAND"}
GRUB_ONIE_CMDLINE_LINUX=${GRUB_ONIE_CMDLINE_LINUX:-"$DEFAULT_CMDLINE"}
export GRUB_ONIE_SERIAL_COMMAND
export GRUB_ONIE_CMDLINE_LINUX

# Return the /dev device corresponding to $onie_boot_label if it
# exists.
onie_get_boot_dev()
{
    device=$(blkid | grep "$onie_boot_label" | sed -e 's/:.*$//')
    [ -n "$device" ] && echo -n "$device"
}

#
# FSCK the given partition with retries.
#
run_fsck()
{

    DEV="$1"

    if grep -s -w -i "forcefsck" /proc/cmdline >& /dev/null ; then
        force="-f"
    else
        force=""
    fi

    if [ "$FSCKFIX" = yes ] ; then
        fix="-y"
    else
        fix="-p"
    fi

    FSCK=/usr/sbin/fsck
    if [ "$verbose" = "yes" ] ; then
        echo "Running fsck on $DEV ..."
        $FSCK $force $fix $DEV
        retval=$?
    else
        $FSCK $force $fix $DEV > /dev/null 2>&1
        retval=$?
    fi

    if [ $retval -gt 3 ]; then
        echo "ERROR  : fsck encountered fatal errors"
        echo "WARNING: Retrying fsck with -y option on $DEV"
        $FSCK -f -y $DEV
        retval=$?
        if [ $retval -gt 2 ]; then
            echo "ERROR: RUN fsck MANUALLY on $DEV without -y or -p options"
            return 1
        fi
    elif [ $retval -eq 2 ]; then
        echo "ERROR: fsck corrected errors, reboot requested."
    elif [ $retval -eq 1 ]; then
        echo "ERROR: fsck corrected errors."
    fi

    return 0
}

# Set ONIE environment variables.  The underlying store uses grubenv.
#
# arg $1 - variable name
# arg $2 - variable value [optional]
#
# If the variable value is not specified the effect is to delete the
# named variable.
onie_setenv()
{
    var="$1"
    val="$2"
    if [ -n "$val" ] ; then
        grub-editenv $grub_env_file set "$var"="$val"
    else
        # delete $var
        grub-editenv $grub_env_file unset "$var"
    fi
}

# Get an ONIE environment variable.  The underlying store uses
# grubenv.
#
# arg $1 - variable name
#
# If the variable name is not found the empty string "" is returned.
onie_getenv()
{
    var="$1"
    val=$(grub-editenv $grub_env_file list | grep "${var}=")
    val=${val#*=}
    echo -n $val
}

# Copy a NOS grub script to grub.d.
#
# arg $1 - NOS grub script filename
#
onie_grub_d_add_nos()
{
    file="$1"
    cp $file $nos_grub_script
    chmod +x $nos_grub_script
}

# Copy a DIAG grub script to grub.d.
#
# arg $1 - DIAG grub script filename
#
onie_grub_d_add_diag()
{
    file="$1"
    cp $file $diag_grub_script
    chmod +x $diag_grub_script
}

# Remove NOS grub script from grub.d.
onie_grub_d_remove_nos()
{
    rm -f $nos_grub_script
}

# Remove DIAG grub script from grub.d.
onie_grub_d_remove_diag()
{
    rm -f $diag_grub_script
}

# Generate a new grub.cfg and then override the original one in ONIE.
onie_update_grub_cfg()
{
    # create a new grub.cfg
    grub_cfg=$(mktemp)

    (cat <<EOF
#
# This file was generated by 'onie_update_grub_cfg' in onie-blkdev-common
# automatically.
#
EOF
    ) > $grub_cfg

    (cat <<EOF

# begin: serial console config

$GRUB_ONIE_SERIAL_COMMAND
terminal_input serial
terminal_output serial

# end: serial console config

EOF
    ) >> $grub_cfg

    # Add the logic to support grub-reboot
    (cat <<EOF
if [ -s \$prefix/grubenv ]; then
   load_env
fi
if [ "\${next_entry}" ] ; then
   set default="\${next_entry}"
   set next_entry=
   save_env next_entry
fi

EOF
    ) >> $grub_cfg

    # add the ONIE machine configuration data
    cat $onie_root_dir/grub/grub-machine.cfg >> $grub_cfg

    # add ONIE configuration common to all ONIE boot modes
    cat $onie_root_dir/grub/grub-common.cfg >> $grub_cfg

    # use each script in grub.d to generate menu entries
    for s in `ls $onie_grub_d_dir` ; do
        $onie_grub_d_dir/$s >> $grub_cfg
    done

    mv $grub_cfg $grub_root_dir/grub.cfg

    # reset ONIE mode
    $onie_root_dir/tools/bin/onie-boot-mode -q -o none
}

# Local Variables:
# mode: shell-script
# eval: (sh-set-shell "/bin/sh" t nil)
# End:
